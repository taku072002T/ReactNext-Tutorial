import {
  SX_PROP_HELPER_TEXT
} from "./chunk-5TDNSO3W.js";
import {
  createBuiltin
} from "./chunk-5BNQEU2R.js";

// src/Form.tsx
import * as React from "react";
import { Box, Stack, styled } from "@mui/material";
import { LoadingButton } from "@mui/lab";
import { useNode } from "@toolpad/studio-runtime";
import { equalProperties } from "@toolpad/utils/collections";
import {
  useForm,
  Controller,
  useController
} from "react-hook-form";
var FormRoot = styled("div")({
  width: "100%"
});
var FormContext = React.createContext({
  form: null,
  fieldValues: {}
});
function Form({
  children,
  value,
  onChange,
  onSubmit = () => {
  },
  hasResetButton = false,
  formControlsAlign = "end",
  formControlsFullWidth,
  submitButtonText = "Submit",
  mode = "onSubmit",
  hasChrome = true,
  sx
}) {
  const form = useForm({ mode });
  const { isSubmitSuccessful } = form.formState;
  const handleSubmit = React.useCallback(async () => {
    await onSubmit();
  }, [onSubmit]);
  React.useEffect(() => {
    form.reset();
  }, [form, isSubmitSuccessful]);
  React.useEffect(() => {
    onChange(form.getValues());
  }, [form, onChange]);
  React.useEffect(() => {
    const formSubscription = form.watch((newValue) => {
      onChange(newValue);
    });
    return () => formSubscription.unsubscribe();
  }, [form, onChange]);
  const handleReset = React.useCallback(() => {
    form.reset();
  }, [form]);
  const formContextValue = React.useMemo(() => ({ form, fieldValues: value }), [form, value]);
  return /* @__PURE__ */ React.createElement(FormContext.Provider, { value: formContextValue }, hasChrome ? /* @__PURE__ */ React.createElement(FormRoot, { sx }, /* @__PURE__ */ React.createElement("form", { onSubmit: form.handleSubmit(handleSubmit), onReset: handleReset }, children, /* @__PURE__ */ React.createElement(
    Box,
    {
      sx: {
        display: "flex",
        flexDirection: "row",
        justifyContent: formControlsAlign,
        pt: 1
      }
    },
    /* @__PURE__ */ React.createElement(
      Stack,
      {
        direction: "row",
        spacing: 1,
        sx: { flex: formControlsFullWidth ? 1 : "0 1 auto" }
      },
      hasResetButton ? /* @__PURE__ */ React.createElement(
        LoadingButton,
        {
          type: "reset",
          color: "secondary",
          variant: "contained",
          sx: { flex: formControlsFullWidth ? 1 : "0 1 auto" }
        },
        "Reset"
      ) : null,
      /* @__PURE__ */ React.createElement(
        LoadingButton,
        {
          type: "submit",
          color: "primary",
          variant: "contained",
          loading: form.formState.isSubmitting,
          sx: { flex: formControlsFullWidth ? 1 : "0 1 auto" }
        },
        submitButtonText
      )
    )
  ))) : children);
}
var Form_default = createBuiltin(Form, {
  helperText: "A form component.",
  argTypes: {
    children: {
      helperText: "The form content.",
      type: "element",
      control: { type: "layoutSlot" }
    },
    value: {
      helperText: "The value that is controlled by this form.",
      type: "object",
      default: {},
      onChangeProp: "onChange"
    },
    onSubmit: {
      helperText: "Add logic to be executed when the user submits the form.",
      type: "event"
    },
    formControlsAlign: {
      helperText: "Form controls alignment.",
      type: "string",
      enum: ["start", "center", "end"],
      default: "end",
      label: "Form controls alignment",
      control: { type: "HorizontalAlign" }
    },
    formControlsFullWidth: {
      helperText: "Whether the form controls should occupy all available horizontal space.",
      type: "boolean",
      default: false
    },
    submitButtonText: {
      helperText: "Submit button text.",
      type: "string",
      default: "Submit"
    },
    hasResetButton: {
      helperText: "Show button to reset form values.",
      type: "boolean",
      default: false
    },
    sx: {
      helperText: SX_PROP_HELPER_TEXT,
      type: "object"
    }
  }
});
function useFormInput({
  name,
  label,
  value,
  onChange,
  emptyValue,
  defaultValue,
  validationProps
}) {
  const { isRequired, minLength, maxLength } = validationProps;
  const { form, fieldValues } = React.useContext(FormContext);
  const nodeRuntime = useNode();
  const fieldName = name || nodeRuntime?.nodeName;
  const fallbackName = React.useId();
  const formInputName = fieldName || fallbackName;
  const formInputDisplayName = label || name || "Field";
  const { fieldState } = useController({
    disabled: !form,
    name: formInputName,
    control: form?.control
  });
  const formInputError = formInputName ? fieldState.error : void 0;
  const previousDefaultValueRef = React.useRef(defaultValue);
  React.useEffect(() => {
    if (form && defaultValue !== previousDefaultValueRef.current) {
      onChange?.(defaultValue);
      form.setValue(formInputName, defaultValue);
      previousDefaultValueRef.current = defaultValue;
    }
  }, [form, onChange, defaultValue, formInputName]);
  const isInitialForm = Object.keys(fieldValues).length === 0;
  React.useEffect(() => {
    if (form) {
      if (!fieldValues[formInputName] && defaultValue && isInitialForm) {
        onChange?.(defaultValue || emptyValue);
        form.setValue(formInputName, defaultValue || emptyValue);
      } else if (value !== fieldValues[formInputName]) {
        onChange?.(fieldValues[formInputName] || emptyValue);
      }
    }
  }, [defaultValue, emptyValue, fieldValues, form, isInitialForm, formInputName, onChange, value]);
  const previousFormInputNameRef = React.useRef(formInputName);
  React.useEffect(() => {
    const previousFormInputName = previousFormInputNameRef.current;
    if (form && previousFormInputName !== formInputName) {
      form.unregister(previousFormInputName);
      previousFormInputNameRef.current = formInputName;
    }
  }, [form, formInputName]);
  const previousManualValidationPropsRef = React.useRef(validationProps);
  React.useEffect(() => {
    if (form && !equalProperties(validationProps, previousManualValidationPropsRef.current) && fieldState.isDirty) {
      form.trigger(formInputName);
      previousManualValidationPropsRef.current = validationProps;
    }
  }, [fieldState.isDirty, form, formInputName, validationProps]);
  const handleFormInputChange = React.useCallback(
    (newValue) => {
      if (form) {
        form.setValue(formInputName, newValue, {
          shouldValidate: true,
          shouldDirty: true,
          shouldTouch: true
        });
      }
      onChange?.(newValue);
    },
    [form, formInputName, onChange]
  );
  const renderFormInput = React.useCallback(
    (element) => form ? /* @__PURE__ */ React.createElement(
      Controller,
      {
        name: formInputName,
        control: form.control,
        rules: {
          required: isRequired ? `${formInputDisplayName} is required.` : false,
          ...minLength && {
            minLength: {
              value: minLength,
              message: `${formInputDisplayName} must have at least ${minLength} characters.`
            }
          },
          ...maxLength && {
            maxLength: {
              value: maxLength,
              message: `${formInputDisplayName} must have no more than ${maxLength} characters.`
            }
          }
        },
        render: () => element
      }
    ) : element,
    [form, formInputDisplayName, formInputName, isRequired, maxLength, minLength]
  );
  return {
    onFormInputChange: handleFormInputChange,
    formInputError,
    renderFormInput
  };
}
function withComponentForm(InputComponent) {
  return function ComponentWithForm(props) {
    const { form } = React.useContext(FormContext);
    const [componentFormValue, setComponentFormValue] = React.useState({});
    const inputElement = /* @__PURE__ */ React.createElement(InputComponent, { ...props });
    return form ? inputElement : /* @__PURE__ */ React.createElement(
      Form,
      {
        value: componentFormValue,
        onChange: setComponentFormValue,
        mode: "onBlur",
        hasChrome: false
      },
      inputElement
    );
  };
}
var FORM_INPUT_ARG_TYPES = {
  name: {
    helperText: "Name of this input. Used as a reference in form data.",
    type: "string"
  },
  isRequired: {
    label: "Required",
    helperText: "Whether the input is required to have a value.",
    type: "boolean",
    default: false,
    category: "validation"
  }
};
var FORM_TEXT_INPUT_ARG_TYPES = {
  minLength: {
    helperText: "Minimum value length.",
    type: "number",
    minimum: 0,
    maximum: 512,
    default: 0,
    category: "validation"
  },
  maxLength: {
    helperText: "Maximum value length.",
    type: "number",
    minimum: 0,
    maximum: 512,
    default: 0,
    category: "validation"
  }
};

export {
  FormContext,
  Form_default,
  useFormInput,
  withComponentForm,
  FORM_INPUT_ARG_TYPES,
  FORM_TEXT_INPUT_ARG_TYPES
};
//# sourceMappingURL=chunk-ER3UTRTB.js.map