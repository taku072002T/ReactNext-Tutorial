import {
  SX_PROP_HELPER_TEXT
} from "./chunk-5TDNSO3W.js";
import {
  createBuiltin
} from "./chunk-5BNQEU2R.js";

// src/Text.tsx
import * as React from "react";
import {
  Skeleton,
  Typography as MuiTypography,
  Link as MuiLink,
  styled,
  TextareaAutosize,
  Typography
} from "@mui/material";
import { useNode } from "@toolpad/studio-runtime";
import ErrorIcon from "@mui/icons-material/Error";
import { errorFrom } from "@toolpad/utils/errors";
var StaticTextRoot = styled(Typography)({
  // This will give it height, even when empty.
  // REMARK: Does it make sense to put it in MUI core?
  [`&:empty::before`]: { content: '""', display: "inline-block" },
  outline: "none",
  whiteSpace: "pre-wrap",
  overflowWrap: "anywhere"
});
var ToolpadLink = styled(MuiLink, {
  shouldForwardProp: (prop) => prop !== "hasMinWidth"
})(({ hasMinWidth }) => ({
  minWidth: hasMinWidth ? 150 : void 0,
  // Same as Typography
  [`&:empty::before`]: { content: '""', display: "inline-block" },
  overflowWrap: "anywhere"
}));
var Markdown = React.lazy(async () => import("markdown-to-jsx"));
var StyledTextareaAutosize = styled(TextareaAutosize)(({ theme }) => ({
  width: "100%",
  resize: "none",
  border: "none",
  outline: "none",
  padding: 0,
  ...Object.fromEntries(
    Object.keys(theme.typography).map((variant) => [
      [`&.variant-${variant}`],
      theme.typography[variant]
    ])
  )
}));
var MarkdownContainer = styled("div")(({ theme }) => ({
  display: "block",
  overflowWrap: "anywhere",
  "&:empty::before, & > span:empty::before": {
    content: '""',
    display: "inline-block"
  },
  "& h1": {
    ...theme.typography.h1,
    marginTop: 16,
    marginBottom: 16
  },
  "& h2": {
    ...theme.typography.h2,
    marginTop: 12,
    marginBottom: 12
  },
  "& h3": {
    ...theme.typography.h3,
    marginTop: 12,
    marginBottom: 12
  },
  "& h4": {
    ...theme.typography.h4,
    marginTop: 12,
    marginBottom: 12
  },
  "& h5": {
    ...theme.typography.h5,
    marginTop: 4,
    marginBottom: 4
  },
  "& h6": {
    ...theme.typography.h6,
    marginTop: 4,
    marginBottom: 4
  },
  "& p": {
    marginTop: 12,
    marginBottom: 12
  },
  "& *:first-child": {
    marginTop: 0
  },
  "& *:last-child": {
    marginBottom: 0
  }
}));
var CodeContainer = styled("pre")(({ theme }) => ({
  backgroundColor: theme.palette.grey[200],
  marginLeft: theme.spacing(1),
  marginRight: theme.spacing(1),
  borderRadius: theme.shape.borderRadius,
  padding: theme.spacing(1),
  overflow: "auto"
}));
function parseInput(text) {
  return String(text).replaceAll("\n", "");
}
function ErrorDisplay({ error }) {
  const errMessage = errorFrom(error).message;
  return /* @__PURE__ */ React.createElement(MuiTypography, { sx: { display: "flex", flexDirection: "row", gap: 1, alignItems: "center" } }, /* @__PURE__ */ React.createElement(ErrorIcon, { fontSize: "small", color: "error" }), /* @__PURE__ */ React.createElement("span", null, errMessage));
}
function LinkContent({ value, href, loading, sx, openInNewTab }) {
  const content = React.useMemo(() => {
    if (loading) {
      return /* @__PURE__ */ React.createElement(Skeleton, { variant: "text" });
    }
    return value;
  }, [value, loading]);
  const hasMinWidth = loading || !value;
  return /* @__PURE__ */ React.createElement(
    ToolpadLink,
    {
      href,
      target: openInNewTab ? "_blank" : void 0,
      rel: "noopener",
      hasMinWidth,
      sx
    },
    content
  );
}
function MarkdownContent({ value, loading, sx }) {
  const loadingFallback = /* @__PURE__ */ React.createElement(Skeleton, { variant: "text", width: "100%" });
  return /* @__PURE__ */ React.createElement(MarkdownContainer, { sx }, loading ? loadingFallback : /* @__PURE__ */ React.createElement(React.Suspense, { fallback: loadingFallback }, /* @__PURE__ */ React.createElement(
    Markdown,
    {
      options: {
        overrides: {
          a: {
            component: MuiLink,
            props: {
              target: "_blank",
              rel: "noopener"
            }
          },
          pre: {
            component: CodeContainer
          }
        },
        slugify: () => ""
      }
    },
    value
  )));
}
function TextContent({ value, loading, sx, variant }) {
  const [contentEditable, setContentEditable] = React.useState(null);
  const [input, setInput] = React.useState(parseInput(value));
  React.useEffect(() => {
    setInput(parseInput(value));
  }, [value]);
  const nodeRuntime = useNode();
  return contentEditable ? /* @__PURE__ */ React.createElement(
    StyledTextareaAutosize,
    {
      value: input,
      onChange: (event) => {
        setInput(parseInput(event.target.value));
      },
      onKeyDown: (event) => {
        if (event.key === "Enter") {
          event.preventDefault();
        }
      },
      autoFocus: true,
      onFocus: (event) => {
        event.currentTarget.selectionStart = contentEditable.selectionStart;
        event.currentTarget.selectionEnd = Math.max(
          contentEditable.selectionStart,
          contentEditable.selectionEnd
        );
      },
      onBlur: () => {
        setContentEditable(null);
        if (nodeRuntime) {
          nodeRuntime.updateAppDomConstProp("value", input);
        }
      },
      className: `variant-${variant}`
    }
  ) : /* @__PURE__ */ React.createElement(
    StaticTextRoot,
    {
      sx,
      variant,
      onDoubleClick: () => {
        if (nodeRuntime) {
          const selection = window.getSelection();
          setContentEditable({
            selectionStart: selection?.anchorOffset || 0,
            selectionEnd: selection?.focusOffset || 0
          });
        }
      }
    },
    loading ? /* @__PURE__ */ React.createElement(Skeleton, { variant: "text" }) : input
  );
}
function Text(props) {
  if (props.error) {
    return /* @__PURE__ */ React.createElement(ErrorDisplay, { error: props.error });
  }
  switch (props.mode) {
    case "markdown":
      return /* @__PURE__ */ React.createElement(MarkdownContent, { ...props });
    case "link":
      return /* @__PURE__ */ React.createElement(LinkContent, { ...props });
    case "text":
    default:
      return /* @__PURE__ */ React.createElement(TextContent, { ...props });
  }
}
var Text_default = createBuiltin(Text, {
  helperText: "The Text component lets you display text. Text can be rendered in multiple forms: plain, as a link, or as markdown. It's rendered using Material\xA0UI [Typography](https://mui.com/material-ui/react-typography/).",
  layoutDirection: "both",
  loadingPropSource: ["value"],
  loadingProp: "loading",
  errorPropSource: ["value"],
  errorProp: "error",
  argTypes: {
    mode: {
      helperText: "Defines how the content is rendered. Either as plain text, markdown, or as a link.",
      type: "string",
      enum: ["text", "markdown", "link"],
      enumLabels: {
        text: "Text",
        markdown: "Markdown",
        link: "Link"
      },
      default: "text",
      label: "Mode",
      control: { type: "ToggleButtons" }
    },
    value: {
      helperText: "The text content.",
      type: "string",
      default: "text",
      label: "Value",
      control: { type: "markdown" }
    },
    href: {
      helperText: "The url that is being linked.",
      type: "string",
      default: "about:blank",
      visible: ({ mode }) => mode === "link"
    },
    openInNewTab: {
      label: "Open in a new tab",
      helperText: "Clicking the link should open a new tab.",
      type: "boolean",
      default: false,
      visible: ({ mode }) => mode === "link"
    },
    variant: {
      helperText: "The Material\xA0UI typography [variant](https://mui.com/material-ui/customization/typography/#variants) that is used to display the text.",
      type: "string",
      enum: ["h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2"],
      default: "body1",
      label: "Variant",
      visible: ({ mode }) => mode === "text"
    },
    loading: {
      helperText: "Displays a loading animation instead of the text. Can be used when the content is not available yet.",
      type: "boolean",
      default: false
    },
    sx: {
      helperText: SX_PROP_HELPER_TEXT,
      type: "object",
      visible: ({ mode }) => mode !== "markdown"
    }
  }
});

export {
  Text_default
};
//# sourceMappingURL=chunk-W4A27YQF.js.map