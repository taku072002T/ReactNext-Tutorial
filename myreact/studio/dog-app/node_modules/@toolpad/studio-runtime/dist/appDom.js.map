{"version":3,"sources":["../src/appDom.ts"],"sourcesContent":["import { nanoid } from 'nanoid/non-secure';\nimport { generateKeyBetween } from 'fractional-indexing';\nimport invariant from 'invariant';\nimport type { BoxProps, ThemeOptions as MuiThemeOptions } from '@mui/material';\nimport { guessTitle, pascalCase, removeDiacritics, uncapitalize } from '@toolpad/utils/strings';\nimport { mapProperties, mapValues, hasOwnProperty } from '@toolpad/utils/collections';\nimport { ExactEntriesOf, Maybe } from '@toolpad/utils/types';\nimport { omit, update, updateOrCreate } from '@toolpad/utils/immutability';\nimport type {\n  NodeId,\n  NodeReference,\n  BindableAttrValue,\n  BindableAttrValues,\n  SecretAttrValue,\n  BindableAttrEntries,\n} from './types';\n\nexport const CURRENT_APPDOM_VERSION = 7;\n\nexport const RESERVED_NODE_PROPERTIES = [\n  'id',\n  'type',\n  'parentId',\n  'parentProp',\n  'parentIndex',\n] as const;\nexport type ReservedNodeProperty = (typeof RESERVED_NODE_PROPERTIES)[number];\n\nexport function createFractionalIndex(index1: string | null, index2: string | null) {\n  return generateKeyBetween(index1, index2);\n}\n\n// Compares two strings lexicographically\nexport function compareFractionalIndex(index1: string, index2: string): number {\n  if (index1 === index2) {\n    return 0;\n  }\n  return index1 > index2 ? 1 : -1;\n}\n\nexport type ToolpadPlan = 'free' | 'pro';\n\nexport type AuthProvider = 'github' | 'google' | 'azure-ad' | 'credentials';\n\nexport interface AuthProviderConfig {\n  readonly provider: AuthProvider;\n  readonly roles?: { source: string[]; target: string }[];\n}\n\nexport interface ConnectionStatus {\n  timestamp: number;\n  error?: string;\n}\n\ntype AppDomNodeType = 'app' | 'connection' | 'theme' | 'page' | 'element' | 'query' | 'mutation';\n\nexport interface AppDomNodeBase {\n  readonly id: NodeId;\n  readonly type: AppDomNodeType;\n  readonly name: string;\n  readonly parentId: NodeId | null;\n  readonly parentProp: string | null;\n  readonly parentIndex: string | null;\n  readonly attributes: {};\n}\n\nexport interface AppNode extends AppDomNodeBase {\n  readonly type: 'app';\n  readonly parentId: null;\n  readonly attributes: {\n    readonly plan?: ToolpadPlan;\n    readonly authentication?: {\n      readonly providers?: AuthProviderConfig[];\n      readonly restrictedDomains?: string[];\n    };\n    readonly authorization?: {\n      readonly roles?: {\n        readonly name: string;\n        readonly description?: string;\n      }[];\n    };\n  };\n}\n\nexport interface ThemeNode extends AppDomNodeBase {\n  readonly type: 'theme';\n  readonly theme?: MuiThemeOptions;\n}\n\nexport interface ConnectionNode<P = unknown> extends AppDomNodeBase {\n  readonly type: 'connection';\n  readonly attributes: {\n    readonly dataSource: string;\n    readonly params: SecretAttrValue<P | null>;\n    readonly status: ConnectionStatus | null;\n  };\n}\n\nexport type PageDisplayMode = 'standalone' | 'shell';\n\nexport type ContainerWidth = 'xs' | 'sm' | 'md' | 'lg' | 'xl' | 'none';\n\nexport const DEFAULT_CONTAINER_WIDTH = 'lg' satisfies ContainerWidth;\n\nexport interface PageNode extends AppDomNodeBase {\n  readonly type: 'page';\n  readonly attributes: {\n    readonly title?: string;\n    readonly alias?: string[];\n    readonly parameters?: [string, string][];\n    readonly module?: string;\n    readonly display?: PageDisplayMode;\n    readonly displayName?: string;\n    readonly maxWidth?: ContainerWidth;\n    readonly authorization?: {\n      readonly allowAll?: boolean;\n      readonly allowedRoles?: string[];\n    };\n  };\n}\n\nexport interface ElementNode<P = any> extends AppDomNodeBase {\n  readonly type: 'element';\n  readonly attributes: {\n    readonly component: string;\n  };\n  readonly props?: BindableAttrValues<P>;\n  readonly layout?: {\n    readonly horizontalAlign?: BoxProps['justifyContent'];\n    readonly verticalAlign?: BoxProps['alignItems'];\n    readonly columnSize?: number;\n    readonly height?: number;\n  };\n}\n\nexport type FetchMode = 'query' | 'mutation';\n\n/**\n * A DOM query is defined primarily by a server defined part \"attributes.query\"\n * and a clientside defined part \"params\". \"params\" are constructed in the runtime\n * from bound expressions. The resolved object will be sent to the server and combined\n * with the query will be used to collect the data from the backend.\n */\nexport interface QueryNode<Q = any> extends AppDomNodeBase {\n  readonly type: 'query';\n  readonly params?: BindableAttrEntries;\n  readonly attributes: {\n    readonly mode?: FetchMode;\n    readonly dataSource?: string;\n    readonly connectionId: NodeReference | null;\n    readonly query: Q;\n    readonly transform?: string;\n    readonly transformEnabled?: boolean;\n    /** @deprecated Not necessary to be user-facing, we will expose staleTime instead if necessary */\n    readonly refetchOnWindowFocus?: boolean;\n    /** @deprecated Not necessary to be user-facing, we will expose staleTime instead if necessary */\n    readonly refetchOnReconnect?: boolean;\n    readonly refetchInterval?: number;\n    readonly cacheTime?: number;\n    readonly enabled?: BindableAttrValue<boolean>;\n  };\n}\n\n/**\n * @deprecated QueryNode can act as a mutation by switching the `mode` attribute to 'mutation'\n */\nexport interface MutationNode<Q = any> extends AppDomNodeBase {\n  readonly type: 'mutation';\n  readonly params?: BindableAttrValues;\n  readonly attributes: {\n    readonly dataSource?: string;\n    readonly connectionId: NodeReference | null;\n    readonly query: Q;\n  };\n}\n\ntype AppDomNodeOfType<K extends AppDomNodeType> = {\n  app: AppNode;\n  connection: ConnectionNode;\n  theme: ThemeNode;\n  page: PageNode;\n  element: ElementNode;\n  query: QueryNode;\n  mutation: MutationNode;\n}[K];\n\ntype AllowedChildren = {\n  app: {\n    pages: 'page';\n    connections: 'connection';\n    themes: 'theme';\n  };\n  theme: {};\n  connection: {};\n  page: {\n    children: 'element';\n    queries: 'query';\n    mutations: 'mutation';\n  };\n  element: {\n    [prop: string]: 'element';\n  };\n  query: {};\n  mutation: {};\n};\n\nexport type AppDomNode = AppDomNodeOfType<AppDomNodeType>;\n\ntype TypeOf<N extends AppDomNode> = N['type'];\ntype AllowedChildTypesOfType<T extends AppDomNodeType> = AllowedChildren[T];\ntype AllowedChildTypesOf<N extends AppDomNode> = AllowedChildTypesOfType<TypeOf<N>>;\n\nexport type ChildNodesOf<N extends AppDomNode> = {\n  [K in keyof AllowedChildTypesOf<N>]: AllowedChildTypesOf<N>[K] extends AppDomNodeType\n    ? AppDomNodeOfType<AllowedChildTypesOf<N>[K]>[]\n    : never;\n};\n\ntype CombinedChildrenOfType<T extends AppDomNodeType> =\n  AllowedChildren[T][keyof AllowedChildren[T]];\n\ntype CombinedAllowedChildren = {\n  [K in AppDomNodeType]: CombinedChildrenOfType<K>;\n};\n\ntype ParentTypeOfType<T extends AppDomNodeType> = {\n  [K in AppDomNodeType]: T extends CombinedAllowedChildren[K] ? K : never;\n}[AppDomNodeType];\nexport type ParentOf<N extends AppDomNode> = AppDomNodeOfType<ParentTypeOfType<TypeOf<N>>> | null;\n\nexport type ParentProp<Parent extends AppDomNode> = keyof AllowedChildTypesOfType<TypeOf<Parent>>;\n\nexport type ParentPropOf<Child extends AppDomNode, Parent extends AppDomNode> = {\n  [K in keyof AllowedChildren[TypeOf<Parent>]]: TypeOf<Child> extends AllowedChildren[TypeOf<Parent>][K]\n    ? K & string\n    : never;\n}[keyof AllowedChildren[TypeOf<Parent>]];\n\nexport type AppDomNodes = Record<NodeId, AppDomNode>;\n\nexport interface AppDom {\n  nodes: AppDomNodes;\n  root: NodeId;\n  version?: number;\n}\n\nfunction isType<T extends AppDomNode>(node: AppDomNode, type: T['type']): node is T {\n  return node.type === type;\n}\n\nfunction assertIsType<T extends AppDomNode>(node: AppDomNode, type: T['type']): asserts node is T {\n  invariant(isType(node, type), `Expected node type \"${type}\" but got \"${node.type}\"`);\n}\n\nexport function createId(): NodeId {\n  return nanoid(7) as NodeId;\n}\n\nexport function createSecret<V>(value: V): SecretAttrValue<V> {\n  return { $$secret: value };\n}\n\nexport function getMaybeNode<T extends AppDomNodeType>(\n  dom: AppDom,\n  nodeId: NodeId,\n  type: T,\n): AppDomNodeOfType<T> | null;\nexport function getMaybeNode<T extends AppDomNodeType>(\n  dom: AppDom,\n  nodeId: NodeId,\n  type?: T,\n): AppDomNode | null;\nexport function getMaybeNode<T extends AppDomNodeType>(\n  dom: AppDom,\n  nodeId: NodeId,\n  type?: T,\n): AppDomNode | null {\n  const node = dom.nodes[nodeId];\n  if (!node) {\n    return null;\n  }\n  if (type) {\n    assertIsType(node, type);\n  }\n  return node;\n}\n\nexport function getNode<T extends AppDomNodeType>(\n  dom: AppDom,\n  nodeId: NodeId,\n  type: T,\n): AppDomNodeOfType<T>;\nexport function getNode<T extends AppDomNodeType>(\n  dom: AppDom,\n  nodeId: NodeId,\n  type?: T,\n): AppDomNode;\nexport function getNode<T extends AppDomNodeType>(\n  dom: AppDom,\n  nodeId: NodeId,\n  type?: T,\n): AppDomNode {\n  const node = getMaybeNode(dom, nodeId, type);\n  if (!node) {\n    throw new Error(`Node \"${nodeId}\" not found`);\n  }\n  return node;\n}\n\nexport function isApp(node: AppDomNode): node is AppNode {\n  return isType<AppNode>(node, 'app');\n}\n\nexport function assertIsApp(node: AppDomNode): asserts node is AppNode {\n  assertIsType<AppNode>(node, 'app');\n}\n\nexport function isPage(node: AppDomNode): node is PageNode {\n  return isType<PageNode>(node, 'page');\n}\n\nexport function assertIsPage(node: AppDomNode): asserts node is PageNode {\n  assertIsType<PageNode>(node, 'page');\n}\n\nexport function isConnection<P>(node: AppDomNode): node is ConnectionNode<P> {\n  return isType<ConnectionNode>(node, 'connection');\n}\n\nexport function assertIsConnection<P>(node: AppDomNode): asserts node is ConnectionNode<P> {\n  assertIsType<ConnectionNode>(node, 'connection');\n}\n\nexport function isTheme(node: AppDomNode): node is ThemeNode {\n  return isType<ThemeNode>(node, 'theme');\n}\n\nexport function assertIsTheme(node: AppDomNode): asserts node is ThemeNode {\n  assertIsType<ThemeNode>(node, 'theme');\n}\n\nexport function isElement<P>(node: AppDomNode): node is ElementNode<P> {\n  return isType<ElementNode>(node, 'element');\n}\n\nexport function assertIsElement<P>(node: AppDomNode): asserts node is ElementNode<P> {\n  assertIsType<ElementNode>(node, 'element');\n}\n\nexport function isQuery<P>(node: AppDomNode): node is QueryNode<P> {\n  return isType<QueryNode>(node, 'query');\n}\n\nexport function assertIsQuery<P>(node: AppDomNode): asserts node is QueryNode<P> {\n  assertIsType<QueryNode>(node, 'query');\n}\n\nexport function isMutation<P>(node: AppDomNode): node is MutationNode<P> {\n  return isType<MutationNode>(node, 'mutation');\n}\n\nexport function assertIsMutation<P>(node: AppDomNode): asserts node is MutationNode<P> {\n  assertIsType<MutationNode>(node, 'mutation');\n}\n\nexport function getRoot(dom: AppDom): AppDomNode {\n  return getNode(dom, dom.root);\n}\n\nexport function getApp(dom: AppDom): AppNode {\n  const app = getRoot(dom);\n  assertIsApp(app);\n  return app;\n}\n\nexport type NodeChildren<N extends AppDomNode = any> = ChildNodesOf<N>;\n\nconst childrenMemo = new WeakMap<AppDom, Map<NodeId, NodeChildren<any>>>();\nexport function getChildNodes<N extends AppDomNode>(dom: AppDom, parent: N): NodeChildren<N> {\n  let domChildrenMemo = childrenMemo.get(dom);\n  if (!domChildrenMemo) {\n    domChildrenMemo = new Map();\n    childrenMemo.set(dom, domChildrenMemo);\n  }\n\n  let result = domChildrenMemo.get(parent.id);\n  if (!result) {\n    result = {};\n    domChildrenMemo.set(parent.id, result);\n\n    const allNodeChildren: AppDomNode[] = Object.values(dom.nodes).filter(\n      (node: AppDomNode) => node.parentId === parent.id,\n    );\n\n    for (const child of allNodeChildren) {\n      const prop = child.parentProp || 'children';\n      let existing = result[prop];\n      if (!existing) {\n        existing = [];\n        result[prop] = existing;\n      }\n      existing.push(child);\n    }\n\n    for (const childArray of Object.values(result)) {\n      childArray?.sort((node1: AppDomNode, node2: AppDomNode) => {\n        invariant(\n          node1.parentIndex && node2.parentIndex,\n          `Nodes inside the dom should have a parentIndex if they have a parent`,\n        );\n        return compareFractionalIndex(node1.parentIndex, node2.parentIndex);\n      });\n    }\n  }\n\n  return result;\n}\n\nexport function getParent<N extends AppDomNode>(dom: AppDom, child: N): ParentOf<N> {\n  // Make sure we're using the last version of child in the dom\n  child = getNode(dom, child.id, child.type) as N;\n  if (child.parentId) {\n    const parent = getNode(dom, child.parentId);\n    return parent as ParentOf<N>;\n  }\n  return null;\n}\n\ntype AppDomNodeInitOfType<T extends AppDomNodeType> = Omit<\n  AppDomNodeOfType<T>,\n  ReservedNodeProperty | 'name'\n> & { name?: string };\n\nfunction createNodeInternal<T extends AppDomNodeType>(\n  id: NodeId,\n  type: T,\n  init: AppDomNodeInitOfType<T> & { name: string },\n): AppDomNodeOfType<T> {\n  return {\n    ...init,\n    id,\n    type,\n    parentId: null,\n    parentProp: null,\n    parentIndex: null,\n  } as AppDomNodeOfType<T>;\n}\n\nfunction slugifyNodeName(nameCandidate: string, fallback: string): string {\n  let slug = nameCandidate;\n  slug = slug.trim();\n  // try to replace accents with relevant ascii\n  slug = removeDiacritics(slug);\n  // replace spaces with camelcase\n  const [first, ...rest] = slug.split(/\\s+/);\n  slug = first + pascalCase(...rest);\n  // replace disallowed characters for js identifiers\n  slug = slug.replace(/[^a-zA-Z0-9]+/g, '_');\n  // remove leading digits\n  slug = slug.replace(/^\\d+/g, '');\n  if (!slug) {\n    slug = fallback;\n  }\n  return slug;\n}\n\nexport function validateNodeName(name: string, disallowedNames: Set<string>, kind: string) {\n  if (!name) {\n    return 'a name is required';\n  }\n\n  const firstLetter = name[0];\n  if (!/[a-z_]/i.test(firstLetter)) {\n    return `${kind} may not start with a \"${firstLetter}\"`;\n  }\n\n  const match = /([^a-z0-9_])/i.exec(name);\n\n  if (match) {\n    const invalidCharacter = match[1];\n    if (/\\s/.test(invalidCharacter)) {\n      return `${kind} may not contain spaces`;\n    }\n\n    return `${kind} may not contain a \"${invalidCharacter}\"`;\n  }\n\n  const slug = slugifyNodeName(name, kind);\n\n  const isDuplicate = disallowedNames.has(slug);\n\n  if (isDuplicate) {\n    return `There already is a ${kind} with this name`;\n  }\n\n  return null;\n}\n\nexport function createNode<T extends AppDomNodeType>(\n  dom: AppDom,\n  type: T,\n  init: AppDomNodeInitOfType<T>,\n): AppDomNodeOfType<T> {\n  const id = createId();\n  const name = slugifyNodeName(init.name || type, type);\n  return createNodeInternal(id, type, {\n    ...init,\n    name,\n  });\n}\n\nfunction createFragmentInternal<T extends AppDomNodeType>(\n  id: NodeId,\n  type: T,\n  init: AppDomNodeInitOfType<T> & { name: string },\n): AppDom {\n  return {\n    nodes: {\n      [id]: createNodeInternal(id, type, init),\n    },\n    root: id,\n    version: CURRENT_APPDOM_VERSION,\n  };\n}\n\nexport function createFragment<T extends AppDomNodeType>(\n  type: T,\n  init: AppDomNodeInitOfType<T> & { name: string },\n): AppDom {\n  const rootId = createId();\n  return createFragmentInternal(rootId, type, init);\n}\n\nexport function createDom(): AppDom {\n  return createFragment('app', {\n    name: 'Application',\n    attributes: {},\n  });\n}\n\n/**\n * Creates a new DOM node representing a React Element\n */\nexport function createElement<P>(\n  dom: AppDom,\n  component: string,\n  props: Partial<BindableAttrValues<P>> = {},\n  layout: Partial<BindableAttrValues<P>> = {},\n  name?: string,\n): ElementNode {\n  return createNode(dom, 'element', {\n    name: name || uncapitalize(component),\n    props,\n    attributes: {\n      component,\n    },\n    layout,\n  });\n}\n\n/**\n * Get all descendants of a `node`, flattens childNodes objects into one single array\n */\nexport function getDescendants(dom: AppDom, node: AppDomNode): readonly AppDomNode[] {\n  const children: readonly AppDomNode[] = (\n    Object.values(getChildNodes(dom, node)) as AppDomNode[][]\n  )\n    .flat()\n    .filter(Boolean);\n  return [...children, ...children.flatMap((child) => getDescendants(dom, child))];\n}\n\n/**\n * Get all siblings of a `node`\n */\nexport function getSiblings(dom: AppDom, node: AppDomNode): readonly AppDomNode[] {\n  return Object.values(dom.nodes).filter(\n    (sibling) =>\n      sibling.parentId === node.parentId &&\n      sibling.parentProp === node.parentProp &&\n      sibling.id !== node.id,\n  );\n}\n\nexport function getAncestors(dom: AppDom, node: AppDomNode): readonly AppDomNode[] {\n  const parent = getParent(dom, node);\n  return parent ? [...getAncestors(dom, parent), parent] : [];\n}\n\n/**\n * Get all the ancestors of the `node` up until the first PageNode node is encountered\n */\nexport function getPageAncestors(\n  dom: AppDom,\n  node: AppDomNode,\n): readonly (ElementNode | PageNode)[] {\n  const parent = getParent(dom, node);\n  return parent && (isElement(parent) || isPage(parent))\n    ? [...getPageAncestors(dom, parent), parent]\n    : [];\n}\n\n/**\n * Get the first PageNode node up in the DOM tree starting from `node`\n */\nexport function getPageAncestor(dom: AppDom, node: AppDomNode): PageNode | null {\n  if (isPage(node)) {\n    return node;\n  }\n  const parent = getParent(dom, node);\n  if (parent) {\n    return getPageAncestor(dom, parent);\n  }\n  return null;\n}\n\n/**\n * Returns all nodes with a given component type\n */\nexport function getComponentTypeNodes(dom: AppDom, componentId: string): readonly AppDomNode[] {\n  return Object.values(dom.nodes).filter(\n    (node) => isElement(node) && node.attributes.component === componentId,\n  );\n}\n\n/**\n * Returns the set of names for which the given node must have a different name\n */\nexport function getExistingNamesForNode(dom: AppDom, node: AppDomNode): Set<string> {\n  if (isElement(node)) {\n    const pageNode = getPageAncestor(dom, node);\n    const pageDescendants = pageNode ? getDescendants(dom, pageNode) : [];\n    return new Set(\n      pageDescendants\n        .filter((descendant) => descendant.id !== node.id)\n        .map((scopeNode) => scopeNode.name),\n    );\n  }\n\n  return new Set(getSiblings(dom, node).map((scopeNode) => scopeNode.name));\n}\n\nexport function getExistingNamesForChildren<Parent extends AppDomNode>(\n  dom: AppDom,\n  parent: Parent,\n  parentProp?: ParentProp<Parent>,\n): Set<string> {\n  const pageNode = getPageAncestor(dom, parent);\n\n  if (pageNode) {\n    const pageDescendants = getDescendants(dom, pageNode);\n    return new Set(pageDescendants.map((scopeNode) => scopeNode.name));\n  }\n\n  if (parentProp) {\n    const childNodes = getChildNodes(dom, parent);\n    const { [parentProp]: children = [] } = childNodes;\n    return new Set(children.map((scopeNode) => scopeNode.name));\n  }\n\n  const descendants = getDescendants(dom, parent);\n  return new Set(descendants.map((scopeNode: AppDomNode) => scopeNode.name));\n}\n\nexport function proposeName(candidate: string, disallowedNames: Set<string> = new Set()): string {\n  const slug = slugifyNodeName(candidate, 'node');\n  if (!disallowedNames.has(slug)) {\n    return slug;\n  }\n  const basename = candidate.replace(/\\d+$/, '');\n  let counter = 1;\n  while (disallowedNames.has(basename + counter)) {\n    counter += 1;\n  }\n  return basename + counter;\n}\n\nexport function setNodeName(dom: AppDom, node: AppDomNode, name: string): AppDom {\n  if (dom.nodes[node.id].name === name) {\n    return dom;\n  }\n  return update(dom, {\n    nodes: update(dom.nodes, {\n      [node.id]: {\n        ...node,\n        name: slugifyNodeName(name, node.type),\n      },\n    }),\n  });\n}\n\nexport type PropNamespaces<N extends AppDomNode> = {\n  [K in keyof N]: N[K] extends BindableAttrValues<any> | undefined ? K : never;\n}[keyof N & string];\n\nexport type BindableProps<T> = {\n  [K in keyof T]: T[K] extends BindableAttrValue<any> ? K : never;\n}[keyof T & string];\n\nexport function setNodeProp<Node extends AppDomNode, Prop extends BindableProps<Node>>(\n  dom: AppDom,\n  node: Node,\n  prop: Prop,\n  value: Node[Prop] | null,\n): AppDom {\n  if (value) {\n    return update(dom, {\n      nodes: update(dom.nodes, {\n        [node.id]: update(node, {\n          [prop]: value,\n        } as any) as Partial<Node>,\n      } as Partial<AppDomNodes>),\n    });\n  }\n\n  return update(dom, {\n    nodes: update(dom.nodes, {\n      [node.id]: omit(node, prop) as Partial<Node>,\n    } as Partial<AppDomNodes>),\n  });\n}\n\nexport function setNamespacedProp<\n  Node extends AppDomNode,\n  Namespace extends PropNamespaces<Node>,\n  Prop extends keyof Node[Namespace] & string,\n>(node: Node, namespace: Namespace, prop: Prop, value: Node[Namespace][Prop] | null): Node {\n  if (value) {\n    return update(node, {\n      [namespace]: updateOrCreate((node as Node)[namespace], {\n        [prop]: value,\n      } as any) as Partial<Node[Namespace]>,\n    } as Partial<Node>);\n  }\n  return update(node, {\n    [namespace]: omit(node[namespace], prop) as Partial<Node[Namespace]>,\n  } as Partial<Node>);\n}\n\nexport function setQueryProp<Q, K extends keyof Q>(\n  node: QueryNode<Q>,\n  prop: K,\n  value: Q[K],\n): QueryNode<Q> {\n  const original = node.attributes.query;\n  return setNamespacedProp(node, 'attributes', 'query', { ...original, [prop]: value });\n}\n\nexport function setNodeNamespacedProp<\n  Node extends AppDomNode,\n  Namespace extends PropNamespaces<Node>,\n  Prop extends keyof NonNullable<Node[Namespace]> & string,\n>(\n  dom: AppDom,\n  node: Node,\n  namespace: Namespace,\n  prop: Prop,\n  value: NonNullable<Node[Namespace]>[Prop],\n): AppDom {\n  return update(dom, {\n    nodes: update(dom.nodes, {\n      [node.id]: update(dom.nodes[node.id], {\n        [namespace]: updateOrCreate((dom.nodes[node.id] as Node)[namespace], {\n          [prop]: value,\n        } as any) as Partial<Node[Namespace]>,\n      } as Partial<Node>),\n    }),\n  });\n}\n\nfunction setNodeParent<N extends AppDomNode>(\n  dom: AppDom,\n  node: N,\n  parentId: NodeId,\n  parentProp: string,\n  parentIndex?: string,\n) {\n  if (!parentIndex) {\n    const parent = getNode(dom, parentId);\n\n    const children: readonly AppDomNode[] = (getChildNodes(dom, parent) as any)[parentProp] ?? [];\n    const lastIndex = children.length > 0 ? children[children.length - 1].parentIndex : null;\n    parentIndex = createFractionalIndex(lastIndex, null);\n  }\n\n  return update(dom, {\n    nodes: update(dom.nodes, {\n      [node.id]: update(node as AppDomNode, {\n        parentId,\n        parentProp,\n        parentIndex,\n      }),\n    }),\n  });\n}\n\nexport function addNode<Parent extends AppDomNode, Child extends AppDomNode>(\n  dom: AppDom,\n  newNode: Child,\n  parent: Parent,\n  parentProp: ParentPropOf<Child, Parent>,\n  parentIndex?: string,\n): AppDom {\n  if (newNode.parentId) {\n    throw new Error(`Node \"${newNode.id}\" is already attached to a parent`);\n  }\n\n  const existingNames = getExistingNamesForChildren(dom, parent, parentProp);\n\n  if (existingNames.has(newNode.name)) {\n    newNode = {\n      ...newNode,\n      name: proposeName(newNode.name, existingNames),\n    };\n  }\n\n  return setNodeParent(dom, newNode, parent.id, parentProp, parentIndex);\n}\n\nexport function moveNode<Parent extends AppDomNode, Child extends AppDomNode>(\n  dom: AppDom,\n  node: Child,\n  parent: Parent,\n  parentProp: ParentPropOf<Child, Parent>,\n  parentIndex?: string,\n) {\n  return setNodeParent(dom, node, parent.id, parentProp, parentIndex);\n}\n\nexport function spreadNode<Child extends AppDomNode>(dom: AppDom, node: Child) {\n  const parent = getParent(dom, node);\n  const parentProp = node.parentProp;\n\n  let draft = dom;\n  if (parent && parentProp && isElement(node)) {\n    for (const child of getChildNodes(draft, node).children) {\n      const parentIndex = getNewParentIndexBeforeNode(draft, node, parentProp);\n      draft = setNodeParent(draft, child, parent.id, parentProp, parentIndex);\n    }\n    draft = removeNode(draft, node.id);\n  }\n\n  return draft;\n}\n\nexport function nodeExists(dom: AppDom, nodeId: NodeId): boolean {\n  return !!getMaybeNode(dom, nodeId);\n}\n\nexport function saveNode(dom: AppDom, node: AppDomNode) {\n  if (!nodeExists(dom, node.id)) {\n    throw new Error(`Attempt to update node \"${node.id}\", but it doesn't exist in the dom`);\n  }\n  return update(dom, {\n    nodes: update(dom.nodes, {\n      [node.id]: update(dom.nodes[node.id], omit(node, ...RESERVED_NODE_PROPERTIES)),\n    }),\n  });\n}\n\nexport function removeNode(dom: AppDom, nodeId: NodeId) {\n  const node = getNode(dom, nodeId);\n  const parent = getParent(dom, node);\n\n  invariant(parent, `Node: \"${node.id}\" can't be removed`);\n\n  const descendantIds = getDescendants(dom, node).map(({ id }) => id);\n\n  return update(dom, {\n    nodes: omit(dom.nodes, node.id, ...descendantIds),\n  });\n}\n\nexport function removeMaybeNode(dom: AppDom, nodeId: NodeId): AppDom {\n  if (getMaybeNode(dom, nodeId)) {\n    return removeNode(dom, nodeId);\n  }\n  return dom;\n}\n\nexport function fromConstPropValue(prop: undefined): undefined;\nexport function fromConstPropValue<T>(prop: BindableAttrValue<T>): T;\nexport function fromConstPropValue<T>(prop?: BindableAttrValue<T | undefined>): T | undefined;\nexport function fromConstPropValue<T>(prop?: BindableAttrValue<T | undefined>): T | undefined {\n  if (!prop) {\n    return undefined;\n  }\n  if (hasOwnProperty(prop, '$$jsExpression') || hasOwnProperty(prop, '$$env')) {\n    throw new Error(`trying to unbox a non-constant prop value`);\n  }\n  return prop as T;\n}\n\nexport function fromConstPropValues<P>(props: BindableAttrValues<P>): Partial<P> {\n  const result: Partial<P> = {};\n  (Object.entries(props) as ExactEntriesOf<BindableAttrValues<P>>).forEach(([name, prop]) => {\n    if (prop) {\n      result[name] = fromConstPropValue<P[typeof name]>(prop);\n    }\n  });\n  return result;\n}\n\nexport function getNodeFirstChild(dom: AppDom, node: ElementNode | PageNode, parentProp: string) {\n  const nodeChildren = (getChildNodes(dom, node) as NodeChildren<ElementNode>)[parentProp] || [];\n  return nodeChildren.length > 0 ? nodeChildren[0] : null;\n}\n\nexport function getNodeLastChild(dom: AppDom, node: ElementNode | PageNode, parentProp: string) {\n  const nodeChildren = (getChildNodes(dom, node) as NodeChildren<ElementNode>)[parentProp] || [];\n  return nodeChildren.length > 0 ? nodeChildren[nodeChildren.length - 1] : null;\n}\n\nexport function getSiblingBeforeNode(\n  dom: AppDom,\n  node: ElementNode | PageNode,\n  parentProp: string,\n) {\n  const parent = getParent(dom, node);\n\n  invariant(parent, `Node: \"${node.id}\" has no parent`);\n\n  const parentChildren =\n    ((isPage(parent) || isElement(parent)) &&\n      (getChildNodes(dom, parent) as NodeChildren<ElementNode>)[parentProp]) ||\n    [];\n\n  const nodeIndex = parentChildren.findIndex((child) => child.id === node.id);\n  const nodeBefore = nodeIndex > 0 ? parentChildren[nodeIndex - 1] : null;\n\n  return nodeBefore;\n}\n\nexport function getSiblingAfterNode(dom: AppDom, node: ElementNode | PageNode, parentProp: string) {\n  const parent = getParent(dom, node);\n\n  invariant(parent, `Node: \"${node.id}\" has no parent`);\n\n  const parentChildren =\n    ((isPage(parent) || isElement(parent)) &&\n      (getChildNodes(dom, parent) as NodeChildren<ElementNode>)[parentProp]) ||\n    [];\n\n  const nodeIndex = parentChildren.findIndex((child) => child.id === node.id);\n  const nodeAfter = nodeIndex < parentChildren.length - 1 ? parentChildren[nodeIndex + 1] : null;\n\n  return nodeAfter;\n}\n\nexport function getNewFirstParentIndexInNode(\n  dom: AppDom,\n  node: ElementNode | PageNode,\n  parentProp: string,\n) {\n  const firstChild = getNodeFirstChild(dom, node, parentProp);\n  return createFractionalIndex(null, firstChild?.parentIndex || null);\n}\n\nexport function getNewLastParentIndexInNode(\n  dom: AppDom,\n  node: ElementNode | PageNode,\n  parentProp: string,\n) {\n  const lastChild = getNodeLastChild(dom, node, parentProp);\n  return createFractionalIndex(lastChild?.parentIndex || null, null);\n}\n\nexport function getNewParentIndexBeforeNode(\n  dom: AppDom,\n  node: ElementNode | PageNode,\n  parentProp: string,\n) {\n  const nodeBefore = getSiblingBeforeNode(dom, node, parentProp);\n  return createFractionalIndex(nodeBefore?.parentIndex || null, node.parentIndex);\n}\n\nexport function getNewParentIndexAfterNode(\n  dom: AppDom,\n  node: ElementNode | PageNode,\n  parentProp: string,\n) {\n  const nodeAfter = getSiblingAfterNode(dom, node, parentProp);\n  return createFractionalIndex(node.parentIndex, nodeAfter?.parentIndex || null);\n}\n\nexport function addFragment(\n  dom: AppDom,\n  fragment: AppDom,\n  parentId: NodeId,\n  parentProp: string,\n  parentIndex?: string | undefined,\n) {\n  const parent = getNode(dom, parentId);\n  const existingNames = getExistingNamesForChildren<any>(dom, parent, parentProp);\n  let combinedDom: AppDom = {\n    ...dom,\n    nodes: {\n      ...dom.nodes,\n      ...mapValues(fragment.nodes, (node: AppDomNode) => {\n        return existingNames.has(node.name)\n          ? { ...node, name: proposeName(node.name, existingNames) }\n          : node;\n      }),\n    },\n  };\n  const fragmentRoot = getNode(combinedDom, fragment.root);\n  combinedDom = setNodeParent(combinedDom, fragmentRoot, parentId, parentProp, parentIndex);\n  return combinedDom;\n}\n\n/**\n * Make a copy of a subtree (a fragment) of the dom. The structure of a fragment is\n * the same as a dom where the root is the node we create the fragment for\n */\nexport function cloneFragment(dom: AppDom, nodeId: NodeId): AppDom {\n  const node = getNode(dom, nodeId);\n  const newNode = createNode(dom, node.type, node);\n  const childNodes = getChildNodes(dom, node);\n\n  let result: AppDom = {\n    root: newNode.id,\n    nodes: {\n      [newNode.id]: newNode,\n    },\n  };\n\n  for (const [childParentProp, children] of Object.entries(childNodes)) {\n    if (children) {\n      for (const child of children as AppDomNode[]) {\n        const childFragment = cloneFragment(dom, child.id);\n        result = addFragment(result, childFragment, newNode.id, childParentProp);\n      }\n    }\n  }\n\n  return result;\n}\n\nexport function duplicateNode(\n  dom: AppDom,\n  node: AppDomNode,\n  parent: AppDomNode | null = getParent(dom, node),\n  parentProp: string | null = node.parentProp,\n): AppDom {\n  if (!parent || !parentProp) {\n    throw new Error(`Node \"${node.id}\" can't be duplicated, it must have a parent`);\n  }\n\n  if (isElement(node)) {\n    const fragment = cloneFragment(dom, node.id);\n    return addFragment(\n      dom,\n      fragment,\n      parent.id,\n      parentProp,\n      getNewParentIndexAfterNode(dom, node, parentProp),\n    );\n  }\n\n  return dom;\n}\n\nconst RENDERTREE_NODES = ['app', 'page', 'element', 'query', 'mutation', 'theme'] as const;\n\nexport type RenderTreeNodeType = (typeof RENDERTREE_NODES)[number];\nexport type RenderTreeNode = { [K in RenderTreeNodeType]: AppDomNodeOfType<K> }[RenderTreeNodeType];\nexport type RenderTreeNodes = Record<NodeId, RenderTreeNode>;\n\nexport interface RenderTree {\n  root: NodeId;\n  nodes: RenderTreeNodes;\n  version?: number;\n}\n\nconst frontendNodes = new Set<string>(RENDERTREE_NODES);\nfunction createRenderTreeNode(node: AppDomNode): RenderTreeNode | null {\n  if (!frontendNodes.has(node.type)) {\n    return null;\n  }\n\n  if (isQuery(node) || isMutation(node)) {\n    if (node.attributes.query) {\n      node = setNamespacedProp(node, 'attributes', 'query', null);\n    }\n  }\n\n  return node as RenderTreeNode;\n}\n\n/**\n * We need to make sure no secrets end up in the frontend html, so let's only send the\n * nodes that we need to build frontend, and that we know don't contain secrets.\n * TODO: Would it make sense to create a separate datastructure that represents the render tree?\n */\nexport function createRenderTree(dom: AppDom): RenderTree {\n  return {\n    ...dom,\n    nodes: mapProperties(dom.nodes, ([id, node]) => {\n      const rendernode = createRenderTreeNode(node);\n      return rendernode ? [id, rendernode] : null;\n    }),\n  };\n}\n\nexport function ref(nodeId: NodeId): NodeReference;\nexport function ref(nodeId: null | undefined): null;\nexport function ref(nodeId: Maybe<NodeId>): NodeReference | null;\nexport function ref(nodeId: Maybe<NodeId>): NodeReference | null {\n  return nodeId ? { $ref: nodeId } : null;\n}\n\nexport function deref(nodeRef: NodeReference): NodeId;\nexport function deref(nodeRef: null | undefined): null;\nexport function deref(nodeRef: Maybe<NodeReference>): NodeId | null;\nexport function deref(nodeRef: Maybe<NodeReference>): NodeId | null {\n  if (nodeRef) {\n    return nodeRef.$ref;\n  }\n  return null;\n}\n\nexport function createDefaultDom(): AppDom {\n  let dom = createDom();\n  const appNode = getApp(dom);\n\n  // Create default page\n  const newPageNode = createNode(dom, 'page', {\n    name: 'Page 1',\n    attributes: {\n      title: 'Page 1',\n      display: 'shell',\n      authorization: {\n        allowAll: true,\n      },\n    },\n  });\n\n  dom = addNode(dom, newPageNode, appNode, 'pages');\n\n  return dom;\n}\n\nexport function getPageByName(dom: AppDom, name: string): PageNode | null {\n  const rootNode = getApp(dom);\n  const { pages = [] } = getChildNodes(dom, rootNode);\n  return pages.find((page) => page.name === name) ?? null;\n}\n\nexport function getQueryByName(dom: AppDom, page: PageNode, name: string): QueryNode | null {\n  const { queries = [] } = getChildNodes(dom, page);\n  return queries.find((query) => query.name === name) ?? null;\n}\n\n/**\n * Represents the changes between two doms in terms of added/deleted nodes.\n */\nexport interface DomDiff {\n  set: AppDomNode[];\n  unset: NodeId[];\n}\n\n/**\n * Compare two doms and return a diff of the changes.\n */\nexport function createDiff(from: AppDom, to: AppDom): DomDiff {\n  const result: DomDiff = {\n    set: [],\n    unset: [],\n  };\n\n  const allIds = new Set<NodeId>([\n    ...(Object.keys(from.nodes) as NodeId[]),\n    ...(Object.keys(to.nodes) as NodeId[]),\n  ]);\n\n  for (const id of allIds) {\n    if (to.nodes[id] && to.nodes[id] !== from.nodes[id]) {\n      result.set.push(to.nodes[id]);\n    } else if (!to.nodes[id] && from.nodes[id]) {\n      result.unset.push(id);\n    }\n  }\n\n  return result;\n}\n\n/**\n * Apply a diff to a dom and return the new dom.\n */\nexport function applyDiff(dom: AppDom, diff: DomDiff): AppDom {\n  let result = dom;\n\n  for (const node of diff.set) {\n    result = update(result, {\n      nodes: update(result.nodes, {\n        [node.id]: node,\n      }),\n    });\n  }\n\n  for (const id of diff.unset) {\n    result = update(result, {\n      nodes: omit(result.nodes, id),\n    });\n  }\n\n  return result;\n}\n\nexport function getPageDisplayName(node: PageNode): string {\n  return node.attributes.displayName || guessTitle(node.name);\n}\n\nexport function getPageTitle(node: PageNode): string {\n  return node.attributes.title || getPageDisplayName(node);\n}\n\nexport function getPlan(dom: AppDom): ToolpadPlan {\n  const appNode = getApp(dom);\n  return appNode.attributes.plan ?? 'free';\n}\n\nexport function getPageForAlias(dom: AppDom, alias: string): string | null {\n  const app = getApp(dom);\n  const pages = getChildNodes(dom, app).pages;\n  for (const page of pages) {\n    if (page.attributes.alias?.includes(alias)) {\n      return page.name;\n    }\n  }\n  return null;\n}\n"],"mappings":"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","names":[]}