import type { BoxProps, ThemeOptions as MuiThemeOptions } from '@mui/material';
import { Maybe } from '@toolpad/utils/types';
import type { NodeId, NodeReference, BindableAttrValue, BindableAttrValues, SecretAttrValue, BindableAttrEntries } from './types';
export declare const CURRENT_APPDOM_VERSION = 7;
export declare const RESERVED_NODE_PROPERTIES: readonly ["id", "type", "parentId", "parentProp", "parentIndex"];
export type ReservedNodeProperty = (typeof RESERVED_NODE_PROPERTIES)[number];
export declare function createFractionalIndex(index1: string | null, index2: string | null): string;
export declare function compareFractionalIndex(index1: string, index2: string): number;
export type ToolpadPlan = 'free' | 'pro';
export type AuthProvider = 'github' | 'google' | 'azure-ad' | 'credentials';
export interface AuthProviderConfig {
    readonly provider: AuthProvider;
    readonly roles?: {
        source: string[];
        target: string;
    }[];
}
export interface ConnectionStatus {
    timestamp: number;
    error?: string;
}
type AppDomNodeType = 'app' | 'connection' | 'theme' | 'page' | 'element' | 'query' | 'mutation';
export interface AppDomNodeBase {
    readonly id: NodeId;
    readonly type: AppDomNodeType;
    readonly name: string;
    readonly parentId: NodeId | null;
    readonly parentProp: string | null;
    readonly parentIndex: string | null;
    readonly attributes: {};
}
export interface AppNode extends AppDomNodeBase {
    readonly type: 'app';
    readonly parentId: null;
    readonly attributes: {
        readonly plan?: ToolpadPlan;
        readonly authentication?: {
            readonly providers?: AuthProviderConfig[];
            readonly restrictedDomains?: string[];
        };
        readonly authorization?: {
            readonly roles?: {
                readonly name: string;
                readonly description?: string;
            }[];
        };
    };
}
export interface ThemeNode extends AppDomNodeBase {
    readonly type: 'theme';
    readonly theme?: MuiThemeOptions;
}
export interface ConnectionNode<P = unknown> extends AppDomNodeBase {
    readonly type: 'connection';
    readonly attributes: {
        readonly dataSource: string;
        readonly params: SecretAttrValue<P | null>;
        readonly status: ConnectionStatus | null;
    };
}
export type PageDisplayMode = 'standalone' | 'shell';
export type ContainerWidth = 'xs' | 'sm' | 'md' | 'lg' | 'xl' | 'none';
export declare const DEFAULT_CONTAINER_WIDTH = "lg";
export interface PageNode extends AppDomNodeBase {
    readonly type: 'page';
    readonly attributes: {
        readonly title?: string;
        readonly alias?: string[];
        readonly parameters?: [string, string][];
        readonly module?: string;
        readonly display?: PageDisplayMode;
        readonly displayName?: string;
        readonly maxWidth?: ContainerWidth;
        readonly authorization?: {
            readonly allowAll?: boolean;
            readonly allowedRoles?: string[];
        };
    };
}
export interface ElementNode<P = any> extends AppDomNodeBase {
    readonly type: 'element';
    readonly attributes: {
        readonly component: string;
    };
    readonly props?: BindableAttrValues<P>;
    readonly layout?: {
        readonly horizontalAlign?: BoxProps['justifyContent'];
        readonly verticalAlign?: BoxProps['alignItems'];
        readonly columnSize?: number;
        readonly height?: number;
    };
}
export type FetchMode = 'query' | 'mutation';
/**
 * A DOM query is defined primarily by a server defined part "attributes.query"
 * and a clientside defined part "params". "params" are constructed in the runtime
 * from bound expressions. The resolved object will be sent to the server and combined
 * with the query will be used to collect the data from the backend.
 */
export interface QueryNode<Q = any> extends AppDomNodeBase {
    readonly type: 'query';
    readonly params?: BindableAttrEntries;
    readonly attributes: {
        readonly mode?: FetchMode;
        readonly dataSource?: string;
        readonly connectionId: NodeReference | null;
        readonly query: Q;
        readonly transform?: string;
        readonly transformEnabled?: boolean;
        /** @deprecated Not necessary to be user-facing, we will expose staleTime instead if necessary */
        readonly refetchOnWindowFocus?: boolean;
        /** @deprecated Not necessary to be user-facing, we will expose staleTime instead if necessary */
        readonly refetchOnReconnect?: boolean;
        readonly refetchInterval?: number;
        readonly cacheTime?: number;
        readonly enabled?: BindableAttrValue<boolean>;
    };
}
/**
 * @deprecated QueryNode can act as a mutation by switching the `mode` attribute to 'mutation'
 */
export interface MutationNode<Q = any> extends AppDomNodeBase {
    readonly type: 'mutation';
    readonly params?: BindableAttrValues;
    readonly attributes: {
        readonly dataSource?: string;
        readonly connectionId: NodeReference | null;
        readonly query: Q;
    };
}
type AppDomNodeOfType<K extends AppDomNodeType> = {
    app: AppNode;
    connection: ConnectionNode;
    theme: ThemeNode;
    page: PageNode;
    element: ElementNode;
    query: QueryNode;
    mutation: MutationNode;
}[K];
type AllowedChildren = {
    app: {
        pages: 'page';
        connections: 'connection';
        themes: 'theme';
    };
    theme: {};
    connection: {};
    page: {
        children: 'element';
        queries: 'query';
        mutations: 'mutation';
    };
    element: {
        [prop: string]: 'element';
    };
    query: {};
    mutation: {};
};
export type AppDomNode = AppDomNodeOfType<AppDomNodeType>;
type TypeOf<N extends AppDomNode> = N['type'];
type AllowedChildTypesOfType<T extends AppDomNodeType> = AllowedChildren[T];
type AllowedChildTypesOf<N extends AppDomNode> = AllowedChildTypesOfType<TypeOf<N>>;
export type ChildNodesOf<N extends AppDomNode> = {
    [K in keyof AllowedChildTypesOf<N>]: AllowedChildTypesOf<N>[K] extends AppDomNodeType ? AppDomNodeOfType<AllowedChildTypesOf<N>[K]>[] : never;
};
type CombinedChildrenOfType<T extends AppDomNodeType> = AllowedChildren[T][keyof AllowedChildren[T]];
type CombinedAllowedChildren = {
    [K in AppDomNodeType]: CombinedChildrenOfType<K>;
};
type ParentTypeOfType<T extends AppDomNodeType> = {
    [K in AppDomNodeType]: T extends CombinedAllowedChildren[K] ? K : never;
}[AppDomNodeType];
export type ParentOf<N extends AppDomNode> = AppDomNodeOfType<ParentTypeOfType<TypeOf<N>>> | null;
export type ParentProp<Parent extends AppDomNode> = keyof AllowedChildTypesOfType<TypeOf<Parent>>;
export type ParentPropOf<Child extends AppDomNode, Parent extends AppDomNode> = {
    [K in keyof AllowedChildren[TypeOf<Parent>]]: TypeOf<Child> extends AllowedChildren[TypeOf<Parent>][K] ? K & string : never;
}[keyof AllowedChildren[TypeOf<Parent>]];
export type AppDomNodes = Record<NodeId, AppDomNode>;
export interface AppDom {
    nodes: AppDomNodes;
    root: NodeId;
    version?: number;
}
export declare function createId(): NodeId;
export declare function createSecret<V>(value: V): SecretAttrValue<V>;
export declare function getMaybeNode<T extends AppDomNodeType>(dom: AppDom, nodeId: NodeId, type: T): AppDomNodeOfType<T> | null;
export declare function getMaybeNode<T extends AppDomNodeType>(dom: AppDom, nodeId: NodeId, type?: T): AppDomNode | null;
export declare function getNode<T extends AppDomNodeType>(dom: AppDom, nodeId: NodeId, type: T): AppDomNodeOfType<T>;
export declare function getNode<T extends AppDomNodeType>(dom: AppDom, nodeId: NodeId, type?: T): AppDomNode;
export declare function isApp(node: AppDomNode): node is AppNode;
export declare function assertIsApp(node: AppDomNode): asserts node is AppNode;
export declare function isPage(node: AppDomNode): node is PageNode;
export declare function assertIsPage(node: AppDomNode): asserts node is PageNode;
export declare function isConnection<P>(node: AppDomNode): node is ConnectionNode<P>;
export declare function assertIsConnection<P>(node: AppDomNode): asserts node is ConnectionNode<P>;
export declare function isTheme(node: AppDomNode): node is ThemeNode;
export declare function assertIsTheme(node: AppDomNode): asserts node is ThemeNode;
export declare function isElement<P>(node: AppDomNode): node is ElementNode<P>;
export declare function assertIsElement<P>(node: AppDomNode): asserts node is ElementNode<P>;
export declare function isQuery<P>(node: AppDomNode): node is QueryNode<P>;
export declare function assertIsQuery<P>(node: AppDomNode): asserts node is QueryNode<P>;
export declare function isMutation<P>(node: AppDomNode): node is MutationNode<P>;
export declare function assertIsMutation<P>(node: AppDomNode): asserts node is MutationNode<P>;
export declare function getRoot(dom: AppDom): AppDomNode;
export declare function getApp(dom: AppDom): AppNode;
export type NodeChildren<N extends AppDomNode = any> = ChildNodesOf<N>;
export declare function getChildNodes<N extends AppDomNode>(dom: AppDom, parent: N): NodeChildren<N>;
export declare function getParent<N extends AppDomNode>(dom: AppDom, child: N): ParentOf<N>;
type AppDomNodeInitOfType<T extends AppDomNodeType> = Omit<AppDomNodeOfType<T>, ReservedNodeProperty | 'name'> & {
    name?: string;
};
export declare function validateNodeName(name: string, disallowedNames: Set<string>, kind: string): string | null;
export declare function createNode<T extends AppDomNodeType>(dom: AppDom, type: T, init: AppDomNodeInitOfType<T>): AppDomNodeOfType<T>;
export declare function createFragment<T extends AppDomNodeType>(type: T, init: AppDomNodeInitOfType<T> & {
    name: string;
}): AppDom;
export declare function createDom(): AppDom;
/**
 * Creates a new DOM node representing a React Element
 */
export declare function createElement<P>(dom: AppDom, component: string, props?: Partial<BindableAttrValues<P>>, layout?: Partial<BindableAttrValues<P>>, name?: string): ElementNode;
/**
 * Get all descendants of a `node`, flattens childNodes objects into one single array
 */
export declare function getDescendants(dom: AppDom, node: AppDomNode): readonly AppDomNode[];
/**
 * Get all siblings of a `node`
 */
export declare function getSiblings(dom: AppDom, node: AppDomNode): readonly AppDomNode[];
export declare function getAncestors(dom: AppDom, node: AppDomNode): readonly AppDomNode[];
/**
 * Get all the ancestors of the `node` up until the first PageNode node is encountered
 */
export declare function getPageAncestors(dom: AppDom, node: AppDomNode): readonly (ElementNode | PageNode)[];
/**
 * Get the first PageNode node up in the DOM tree starting from `node`
 */
export declare function getPageAncestor(dom: AppDom, node: AppDomNode): PageNode | null;
/**
 * Returns all nodes with a given component type
 */
export declare function getComponentTypeNodes(dom: AppDom, componentId: string): readonly AppDomNode[];
/**
 * Returns the set of names for which the given node must have a different name
 */
export declare function getExistingNamesForNode(dom: AppDom, node: AppDomNode): Set<string>;
export declare function getExistingNamesForChildren<Parent extends AppDomNode>(dom: AppDom, parent: Parent, parentProp?: ParentProp<Parent>): Set<string>;
export declare function proposeName(candidate: string, disallowedNames?: Set<string>): string;
export declare function setNodeName(dom: AppDom, node: AppDomNode, name: string): AppDom;
export type PropNamespaces<N extends AppDomNode> = {
    [K in keyof N]: N[K] extends BindableAttrValues<any> | undefined ? K : never;
}[keyof N & string];
export type BindableProps<T> = {
    [K in keyof T]: T[K] extends BindableAttrValue<any> ? K : never;
}[keyof T & string];
export declare function setNodeProp<Node extends AppDomNode, Prop extends BindableProps<Node>>(dom: AppDom, node: Node, prop: Prop, value: Node[Prop] | null): AppDom;
export declare function setNamespacedProp<Node extends AppDomNode, Namespace extends PropNamespaces<Node>, Prop extends keyof Node[Namespace] & string>(node: Node, namespace: Namespace, prop: Prop, value: Node[Namespace][Prop] | null): Node;
export declare function setQueryProp<Q, K extends keyof Q>(node: QueryNode<Q>, prop: K, value: Q[K]): QueryNode<Q>;
export declare function setNodeNamespacedProp<Node extends AppDomNode, Namespace extends PropNamespaces<Node>, Prop extends keyof NonNullable<Node[Namespace]> & string>(dom: AppDom, node: Node, namespace: Namespace, prop: Prop, value: NonNullable<Node[Namespace]>[Prop]): AppDom;
export declare function addNode<Parent extends AppDomNode, Child extends AppDomNode>(dom: AppDom, newNode: Child, parent: Parent, parentProp: ParentPropOf<Child, Parent>, parentIndex?: string): AppDom;
export declare function moveNode<Parent extends AppDomNode, Child extends AppDomNode>(dom: AppDom, node: Child, parent: Parent, parentProp: ParentPropOf<Child, Parent>, parentIndex?: string): AppDom;
export declare function spreadNode<Child extends AppDomNode>(dom: AppDom, node: Child): AppDom;
export declare function nodeExists(dom: AppDom, nodeId: NodeId): boolean;
export declare function saveNode(dom: AppDom, node: AppDomNode): AppDom;
export declare function removeNode(dom: AppDom, nodeId: NodeId): AppDom;
export declare function removeMaybeNode(dom: AppDom, nodeId: NodeId): AppDom;
export declare function fromConstPropValue(prop: undefined): undefined;
export declare function fromConstPropValue<T>(prop: BindableAttrValue<T>): T;
export declare function fromConstPropValue<T>(prop?: BindableAttrValue<T | undefined>): T | undefined;
export declare function fromConstPropValues<P>(props: BindableAttrValues<P>): Partial<P>;
export declare function getNodeFirstChild(dom: AppDom, node: ElementNode | PageNode, parentProp: string): ElementNode<any> | null;
export declare function getNodeLastChild(dom: AppDom, node: ElementNode | PageNode, parentProp: string): ElementNode<any> | null;
export declare function getSiblingBeforeNode(dom: AppDom, node: ElementNode | PageNode, parentProp: string): ElementNode<any> | null;
export declare function getSiblingAfterNode(dom: AppDom, node: ElementNode | PageNode, parentProp: string): ElementNode<any> | null;
export declare function getNewFirstParentIndexInNode(dom: AppDom, node: ElementNode | PageNode, parentProp: string): string;
export declare function getNewLastParentIndexInNode(dom: AppDom, node: ElementNode | PageNode, parentProp: string): string;
export declare function getNewParentIndexBeforeNode(dom: AppDom, node: ElementNode | PageNode, parentProp: string): string;
export declare function getNewParentIndexAfterNode(dom: AppDom, node: ElementNode | PageNode, parentProp: string): string;
export declare function addFragment(dom: AppDom, fragment: AppDom, parentId: NodeId, parentProp: string, parentIndex?: string | undefined): AppDom;
/**
 * Make a copy of a subtree (a fragment) of the dom. The structure of a fragment is
 * the same as a dom where the root is the node we create the fragment for
 */
export declare function cloneFragment(dom: AppDom, nodeId: NodeId): AppDom;
export declare function duplicateNode(dom: AppDom, node: AppDomNode, parent?: AppDomNode | null, parentProp?: string | null): AppDom;
declare const RENDERTREE_NODES: readonly ["app", "page", "element", "query", "mutation", "theme"];
export type RenderTreeNodeType = (typeof RENDERTREE_NODES)[number];
export type RenderTreeNode = {
    [K in RenderTreeNodeType]: AppDomNodeOfType<K>;
}[RenderTreeNodeType];
export type RenderTreeNodes = Record<NodeId, RenderTreeNode>;
export interface RenderTree {
    root: NodeId;
    nodes: RenderTreeNodes;
    version?: number;
}
/**
 * We need to make sure no secrets end up in the frontend html, so let's only send the
 * nodes that we need to build frontend, and that we know don't contain secrets.
 * TODO: Would it make sense to create a separate datastructure that represents the render tree?
 */
export declare function createRenderTree(dom: AppDom): RenderTree;
export declare function ref(nodeId: NodeId): NodeReference;
export declare function ref(nodeId: null | undefined): null;
export declare function ref(nodeId: Maybe<NodeId>): NodeReference | null;
export declare function deref(nodeRef: NodeReference): NodeId;
export declare function deref(nodeRef: null | undefined): null;
export declare function deref(nodeRef: Maybe<NodeReference>): NodeId | null;
export declare function createDefaultDom(): AppDom;
export declare function getPageByName(dom: AppDom, name: string): PageNode | null;
export declare function getQueryByName(dom: AppDom, page: PageNode, name: string): QueryNode | null;
/**
 * Represents the changes between two doms in terms of added/deleted nodes.
 */
export interface DomDiff {
    set: AppDomNode[];
    unset: NodeId[];
}
/**
 * Compare two doms and return a diff of the changes.
 */
export declare function createDiff(from: AppDom, to: AppDom): DomDiff;
/**
 * Apply a diff to a dom and return the new dom.
 */
export declare function applyDiff(dom: AppDom, diff: DomDiff): AppDom;
export declare function getPageDisplayName(node: PageNode): string;
export declare function getPageTitle(node: PageNode): string;
export declare function getPlan(dom: AppDom): ToolpadPlan;
export declare function getPageForAlias(dom: AppDom, alias: string): string | null;
export {};
