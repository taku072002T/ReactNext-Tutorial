// src/appDom.ts
import { nanoid } from "nanoid/non-secure";
import { generateKeyBetween } from "fractional-indexing";
import invariant from "invariant";
import { guessTitle, pascalCase, removeDiacritics, uncapitalize } from "@toolpad/utils/strings";
import { mapProperties, mapValues, hasOwnProperty } from "@toolpad/utils/collections";
import { omit, update, updateOrCreate } from "@toolpad/utils/immutability";
var CURRENT_APPDOM_VERSION = 7;
var RESERVED_NODE_PROPERTIES = [
  "id",
  "type",
  "parentId",
  "parentProp",
  "parentIndex"
];
function createFractionalIndex(index1, index2) {
  return generateKeyBetween(index1, index2);
}
function compareFractionalIndex(index1, index2) {
  if (index1 === index2) {
    return 0;
  }
  return index1 > index2 ? 1 : -1;
}
var DEFAULT_CONTAINER_WIDTH = "lg";
function isType(node, type) {
  return node.type === type;
}
function assertIsType(node, type) {
  invariant(isType(node, type), `Expected node type "${type}" but got "${node.type}"`);
}
function createId() {
  return nanoid(7);
}
function createSecret(value) {
  return { $$secret: value };
}
function getMaybeNode(dom, nodeId, type) {
  const node = dom.nodes[nodeId];
  if (!node) {
    return null;
  }
  if (type) {
    assertIsType(node, type);
  }
  return node;
}
function getNode(dom, nodeId, type) {
  const node = getMaybeNode(dom, nodeId, type);
  if (!node) {
    throw new Error(`Node "${nodeId}" not found`);
  }
  return node;
}
function isApp(node) {
  return isType(node, "app");
}
function assertIsApp(node) {
  assertIsType(node, "app");
}
function isPage(node) {
  return isType(node, "page");
}
function assertIsPage(node) {
  assertIsType(node, "page");
}
function isConnection(node) {
  return isType(node, "connection");
}
function assertIsConnection(node) {
  assertIsType(node, "connection");
}
function isTheme(node) {
  return isType(node, "theme");
}
function assertIsTheme(node) {
  assertIsType(node, "theme");
}
function isElement(node) {
  return isType(node, "element");
}
function assertIsElement(node) {
  assertIsType(node, "element");
}
function isQuery(node) {
  return isType(node, "query");
}
function assertIsQuery(node) {
  assertIsType(node, "query");
}
function isMutation(node) {
  return isType(node, "mutation");
}
function assertIsMutation(node) {
  assertIsType(node, "mutation");
}
function getRoot(dom) {
  return getNode(dom, dom.root);
}
function getApp(dom) {
  const app = getRoot(dom);
  assertIsApp(app);
  return app;
}
var childrenMemo = /* @__PURE__ */ new WeakMap();
function getChildNodes(dom, parent) {
  let domChildrenMemo = childrenMemo.get(dom);
  if (!domChildrenMemo) {
    domChildrenMemo = /* @__PURE__ */ new Map();
    childrenMemo.set(dom, domChildrenMemo);
  }
  let result = domChildrenMemo.get(parent.id);
  if (!result) {
    result = {};
    domChildrenMemo.set(parent.id, result);
    const allNodeChildren = Object.values(dom.nodes).filter(
      (node) => node.parentId === parent.id
    );
    for (const child of allNodeChildren) {
      const prop = child.parentProp || "children";
      let existing = result[prop];
      if (!existing) {
        existing = [];
        result[prop] = existing;
      }
      existing.push(child);
    }
    for (const childArray of Object.values(result)) {
      childArray?.sort((node1, node2) => {
        invariant(
          node1.parentIndex && node2.parentIndex,
          `Nodes inside the dom should have a parentIndex if they have a parent`
        );
        return compareFractionalIndex(node1.parentIndex, node2.parentIndex);
      });
    }
  }
  return result;
}
function getParent(dom, child) {
  child = getNode(dom, child.id, child.type);
  if (child.parentId) {
    const parent = getNode(dom, child.parentId);
    return parent;
  }
  return null;
}
function createNodeInternal(id, type, init) {
  return {
    ...init,
    id,
    type,
    parentId: null,
    parentProp: null,
    parentIndex: null
  };
}
function slugifyNodeName(nameCandidate, fallback) {
  let slug = nameCandidate;
  slug = slug.trim();
  slug = removeDiacritics(slug);
  const [first, ...rest] = slug.split(/\s+/);
  slug = first + pascalCase(...rest);
  slug = slug.replace(/[^a-zA-Z0-9]+/g, "_");
  slug = slug.replace(/^\d+/g, "");
  if (!slug) {
    slug = fallback;
  }
  return slug;
}
function validateNodeName(name, disallowedNames, kind) {
  if (!name) {
    return "a name is required";
  }
  const firstLetter = name[0];
  if (!/[a-z_]/i.test(firstLetter)) {
    return `${kind} may not start with a "${firstLetter}"`;
  }
  const match = /([^a-z0-9_])/i.exec(name);
  if (match) {
    const invalidCharacter = match[1];
    if (/\s/.test(invalidCharacter)) {
      return `${kind} may not contain spaces`;
    }
    return `${kind} may not contain a "${invalidCharacter}"`;
  }
  const slug = slugifyNodeName(name, kind);
  const isDuplicate = disallowedNames.has(slug);
  if (isDuplicate) {
    return `There already is a ${kind} with this name`;
  }
  return null;
}
function createNode(dom, type, init) {
  const id = createId();
  const name = slugifyNodeName(init.name || type, type);
  return createNodeInternal(id, type, {
    ...init,
    name
  });
}
function createFragmentInternal(id, type, init) {
  return {
    nodes: {
      [id]: createNodeInternal(id, type, init)
    },
    root: id,
    version: CURRENT_APPDOM_VERSION
  };
}
function createFragment(type, init) {
  const rootId = createId();
  return createFragmentInternal(rootId, type, init);
}
function createDom() {
  return createFragment("app", {
    name: "Application",
    attributes: {}
  });
}
function createElement(dom, component, props = {}, layout = {}, name) {
  return createNode(dom, "element", {
    name: name || uncapitalize(component),
    props,
    attributes: {
      component
    },
    layout
  });
}
function getDescendants(dom, node) {
  const children = Object.values(getChildNodes(dom, node)).flat().filter(Boolean);
  return [...children, ...children.flatMap((child) => getDescendants(dom, child))];
}
function getSiblings(dom, node) {
  return Object.values(dom.nodes).filter(
    (sibling) => sibling.parentId === node.parentId && sibling.parentProp === node.parentProp && sibling.id !== node.id
  );
}
function getAncestors(dom, node) {
  const parent = getParent(dom, node);
  return parent ? [...getAncestors(dom, parent), parent] : [];
}
function getPageAncestors(dom, node) {
  const parent = getParent(dom, node);
  return parent && (isElement(parent) || isPage(parent)) ? [...getPageAncestors(dom, parent), parent] : [];
}
function getPageAncestor(dom, node) {
  if (isPage(node)) {
    return node;
  }
  const parent = getParent(dom, node);
  if (parent) {
    return getPageAncestor(dom, parent);
  }
  return null;
}
function getComponentTypeNodes(dom, componentId) {
  return Object.values(dom.nodes).filter(
    (node) => isElement(node) && node.attributes.component === componentId
  );
}
function getExistingNamesForNode(dom, node) {
  if (isElement(node)) {
    const pageNode = getPageAncestor(dom, node);
    const pageDescendants = pageNode ? getDescendants(dom, pageNode) : [];
    return new Set(
      pageDescendants.filter((descendant) => descendant.id !== node.id).map((scopeNode) => scopeNode.name)
    );
  }
  return new Set(getSiblings(dom, node).map((scopeNode) => scopeNode.name));
}
function getExistingNamesForChildren(dom, parent, parentProp) {
  const pageNode = getPageAncestor(dom, parent);
  if (pageNode) {
    const pageDescendants = getDescendants(dom, pageNode);
    return new Set(pageDescendants.map((scopeNode) => scopeNode.name));
  }
  if (parentProp) {
    const childNodes = getChildNodes(dom, parent);
    const { [parentProp]: children = [] } = childNodes;
    return new Set(children.map((scopeNode) => scopeNode.name));
  }
  const descendants = getDescendants(dom, parent);
  return new Set(descendants.map((scopeNode) => scopeNode.name));
}
function proposeName(candidate, disallowedNames = /* @__PURE__ */ new Set()) {
  const slug = slugifyNodeName(candidate, "node");
  if (!disallowedNames.has(slug)) {
    return slug;
  }
  const basename = candidate.replace(/\d+$/, "");
  let counter = 1;
  while (disallowedNames.has(basename + counter)) {
    counter += 1;
  }
  return basename + counter;
}
function setNodeName(dom, node, name) {
  if (dom.nodes[node.id].name === name) {
    return dom;
  }
  return update(dom, {
    nodes: update(dom.nodes, {
      [node.id]: {
        ...node,
        name: slugifyNodeName(name, node.type)
      }
    })
  });
}
function setNodeProp(dom, node, prop, value) {
  if (value) {
    return update(dom, {
      nodes: update(dom.nodes, {
        [node.id]: update(node, {
          [prop]: value
        })
      })
    });
  }
  return update(dom, {
    nodes: update(dom.nodes, {
      [node.id]: omit(node, prop)
    })
  });
}
function setNamespacedProp(node, namespace, prop, value) {
  if (value) {
    return update(node, {
      [namespace]: updateOrCreate(node[namespace], {
        [prop]: value
      })
    });
  }
  return update(node, {
    [namespace]: omit(node[namespace], prop)
  });
}
function setQueryProp(node, prop, value) {
  const original = node.attributes.query;
  return setNamespacedProp(node, "attributes", "query", { ...original, [prop]: value });
}
function setNodeNamespacedProp(dom, node, namespace, prop, value) {
  return update(dom, {
    nodes: update(dom.nodes, {
      [node.id]: update(dom.nodes[node.id], {
        [namespace]: updateOrCreate(dom.nodes[node.id][namespace], {
          [prop]: value
        })
      })
    })
  });
}
function setNodeParent(dom, node, parentId, parentProp, parentIndex) {
  if (!parentIndex) {
    const parent = getNode(dom, parentId);
    const children = getChildNodes(dom, parent)[parentProp] ?? [];
    const lastIndex = children.length > 0 ? children[children.length - 1].parentIndex : null;
    parentIndex = createFractionalIndex(lastIndex, null);
  }
  return update(dom, {
    nodes: update(dom.nodes, {
      [node.id]: update(node, {
        parentId,
        parentProp,
        parentIndex
      })
    })
  });
}
function addNode(dom, newNode, parent, parentProp, parentIndex) {
  if (newNode.parentId) {
    throw new Error(`Node "${newNode.id}" is already attached to a parent`);
  }
  const existingNames = getExistingNamesForChildren(dom, parent, parentProp);
  if (existingNames.has(newNode.name)) {
    newNode = {
      ...newNode,
      name: proposeName(newNode.name, existingNames)
    };
  }
  return setNodeParent(dom, newNode, parent.id, parentProp, parentIndex);
}
function moveNode(dom, node, parent, parentProp, parentIndex) {
  return setNodeParent(dom, node, parent.id, parentProp, parentIndex);
}
function spreadNode(dom, node) {
  const parent = getParent(dom, node);
  const parentProp = node.parentProp;
  let draft = dom;
  if (parent && parentProp && isElement(node)) {
    for (const child of getChildNodes(draft, node).children) {
      const parentIndex = getNewParentIndexBeforeNode(draft, node, parentProp);
      draft = setNodeParent(draft, child, parent.id, parentProp, parentIndex);
    }
    draft = removeNode(draft, node.id);
  }
  return draft;
}
function nodeExists(dom, nodeId) {
  return !!getMaybeNode(dom, nodeId);
}
function saveNode(dom, node) {
  if (!nodeExists(dom, node.id)) {
    throw new Error(`Attempt to update node "${node.id}", but it doesn't exist in the dom`);
  }
  return update(dom, {
    nodes: update(dom.nodes, {
      [node.id]: update(dom.nodes[node.id], omit(node, ...RESERVED_NODE_PROPERTIES))
    })
  });
}
function removeNode(dom, nodeId) {
  const node = getNode(dom, nodeId);
  const parent = getParent(dom, node);
  invariant(parent, `Node: "${node.id}" can't be removed`);
  const descendantIds = getDescendants(dom, node).map(({ id }) => id);
  return update(dom, {
    nodes: omit(dom.nodes, node.id, ...descendantIds)
  });
}
function removeMaybeNode(dom, nodeId) {
  if (getMaybeNode(dom, nodeId)) {
    return removeNode(dom, nodeId);
  }
  return dom;
}
function fromConstPropValue(prop) {
  if (!prop) {
    return void 0;
  }
  if (hasOwnProperty(prop, "$$jsExpression") || hasOwnProperty(prop, "$$env")) {
    throw new Error(`trying to unbox a non-constant prop value`);
  }
  return prop;
}
function fromConstPropValues(props) {
  const result = {};
  Object.entries(props).forEach(([name, prop]) => {
    if (prop) {
      result[name] = fromConstPropValue(prop);
    }
  });
  return result;
}
function getNodeFirstChild(dom, node, parentProp) {
  const nodeChildren = getChildNodes(dom, node)[parentProp] || [];
  return nodeChildren.length > 0 ? nodeChildren[0] : null;
}
function getNodeLastChild(dom, node, parentProp) {
  const nodeChildren = getChildNodes(dom, node)[parentProp] || [];
  return nodeChildren.length > 0 ? nodeChildren[nodeChildren.length - 1] : null;
}
function getSiblingBeforeNode(dom, node, parentProp) {
  const parent = getParent(dom, node);
  invariant(parent, `Node: "${node.id}" has no parent`);
  const parentChildren = (isPage(parent) || isElement(parent)) && getChildNodes(dom, parent)[parentProp] || [];
  const nodeIndex = parentChildren.findIndex((child) => child.id === node.id);
  const nodeBefore = nodeIndex > 0 ? parentChildren[nodeIndex - 1] : null;
  return nodeBefore;
}
function getSiblingAfterNode(dom, node, parentProp) {
  const parent = getParent(dom, node);
  invariant(parent, `Node: "${node.id}" has no parent`);
  const parentChildren = (isPage(parent) || isElement(parent)) && getChildNodes(dom, parent)[parentProp] || [];
  const nodeIndex = parentChildren.findIndex((child) => child.id === node.id);
  const nodeAfter = nodeIndex < parentChildren.length - 1 ? parentChildren[nodeIndex + 1] : null;
  return nodeAfter;
}
function getNewFirstParentIndexInNode(dom, node, parentProp) {
  const firstChild = getNodeFirstChild(dom, node, parentProp);
  return createFractionalIndex(null, firstChild?.parentIndex || null);
}
function getNewLastParentIndexInNode(dom, node, parentProp) {
  const lastChild = getNodeLastChild(dom, node, parentProp);
  return createFractionalIndex(lastChild?.parentIndex || null, null);
}
function getNewParentIndexBeforeNode(dom, node, parentProp) {
  const nodeBefore = getSiblingBeforeNode(dom, node, parentProp);
  return createFractionalIndex(nodeBefore?.parentIndex || null, node.parentIndex);
}
function getNewParentIndexAfterNode(dom, node, parentProp) {
  const nodeAfter = getSiblingAfterNode(dom, node, parentProp);
  return createFractionalIndex(node.parentIndex, nodeAfter?.parentIndex || null);
}
function addFragment(dom, fragment, parentId, parentProp, parentIndex) {
  const parent = getNode(dom, parentId);
  const existingNames = getExistingNamesForChildren(dom, parent, parentProp);
  let combinedDom = {
    ...dom,
    nodes: {
      ...dom.nodes,
      ...mapValues(fragment.nodes, (node) => {
        return existingNames.has(node.name) ? { ...node, name: proposeName(node.name, existingNames) } : node;
      })
    }
  };
  const fragmentRoot = getNode(combinedDom, fragment.root);
  combinedDom = setNodeParent(combinedDom, fragmentRoot, parentId, parentProp, parentIndex);
  return combinedDom;
}
function cloneFragment(dom, nodeId) {
  const node = getNode(dom, nodeId);
  const newNode = createNode(dom, node.type, node);
  const childNodes = getChildNodes(dom, node);
  let result = {
    root: newNode.id,
    nodes: {
      [newNode.id]: newNode
    }
  };
  for (const [childParentProp, children] of Object.entries(childNodes)) {
    if (children) {
      for (const child of children) {
        const childFragment = cloneFragment(dom, child.id);
        result = addFragment(result, childFragment, newNode.id, childParentProp);
      }
    }
  }
  return result;
}
function duplicateNode(dom, node, parent = getParent(dom, node), parentProp = node.parentProp) {
  if (!parent || !parentProp) {
    throw new Error(`Node "${node.id}" can't be duplicated, it must have a parent`);
  }
  if (isElement(node)) {
    const fragment = cloneFragment(dom, node.id);
    return addFragment(
      dom,
      fragment,
      parent.id,
      parentProp,
      getNewParentIndexAfterNode(dom, node, parentProp)
    );
  }
  return dom;
}
var RENDERTREE_NODES = ["app", "page", "element", "query", "mutation", "theme"];
var frontendNodes = new Set(RENDERTREE_NODES);
function createRenderTreeNode(node) {
  if (!frontendNodes.has(node.type)) {
    return null;
  }
  if (isQuery(node) || isMutation(node)) {
    if (node.attributes.query) {
      node = setNamespacedProp(node, "attributes", "query", null);
    }
  }
  return node;
}
function createRenderTree(dom) {
  return {
    ...dom,
    nodes: mapProperties(dom.nodes, ([id, node]) => {
      const rendernode = createRenderTreeNode(node);
      return rendernode ? [id, rendernode] : null;
    })
  };
}
function ref(nodeId) {
  return nodeId ? { $ref: nodeId } : null;
}
function deref(nodeRef) {
  if (nodeRef) {
    return nodeRef.$ref;
  }
  return null;
}
function createDefaultDom() {
  let dom = createDom();
  const appNode = getApp(dom);
  const newPageNode = createNode(dom, "page", {
    name: "Page 1",
    attributes: {
      title: "Page 1",
      display: "shell",
      authorization: {
        allowAll: true
      }
    }
  });
  dom = addNode(dom, newPageNode, appNode, "pages");
  return dom;
}
function getPageByName(dom, name) {
  const rootNode = getApp(dom);
  const { pages = [] } = getChildNodes(dom, rootNode);
  return pages.find((page) => page.name === name) ?? null;
}
function getQueryByName(dom, page, name) {
  const { queries = [] } = getChildNodes(dom, page);
  return queries.find((query) => query.name === name) ?? null;
}
function createDiff(from, to) {
  const result = {
    set: [],
    unset: []
  };
  const allIds = /* @__PURE__ */ new Set([
    ...Object.keys(from.nodes),
    ...Object.keys(to.nodes)
  ]);
  for (const id of allIds) {
    if (to.nodes[id] && to.nodes[id] !== from.nodes[id]) {
      result.set.push(to.nodes[id]);
    } else if (!to.nodes[id] && from.nodes[id]) {
      result.unset.push(id);
    }
  }
  return result;
}
function applyDiff(dom, diff) {
  let result = dom;
  for (const node of diff.set) {
    result = update(result, {
      nodes: update(result.nodes, {
        [node.id]: node
      })
    });
  }
  for (const id of diff.unset) {
    result = update(result, {
      nodes: omit(result.nodes, id)
    });
  }
  return result;
}
function getPageDisplayName(node) {
  return node.attributes.displayName || guessTitle(node.name);
}
function getPageTitle(node) {
  return node.attributes.title || getPageDisplayName(node);
}
function getPlan(dom) {
  const appNode = getApp(dom);
  return appNode.attributes.plan ?? "free";
}
function getPageForAlias(dom, alias) {
  const app = getApp(dom);
  const pages = getChildNodes(dom, app).pages;
  for (const page of pages) {
    if (page.attributes.alias?.includes(alias)) {
      return page.name;
    }
  }
  return null;
}
export {
  CURRENT_APPDOM_VERSION,
  DEFAULT_CONTAINER_WIDTH,
  RESERVED_NODE_PROPERTIES,
  addFragment,
  addNode,
  applyDiff,
  assertIsApp,
  assertIsConnection,
  assertIsElement,
  assertIsMutation,
  assertIsPage,
  assertIsQuery,
  assertIsTheme,
  cloneFragment,
  compareFractionalIndex,
  createDefaultDom,
  createDiff,
  createDom,
  createElement,
  createFractionalIndex,
  createFragment,
  createId,
  createNode,
  createRenderTree,
  createSecret,
  deref,
  duplicateNode,
  fromConstPropValue,
  fromConstPropValues,
  getAncestors,
  getApp,
  getChildNodes,
  getComponentTypeNodes,
  getDescendants,
  getExistingNamesForChildren,
  getExistingNamesForNode,
  getMaybeNode,
  getNewFirstParentIndexInNode,
  getNewLastParentIndexInNode,
  getNewParentIndexAfterNode,
  getNewParentIndexBeforeNode,
  getNode,
  getNodeFirstChild,
  getNodeLastChild,
  getPageAncestor,
  getPageAncestors,
  getPageByName,
  getPageDisplayName,
  getPageForAlias,
  getPageTitle,
  getParent,
  getPlan,
  getQueryByName,
  getRoot,
  getSiblingAfterNode,
  getSiblingBeforeNode,
  getSiblings,
  isApp,
  isConnection,
  isElement,
  isMutation,
  isPage,
  isQuery,
  isTheme,
  moveNode,
  nodeExists,
  proposeName,
  ref,
  removeMaybeNode,
  removeNode,
  saveNode,
  setNamespacedProp,
  setNodeName,
  setNodeNamespacedProp,
  setNodeProp,
  setQueryProp,
  spreadNode,
  validateNodeName
};
//# sourceMappingURL=appDom.js.map