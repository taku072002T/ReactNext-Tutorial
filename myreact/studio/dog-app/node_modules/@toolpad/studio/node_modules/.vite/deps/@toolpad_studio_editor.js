import {
  getDesignTokens,
  getMetaThemeColor,
  getThemedComponents
} from "./chunk-UAYT4TLE.js";
import {
  createHarLog,
  mergeHar
} from "./chunk-V2BXJGCT.js";
import {
  index_modern_default
} from "./chunk-EY4QO52J.js";
import {
  Add_default,
  AppHostProvider,
  ArrowBack_default,
  BrowserRouter,
  CanvasEventsContext,
  CanvasHooksContext,
  Close_default,
  Controller,
  DEFAULT_CONTAINER_WIDTH,
  DarkMode_default,
  DataGrid,
  DateFormatEditor,
  ErrorBoundary,
  EventManager,
  ExpandLess_default,
  FORM_COMPONENT_ID,
  GitHub_default,
  GridActionsCellItem,
  GridRowModes,
  GridToolbarContainer,
  LAYOUT_DIRECTION_BOTH,
  LAYOUT_DIRECTION_HORIZONTAL,
  LAYOUT_DIRECTION_VERTICAL,
  LightMode_default,
  Link,
  LoadingButton_default,
  MoreVert_default,
  NumberFormatEditor,
  PAGE_COLUMN_COMPONENT_ID,
  PAGE_ROW_COMPONENT_ID,
  Password_default,
  RenderedPage,
  Route,
  Routes,
  SPACER_COMPONENT_ID,
  STACK_COMPONENT_ID,
  TabContext,
  TabList_default,
  TabPanel_default,
  ToolpadAppProvider,
  ToolpadAppRoutes,
  addFragment,
  addNode,
  blueberryTwilightPalette,
  cloneFragment,
  createDiff,
  createElement,
  createNode,
  createProvidedContext,
  createRenderTree,
  createRpcApi,
  createToolpadAppTheme,
  debounce_default,
  deref,
  duplicateNode,
  ensureSuffix,
  errorFrom,
  evaluateBindable,
  generateUniqueString,
  getAncestors,
  getApp,
  getBindingType,
  getBindingValue,
  getChildNodes,
  getComponentTypeNodes,
  getDescendants,
  getElementNodeComponentId,
  getExistingNamesForChildren,
  getExistingNamesForNode,
  getMaybeNode,
  getNewFirstParentIndexInNode,
  getNewLastParentIndexInNode,
  getNewParentIndexAfterNode,
  getNewParentIndexBeforeNode,
  getNode,
  getNodeFirstChild,
  getNodeLastChild,
  getPageAncestor,
  getPageAncestors,
  getPageByName,
  getPageDisplayName,
  getPageTitle,
  getParent,
  getPlan,
  getSiblingAfterNode,
  getSiblingBeforeNode,
  getSiblings,
  groupBy_default,
  indent,
  inferColumns,
  interleave,
  isElement,
  isFormComponent,
  isPage,
  isPageColumn,
  isPageLayoutComponent,
  isPageRow,
  layoutBoxArgTypes,
  mapValues,
  matchPath,
  moveNode,
  omit,
  proposeName,
  queryClient,
  remove,
  removeMaybeNode,
  removeNode,
  saveNode,
  setNodeName,
  setNodeNamespacedProp,
  setNodeProp,
  spreadNode,
  throttle_default,
  uncapitalize,
  update,
  updateArray,
  updateOrCreate,
  useAppHost,
  useBoolean,
  useBrowserJsRuntime,
  useForm,
  useLatest_default,
  useLocation,
  useNavigate,
  useNonNullableContext,
  usePageTitle,
  useSsr,
  validateNodeName,
  warnOnce
} from "./chunk-HU64LJ2T.js";
import {
  QueryClient,
  QueryClientProvider,
  useMutation,
  useQuery,
  useQueryClient,
  useSuspenseQuery
} from "./chunk-QJETXSVA.js";
import {
  ExpandMore_default,
  require_browser
} from "./chunk-OHP53Y5E.js";
import {
  AlertTitle_default,
  Alert_default,
  AppBar_default,
  Autocomplete_default,
  Box_default,
  Box_default2,
  ButtonBase_default,
  Button_default,
  CacheProvider,
  Checkbox_default,
  Chip_default,
  CircularProgress_default,
  ClickAwayListener,
  Collapse_default,
  CssBaseline_default,
  DialogActions_default,
  DialogContentText_default,
  DialogContent_default,
  DialogTitle_default,
  Dialog_default,
  Divider_default,
  Drawer_default,
  FormControlLabel_default,
  FormControl_default,
  FormHelperText_default,
  FormLabel_default,
  Grid2_default,
  Grid_default,
  IconButton_default,
  InputAdornment_default,
  InputBase_default,
  InputLabel_default,
  Input_default,
  LinearProgress_default,
  Link_default,
  ListItemButton_default,
  ListItemIcon_default,
  ListItemText_default,
  ListItem_default,
  ListSubheader_default,
  List_default,
  MenuItem_default,
  Menu_default,
  Paper_default,
  Popover_default,
  Popper_default,
  Portal_default,
  RadioGroup_default,
  Radio_default,
  ScopedCssBaseline_default,
  Select_default,
  Skeleton_default,
  Slider_default,
  Snackbar_default,
  Stack_default,
  Tab_default,
  TextField_default,
  ThemeProvider,
  ToggleButtonGroup_default,
  ToggleButton_default,
  Toolbar_default,
  Tooltip_default,
  Typography_default,
  __export as __export2,
  __reExport,
  _extends,
  _objectWithoutPropertiesLoose,
  alpha,
  autocompleteClasses_default,
  capitalize_default,
  clsx_default,
  colors_exports,
  composeClasses,
  createCache,
  createFilterOptions,
  createSvgIcon,
  createTheme,
  darken,
  deepmerge,
  elementTypeAcceptingRef_default,
  extractEventHandlers_default,
  formLabelClasses_default,
  generateUtilityClass,
  generateUtilityClasses,
  inputBaseClasses_default,
  inputLabelClasses_default,
  lighten,
  ownerDocument,
  require_prop_types,
  require_react_dom,
  resolveComponentProps_default,
  rgbToHex,
  shouldForwardProp,
  styled_default2 as styled_default,
  toggleButtonClasses_default,
  tooltipClasses_default,
  typographyClasses_default,
  unsupportedProp,
  useEnhancedEffect_default,
  useEventCallback_default,
  useEventCallback_default2,
  useForkRef,
  useMediaQuery,
  useRtl,
  useSlotProps_default,
  useTheme,
  useThemeProps
} from "./chunk-UDNLGK53.js";
import "./chunk-EWCJMWEG.js";
import {
  require_jsx_runtime
} from "./chunk-T6H2VCUJ.js";
import {
  require_react
} from "./chunk-4OKMCUX3.js";
import {
  __commonJS,
  __export,
  __publicField,
  __require,
  __toESM
} from "./chunk-7LSNTUAC.js";

// node_modules/prettier/plugins/babel.js
var require_babel = __commonJS({
  "node_modules/prettier/plugins/babel.js"(exports2, module2) {
    (function(f) {
      function e() {
        var i = f();
        return i.default || i;
      }
      if (typeof exports2 == "object" && typeof module2 == "object") module2.exports = e();
      else if (typeof define == "function" && define.amd) define(e);
      else {
        var t = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof self < "u" ? self : this || {};
        t.prettierPlugins = t.prettierPlugins || {}, t.prettierPlugins.babel = e();
      }
    })(function() {
      "use strict";
      var $s = Object.create;
      var Se2 = Object.defineProperty;
      var Vs = Object.getOwnPropertyDescriptor;
      var qs = Object.getOwnPropertyNames;
      var zs = Object.getPrototypeOf, Ks = Object.prototype.hasOwnProperty;
      var Hs = (a, t) => () => (t || a((t = { exports: {} }).exports, t), t.exports), Ws = (a, t) => {
        for (var e in t) Se2(a, e, { get: t[e], enumerable: true });
      }, kt2 = (a, t, e, s) => {
        if (t && typeof t == "object" || typeof t == "function") for (let i of qs(t)) !Ks.call(a, i) && i !== e && Se2(a, i, { get: () => t[i], enumerable: !(s = Vs(t, i)) || s.enumerable });
        return a;
      };
      var vt2 = (a, t, e) => (e = a != null ? $s(zs(a)) : {}, kt2(t || !a || !a.__esModule ? Se2(e, "default", { value: a, enumerable: true }) : e, a)), Js = (a) => kt2(Se2({}, "__esModule", { value: true }), a);
      var At2 = Hs((xe2) => {
        "use strict";
        Object.defineProperty(xe2, "__esModule", { value: true });
        function Ht2(a, t) {
          if (a == null) return {};
          var e = {}, s = Object.keys(a), i, r;
          for (r = 0; r < s.length; r++) i = s[r], !(t.indexOf(i) >= 0) && (e[i] = a[i]);
          return e;
        }
        var F = class {
          constructor(t, e, s) {
            this.line = void 0, this.column = void 0, this.index = void 0, this.line = t, this.column = e, this.index = s;
          }
        }, ee2 = class {
          constructor(t, e) {
            this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = t, this.end = e;
          }
        };
        function v(a, t) {
          let { line: e, column: s, index: i } = a;
          return new F(e, s + t, i + t);
        }
        var Lt2 = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED", Xs = { ImportMetaOutsideModule: { message: `import.meta may appear only with 'sourceType: "module"'`, code: Lt2 }, ImportOutsideModule: { message: `'import' and 'export' may appear only with 'sourceType: "module"'`, code: Lt2 } }, Dt2 = { ArrayPattern: "array destructuring pattern", AssignmentExpression: "assignment expression", AssignmentPattern: "assignment expression", ArrowFunctionExpression: "arrow function expression", ConditionalExpression: "conditional expression", CatchClause: "catch clause", ForOfStatement: "for-of statement", ForInStatement: "for-in statement", ForStatement: "for-loop", FormalParameters: "function parameter list", Identifier: "identifier", ImportSpecifier: "import specifier", ImportDefaultSpecifier: "import default specifier", ImportNamespaceSpecifier: "import namespace specifier", ObjectPattern: "object destructuring pattern", ParenthesizedExpression: "parenthesized expression", RestElement: "rest element", UpdateExpression: { true: "prefix operation", false: "postfix operation" }, VariableDeclarator: "variable declaration", YieldExpression: "yield expression" }, Ee2 = (a) => a.type === "UpdateExpression" ? Dt2.UpdateExpression[`${a.prefix}`] : Dt2[a.type], Gs = { AccessorIsGenerator: ({ kind: a }) => `A ${a}ter cannot be a generator.`, ArgumentsInClass: "'arguments' is only allowed in functions and class methods.", AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.", AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.", AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.", AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.", AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncFunction: "'await' is only allowed within async functions.", BadGetterArity: "A 'get' accessor must not have any formal parameters.", BadSetterArity: "A 'set' accessor must have exactly one formal parameter.", BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.", ConstructorClassField: "Classes may not have a field named 'constructor'.", ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.", ConstructorIsAccessor: "Class constructor may not be an accessor.", ConstructorIsAsync: "Constructor can't be an async function.", ConstructorIsGenerator: "Constructor can't be a generator.", DeclarationMissingInitializer: ({ kind: a }) => `Missing initializer in ${a} declaration.`, DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.", DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.", DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.", DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?", DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.", DecoratorSemicolon: "Decorators must not be followed by a semicolon.", DecoratorStaticBlock: "Decorators can't be used with a static block.", DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.', DeletePrivateField: "Deleting a private field is not allowed.", DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.", DuplicateConstructor: "Duplicate constructor in the same class.", DuplicateDefaultExport: "Only one default export allowed per module.", DuplicateExport: ({ exportName: a }) => `\`${a}\` has already been exported. Exported identifiers must be unique.`, DuplicateProto: "Redefinition of __proto__ property.", DuplicateRegExpFlags: "Duplicate regular expression flag.", DynamicImportPhaseRequiresImportExpressions: ({ phase: a }) => `'import.${a}(...)' can only be parsed when using the 'createImportExpressions' option.`, ElementAfterRest: "Rest element must be last element.", EscapedCharNotAnIdentifier: "Invalid Unicode escape.", ExportBindingIsString: ({ localName: a, exportName: t }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${a}' as '${t}' } from 'some-module'\`?`, ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.", ForInOfLoopInitializer: ({ type: a }) => `'${a === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`, ForInUsing: "For-in loop may not start with 'using' declaration.", ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.", ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.", GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.", IllegalBreakContinue: ({ type: a }) => `Unsyntactic ${a === "BreakStatement" ? "break" : "continue"}.`, IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.", IllegalReturn: "'return' outside of function.", ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.", ImportBindingIsString: ({ importName: a }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${a}" as foo }\`?`, ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.", ImportCallArity: ({ maxArgumentCount: a }) => `\`import()\` requires exactly ${a === 1 ? "one argument" : "one or two arguments"}.`, ImportCallNotNewExpression: "Cannot use new with import(...).", ImportCallSpreadArgument: "`...` is not allowed in `import()`.", ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.", ImportReflectionHasAssertion: "`import module x` cannot have assertions.", ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.', IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.", InvalidBigIntLiteral: "Invalid BigIntLiteral.", InvalidCodePoint: "Code point out of bounds.", InvalidCoverInitializedName: "Invalid shorthand property initializer.", InvalidDecimal: "Invalid decimal.", InvalidDigit: ({ radix: a }) => `Expected number in radix ${a}.`, InvalidEscapeSequence: "Bad character escape sequence.", InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.", InvalidEscapedReservedWord: ({ reservedWord: a }) => `Escape sequence in keyword ${a}.`, InvalidIdentifier: ({ identifierName: a }) => `Invalid identifier ${a}.`, InvalidLhs: ({ ancestor: a }) => `Invalid left-hand side in ${Ee2(a)}.`, InvalidLhsBinding: ({ ancestor: a }) => `Binding invalid left-hand side in ${Ee2(a)}.`, InvalidLhsOptionalChaining: ({ ancestor: a }) => `Invalid optional chaining in the left-hand side of ${Ee2(a)}.`, InvalidNumber: "Invalid number.", InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.", InvalidOrUnexpectedToken: ({ unexpected: a }) => `Unexpected character '${a}'.`, InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.", InvalidPrivateFieldResolution: ({ identifierName: a }) => `Private name #${a} is not defined.`, InvalidPropertyBindingPattern: "Binding member expression.", InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.", InvalidRestAssignmentPattern: "Invalid rest operator's argument.", LabelRedeclaration: ({ labelName: a }) => `Label '${a}' is already declared.`, LetInLexicalBinding: "'let' is disallowed as a lexically bound name.", LineTerminatorBeforeArrow: "No line break is allowed before '=>'.", MalformedRegExpFlags: "Invalid regular expression flag.", MissingClassName: "A class name is required.", MissingEqInAssignment: "Only '=' operator can be used for specifying default value.", MissingSemicolon: "Missing semicolon.", MissingPlugin: ({ missingPlugin: a }) => `This experimental syntax requires enabling the parser plugin: ${a.map((t) => JSON.stringify(t)).join(", ")}.`, MissingOneOfPlugins: ({ missingPlugin: a }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${a.map((t) => JSON.stringify(t)).join(", ")}.`, MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.", MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.", ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.", ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.", ModuleAttributesWithDuplicateKeys: ({ key: a }) => `Duplicate key "${a}" is not allowed in module attributes.`, ModuleExportNameHasLoneSurrogate: ({ surrogateCharCode: a }) => `An export name cannot include a lone surrogate, found '\\u${a.toString(16)}'.`, ModuleExportUndefined: ({ localName: a }) => `Export '${a}' is not defined.`, MultipleDefaultsInSwitch: "Multiple default clauses.", NewlineAfterThrow: "Illegal newline after throw.", NoCatchOrFinally: "Missing catch or finally clause.", NumberIdentifier: "Identifier directly after number.", NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.", ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.", OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.", OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.", OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.", ParamDupe: "Argument name clash.", PatternHasAccessor: "Object pattern can't contain getter or setter.", PatternHasMethod: "Object pattern can't contain methods.", PrivateInExpectedIn: ({ identifierName: a }) => `Private names are only allowed in property accesses (\`obj.#${a}\`) or in \`in\` expressions (\`#${a} in obj\`).`, PrivateNameRedeclaration: ({ identifierName: a }) => `Duplicate private name #${a}.`, RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", RecordNoProto: "'__proto__' is not allowed in Record expressions.", RestTrailingComma: "Unexpected trailing comma after rest element.", SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.", SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.", SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.', StaticPrototype: "Classes may not have static property named prototype.", SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?", SuperPrivateField: "Private fields can't be accessed on super.", TrailingDecorator: "Decorators must be attached to a class element.", TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.", UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.', UnexpectedDigitAfterHash: "Unexpected digit after hash token.", UnexpectedImportExport: "'import' and 'export' may only appear at the top level.", UnexpectedKeyword: ({ keyword: a }) => `Unexpected keyword '${a}'.`, UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.", UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.", UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.", UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.", UnexpectedPrivateField: "Unexpected private name.", UnexpectedReservedWord: ({ reservedWord: a }) => `Unexpected reserved word '${a}'.`, UnexpectedSuper: "'super' is only allowed in object methods and classes.", UnexpectedToken: ({ expected: a, unexpected: t }) => `Unexpected token${t ? ` '${t}'.` : ""}${a ? `, expected "${a}"` : ""}`, UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.", UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.", UnsupportedBind: "Binding should be performed on object property.", UnsupportedDecoratorExport: "A decorated export must export a class declaration.", UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.", UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.", UnsupportedMetaProperty: ({ target: a, onlyValidPropertyName: t }) => `The only valid meta property for ${a} is ${a}.${t}.`, UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.", UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.", UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).", UnterminatedComment: "Unterminated comment.", UnterminatedRegExp: "Unterminated regular expression.", UnterminatedString: "Unterminated string constant.", UnterminatedTemplate: "Unterminated template.", UsingDeclarationExport: "Using declaration cannot be exported.", UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.", VarRedeclaration: ({ identifierName: a }) => `Identifier '${a}' has already been declared.`, YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.", YieldInParameter: "Yield expression is not allowed in formal parameters.", ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0." }, Ys = { StrictDelete: "Deleting local variable in strict mode.", StrictEvalArguments: ({ referenceName: a }) => `Assigning to '${a}' in strict mode.`, StrictEvalArgumentsBinding: ({ bindingName: a }) => `Binding '${a}' in strict mode.`, StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.", StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.", StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.", StrictWith: "'with' in strict mode." }, Qs = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]), Zs = { PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.", PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.', PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.", PipeTopicUnconfiguredToken: ({ token: a }) => `Invalid topic token ${a}. In order to use ${a} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${a}" }.`, PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.", PipeUnparenthesizedBody: ({ type: a }) => `Hack-style pipe body cannot be an unparenthesized ${Ee2({ type: a })}; please wrap it in parentheses.`, PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.', PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.", PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.", PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.", PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.", PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.' }, ei2 = ["toMessage"], ti2 = ["message"];
        function Mt2(a, t, e) {
          Object.defineProperty(a, t, { enumerable: false, configurable: true, value: e });
        }
        function si2(a) {
          let { toMessage: t } = a, e = Ht2(a, ei2);
          return function s(i, r) {
            let n = new SyntaxError();
            return Object.assign(n, e, { loc: i, pos: i.index }), "missingPlugin" in r && Object.assign(n, { missingPlugin: r.missingPlugin }), Mt2(n, "clone", function(h = {}) {
              var c2;
              let { line: l, column: u, index: f } = (c2 = h.loc) != null ? c2 : i;
              return s(new F(l, u, f), Object.assign({}, r, h.details));
            }), Mt2(n, "details", r), Object.defineProperty(n, "message", { configurable: true, get() {
              let o = `${t(r)} (${i.line}:${i.column})`;
              return this.message = o, o;
            }, set(o) {
              Object.defineProperty(this, "message", { value: o, writable: true });
            } }), n;
          };
        }
        function j2(a, t) {
          if (Array.isArray(a)) return (s) => j2(s, a[0]);
          let e = {};
          for (let s of Object.keys(a)) {
            let i = a[s], r = typeof i == "string" ? { message: () => i } : typeof i == "function" ? { message: i } : i, { message: n } = r, o = Ht2(r, ti2), h = typeof n == "string" ? () => n : n;
            e[s] = si2(Object.assign({ code: "BABEL_PARSER_SYNTAX_ERROR", reasonCode: s, toMessage: h }, t ? { syntaxPlugin: t } : {}, o));
          }
          return e;
        }
        var p = Object.assign({}, j2(Xs), j2(Gs), j2(Ys), j2`pipelineOperator`(Zs)), { defineProperty: ii2 } = Object, Ot2 = (a, t) => {
          a && ii2(a, t, { enumerable: false, value: a[t] });
        };
        function oe2(a) {
          return Ot2(a.loc.start, "index"), Ot2(a.loc.end, "index"), a;
        }
        var ri2 = (a) => class extends a {
          parse() {
            let e = oe2(super.parse());
            return this.options.tokens && (e.tokens = e.tokens.map(oe2)), e;
          }
          parseRegExpLiteral({ pattern: e, flags: s }) {
            let i = null;
            try {
              i = new RegExp(e, s);
            } catch {
            }
            let r = this.estreeParseLiteral(i);
            return r.regex = { pattern: e, flags: s }, r;
          }
          parseBigIntLiteral(e) {
            let s;
            try {
              s = BigInt(e);
            } catch {
              s = null;
            }
            let i = this.estreeParseLiteral(s);
            return i.bigint = String(i.value || e), i;
          }
          parseDecimalLiteral(e) {
            let i = this.estreeParseLiteral(null);
            return i.decimal = String(i.value || e), i;
          }
          estreeParseLiteral(e) {
            return this.parseLiteral(e, "Literal");
          }
          parseStringLiteral(e) {
            return this.estreeParseLiteral(e);
          }
          parseNumericLiteral(e) {
            return this.estreeParseLiteral(e);
          }
          parseNullLiteral() {
            return this.estreeParseLiteral(null);
          }
          parseBooleanLiteral(e) {
            return this.estreeParseLiteral(e);
          }
          directiveToStmt(e) {
            let s = e.value;
            delete e.value, s.type = "Literal", s.raw = s.extra.raw, s.value = s.extra.expressionValue;
            let i = e;
            return i.type = "ExpressionStatement", i.expression = s, i.directive = s.extra.rawValue, delete s.extra, i;
          }
          initFunction(e, s) {
            super.initFunction(e, s), e.expression = false;
          }
          checkDeclaration(e) {
            e != null && this.isObjectProperty(e) ? this.checkDeclaration(e.value) : super.checkDeclaration(e);
          }
          getObjectOrClassMethodParams(e) {
            return e.value.params;
          }
          isValidDirective(e) {
            var s;
            return e.type === "ExpressionStatement" && e.expression.type === "Literal" && typeof e.expression.value == "string" && !((s = e.expression.extra) != null && s.parenthesized);
          }
          parseBlockBody(e, s, i, r, n) {
            super.parseBlockBody(e, s, i, r, n);
            let o = e.directives.map((h) => this.directiveToStmt(h));
            e.body = o.concat(e.body), delete e.directives;
          }
          pushClassMethod(e, s, i, r, n, o) {
            this.parseMethod(s, i, r, n, o, "ClassMethod", true), s.typeParameters && (s.value.typeParameters = s.typeParameters, delete s.typeParameters), e.body.push(s);
          }
          parsePrivateName() {
            let e = super.parsePrivateName();
            return this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(e) : e;
          }
          convertPrivateNameToPrivateIdentifier(e) {
            let s = super.getPrivateNameSV(e);
            return e = e, delete e.id, e.name = s, e.type = "PrivateIdentifier", e;
          }
          isPrivateName(e) {
            return this.getPluginOption("estree", "classFeatures") ? e.type === "PrivateIdentifier" : super.isPrivateName(e);
          }
          getPrivateNameSV(e) {
            return this.getPluginOption("estree", "classFeatures") ? e.name : super.getPrivateNameSV(e);
          }
          parseLiteral(e, s) {
            let i = super.parseLiteral(e, s);
            return i.raw = i.extra.raw, delete i.extra, i;
          }
          parseFunctionBody(e, s, i = false) {
            super.parseFunctionBody(e, s, i), e.expression = e.body.type !== "BlockStatement";
          }
          parseMethod(e, s, i, r, n, o, h = false) {
            let c2 = this.startNode();
            return c2.kind = e.kind, c2 = super.parseMethod(c2, s, i, r, n, o, h), c2.type = "FunctionExpression", delete c2.kind, e.value = c2, o === "ClassPrivateMethod" && (e.computed = false), this.finishNode(e, "MethodDefinition");
          }
          nameIsConstructor(e) {
            return e.type === "Literal" ? e.value === "constructor" : super.nameIsConstructor(e);
          }
          parseClassProperty(...e) {
            let s = super.parseClassProperty(...e);
            return this.getPluginOption("estree", "classFeatures") && (s.type = "PropertyDefinition"), s;
          }
          parseClassPrivateProperty(...e) {
            let s = super.parseClassPrivateProperty(...e);
            return this.getPluginOption("estree", "classFeatures") && (s.type = "PropertyDefinition", s.computed = false), s;
          }
          parseObjectMethod(e, s, i, r, n) {
            let o = super.parseObjectMethod(e, s, i, r, n);
            return o && (o.type = "Property", o.kind === "method" && (o.kind = "init"), o.shorthand = false), o;
          }
          parseObjectProperty(e, s, i, r) {
            let n = super.parseObjectProperty(e, s, i, r);
            return n && (n.kind = "init", n.type = "Property"), n;
          }
          isValidLVal(e, s, i) {
            return e === "Property" ? "value" : super.isValidLVal(e, s, i);
          }
          isAssignable(e, s) {
            return e != null && this.isObjectProperty(e) ? this.isAssignable(e.value, s) : super.isAssignable(e, s);
          }
          toAssignable(e, s = false) {
            if (e != null && this.isObjectProperty(e)) {
              let { key: i, value: r } = e;
              this.isPrivateName(i) && this.classScope.usePrivateName(this.getPrivateNameSV(i), i.loc.start), this.toAssignable(r, s);
            } else super.toAssignable(e, s);
          }
          toAssignableObjectExpressionProp(e, s, i) {
            e.type === "Property" && (e.kind === "get" || e.kind === "set") ? this.raise(p.PatternHasAccessor, e.key) : e.type === "Property" && e.method ? this.raise(p.PatternHasMethod, e.key) : super.toAssignableObjectExpressionProp(e, s, i);
          }
          finishCallExpression(e, s) {
            let i = super.finishCallExpression(e, s);
            if (i.callee.type === "Import") {
              if (i.type = "ImportExpression", i.source = i.arguments[0], this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
                var r, n;
                i.options = (r = i.arguments[1]) != null ? r : null, i.attributes = (n = i.arguments[1]) != null ? n : null;
              }
              delete i.arguments, delete i.callee;
            }
            return i;
          }
          toReferencedArguments(e) {
            e.type !== "ImportExpression" && super.toReferencedArguments(e);
          }
          parseExport(e, s) {
            let i = this.state.lastTokStartLoc, r = super.parseExport(e, s);
            switch (r.type) {
              case "ExportAllDeclaration":
                r.exported = null;
                break;
              case "ExportNamedDeclaration":
                r.specifiers.length === 1 && r.specifiers[0].type === "ExportNamespaceSpecifier" && (r.type = "ExportAllDeclaration", r.exported = r.specifiers[0].exported, delete r.specifiers);
              case "ExportDefaultDeclaration":
                {
                  var n;
                  let { declaration: o } = r;
                  (o == null ? void 0 : o.type) === "ClassDeclaration" && ((n = o.decorators) == null ? void 0 : n.length) > 0 && o.start === r.start && this.resetStartLocation(r, i);
                }
                break;
            }
            return r;
          }
          parseSubscript(e, s, i, r) {
            let n = super.parseSubscript(e, s, i, r);
            if (r.optionalChainMember) {
              if ((n.type === "OptionalMemberExpression" || n.type === "OptionalCallExpression") && (n.type = n.type.substring(8)), r.stop) {
                let o = this.startNodeAtNode(n);
                return o.expression = n, this.finishNode(o, "ChainExpression");
              }
            } else (n.type === "MemberExpression" || n.type === "CallExpression") && (n.optional = false);
            return n;
          }
          isOptionalMemberExpression(e) {
            return e.type === "ChainExpression" ? e.expression.type === "MemberExpression" : super.isOptionalMemberExpression(e);
          }
          hasPropertyAsPrivateName(e) {
            return e.type === "ChainExpression" && (e = e.expression), super.hasPropertyAsPrivateName(e);
          }
          isObjectProperty(e) {
            return e.type === "Property" && e.kind === "init" && !e.method;
          }
          isObjectMethod(e) {
            return e.type === "Property" && (e.method || e.kind === "get" || e.kind === "set");
          }
          finishNodeAt(e, s, i) {
            return oe2(super.finishNodeAt(e, s, i));
          }
          resetStartLocation(e, s) {
            super.resetStartLocation(e, s), oe2(e);
          }
          resetEndLocation(e, s = this.state.lastTokEndLoc) {
            super.resetEndLocation(e, s), oe2(e);
          }
        }, X2 = class {
          constructor(t, e) {
            this.token = void 0, this.preserveSpace = void 0, this.token = t, this.preserveSpace = !!e;
          }
        }, C = { brace: new X2("{"), j_oTag: new X2("<tag"), j_cTag: new X2("</tag"), j_expr: new X2("<tag>...</tag>", true) };
        C.template = new X2("`", true);
        var b2 = true, m = true, $e2 = true, he2 = true, q2 = true, ai2 = true, ve2 = class {
          constructor(t, e = {}) {
            this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.label = t, this.keyword = e.keyword, this.beforeExpr = !!e.beforeExpr, this.startsExpr = !!e.startsExpr, this.rightAssociative = !!e.rightAssociative, this.isLoop = !!e.isLoop, this.isAssign = !!e.isAssign, this.prefix = !!e.prefix, this.postfix = !!e.postfix, this.binop = e.binop != null ? e.binop : null, this.updateContext = null;
          }
        }, ut2 = /* @__PURE__ */ new Map();
        function A(a, t = {}) {
          t.keyword = a;
          let e = P2(a, t);
          return ut2.set(a, e), e;
        }
        function k(a, t) {
          return P2(a, { beforeExpr: b2, binop: t });
        }
        var ue2 = -1, U2 = [], ft2 = [], dt2 = [], mt2 = [], yt = [], xt2 = [];
        function P2(a, t = {}) {
          var e, s, i, r;
          return ++ue2, ft2.push(a), dt2.push((e = t.binop) != null ? e : -1), mt2.push((s = t.beforeExpr) != null ? s : false), yt.push((i = t.startsExpr) != null ? i : false), xt2.push((r = t.prefix) != null ? r : false), U2.push(new ve2(a, t)), ue2;
        }
        function T2(a, t = {}) {
          var e, s, i, r;
          return ++ue2, ut2.set(a, ue2), ft2.push(a), dt2.push((e = t.binop) != null ? e : -1), mt2.push((s = t.beforeExpr) != null ? s : false), yt.push((i = t.startsExpr) != null ? i : false), xt2.push((r = t.prefix) != null ? r : false), U2.push(new ve2("name", t)), ue2;
        }
        var ni2 = { bracketL: P2("[", { beforeExpr: b2, startsExpr: m }), bracketHashL: P2("#[", { beforeExpr: b2, startsExpr: m }), bracketBarL: P2("[|", { beforeExpr: b2, startsExpr: m }), bracketR: P2("]"), bracketBarR: P2("|]"), braceL: P2("{", { beforeExpr: b2, startsExpr: m }), braceBarL: P2("{|", { beforeExpr: b2, startsExpr: m }), braceHashL: P2("#{", { beforeExpr: b2, startsExpr: m }), braceR: P2("}"), braceBarR: P2("|}"), parenL: P2("(", { beforeExpr: b2, startsExpr: m }), parenR: P2(")"), comma: P2(",", { beforeExpr: b2 }), semi: P2(";", { beforeExpr: b2 }), colon: P2(":", { beforeExpr: b2 }), doubleColon: P2("::", { beforeExpr: b2 }), dot: P2("."), question: P2("?", { beforeExpr: b2 }), questionDot: P2("?."), arrow: P2("=>", { beforeExpr: b2 }), template: P2("template"), ellipsis: P2("...", { beforeExpr: b2 }), backQuote: P2("`", { startsExpr: m }), dollarBraceL: P2("${", { beforeExpr: b2, startsExpr: m }), templateTail: P2("...`", { startsExpr: m }), templateNonTail: P2("...${", { beforeExpr: b2, startsExpr: m }), at: P2("@"), hash: P2("#", { startsExpr: m }), interpreterDirective: P2("#!..."), eq: P2("=", { beforeExpr: b2, isAssign: he2 }), assign: P2("_=", { beforeExpr: b2, isAssign: he2 }), slashAssign: P2("_=", { beforeExpr: b2, isAssign: he2 }), xorAssign: P2("_=", { beforeExpr: b2, isAssign: he2 }), moduloAssign: P2("_=", { beforeExpr: b2, isAssign: he2 }), incDec: P2("++/--", { prefix: q2, postfix: ai2, startsExpr: m }), bang: P2("!", { beforeExpr: b2, prefix: q2, startsExpr: m }), tilde: P2("~", { beforeExpr: b2, prefix: q2, startsExpr: m }), doubleCaret: P2("^^", { startsExpr: m }), doubleAt: P2("@@", { startsExpr: m }), pipeline: k("|>", 0), nullishCoalescing: k("??", 1), logicalOR: k("||", 1), logicalAND: k("&&", 2), bitwiseOR: k("|", 3), bitwiseXOR: k("^", 4), bitwiseAND: k("&", 5), equality: k("==/!=/===/!==", 6), lt: k("</>/<=/>=", 7), gt: k("</>/<=/>=", 7), relational: k("</>/<=/>=", 7), bitShift: k("<</>>/>>>", 8), bitShiftL: k("<</>>/>>>", 8), bitShiftR: k("<</>>/>>>", 8), plusMin: P2("+/-", { beforeExpr: b2, binop: 9, prefix: q2, startsExpr: m }), modulo: P2("%", { binop: 10, startsExpr: m }), star: P2("*", { binop: 10 }), slash: k("/", 10), exponent: P2("**", { beforeExpr: b2, binop: 11, rightAssociative: true }), _in: A("in", { beforeExpr: b2, binop: 7 }), _instanceof: A("instanceof", { beforeExpr: b2, binop: 7 }), _break: A("break"), _case: A("case", { beforeExpr: b2 }), _catch: A("catch"), _continue: A("continue"), _debugger: A("debugger"), _default: A("default", { beforeExpr: b2 }), _else: A("else", { beforeExpr: b2 }), _finally: A("finally"), _function: A("function", { startsExpr: m }), _if: A("if"), _return: A("return", { beforeExpr: b2 }), _switch: A("switch"), _throw: A("throw", { beforeExpr: b2, prefix: q2, startsExpr: m }), _try: A("try"), _var: A("var"), _const: A("const"), _with: A("with"), _new: A("new", { beforeExpr: b2, startsExpr: m }), _this: A("this", { startsExpr: m }), _super: A("super", { startsExpr: m }), _class: A("class", { startsExpr: m }), _extends: A("extends", { beforeExpr: b2 }), _export: A("export"), _import: A("import", { startsExpr: m }), _null: A("null", { startsExpr: m }), _true: A("true", { startsExpr: m }), _false: A("false", { startsExpr: m }), _typeof: A("typeof", { beforeExpr: b2, prefix: q2, startsExpr: m }), _void: A("void", { beforeExpr: b2, prefix: q2, startsExpr: m }), _delete: A("delete", { beforeExpr: b2, prefix: q2, startsExpr: m }), _do: A("do", { isLoop: $e2, beforeExpr: b2 }), _for: A("for", { isLoop: $e2 }), _while: A("while", { isLoop: $e2 }), _as: T2("as", { startsExpr: m }), _assert: T2("assert", { startsExpr: m }), _async: T2("async", { startsExpr: m }), _await: T2("await", { startsExpr: m }), _defer: T2("defer", { startsExpr: m }), _from: T2("from", { startsExpr: m }), _get: T2("get", { startsExpr: m }), _let: T2("let", { startsExpr: m }), _meta: T2("meta", { startsExpr: m }), _of: T2("of", { startsExpr: m }), _sent: T2("sent", { startsExpr: m }), _set: T2("set", { startsExpr: m }), _source: T2("source", { startsExpr: m }), _static: T2("static", { startsExpr: m }), _using: T2("using", { startsExpr: m }), _yield: T2("yield", { startsExpr: m }), _asserts: T2("asserts", { startsExpr: m }), _checks: T2("checks", { startsExpr: m }), _exports: T2("exports", { startsExpr: m }), _global: T2("global", { startsExpr: m }), _implements: T2("implements", { startsExpr: m }), _intrinsic: T2("intrinsic", { startsExpr: m }), _infer: T2("infer", { startsExpr: m }), _is: T2("is", { startsExpr: m }), _mixins: T2("mixins", { startsExpr: m }), _proto: T2("proto", { startsExpr: m }), _require: T2("require", { startsExpr: m }), _satisfies: T2("satisfies", { startsExpr: m }), _keyof: T2("keyof", { startsExpr: m }), _readonly: T2("readonly", { startsExpr: m }), _unique: T2("unique", { startsExpr: m }), _abstract: T2("abstract", { startsExpr: m }), _declare: T2("declare", { startsExpr: m }), _enum: T2("enum", { startsExpr: m }), _module: T2("module", { startsExpr: m }), _namespace: T2("namespace", { startsExpr: m }), _interface: T2("interface", { startsExpr: m }), _type: T2("type", { startsExpr: m }), _opaque: T2("opaque", { startsExpr: m }), name: P2("name", { startsExpr: m }), string: P2("string", { startsExpr: m }), num: P2("num", { startsExpr: m }), bigint: P2("bigint", { startsExpr: m }), decimal: P2("decimal", { startsExpr: m }), regexp: P2("regexp", { startsExpr: m }), privateName: P2("#name", { startsExpr: m }), eof: P2("eof"), jsxName: P2("jsxName"), jsxText: P2("jsxText", { beforeExpr: true }), jsxTagStart: P2("jsxTagStart", { startsExpr: true }), jsxTagEnd: P2("jsxTagEnd"), placeholder: P2("%%", { startsExpr: true }) };
        function w(a) {
          return a >= 93 && a <= 132;
        }
        function oi2(a) {
          return a <= 92;
        }
        function M2(a) {
          return a >= 58 && a <= 132;
        }
        function Wt2(a) {
          return a >= 58 && a <= 136;
        }
        function hi2(a) {
          return mt2[a];
        }
        function He2(a) {
          return yt[a];
        }
        function li2(a) {
          return a >= 29 && a <= 33;
        }
        function Ft2(a) {
          return a >= 129 && a <= 131;
        }
        function ci2(a) {
          return a >= 90 && a <= 92;
        }
        function Pt2(a) {
          return a >= 58 && a <= 92;
        }
        function pi2(a) {
          return a >= 39 && a <= 59;
        }
        function ui2(a) {
          return a === 34;
        }
        function fi2(a) {
          return xt2[a];
        }
        function di2(a) {
          return a >= 121 && a <= 123;
        }
        function mi(a) {
          return a >= 124 && a <= 130;
        }
        function K2(a) {
          return ft2[a];
        }
        function Ie2(a) {
          return dt2[a];
        }
        function yi(a) {
          return a === 57;
        }
        function Le2(a) {
          return a >= 24 && a <= 25;
        }
        function R2(a) {
          return U2[a];
        }
        U2[8].updateContext = (a) => {
          a.pop();
        }, U2[5].updateContext = U2[7].updateContext = U2[23].updateContext = (a) => {
          a.push(C.brace);
        }, U2[22].updateContext = (a) => {
          a[a.length - 1] === C.template ? a.pop() : a.push(C.template);
        }, U2[142].updateContext = (a) => {
          a.push(C.j_expr, C.j_oTag);
        };
        var gt2 = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", Jt2 = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･", xi = new RegExp("[" + gt2 + "]"), Pi = new RegExp("[" + gt2 + Jt2 + "]");
        gt2 = Jt2 = null;
        var Xt = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], gi = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
        function We2(a, t) {
          let e = 65536;
          for (let s = 0, i = t.length; s < i; s += 2) {
            if (e += t[s], e > a) return false;
            if (e += t[s + 1], e >= a) return true;
          }
          return false;
        }
        function _2(a) {
          return a < 65 ? a === 36 : a <= 90 ? true : a < 97 ? a === 95 : a <= 122 ? true : a <= 65535 ? a >= 170 && xi.test(String.fromCharCode(a)) : We2(a, Xt);
        }
        function Q2(a) {
          return a < 48 ? a === 36 : a < 58 ? true : a < 65 ? false : a <= 90 ? true : a < 97 ? a === 95 : a <= 122 ? true : a <= 65535 ? a >= 170 && Pi.test(String.fromCharCode(a)) : We2(a, Xt) || We2(a, gi);
        }
        var Tt2 = { keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"], strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"], strictBind: ["eval", "arguments"] }, Ti = new Set(Tt2.keyword), bi = new Set(Tt2.strict), Ai = new Set(Tt2.strictBind);
        function Gt2(a, t) {
          return t && a === "await" || a === "enum";
        }
        function Yt2(a, t) {
          return Gt2(a, t) || bi.has(a);
        }
        function Qt2(a) {
          return Ai.has(a);
        }
        function Zt(a, t) {
          return Yt2(a, t) || Qt2(a);
        }
        function Si(a) {
          return Ti.has(a);
        }
        function wi(a, t, e) {
          return a === 64 && t === 64 && _2(e);
        }
        var Ci = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
        function Ei(a) {
          return Ci.has(a);
        }
        var de2 = class {
          constructor(t) {
            this.flags = 0, this.names = /* @__PURE__ */ new Map(), this.firstLexicalName = "", this.flags = t;
          }
        }, me2 = class {
          constructor(t, e) {
            this.parser = void 0, this.scopeStack = [], this.inModule = void 0, this.undefinedExports = /* @__PURE__ */ new Map(), this.parser = t, this.inModule = e;
          }
          get inTopLevel() {
            return (this.currentScope().flags & 1) > 0;
          }
          get inFunction() {
            return (this.currentVarScopeFlags() & 2) > 0;
          }
          get allowSuper() {
            return (this.currentThisScopeFlags() & 16) > 0;
          }
          get allowDirectSuper() {
            return (this.currentThisScopeFlags() & 32) > 0;
          }
          get inClass() {
            return (this.currentThisScopeFlags() & 64) > 0;
          }
          get inClassAndNotInNonArrowFunction() {
            let t = this.currentThisScopeFlags();
            return (t & 64) > 0 && (t & 2) === 0;
          }
          get inStaticBlock() {
            for (let t = this.scopeStack.length - 1; ; t--) {
              let { flags: e } = this.scopeStack[t];
              if (e & 128) return true;
              if (e & 451) return false;
            }
          }
          get inNonArrowFunction() {
            return (this.currentThisScopeFlags() & 2) > 0;
          }
          get treatFunctionsAsVar() {
            return this.treatFunctionsAsVarInScope(this.currentScope());
          }
          createScope(t) {
            return new de2(t);
          }
          enter(t) {
            this.scopeStack.push(this.createScope(t));
          }
          exit() {
            return this.scopeStack.pop().flags;
          }
          treatFunctionsAsVarInScope(t) {
            return !!(t.flags & 130 || !this.parser.inModule && t.flags & 1);
          }
          declareName(t, e, s) {
            let i = this.currentScope();
            if (e & 8 || e & 16) {
              this.checkRedeclarationInScope(i, t, e, s);
              let r = i.names.get(t) || 0;
              e & 16 ? r = r | 4 : (i.firstLexicalName || (i.firstLexicalName = t), r = r | 2), i.names.set(t, r), e & 8 && this.maybeExportDefined(i, t);
            } else if (e & 4) for (let r = this.scopeStack.length - 1; r >= 0 && (i = this.scopeStack[r], this.checkRedeclarationInScope(i, t, e, s), i.names.set(t, (i.names.get(t) || 0) | 1), this.maybeExportDefined(i, t), !(i.flags & 387)); --r) ;
            this.parser.inModule && i.flags & 1 && this.undefinedExports.delete(t);
          }
          maybeExportDefined(t, e) {
            this.parser.inModule && t.flags & 1 && this.undefinedExports.delete(e);
          }
          checkRedeclarationInScope(t, e, s, i) {
            this.isRedeclaredInScope(t, e, s) && this.parser.raise(p.VarRedeclaration, i, { identifierName: e });
          }
          isRedeclaredInScope(t, e, s) {
            if (!(s & 1)) return false;
            if (s & 8) return t.names.has(e);
            let i = t.names.get(e);
            return s & 16 ? (i & 2) > 0 || !this.treatFunctionsAsVarInScope(t) && (i & 1) > 0 : (i & 2) > 0 && !(t.flags & 8 && t.firstLexicalName === e) || !this.treatFunctionsAsVarInScope(t) && (i & 4) > 0;
          }
          checkLocalExport(t) {
            let { name: e } = t;
            this.scopeStack[0].names.has(e) || this.undefinedExports.set(e, t.loc.start);
          }
          currentScope() {
            return this.scopeStack[this.scopeStack.length - 1];
          }
          currentVarScopeFlags() {
            for (let t = this.scopeStack.length - 1; ; t--) {
              let { flags: e } = this.scopeStack[t];
              if (e & 387) return e;
            }
          }
          currentThisScopeFlags() {
            for (let t = this.scopeStack.length - 1; ; t--) {
              let { flags: e } = this.scopeStack[t];
              if (e & 451 && !(e & 4)) return e;
            }
          }
        }, Je2 = class extends de2 {
          constructor(...t) {
            super(...t), this.declareFunctions = /* @__PURE__ */ new Set();
          }
        }, Xe2 = class extends me2 {
          createScope(t) {
            return new Je2(t);
          }
          declareName(t, e, s) {
            let i = this.currentScope();
            if (e & 2048) {
              this.checkRedeclarationInScope(i, t, e, s), this.maybeExportDefined(i, t), i.declareFunctions.add(t);
              return;
            }
            super.declareName(t, e, s);
          }
          isRedeclaredInScope(t, e, s) {
            if (super.isRedeclaredInScope(t, e, s)) return true;
            if (s & 2048 && !t.declareFunctions.has(e)) {
              let i = t.names.get(e);
              return (i & 4) > 0 || (i & 2) > 0;
            }
            return false;
          }
          checkLocalExport(t) {
            this.scopeStack[0].declareFunctions.has(t.name) || super.checkLocalExport(t);
          }
        }, Ge2 = class {
          constructor() {
            this.sawUnambiguousESM = false, this.ambiguousScriptDifferentAst = false;
          }
          hasPlugin(t) {
            if (typeof t == "string") return this.plugins.has(t);
            {
              let [e, s] = t;
              if (!this.hasPlugin(e)) return false;
              let i = this.plugins.get(e);
              for (let r of Object.keys(s)) if ((i == null ? void 0 : i[r]) !== s[r]) return false;
              return true;
            }
          }
          getPluginOption(t, e) {
            var s;
            return (s = this.plugins.get(t)) == null ? void 0 : s[e];
          }
        };
        function es(a, t) {
          a.trailingComments === void 0 ? a.trailingComments = t : a.trailingComments.unshift(...t);
        }
        function Ii(a, t) {
          a.leadingComments === void 0 ? a.leadingComments = t : a.leadingComments.unshift(...t);
        }
        function ye(a, t) {
          a.innerComments === void 0 ? a.innerComments = t : a.innerComments.unshift(...t);
        }
        function le2(a, t, e) {
          let s = null, i = t.length;
          for (; s === null && i > 0; ) s = t[--i];
          s === null || s.start > e.start ? ye(a, e.comments) : es(s, e.comments);
        }
        var Ye2 = class extends Ge2 {
          addComment(t) {
            this.filename && (t.loc.filename = this.filename);
            let { commentsLen: e } = this.state;
            this.comments.length !== e && (this.comments.length = e), this.comments.push(t), this.state.commentsLen++;
          }
          processComment(t) {
            let { commentStack: e } = this.state, s = e.length;
            if (s === 0) return;
            let i = s - 1, r = e[i];
            r.start === t.end && (r.leadingNode = t, i--);
            let { start: n } = t;
            for (; i >= 0; i--) {
              let o = e[i], h = o.end;
              if (h > n) o.containingNode = t, this.finalizeComment(o), e.splice(i, 1);
              else {
                h === n && (o.trailingNode = t);
                break;
              }
            }
          }
          finalizeComment(t) {
            let { comments: e } = t;
            if (t.leadingNode !== null || t.trailingNode !== null) t.leadingNode !== null && es(t.leadingNode, e), t.trailingNode !== null && Ii(t.trailingNode, e);
            else {
              let { containingNode: s, start: i } = t;
              if (this.input.charCodeAt(i - 1) === 44) switch (s.type) {
                case "ObjectExpression":
                case "ObjectPattern":
                case "RecordExpression":
                  le2(s, s.properties, t);
                  break;
                case "CallExpression":
                case "OptionalCallExpression":
                  le2(s, s.arguments, t);
                  break;
                case "FunctionDeclaration":
                case "FunctionExpression":
                case "ArrowFunctionExpression":
                case "ObjectMethod":
                case "ClassMethod":
                case "ClassPrivateMethod":
                  le2(s, s.params, t);
                  break;
                case "ArrayExpression":
                case "ArrayPattern":
                case "TupleExpression":
                  le2(s, s.elements, t);
                  break;
                case "ExportNamedDeclaration":
                case "ImportDeclaration":
                  le2(s, s.specifiers, t);
                  break;
                default:
                  ye(s, e);
              }
              else ye(s, e);
            }
          }
          finalizeRemainingComments() {
            let { commentStack: t } = this.state;
            for (let e = t.length - 1; e >= 0; e--) this.finalizeComment(t[e]);
            this.state.commentStack = [];
          }
          resetPreviousNodeTrailingComments(t) {
            let { commentStack: e } = this.state, { length: s } = e;
            if (s === 0) return;
            let i = e[s - 1];
            i.leadingNode === t && (i.leadingNode = null);
          }
          resetPreviousIdentifierLeadingComments(t) {
            let { commentStack: e } = this.state, { length: s } = e;
            s !== 0 && (e[s - 1].trailingNode === t ? e[s - 1].trailingNode = null : s >= 2 && e[s - 2].trailingNode === t && (e[s - 2].trailingNode = null));
          }
          takeSurroundingComments(t, e, s) {
            let { commentStack: i } = this.state, r = i.length;
            if (r === 0) return;
            let n = r - 1;
            for (; n >= 0; n--) {
              let o = i[n], h = o.end;
              if (o.start === s) o.leadingNode = t;
              else if (h === e) o.trailingNode = t;
              else if (h < e) break;
            }
          }
        }, ts = /\r\n?|[\n\u2028\u2029]/, we2 = new RegExp(ts.source, "g");
        function fe2(a) {
          switch (a) {
            case 10:
            case 13:
            case 8232:
            case 8233:
              return true;
            default:
              return false;
          }
        }
        var Ve2 = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, Ne2 = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g, Bt2 = new RegExp("(?=(" + Ne2.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
        function Ni(a) {
          switch (a) {
            case 9:
            case 11:
            case 12:
            case 32:
            case 160:
            case 5760:
            case 8192:
            case 8193:
            case 8194:
            case 8195:
            case 8196:
            case 8197:
            case 8198:
            case 8199:
            case 8200:
            case 8201:
            case 8202:
            case 8239:
            case 8287:
            case 12288:
            case 65279:
              return true;
            default:
              return false;
          }
        }
        var Qe2 = class a {
          constructor() {
            this.flags = 1024, this.curLine = void 0, this.lineStart = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null }, this.labels = [], this.commentsLen = 0, this.commentStack = [], this.pos = 0, this.type = 139, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.context = [C.brace], this.firstInvalidTemplateEscapePos = null, this.strictErrors = /* @__PURE__ */ new Map(), this.tokensLength = 0;
          }
          get strict() {
            return (this.flags & 1) > 0;
          }
          set strict(t) {
            t ? this.flags |= 1 : this.flags &= -2;
          }
          init({ strictMode: t, sourceType: e, startLine: s, startColumn: i }) {
            this.strict = t === false ? false : t === true ? true : e === "module", this.curLine = s, this.lineStart = -i, this.startLoc = this.endLoc = new F(s, i, 0);
          }
          get maybeInArrowParameters() {
            return (this.flags & 2) > 0;
          }
          set maybeInArrowParameters(t) {
            t ? this.flags |= 2 : this.flags &= -3;
          }
          get inType() {
            return (this.flags & 4) > 0;
          }
          set inType(t) {
            t ? this.flags |= 4 : this.flags &= -5;
          }
          get noAnonFunctionType() {
            return (this.flags & 8) > 0;
          }
          set noAnonFunctionType(t) {
            t ? this.flags |= 8 : this.flags &= -9;
          }
          get hasFlowComment() {
            return (this.flags & 16) > 0;
          }
          set hasFlowComment(t) {
            t ? this.flags |= 16 : this.flags &= -17;
          }
          get isAmbientContext() {
            return (this.flags & 32) > 0;
          }
          set isAmbientContext(t) {
            t ? this.flags |= 32 : this.flags &= -33;
          }
          get inAbstractClass() {
            return (this.flags & 64) > 0;
          }
          set inAbstractClass(t) {
            t ? this.flags |= 64 : this.flags &= -65;
          }
          get inDisallowConditionalTypesContext() {
            return (this.flags & 128) > 0;
          }
          set inDisallowConditionalTypesContext(t) {
            t ? this.flags |= 128 : this.flags &= -129;
          }
          get soloAwait() {
            return (this.flags & 256) > 0;
          }
          set soloAwait(t) {
            t ? this.flags |= 256 : this.flags &= -257;
          }
          get inFSharpPipelineDirectBody() {
            return (this.flags & 512) > 0;
          }
          set inFSharpPipelineDirectBody(t) {
            t ? this.flags |= 512 : this.flags &= -513;
          }
          get canStartJSXElement() {
            return (this.flags & 1024) > 0;
          }
          set canStartJSXElement(t) {
            t ? this.flags |= 1024 : this.flags &= -1025;
          }
          get containsEsc() {
            return (this.flags & 2048) > 0;
          }
          set containsEsc(t) {
            t ? this.flags |= 2048 : this.flags &= -2049;
          }
          curPosition() {
            return new F(this.curLine, this.pos - this.lineStart, this.pos);
          }
          clone() {
            let t = new a();
            return t.flags = this.flags, t.curLine = this.curLine, t.lineStart = this.lineStart, t.startLoc = this.startLoc, t.endLoc = this.endLoc, t.errors = this.errors.slice(), t.potentialArrowAt = this.potentialArrowAt, t.noArrowAt = this.noArrowAt.slice(), t.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice(), t.topicContext = this.topicContext, t.labels = this.labels.slice(), t.commentsLen = this.commentsLen, t.commentStack = this.commentStack.slice(), t.pos = this.pos, t.type = this.type, t.value = this.value, t.start = this.start, t.end = this.end, t.lastTokEndLoc = this.lastTokEndLoc, t.lastTokStartLoc = this.lastTokStartLoc, t.context = this.context.slice(), t.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos, t.strictErrors = this.strictErrors, t.tokensLength = this.tokensLength, t;
          }
        }, ki = function(t) {
          return t >= 48 && t <= 57;
        }, Rt2 = { decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]), hex: /* @__PURE__ */ new Set([46, 88, 95, 120]) }, Ce2 = { bin: (a) => a === 48 || a === 49, oct: (a) => a >= 48 && a <= 55, dec: (a) => a >= 48 && a <= 57, hex: (a) => a >= 48 && a <= 57 || a >= 65 && a <= 70 || a >= 97 && a <= 102 };
        function Ut2(a, t, e, s, i, r) {
          let n = e, o = s, h = i, c2 = "", l = null, u = e, { length: f } = t;
          for (; ; ) {
            if (e >= f) {
              r.unterminated(n, o, h), c2 += t.slice(u, e);
              break;
            }
            let d = t.charCodeAt(e);
            if (vi(a, d, t, e)) {
              c2 += t.slice(u, e);
              break;
            }
            if (d === 92) {
              c2 += t.slice(u, e);
              let y2 = Li(t, e, s, i, a === "template", r);
              y2.ch === null && !l ? l = { pos: e, lineStart: s, curLine: i } : c2 += y2.ch, { pos: e, lineStart: s, curLine: i } = y2, u = e;
            } else d === 8232 || d === 8233 ? (++e, ++i, s = e) : d === 10 || d === 13 ? a === "template" ? (c2 += t.slice(u, e) + `
`, ++e, d === 13 && t.charCodeAt(e) === 10 && ++e, ++i, u = s = e) : r.unterminated(n, o, h) : ++e;
          }
          return { pos: e, str: c2, firstInvalidLoc: l, lineStart: s, curLine: i, containsInvalid: !!l };
        }
        function vi(a, t, e, s) {
          return a === "template" ? t === 96 || t === 36 && e.charCodeAt(s + 1) === 123 : t === (a === "double" ? 34 : 39);
        }
        function Li(a, t, e, s, i, r) {
          let n = !i;
          t++;
          let o = (c2) => ({ pos: t, ch: c2, lineStart: e, curLine: s }), h = a.charCodeAt(t++);
          switch (h) {
            case 110:
              return o(`
`);
            case 114:
              return o("\r");
            case 120: {
              let c2;
              return { code: c2, pos: t } = Ze2(a, t, e, s, 2, false, n, r), o(c2 === null ? null : String.fromCharCode(c2));
            }
            case 117: {
              let c2;
              return { code: c2, pos: t } = is(a, t, e, s, n, r), o(c2 === null ? null : String.fromCodePoint(c2));
            }
            case 116:
              return o("	");
            case 98:
              return o("\b");
            case 118:
              return o("\v");
            case 102:
              return o("\f");
            case 13:
              a.charCodeAt(t) === 10 && ++t;
            case 10:
              e = t, ++s;
            case 8232:
            case 8233:
              return o("");
            case 56:
            case 57:
              if (i) return o(null);
              r.strictNumericEscape(t - 1, e, s);
            default:
              if (h >= 48 && h <= 55) {
                let c2 = t - 1, u = /^[0-7]+/.exec(a.slice(c2, t + 2))[0], f = parseInt(u, 8);
                f > 255 && (u = u.slice(0, -1), f = parseInt(u, 8)), t += u.length - 1;
                let d = a.charCodeAt(t);
                if (u !== "0" || d === 56 || d === 57) {
                  if (i) return o(null);
                  r.strictNumericEscape(c2, e, s);
                }
                return o(String.fromCharCode(f));
              }
              return o(String.fromCharCode(h));
          }
        }
        function Ze2(a, t, e, s, i, r, n, o) {
          let h = t, c2;
          return { n: c2, pos: t } = ss(a, t, e, s, 16, i, r, false, o, !n), c2 === null && (n ? o.invalidEscapeSequence(h, e, s) : t = h - 1), { code: c2, pos: t };
        }
        function ss(a, t, e, s, i, r, n, o, h, c2) {
          let l = t, u = i === 16 ? Rt2.hex : Rt2.decBinOct, f = i === 16 ? Ce2.hex : i === 10 ? Ce2.dec : i === 8 ? Ce2.oct : Ce2.bin, d = false, y2 = 0;
          for (let E = 0, L2 = r ?? 1 / 0; E < L2; ++E) {
            let S2 = a.charCodeAt(t), I2;
            if (S2 === 95 && o !== "bail") {
              let Ae2 = a.charCodeAt(t - 1), ne2 = a.charCodeAt(t + 1);
              if (o) {
                if (Number.isNaN(ne2) || !f(ne2) || u.has(Ae2) || u.has(ne2)) {
                  if (c2) return { n: null, pos: t };
                  h.unexpectedNumericSeparator(t, e, s);
                }
              } else {
                if (c2) return { n: null, pos: t };
                h.numericSeparatorInEscapeSequence(t, e, s);
              }
              ++t;
              continue;
            }
            if (S2 >= 97 ? I2 = S2 - 97 + 10 : S2 >= 65 ? I2 = S2 - 65 + 10 : ki(S2) ? I2 = S2 - 48 : I2 = 1 / 0, I2 >= i) {
              if (I2 <= 9 && c2) return { n: null, pos: t };
              if (I2 <= 9 && h.invalidDigit(t, e, s, i)) I2 = 0;
              else if (n) I2 = 0, d = true;
              else break;
            }
            ++t, y2 = y2 * i + I2;
          }
          return t === l || r != null && t - l !== r || d ? { n: null, pos: t } : { n: y2, pos: t };
        }
        function is(a, t, e, s, i, r) {
          let n = a.charCodeAt(t), o;
          if (n === 123) {
            if (++t, { code: o, pos: t } = Ze2(a, t, e, s, a.indexOf("}", t) - t, true, i, r), ++t, o !== null && o > 1114111) if (i) r.invalidCodePoint(t, e, s);
            else return { code: null, pos: t };
          } else ({ code: o, pos: t } = Ze2(a, t, e, s, 4, false, i, r));
          return { code: o, pos: t };
        }
        function ce2(a, t, e) {
          return new F(e, a - t, a);
        }
        var Di2 = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]), O2 = class {
          constructor(t) {
            this.type = t.type, this.value = t.value, this.start = t.start, this.end = t.end, this.loc = new ee2(t.startLoc, t.endLoc);
          }
        }, et2 = class extends Ye2 {
          constructor(t, e) {
            super(), this.isLookahead = void 0, this.tokens = [], this.errorHandlers_readInt = { invalidDigit: (s, i, r, n) => this.options.errorRecovery ? (this.raise(p.InvalidDigit, ce2(s, i, r), { radix: n }), true) : false, numericSeparatorInEscapeSequence: this.errorBuilder(p.NumericSeparatorInEscapeSequence), unexpectedNumericSeparator: this.errorBuilder(p.UnexpectedNumericSeparator) }, this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, { invalidEscapeSequence: this.errorBuilder(p.InvalidEscapeSequence), invalidCodePoint: this.errorBuilder(p.InvalidCodePoint) }), this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: (s, i, r) => {
              this.recordStrictModeErrors(p.StrictNumericEscape, ce2(s, i, r));
            }, unterminated: (s, i, r) => {
              throw this.raise(p.UnterminatedString, ce2(s - 1, i, r));
            } }), this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, { strictNumericEscape: this.errorBuilder(p.StrictNumericEscape), unterminated: (s, i, r) => {
              throw this.raise(p.UnterminatedTemplate, ce2(s, i, r));
            } }), this.state = new Qe2(), this.state.init(t), this.input = e, this.length = e.length, this.comments = [], this.isLookahead = false;
          }
          pushToken(t) {
            this.tokens.length = this.state.tokensLength, this.tokens.push(t), ++this.state.tokensLength;
          }
          next() {
            this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new O2(this.state)), this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
          }
          eat(t) {
            return this.match(t) ? (this.next(), true) : false;
          }
          match(t) {
            return this.state.type === t;
          }
          createLookaheadState(t) {
            return { pos: t.pos, value: null, type: t.type, start: t.start, end: t.end, context: [this.curContext()], inType: t.inType, startLoc: t.startLoc, lastTokEndLoc: t.lastTokEndLoc, curLine: t.curLine, lineStart: t.lineStart, curPosition: t.curPosition };
          }
          lookahead() {
            let t = this.state;
            this.state = this.createLookaheadState(t), this.isLookahead = true, this.nextToken(), this.isLookahead = false;
            let e = this.state;
            return this.state = t, e;
          }
          nextTokenStart() {
            return this.nextTokenStartSince(this.state.pos);
          }
          nextTokenStartSince(t) {
            return Ve2.lastIndex = t, Ve2.test(this.input) ? Ve2.lastIndex : t;
          }
          lookaheadCharCode() {
            return this.input.charCodeAt(this.nextTokenStart());
          }
          nextTokenInLineStart() {
            return this.nextTokenInLineStartSince(this.state.pos);
          }
          nextTokenInLineStartSince(t) {
            return Ne2.lastIndex = t, Ne2.test(this.input) ? Ne2.lastIndex : t;
          }
          lookaheadInLineCharCode() {
            return this.input.charCodeAt(this.nextTokenInLineStart());
          }
          codePointAtPos(t) {
            let e = this.input.charCodeAt(t);
            if ((e & 64512) === 55296 && ++t < this.input.length) {
              let s = this.input.charCodeAt(t);
              (s & 64512) === 56320 && (e = 65536 + ((e & 1023) << 10) + (s & 1023));
            }
            return e;
          }
          setStrict(t) {
            this.state.strict = t, t && (this.state.strictErrors.forEach(([e, s]) => this.raise(e, s)), this.state.strictErrors.clear());
          }
          curContext() {
            return this.state.context[this.state.context.length - 1];
          }
          nextToken() {
            if (this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length) {
              this.finishToken(139);
              return;
            }
            this.getTokenFromCode(this.codePointAtPos(this.state.pos));
          }
          skipBlockComment(t) {
            let e;
            this.isLookahead || (e = this.state.curPosition());
            let s = this.state.pos, i = this.input.indexOf(t, s + 2);
            if (i === -1) throw this.raise(p.UnterminatedComment, this.state.curPosition());
            for (this.state.pos = i + t.length, we2.lastIndex = s + 2; we2.test(this.input) && we2.lastIndex <= i; ) ++this.state.curLine, this.state.lineStart = we2.lastIndex;
            if (this.isLookahead) return;
            let r = { type: "CommentBlock", value: this.input.slice(s + 2, i), start: s, end: i + t.length, loc: new ee2(e, this.state.curPosition()) };
            return this.options.tokens && this.pushToken(r), r;
          }
          skipLineComment(t) {
            let e = this.state.pos, s;
            this.isLookahead || (s = this.state.curPosition());
            let i = this.input.charCodeAt(this.state.pos += t);
            if (this.state.pos < this.length) for (; !fe2(i) && ++this.state.pos < this.length; ) i = this.input.charCodeAt(this.state.pos);
            if (this.isLookahead) return;
            let r = this.state.pos, o = { type: "CommentLine", value: this.input.slice(e + t, r), start: e, end: r, loc: new ee2(s, this.state.curPosition()) };
            return this.options.tokens && this.pushToken(o), o;
          }
          skipSpace() {
            let t = this.state.pos, e = [];
            e: for (; this.state.pos < this.length; ) {
              let s = this.input.charCodeAt(this.state.pos);
              switch (s) {
                case 32:
                case 160:
                case 9:
                  ++this.state.pos;
                  break;
                case 13:
                  this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
                case 10:
                case 8232:
                case 8233:
                  ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
                  break;
                case 47:
                  switch (this.input.charCodeAt(this.state.pos + 1)) {
                    case 42: {
                      let i = this.skipBlockComment("*/");
                      i !== void 0 && (this.addComment(i), this.options.attachComment && e.push(i));
                      break;
                    }
                    case 47: {
                      let i = this.skipLineComment(2);
                      i !== void 0 && (this.addComment(i), this.options.attachComment && e.push(i));
                      break;
                    }
                    default:
                      break e;
                  }
                  break;
                default:
                  if (Ni(s)) ++this.state.pos;
                  else if (s === 45 && !this.inModule && this.options.annexB) {
                    let i = this.state.pos;
                    if (this.input.charCodeAt(i + 1) === 45 && this.input.charCodeAt(i + 2) === 62 && (t === 0 || this.state.lineStart > t)) {
                      let r = this.skipLineComment(3);
                      r !== void 0 && (this.addComment(r), this.options.attachComment && e.push(r));
                    } else break e;
                  } else if (s === 60 && !this.inModule && this.options.annexB) {
                    let i = this.state.pos;
                    if (this.input.charCodeAt(i + 1) === 33 && this.input.charCodeAt(i + 2) === 45 && this.input.charCodeAt(i + 3) === 45) {
                      let r = this.skipLineComment(4);
                      r !== void 0 && (this.addComment(r), this.options.attachComment && e.push(r));
                    } else break e;
                  } else break e;
              }
            }
            if (e.length > 0) {
              let s = this.state.pos, i = { start: t, end: s, comments: e, leadingNode: null, trailingNode: null, containingNode: null };
              this.state.commentStack.push(i);
            }
          }
          finishToken(t, e) {
            this.state.end = this.state.pos, this.state.endLoc = this.state.curPosition();
            let s = this.state.type;
            this.state.type = t, this.state.value = e, this.isLookahead || this.updateContext(s);
          }
          replaceToken(t) {
            this.state.type = t, this.updateContext();
          }
          readToken_numberSign() {
            if (this.state.pos === 0 && this.readToken_interpreter()) return;
            let t = this.state.pos + 1, e = this.codePointAtPos(t);
            if (e >= 48 && e <= 57) throw this.raise(p.UnexpectedDigitAfterHash, this.state.curPosition());
            if (e === 123 || e === 91 && this.hasPlugin("recordAndTuple")) {
              if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") === "bar") throw this.raise(e === 123 ? p.RecordExpressionHashIncorrectStartSyntaxType : p.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
              this.state.pos += 2, e === 123 ? this.finishToken(7) : this.finishToken(1);
            } else _2(e) ? (++this.state.pos, this.finishToken(138, this.readWord1(e))) : e === 92 ? (++this.state.pos, this.finishToken(138, this.readWord1())) : this.finishOp(27, 1);
          }
          readToken_dot() {
            let t = this.input.charCodeAt(this.state.pos + 1);
            if (t >= 48 && t <= 57) {
              this.readNumber(true);
              return;
            }
            t === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(21)) : (++this.state.pos, this.finishToken(16));
          }
          readToken_slash() {
            this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(31, 2) : this.finishOp(56, 1);
          }
          readToken_interpreter() {
            if (this.state.pos !== 0 || this.length < 2) return false;
            let t = this.input.charCodeAt(this.state.pos + 1);
            if (t !== 33) return false;
            let e = this.state.pos;
            for (this.state.pos += 1; !fe2(t) && ++this.state.pos < this.length; ) t = this.input.charCodeAt(this.state.pos);
            let s = this.input.slice(e + 2, this.state.pos);
            return this.finishToken(28, s), true;
          }
          readToken_mult_modulo(t) {
            let e = t === 42 ? 55 : 54, s = 1, i = this.input.charCodeAt(this.state.pos + 1);
            t === 42 && i === 42 && (s++, i = this.input.charCodeAt(this.state.pos + 2), e = 57), i === 61 && !this.state.inType && (s++, e = t === 37 ? 33 : 30), this.finishOp(e, s);
          }
          readToken_pipe_amp(t) {
            let e = this.input.charCodeAt(this.state.pos + 1);
            if (e === t) {
              this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(30, 3) : this.finishOp(t === 124 ? 41 : 42, 2);
              return;
            }
            if (t === 124) {
              if (e === 62) {
                this.finishOp(39, 2);
                return;
              }
              if (this.hasPlugin("recordAndTuple") && e === 125) {
                if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") throw this.raise(p.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
                this.state.pos += 2, this.finishToken(9);
                return;
              }
              if (this.hasPlugin("recordAndTuple") && e === 93) {
                if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") throw this.raise(p.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
                this.state.pos += 2, this.finishToken(4);
                return;
              }
            }
            if (e === 61) {
              this.finishOp(30, 2);
              return;
            }
            this.finishOp(t === 124 ? 43 : 45, 1);
          }
          readToken_caret() {
            let t = this.input.charCodeAt(this.state.pos + 1);
            t === 61 && !this.state.inType ? this.finishOp(32, 2) : t === 94 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "^^" }]) ? (this.finishOp(37, 2), this.input.codePointAt(this.state.pos) === 94 && this.unexpected()) : this.finishOp(44, 1);
          }
          readToken_atSign() {
            this.input.charCodeAt(this.state.pos + 1) === 64 && this.hasPlugin(["pipelineOperator", { proposal: "hack", topicToken: "@@" }]) ? this.finishOp(38, 2) : this.finishOp(26, 1);
          }
          readToken_plus_min(t) {
            let e = this.input.charCodeAt(this.state.pos + 1);
            if (e === t) {
              this.finishOp(34, 2);
              return;
            }
            e === 61 ? this.finishOp(30, 2) : this.finishOp(53, 1);
          }
          readToken_lt() {
            let { pos: t } = this.state, e = this.input.charCodeAt(t + 1);
            if (e === 60) {
              if (this.input.charCodeAt(t + 2) === 61) {
                this.finishOp(30, 3);
                return;
              }
              this.finishOp(51, 2);
              return;
            }
            if (e === 61) {
              this.finishOp(49, 2);
              return;
            }
            this.finishOp(47, 1);
          }
          readToken_gt() {
            let { pos: t } = this.state, e = this.input.charCodeAt(t + 1);
            if (e === 62) {
              let s = this.input.charCodeAt(t + 2) === 62 ? 3 : 2;
              if (this.input.charCodeAt(t + s) === 61) {
                this.finishOp(30, s + 1);
                return;
              }
              this.finishOp(52, s);
              return;
            }
            if (e === 61) {
              this.finishOp(49, 2);
              return;
            }
            this.finishOp(48, 1);
          }
          readToken_eq_excl(t) {
            let e = this.input.charCodeAt(this.state.pos + 1);
            if (e === 61) {
              this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
              return;
            }
            if (t === 61 && e === 62) {
              this.state.pos += 2, this.finishToken(19);
              return;
            }
            this.finishOp(t === 61 ? 29 : 35, 1);
          }
          readToken_question() {
            let t = this.input.charCodeAt(this.state.pos + 1), e = this.input.charCodeAt(this.state.pos + 2);
            t === 63 ? e === 61 ? this.finishOp(30, 3) : this.finishOp(40, 2) : t === 46 && !(e >= 48 && e <= 57) ? (this.state.pos += 2, this.finishToken(18)) : (++this.state.pos, this.finishToken(17));
          }
          getTokenFromCode(t) {
            switch (t) {
              case 46:
                this.readToken_dot();
                return;
              case 40:
                ++this.state.pos, this.finishToken(10);
                return;
              case 41:
                ++this.state.pos, this.finishToken(11);
                return;
              case 59:
                ++this.state.pos, this.finishToken(13);
                return;
              case 44:
                ++this.state.pos, this.finishToken(12);
                return;
              case 91:
                if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") throw this.raise(p.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
                  this.state.pos += 2, this.finishToken(2);
                } else ++this.state.pos, this.finishToken(0);
                return;
              case 93:
                ++this.state.pos, this.finishToken(3);
                return;
              case 123:
                if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                  if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") throw this.raise(p.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
                  this.state.pos += 2, this.finishToken(6);
                } else ++this.state.pos, this.finishToken(5);
                return;
              case 125:
                ++this.state.pos, this.finishToken(8);
                return;
              case 58:
                this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(15, 2) : (++this.state.pos, this.finishToken(14));
                return;
              case 63:
                this.readToken_question();
                return;
              case 96:
                this.readTemplateToken();
                return;
              case 48: {
                let e = this.input.charCodeAt(this.state.pos + 1);
                if (e === 120 || e === 88) {
                  this.readRadixNumber(16);
                  return;
                }
                if (e === 111 || e === 79) {
                  this.readRadixNumber(8);
                  return;
                }
                if (e === 98 || e === 66) {
                  this.readRadixNumber(2);
                  return;
                }
              }
              case 49:
              case 50:
              case 51:
              case 52:
              case 53:
              case 54:
              case 55:
              case 56:
              case 57:
                this.readNumber(false);
                return;
              case 34:
              case 39:
                this.readString(t);
                return;
              case 47:
                this.readToken_slash();
                return;
              case 37:
              case 42:
                this.readToken_mult_modulo(t);
                return;
              case 124:
              case 38:
                this.readToken_pipe_amp(t);
                return;
              case 94:
                this.readToken_caret();
                return;
              case 43:
              case 45:
                this.readToken_plus_min(t);
                return;
              case 60:
                this.readToken_lt();
                return;
              case 62:
                this.readToken_gt();
                return;
              case 61:
              case 33:
                this.readToken_eq_excl(t);
                return;
              case 126:
                this.finishOp(36, 1);
                return;
              case 64:
                this.readToken_atSign();
                return;
              case 35:
                this.readToken_numberSign();
                return;
              case 92:
                this.readWord();
                return;
              default:
                if (_2(t)) {
                  this.readWord(t);
                  return;
                }
            }
            throw this.raise(p.InvalidOrUnexpectedToken, this.state.curPosition(), { unexpected: String.fromCodePoint(t) });
          }
          finishOp(t, e) {
            let s = this.input.slice(this.state.pos, this.state.pos + e);
            this.state.pos += e, this.finishToken(t, s);
          }
          readRegexp() {
            let t = this.state.startLoc, e = this.state.start + 1, s, i, { pos: r } = this.state;
            for (; ; ++r) {
              if (r >= this.length) throw this.raise(p.UnterminatedRegExp, v(t, 1));
              let c2 = this.input.charCodeAt(r);
              if (fe2(c2)) throw this.raise(p.UnterminatedRegExp, v(t, 1));
              if (s) s = false;
              else {
                if (c2 === 91) i = true;
                else if (c2 === 93 && i) i = false;
                else if (c2 === 47 && !i) break;
                s = c2 === 92;
              }
            }
            let n = this.input.slice(e, r);
            ++r;
            let o = "", h = () => v(t, r + 2 - e);
            for (; r < this.length; ) {
              let c2 = this.codePointAtPos(r), l = String.fromCharCode(c2);
              if (Di2.has(c2)) c2 === 118 ? o.includes("u") && this.raise(p.IncompatibleRegExpUVFlags, h()) : c2 === 117 && o.includes("v") && this.raise(p.IncompatibleRegExpUVFlags, h()), o.includes(l) && this.raise(p.DuplicateRegExpFlags, h());
              else if (Q2(c2) || c2 === 92) this.raise(p.MalformedRegExpFlags, h());
              else break;
              ++r, o += l;
            }
            this.state.pos = r, this.finishToken(137, { pattern: n, flags: o });
          }
          readInt(t, e, s = false, i = true) {
            let { n: r, pos: n } = ss(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t, e, s, i, this.errorHandlers_readInt, false);
            return this.state.pos = n, r;
          }
          readRadixNumber(t) {
            let e = this.state.curPosition(), s = false;
            this.state.pos += 2;
            let i = this.readInt(t);
            i == null && this.raise(p.InvalidDigit, v(e, 2), { radix: t });
            let r = this.input.charCodeAt(this.state.pos);
            if (r === 110) ++this.state.pos, s = true;
            else if (r === 109) throw this.raise(p.InvalidDecimal, e);
            if (_2(this.codePointAtPos(this.state.pos))) throw this.raise(p.NumberIdentifier, this.state.curPosition());
            if (s) {
              let n = this.input.slice(e.index, this.state.pos).replace(/[_n]/g, "");
              this.finishToken(135, n);
              return;
            }
            this.finishToken(134, i);
          }
          readNumber(t) {
            let e = this.state.pos, s = this.state.curPosition(), i = false, r = false, n = false, o = false, h = false;
            !t && this.readInt(10) === null && this.raise(p.InvalidNumber, this.state.curPosition());
            let c2 = this.state.pos - e >= 2 && this.input.charCodeAt(e) === 48;
            if (c2) {
              let d = this.input.slice(e, this.state.pos);
              if (this.recordStrictModeErrors(p.StrictOctalLiteral, s), !this.state.strict) {
                let y2 = d.indexOf("_");
                y2 > 0 && this.raise(p.ZeroDigitNumericSeparator, v(s, y2));
              }
              h = c2 && !/[89]/.test(d);
            }
            let l = this.input.charCodeAt(this.state.pos);
            if (l === 46 && !h && (++this.state.pos, this.readInt(10), i = true, l = this.input.charCodeAt(this.state.pos)), (l === 69 || l === 101) && !h && (l = this.input.charCodeAt(++this.state.pos), (l === 43 || l === 45) && ++this.state.pos, this.readInt(10) === null && this.raise(p.InvalidOrMissingExponent, s), i = true, o = true, l = this.input.charCodeAt(this.state.pos)), l === 110 && ((i || c2) && this.raise(p.InvalidBigIntLiteral, s), ++this.state.pos, r = true), l === 109 && (this.expectPlugin("decimal", this.state.curPosition()), (o || c2) && this.raise(p.InvalidDecimal, s), ++this.state.pos, n = true), _2(this.codePointAtPos(this.state.pos))) throw this.raise(p.NumberIdentifier, this.state.curPosition());
            let u = this.input.slice(e, this.state.pos).replace(/[_mn]/g, "");
            if (r) {
              this.finishToken(135, u);
              return;
            }
            if (n) {
              this.finishToken(136, u);
              return;
            }
            let f = h ? parseInt(u, 8) : parseFloat(u);
            this.finishToken(134, f);
          }
          readCodePoint(t) {
            let { code: e, pos: s } = is(this.input, this.state.pos, this.state.lineStart, this.state.curLine, t, this.errorHandlers_readCodePoint);
            return this.state.pos = s, e;
          }
          readString(t) {
            let { str: e, pos: s, curLine: i, lineStart: r } = Ut2(t === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
            this.state.pos = s + 1, this.state.lineStart = r, this.state.curLine = i, this.finishToken(133, e);
          }
          readTemplateContinuation() {
            this.match(8) || this.unexpected(null, 8), this.state.pos--, this.readTemplateToken();
          }
          readTemplateToken() {
            let t = this.input[this.state.pos], { str: e, firstInvalidLoc: s, pos: i, curLine: r, lineStart: n } = Ut2("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
            this.state.pos = i + 1, this.state.lineStart = n, this.state.curLine = r, s && (this.state.firstInvalidTemplateEscapePos = new F(s.curLine, s.pos - s.lineStart, s.pos)), this.input.codePointAt(i) === 96 ? this.finishToken(24, s ? null : t + e + "`") : (this.state.pos++, this.finishToken(25, s ? null : t + e + "${"));
          }
          recordStrictModeErrors(t, e) {
            let s = e.index;
            this.state.strict && !this.state.strictErrors.has(s) ? this.raise(t, e) : this.state.strictErrors.set(s, [t, e]);
          }
          readWord1(t) {
            this.state.containsEsc = false;
            let e = "", s = this.state.pos, i = this.state.pos;
            for (t !== void 0 && (this.state.pos += t <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
              let r = this.codePointAtPos(this.state.pos);
              if (Q2(r)) this.state.pos += r <= 65535 ? 1 : 2;
              else if (r === 92) {
                this.state.containsEsc = true, e += this.input.slice(i, this.state.pos);
                let n = this.state.curPosition(), o = this.state.pos === s ? _2 : Q2;
                if (this.input.charCodeAt(++this.state.pos) !== 117) {
                  this.raise(p.MissingUnicodeEscape, this.state.curPosition()), i = this.state.pos - 1;
                  continue;
                }
                ++this.state.pos;
                let h = this.readCodePoint(true);
                h !== null && (o(h) || this.raise(p.EscapedCharNotAnIdentifier, n), e += String.fromCodePoint(h)), i = this.state.pos;
              } else break;
            }
            return e + this.input.slice(i, this.state.pos);
          }
          readWord(t) {
            let e = this.readWord1(t), s = ut2.get(e);
            s !== void 0 ? this.finishToken(s, K2(s)) : this.finishToken(132, e);
          }
          checkKeywordEscapes() {
            let { type: t } = this.state;
            Pt2(t) && this.state.containsEsc && this.raise(p.InvalidEscapedReservedWord, this.state.startLoc, { reservedWord: K2(t) });
          }
          raise(t, e, s = {}) {
            let i = e instanceof F ? e : e.loc.start, r = t(i, s);
            if (!this.options.errorRecovery) throw r;
            return this.isLookahead || this.state.errors.push(r), r;
          }
          raiseOverwrite(t, e, s = {}) {
            let i = e instanceof F ? e : e.loc.start, r = i.index, n = this.state.errors;
            for (let o = n.length - 1; o >= 0; o--) {
              let h = n[o];
              if (h.loc.index === r) return n[o] = t(i, s);
              if (h.loc.index < r) break;
            }
            return this.raise(t, e, s);
          }
          updateContext(t) {
          }
          unexpected(t, e) {
            throw this.raise(p.UnexpectedToken, t ?? this.state.startLoc, { expected: e ? K2(e) : null });
          }
          expectPlugin(t, e) {
            if (this.hasPlugin(t)) return true;
            throw this.raise(p.MissingPlugin, e ?? this.state.startLoc, { missingPlugin: [t] });
          }
          expectOnePlugin(t) {
            if (!t.some((e) => this.hasPlugin(e))) throw this.raise(p.MissingOneOfPlugins, this.state.startLoc, { missingPlugin: t });
          }
          errorBuilder(t) {
            return (e, s, i) => {
              this.raise(t, ce2(e, s, i));
            };
          }
        }, tt2 = class {
          constructor() {
            this.privateNames = /* @__PURE__ */ new Set(), this.loneAccessors = /* @__PURE__ */ new Map(), this.undefinedPrivateNames = /* @__PURE__ */ new Map();
          }
        }, st2 = class {
          constructor(t) {
            this.parser = void 0, this.stack = [], this.undefinedPrivateNames = /* @__PURE__ */ new Map(), this.parser = t;
          }
          current() {
            return this.stack[this.stack.length - 1];
          }
          enter() {
            this.stack.push(new tt2());
          }
          exit() {
            let t = this.stack.pop(), e = this.current();
            for (let [s, i] of Array.from(t.undefinedPrivateNames)) e ? e.undefinedPrivateNames.has(s) || e.undefinedPrivateNames.set(s, i) : this.parser.raise(p.InvalidPrivateFieldResolution, i, { identifierName: s });
          }
          declarePrivateName(t, e, s) {
            let { privateNames: i, loneAccessors: r, undefinedPrivateNames: n } = this.current(), o = i.has(t);
            if (e & 3) {
              let h = o && r.get(t);
              if (h) {
                let c2 = h & 4, l = e & 4, u = h & 3, f = e & 3;
                o = u === f || c2 !== l, o || r.delete(t);
              } else o || r.set(t, e);
            }
            o && this.parser.raise(p.PrivateNameRedeclaration, s, { identifierName: t }), i.add(t), n.delete(t);
          }
          usePrivateName(t, e) {
            let s;
            for (s of this.stack) if (s.privateNames.has(t)) return;
            s ? s.undefinedPrivateNames.set(t, e) : this.parser.raise(p.InvalidPrivateFieldResolution, e, { identifierName: t });
          }
        }, te2 = class {
          constructor(t = 0) {
            this.type = t;
          }
          canBeArrowParameterDeclaration() {
            return this.type === 2 || this.type === 1;
          }
          isCertainlyParameterDeclaration() {
            return this.type === 3;
          }
        }, De2 = class extends te2 {
          constructor(t) {
            super(t), this.declarationErrors = /* @__PURE__ */ new Map();
          }
          recordDeclarationError(t, e) {
            let s = e.index;
            this.declarationErrors.set(s, [t, e]);
          }
          clearDeclarationError(t) {
            this.declarationErrors.delete(t);
          }
          iterateErrors(t) {
            this.declarationErrors.forEach(t);
          }
        }, it2 = class {
          constructor(t) {
            this.parser = void 0, this.stack = [new te2()], this.parser = t;
          }
          enter(t) {
            this.stack.push(t);
          }
          exit() {
            this.stack.pop();
          }
          recordParameterInitializerError(t, e) {
            let s = e.loc.start, { stack: i } = this, r = i.length - 1, n = i[r];
            for (; !n.isCertainlyParameterDeclaration(); ) {
              if (n.canBeArrowParameterDeclaration()) n.recordDeclarationError(t, s);
              else return;
              n = i[--r];
            }
            this.parser.raise(t, s);
          }
          recordArrowParameterBindingError(t, e) {
            let { stack: s } = this, i = s[s.length - 1], r = e.loc.start;
            if (i.isCertainlyParameterDeclaration()) this.parser.raise(t, r);
            else if (i.canBeArrowParameterDeclaration()) i.recordDeclarationError(t, r);
            else return;
          }
          recordAsyncArrowParametersError(t) {
            let { stack: e } = this, s = e.length - 1, i = e[s];
            for (; i.canBeArrowParameterDeclaration(); ) i.type === 2 && i.recordDeclarationError(p.AwaitBindingIdentifier, t), i = e[--s];
          }
          validateAsPattern() {
            let { stack: t } = this, e = t[t.length - 1];
            e.canBeArrowParameterDeclaration() && e.iterateErrors(([s, i]) => {
              this.parser.raise(s, i);
              let r = t.length - 2, n = t[r];
              for (; n.canBeArrowParameterDeclaration(); ) n.clearDeclarationError(i.index), n = t[--r];
            });
          }
        };
        function Mi() {
          return new te2(3);
        }
        function Oi() {
          return new De2(1);
        }
        function Fi() {
          return new De2(2);
        }
        function rs() {
          return new te2();
        }
        var rt2 = class {
          constructor() {
            this.stacks = [];
          }
          enter(t) {
            this.stacks.push(t);
          }
          exit() {
            this.stacks.pop();
          }
          currentFlags() {
            return this.stacks[this.stacks.length - 1];
          }
          get hasAwait() {
            return (this.currentFlags() & 2) > 0;
          }
          get hasYield() {
            return (this.currentFlags() & 1) > 0;
          }
          get hasReturn() {
            return (this.currentFlags() & 4) > 0;
          }
          get hasIn() {
            return (this.currentFlags() & 8) > 0;
          }
        };
        function ke2(a, t) {
          return (a ? 2 : 0) | (t ? 1 : 0);
        }
        var at2 = class extends et2 {
          addExtra(t, e, s, i = true) {
            if (!t) return;
            let r = t.extra = t.extra || {};
            i ? r[e] = s : Object.defineProperty(r, e, { enumerable: i, value: s });
          }
          isContextual(t) {
            return this.state.type === t && !this.state.containsEsc;
          }
          isUnparsedContextual(t, e) {
            let s = t + e.length;
            if (this.input.slice(t, s) === e) {
              let i = this.input.charCodeAt(s);
              return !(Q2(i) || (i & 64512) === 55296);
            }
            return false;
          }
          isLookaheadContextual(t) {
            let e = this.nextTokenStart();
            return this.isUnparsedContextual(e, t);
          }
          eatContextual(t) {
            return this.isContextual(t) ? (this.next(), true) : false;
          }
          expectContextual(t, e) {
            if (!this.eatContextual(t)) {
              if (e != null) throw this.raise(e, this.state.startLoc);
              this.unexpected(null, t);
            }
          }
          canInsertSemicolon() {
            return this.match(139) || this.match(8) || this.hasPrecedingLineBreak();
          }
          hasPrecedingLineBreak() {
            return ts.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
          }
          hasFollowingLineBreak() {
            return Bt2.lastIndex = this.state.end, Bt2.test(this.input);
          }
          isLineTerminator() {
            return this.eat(13) || this.canInsertSemicolon();
          }
          semicolon(t = true) {
            (t ? this.isLineTerminator() : this.eat(13)) || this.raise(p.MissingSemicolon, this.state.lastTokEndLoc);
          }
          expect(t, e) {
            this.eat(t) || this.unexpected(e, t);
          }
          tryParse(t, e = this.state.clone()) {
            let s = { node: null };
            try {
              let i = t((r = null) => {
                throw s.node = r, s;
              });
              if (this.state.errors.length > e.errors.length) {
                let r = this.state;
                return this.state = e, this.state.tokensLength = r.tokensLength, { node: i, error: r.errors[e.errors.length], thrown: false, aborted: false, failState: r };
              }
              return { node: i, error: null, thrown: false, aborted: false, failState: null };
            } catch (i) {
              let r = this.state;
              if (this.state = e, i instanceof SyntaxError) return { node: null, error: i, thrown: true, aborted: false, failState: r };
              if (i === s) return { node: s.node, error: null, thrown: false, aborted: true, failState: r };
              throw i;
            }
          }
          checkExpressionErrors(t, e) {
            if (!t) return false;
            let { shorthandAssignLoc: s, doubleProtoLoc: i, privateKeyLoc: r, optionalParametersLoc: n } = t, o = !!s || !!i || !!n || !!r;
            if (!e) return o;
            s != null && this.raise(p.InvalidCoverInitializedName, s), i != null && this.raise(p.DuplicateProto, i), r != null && this.raise(p.UnexpectedPrivateField, r), n != null && this.unexpected(n);
          }
          isLiteralPropertyName() {
            return Wt2(this.state.type);
          }
          isPrivateName(t) {
            return t.type === "PrivateName";
          }
          getPrivateNameSV(t) {
            return t.id.name;
          }
          hasPropertyAsPrivateName(t) {
            return (t.type === "MemberExpression" || t.type === "OptionalMemberExpression") && this.isPrivateName(t.property);
          }
          isObjectProperty(t) {
            return t.type === "ObjectProperty";
          }
          isObjectMethod(t) {
            return t.type === "ObjectMethod";
          }
          initializeScopes(t = this.options.sourceType === "module") {
            let e = this.state.labels;
            this.state.labels = [];
            let s = this.exportedIdentifiers;
            this.exportedIdentifiers = /* @__PURE__ */ new Set();
            let i = this.inModule;
            this.inModule = t;
            let r = this.scope, n = this.getScopeHandler();
            this.scope = new n(this, t);
            let o = this.prodParam;
            this.prodParam = new rt2();
            let h = this.classScope;
            this.classScope = new st2(this);
            let c2 = this.expressionScope;
            return this.expressionScope = new it2(this), () => {
              this.state.labels = e, this.exportedIdentifiers = s, this.inModule = i, this.scope = r, this.prodParam = o, this.classScope = h, this.expressionScope = c2;
            };
          }
          enterInitialScopes() {
            let t = 0;
            this.inModule && (t |= 2), this.scope.enter(1), this.prodParam.enter(t);
          }
          checkDestructuringPrivate(t) {
            let { privateKeyLoc: e } = t;
            e !== null && this.expectPlugin("destructuringPrivate", e);
          }
        }, Z2 = class {
          constructor() {
            this.shorthandAssignLoc = null, this.doubleProtoLoc = null, this.privateKeyLoc = null, this.optionalParametersLoc = null;
          }
        }, se2 = class {
          constructor(t, e, s) {
            this.type = "", this.start = e, this.end = 0, this.loc = new ee2(s), t != null && t.options.ranges && (this.range = [e, 0]), t != null && t.filename && (this.loc.filename = t.filename);
          }
        }, bt2 = se2.prototype;
        bt2.__clone = function() {
          let a = new se2(void 0, this.start, this.loc.start), t = Object.keys(this);
          for (let e = 0, s = t.length; e < s; e++) {
            let i = t[e];
            i !== "leadingComments" && i !== "trailingComments" && i !== "innerComments" && (a[i] = this[i]);
          }
          return a;
        };
        function Bi(a) {
          return $(a);
        }
        function $(a) {
          let { type: t, start: e, end: s, loc: i, range: r, extra: n, name: o } = a, h = Object.create(bt2);
          return h.type = t, h.start = e, h.end = s, h.loc = i, h.range = r, h.extra = n, h.name = o, t === "Placeholder" && (h.expectedNode = a.expectedNode), h;
        }
        function Ri(a) {
          let { type: t, start: e, end: s, loc: i, range: r, extra: n } = a;
          if (t === "Placeholder") return Bi(a);
          let o = Object.create(bt2);
          return o.type = t, o.start = e, o.end = s, o.loc = i, o.range = r, a.raw !== void 0 ? o.raw = a.raw : o.extra = n, o.value = a.value, o;
        }
        var nt2 = class extends at2 {
          startNode() {
            let t = this.state.startLoc;
            return new se2(this, t.index, t);
          }
          startNodeAt(t) {
            return new se2(this, t.index, t);
          }
          startNodeAtNode(t) {
            return this.startNodeAt(t.loc.start);
          }
          finishNode(t, e) {
            return this.finishNodeAt(t, e, this.state.lastTokEndLoc);
          }
          finishNodeAt(t, e, s) {
            return t.type = e, t.end = s.index, t.loc.end = s, this.options.ranges && (t.range[1] = s.index), this.options.attachComment && this.processComment(t), t;
          }
          resetStartLocation(t, e) {
            t.start = e.index, t.loc.start = e, this.options.ranges && (t.range[0] = e.index);
          }
          resetEndLocation(t, e = this.state.lastTokEndLoc) {
            t.end = e.index, t.loc.end = e, this.options.ranges && (t.range[1] = e.index);
          }
          resetStartLocationFromNode(t, e) {
            this.resetStartLocation(t, e.loc.start);
          }
        }, Ui = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), g = j2`flow`({ AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.", AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.", AssignReservedType: ({ reservedType: a }) => `Cannot overwrite reserved type ${a}.`, DeclareClassElement: "The `declare` modifier can only appear on class fields.", DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.", DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.", EnumBooleanMemberNotInitialized: ({ memberName: a, enumName: t }) => `Boolean enum members need to be initialized. Use either \`${a} = true,\` or \`${a} = false,\` in enum \`${t}\`.`, EnumDuplicateMemberName: ({ memberName: a, enumName: t }) => `Enum member names need to be unique, but the name \`${a}\` has already been used before in enum \`${t}\`.`, EnumInconsistentMemberValues: ({ enumName: a }) => `Enum \`${a}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`, EnumInvalidExplicitType: ({ invalidEnumType: a, enumName: t }) => `Enum type \`${a}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${t}\`.`, EnumInvalidExplicitTypeUnknownSupplied: ({ enumName: a }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${a}\`.`, EnumInvalidMemberInitializerPrimaryType: ({ enumName: a, memberName: t, explicitType: e }) => `Enum \`${a}\` has type \`${e}\`, so the initializer of \`${t}\` needs to be a ${e} literal.`, EnumInvalidMemberInitializerSymbolType: ({ enumName: a, memberName: t }) => `Symbol enum members cannot be initialized. Use \`${t},\` in enum \`${a}\`.`, EnumInvalidMemberInitializerUnknownType: ({ enumName: a, memberName: t }) => `The enum member initializer for \`${t}\` needs to be a literal (either a boolean, number, or string) in enum \`${a}\`.`, EnumInvalidMemberName: ({ enumName: a, memberName: t, suggestion: e }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${t}\`, consider using \`${e}\`, in enum \`${a}\`.`, EnumNumberMemberNotInitialized: ({ enumName: a, memberName: t }) => `Number enum members need to be initialized, e.g. \`${t} = 1\` in enum \`${a}\`.`, EnumStringMemberInconsistentlyInitialized: ({ enumName: a }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${a}\`.`, GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.", ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.", InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.", InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.", InexactVariance: "Explicit inexact syntax cannot have variance.", InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.", MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.", NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.", NestedFlowComment: "Cannot have a flow comment inside another flow comment.", PatternIsOptional: Object.assign({ message: "A binding pattern parameter cannot be optional in an implementation signature." }, { reasonCode: "OptionalBindingPattern" }), SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.", SpreadVariance: "Spread properties cannot have variance.", ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.", ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.", ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.", ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.", ThisParamNoDefault: "The `this` parameter may not have a default value.", TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.", UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.", UnexpectedReservedType: ({ reservedType: a }) => `Unexpected reserved type ${a}.`, UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.", UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.", UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.", UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".', UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.", UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.", UnsupportedDeclareExportKind: ({ unsupportedExportKind: a, suggestion: t }) => `\`declare export ${a}\` is not supported. Use \`${t}\` instead.`, UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.", UnterminatedFlowComment: "Unterminated flow-comment." });
        function _i(a) {
          return a.type === "DeclareExportAllDeclaration" || a.type === "DeclareExportDeclaration" && (!a.declaration || a.declaration.type !== "TypeAlias" && a.declaration.type !== "InterfaceDeclaration");
        }
        function _t2(a) {
          return a.importKind === "type" || a.importKind === "typeof";
        }
        var ji = { const: "declare export var", let: "declare export var", type: "export type", interface: "export interface" };
        function $i(a, t) {
          let e = [], s = [];
          for (let i = 0; i < a.length; i++) (t(a[i], i, a) ? e : s).push(a[i]);
          return [e, s];
        }
        var Vi = /\*?\s*@((?:no)?flow)\b/, qi = (a) => class extends a {
          constructor(...e) {
            super(...e), this.flowPragma = void 0;
          }
          getScopeHandler() {
            return Xe2;
          }
          shouldParseTypes() {
            return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
          }
          shouldParseEnums() {
            return !!this.getPluginOption("flow", "enums");
          }
          finishToken(e, s) {
            e !== 133 && e !== 13 && e !== 28 && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(e, s);
          }
          addComment(e) {
            if (this.flowPragma === void 0) {
              let s = Vi.exec(e.value);
              if (s) if (s[1] === "flow") this.flowPragma = "flow";
              else if (s[1] === "noflow") this.flowPragma = "noflow";
              else throw new Error("Unexpected flow pragma");
            }
            super.addComment(e);
          }
          flowParseTypeInitialiser(e) {
            let s = this.state.inType;
            this.state.inType = true, this.expect(e || 14);
            let i = this.flowParseType();
            return this.state.inType = s, i;
          }
          flowParsePredicate() {
            let e = this.startNode(), s = this.state.startLoc;
            return this.next(), this.expectContextual(110), this.state.lastTokStartLoc.index > s.index + 1 && this.raise(g.UnexpectedSpaceBetweenModuloChecks, s), this.eat(10) ? (e.value = super.parseExpression(), this.expect(11), this.finishNode(e, "DeclaredPredicate")) : this.finishNode(e, "InferredPredicate");
          }
          flowParseTypeAndPredicateInitialiser() {
            let e = this.state.inType;
            this.state.inType = true, this.expect(14);
            let s = null, i = null;
            return this.match(54) ? (this.state.inType = e, i = this.flowParsePredicate()) : (s = this.flowParseType(), this.state.inType = e, this.match(54) && (i = this.flowParsePredicate())), [s, i];
          }
          flowParseDeclareClass(e) {
            return this.next(), this.flowParseInterfaceish(e, true), this.finishNode(e, "DeclareClass");
          }
          flowParseDeclareFunction(e) {
            this.next();
            let s = e.id = this.parseIdentifier(), i = this.startNode(), r = this.startNode();
            this.match(47) ? i.typeParameters = this.flowParseTypeParameterDeclaration() : i.typeParameters = null, this.expect(10);
            let n = this.flowParseFunctionTypeParams();
            return i.params = n.params, i.rest = n.rest, i.this = n._this, this.expect(11), [i.returnType, e.predicate] = this.flowParseTypeAndPredicateInitialiser(), r.typeAnnotation = this.finishNode(i, "FunctionTypeAnnotation"), s.typeAnnotation = this.finishNode(r, "TypeAnnotation"), this.resetEndLocation(s), this.semicolon(), this.scope.declareName(e.id.name, 2048, e.id.loc.start), this.finishNode(e, "DeclareFunction");
          }
          flowParseDeclare(e, s) {
            if (this.match(80)) return this.flowParseDeclareClass(e);
            if (this.match(68)) return this.flowParseDeclareFunction(e);
            if (this.match(74)) return this.flowParseDeclareVariable(e);
            if (this.eatContextual(127)) return this.match(16) ? this.flowParseDeclareModuleExports(e) : (s && this.raise(g.NestedDeclareModule, this.state.lastTokStartLoc), this.flowParseDeclareModule(e));
            if (this.isContextual(130)) return this.flowParseDeclareTypeAlias(e);
            if (this.isContextual(131)) return this.flowParseDeclareOpaqueType(e);
            if (this.isContextual(129)) return this.flowParseDeclareInterface(e);
            if (this.match(82)) return this.flowParseDeclareExportDeclaration(e, s);
            this.unexpected();
          }
          flowParseDeclareVariable(e) {
            return this.next(), e.id = this.flowParseTypeAnnotatableIdentifier(true), this.scope.declareName(e.id.name, 5, e.id.loc.start), this.semicolon(), this.finishNode(e, "DeclareVariable");
          }
          flowParseDeclareModule(e) {
            this.scope.enter(0), this.match(133) ? e.id = super.parseExprAtom() : e.id = this.parseIdentifier();
            let s = e.body = this.startNode(), i = s.body = [];
            for (this.expect(5); !this.match(8); ) {
              let o = this.startNode();
              this.match(83) ? (this.next(), !this.isContextual(130) && !this.match(87) && this.raise(g.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc), super.parseImport(o)) : (this.expectContextual(125, g.UnsupportedStatementInDeclareModule), o = this.flowParseDeclare(o, true)), i.push(o);
            }
            this.scope.exit(), this.expect(8), this.finishNode(s, "BlockStatement");
            let r = null, n = false;
            return i.forEach((o) => {
              _i(o) ? (r === "CommonJS" && this.raise(g.AmbiguousDeclareModuleKind, o), r = "ES") : o.type === "DeclareModuleExports" && (n && this.raise(g.DuplicateDeclareModuleExports, o), r === "ES" && this.raise(g.AmbiguousDeclareModuleKind, o), r = "CommonJS", n = true);
            }), e.kind = r || "CommonJS", this.finishNode(e, "DeclareModule");
          }
          flowParseDeclareExportDeclaration(e, s) {
            if (this.expect(82), this.eat(65)) return this.match(68) || this.match(80) ? e.declaration = this.flowParseDeclare(this.startNode()) : (e.declaration = this.flowParseType(), this.semicolon()), e.default = true, this.finishNode(e, "DeclareExportDeclaration");
            if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !s) {
              let i = this.state.value;
              throw this.raise(g.UnsupportedDeclareExportKind, this.state.startLoc, { unsupportedExportKind: i, suggestion: ji[i] });
            }
            if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131)) return e.declaration = this.flowParseDeclare(this.startNode()), e.default = false, this.finishNode(e, "DeclareExportDeclaration");
            if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131)) return e = this.parseExport(e, null), e.type === "ExportNamedDeclaration" && (e.type = "ExportDeclaration", e.default = false, delete e.exportKind), e.type = "Declare" + e.type, e;
            this.unexpected();
          }
          flowParseDeclareModuleExports(e) {
            return this.next(), this.expectContextual(111), e.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(e, "DeclareModuleExports");
          }
          flowParseDeclareTypeAlias(e) {
            this.next();
            let s = this.flowParseTypeAlias(e);
            return s.type = "DeclareTypeAlias", s;
          }
          flowParseDeclareOpaqueType(e) {
            this.next();
            let s = this.flowParseOpaqueType(e, true);
            return s.type = "DeclareOpaqueType", s;
          }
          flowParseDeclareInterface(e) {
            return this.next(), this.flowParseInterfaceish(e, false), this.finishNode(e, "DeclareInterface");
          }
          flowParseInterfaceish(e, s) {
            if (e.id = this.flowParseRestrictedIdentifier(!s, true), this.scope.declareName(e.id.name, s ? 17 : 8201, e.id.loc.start), this.match(47) ? e.typeParameters = this.flowParseTypeParameterDeclaration() : e.typeParameters = null, e.extends = [], this.eat(81)) do
              e.extends.push(this.flowParseInterfaceExtends());
            while (!s && this.eat(12));
            if (s) {
              if (e.implements = [], e.mixins = [], this.eatContextual(117)) do
                e.mixins.push(this.flowParseInterfaceExtends());
              while (this.eat(12));
              if (this.eatContextual(113)) do
                e.implements.push(this.flowParseInterfaceExtends());
              while (this.eat(12));
            }
            e.body = this.flowParseObjectType({ allowStatic: s, allowExact: false, allowSpread: false, allowProto: s, allowInexact: false });
          }
          flowParseInterfaceExtends() {
            let e = this.startNode();
            return e.id = this.flowParseQualifiedTypeIdentifier(), this.match(47) ? e.typeParameters = this.flowParseTypeParameterInstantiation() : e.typeParameters = null, this.finishNode(e, "InterfaceExtends");
          }
          flowParseInterface(e) {
            return this.flowParseInterfaceish(e, false), this.finishNode(e, "InterfaceDeclaration");
          }
          checkNotUnderscore(e) {
            e === "_" && this.raise(g.UnexpectedReservedUnderscore, this.state.startLoc);
          }
          checkReservedType(e, s, i) {
            Ui.has(e) && this.raise(i ? g.AssignReservedType : g.UnexpectedReservedType, s, { reservedType: e });
          }
          flowParseRestrictedIdentifier(e, s) {
            return this.checkReservedType(this.state.value, this.state.startLoc, s), this.parseIdentifier(e);
          }
          flowParseTypeAlias(e) {
            return e.id = this.flowParseRestrictedIdentifier(false, true), this.scope.declareName(e.id.name, 8201, e.id.loc.start), this.match(47) ? e.typeParameters = this.flowParseTypeParameterDeclaration() : e.typeParameters = null, e.right = this.flowParseTypeInitialiser(29), this.semicolon(), this.finishNode(e, "TypeAlias");
          }
          flowParseOpaqueType(e, s) {
            return this.expectContextual(130), e.id = this.flowParseRestrictedIdentifier(true, true), this.scope.declareName(e.id.name, 8201, e.id.loc.start), this.match(47) ? e.typeParameters = this.flowParseTypeParameterDeclaration() : e.typeParameters = null, e.supertype = null, this.match(14) && (e.supertype = this.flowParseTypeInitialiser(14)), e.impltype = null, s || (e.impltype = this.flowParseTypeInitialiser(29)), this.semicolon(), this.finishNode(e, "OpaqueType");
          }
          flowParseTypeParameter(e = false) {
            let s = this.state.startLoc, i = this.startNode(), r = this.flowParseVariance(), n = this.flowParseTypeAnnotatableIdentifier();
            return i.name = n.name, i.variance = r, i.bound = n.typeAnnotation, this.match(29) ? (this.eat(29), i.default = this.flowParseType()) : e && this.raise(g.MissingTypeParamDefault, s), this.finishNode(i, "TypeParameter");
          }
          flowParseTypeParameterDeclaration() {
            let e = this.state.inType, s = this.startNode();
            s.params = [], this.state.inType = true, this.match(47) || this.match(142) ? this.next() : this.unexpected();
            let i = false;
            do {
              let r = this.flowParseTypeParameter(i);
              s.params.push(r), r.default && (i = true), this.match(48) || this.expect(12);
            } while (!this.match(48));
            return this.expect(48), this.state.inType = e, this.finishNode(s, "TypeParameterDeclaration");
          }
          flowParseTypeParameterInstantiation() {
            let e = this.startNode(), s = this.state.inType;
            e.params = [], this.state.inType = true, this.expect(47);
            let i = this.state.noAnonFunctionType;
            for (this.state.noAnonFunctionType = false; !this.match(48); ) e.params.push(this.flowParseType()), this.match(48) || this.expect(12);
            return this.state.noAnonFunctionType = i, this.expect(48), this.state.inType = s, this.finishNode(e, "TypeParameterInstantiation");
          }
          flowParseTypeParameterInstantiationCallOrNew() {
            let e = this.startNode(), s = this.state.inType;
            for (e.params = [], this.state.inType = true, this.expect(47); !this.match(48); ) e.params.push(this.flowParseTypeOrImplicitInstantiation()), this.match(48) || this.expect(12);
            return this.expect(48), this.state.inType = s, this.finishNode(e, "TypeParameterInstantiation");
          }
          flowParseInterfaceType() {
            let e = this.startNode();
            if (this.expectContextual(129), e.extends = [], this.eat(81)) do
              e.extends.push(this.flowParseInterfaceExtends());
            while (this.eat(12));
            return e.body = this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: false, allowProto: false, allowInexact: false }), this.finishNode(e, "InterfaceTypeAnnotation");
          }
          flowParseObjectPropertyKey() {
            return this.match(134) || this.match(133) ? super.parseExprAtom() : this.parseIdentifier(true);
          }
          flowParseObjectTypeIndexer(e, s, i) {
            return e.static = s, this.lookahead().type === 14 ? (e.id = this.flowParseObjectPropertyKey(), e.key = this.flowParseTypeInitialiser()) : (e.id = null, e.key = this.flowParseType()), this.expect(3), e.value = this.flowParseTypeInitialiser(), e.variance = i, this.finishNode(e, "ObjectTypeIndexer");
          }
          flowParseObjectTypeInternalSlot(e, s) {
            return e.static = s, e.id = this.flowParseObjectPropertyKey(), this.expect(3), this.expect(3), this.match(47) || this.match(10) ? (e.method = true, e.optional = false, e.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e.loc.start))) : (e.method = false, this.eat(17) && (e.optional = true), e.value = this.flowParseTypeInitialiser()), this.finishNode(e, "ObjectTypeInternalSlot");
          }
          flowParseObjectTypeMethodish(e) {
            for (e.params = [], e.rest = null, e.typeParameters = null, e.this = null, this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(10), this.match(78) && (e.this = this.flowParseFunctionTypeParam(true), e.this.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); ) e.params.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
            return this.eat(21) && (e.rest = this.flowParseFunctionTypeParam(false)), this.expect(11), e.returnType = this.flowParseTypeInitialiser(), this.finishNode(e, "FunctionTypeAnnotation");
          }
          flowParseObjectTypeCallProperty(e, s) {
            let i = this.startNode();
            return e.static = s, e.value = this.flowParseObjectTypeMethodish(i), this.finishNode(e, "ObjectTypeCallProperty");
          }
          flowParseObjectType({ allowStatic: e, allowExact: s, allowSpread: i, allowProto: r, allowInexact: n }) {
            let o = this.state.inType;
            this.state.inType = true;
            let h = this.startNode();
            h.callProperties = [], h.properties = [], h.indexers = [], h.internalSlots = [];
            let c2, l, u = false;
            for (s && this.match(6) ? (this.expect(6), c2 = 9, l = true) : (this.expect(5), c2 = 8, l = false), h.exact = l; !this.match(c2); ) {
              let d = false, y2 = null, E = null, L2 = this.startNode();
              if (r && this.isContextual(118)) {
                let I2 = this.lookahead();
                I2.type !== 14 && I2.type !== 17 && (this.next(), y2 = this.state.startLoc, e = false);
              }
              if (e && this.isContextual(106)) {
                let I2 = this.lookahead();
                I2.type !== 14 && I2.type !== 17 && (this.next(), d = true);
              }
              let S2 = this.flowParseVariance();
              if (this.eat(0)) y2 != null && this.unexpected(y2), this.eat(0) ? (S2 && this.unexpected(S2.loc.start), h.internalSlots.push(this.flowParseObjectTypeInternalSlot(L2, d))) : h.indexers.push(this.flowParseObjectTypeIndexer(L2, d, S2));
              else if (this.match(10) || this.match(47)) y2 != null && this.unexpected(y2), S2 && this.unexpected(S2.loc.start), h.callProperties.push(this.flowParseObjectTypeCallProperty(L2, d));
              else {
                let I2 = "init";
                if (this.isContextual(99) || this.isContextual(104)) {
                  let ne2 = this.lookahead();
                  Wt2(ne2.type) && (I2 = this.state.value, this.next());
                }
                let Ae2 = this.flowParseObjectTypeProperty(L2, d, y2, S2, I2, i, n ?? !l);
                Ae2 === null ? (u = true, E = this.state.lastTokStartLoc) : h.properties.push(Ae2);
              }
              this.flowObjectTypeSemicolon(), E && !this.match(8) && !this.match(9) && this.raise(g.UnexpectedExplicitInexactInObject, E);
            }
            this.expect(c2), i && (h.inexact = u);
            let f = this.finishNode(h, "ObjectTypeAnnotation");
            return this.state.inType = o, f;
          }
          flowParseObjectTypeProperty(e, s, i, r, n, o, h) {
            if (this.eat(21)) return this.match(12) || this.match(13) || this.match(8) || this.match(9) ? (o ? h || this.raise(g.InexactInsideExact, this.state.lastTokStartLoc) : this.raise(g.InexactInsideNonObject, this.state.lastTokStartLoc), r && this.raise(g.InexactVariance, r), null) : (o || this.raise(g.UnexpectedSpreadType, this.state.lastTokStartLoc), i != null && this.unexpected(i), r && this.raise(g.SpreadVariance, r), e.argument = this.flowParseType(), this.finishNode(e, "ObjectTypeSpreadProperty"));
            {
              e.key = this.flowParseObjectPropertyKey(), e.static = s, e.proto = i != null, e.kind = n;
              let c2 = false;
              return this.match(47) || this.match(10) ? (e.method = true, i != null && this.unexpected(i), r && this.unexpected(r.loc.start), e.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e.loc.start)), (n === "get" || n === "set") && this.flowCheckGetterSetterParams(e), !o && e.key.name === "constructor" && e.value.this && this.raise(g.ThisParamBannedInConstructor, e.value.this)) : (n !== "init" && this.unexpected(), e.method = false, this.eat(17) && (c2 = true), e.value = this.flowParseTypeInitialiser(), e.variance = r), e.optional = c2, this.finishNode(e, "ObjectTypeProperty");
            }
          }
          flowCheckGetterSetterParams(e) {
            let s = e.kind === "get" ? 0 : 1, i = e.value.params.length + (e.value.rest ? 1 : 0);
            e.value.this && this.raise(e.kind === "get" ? g.GetterMayNotHaveThisParam : g.SetterMayNotHaveThisParam, e.value.this), i !== s && this.raise(e.kind === "get" ? p.BadGetterArity : p.BadSetterArity, e), e.kind === "set" && e.value.rest && this.raise(p.BadSetterRestParameter, e);
          }
          flowObjectTypeSemicolon() {
            !this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9) && this.unexpected();
          }
          flowParseQualifiedTypeIdentifier(e, s) {
            var i;
            (i = e) != null || (e = this.state.startLoc);
            let r = s || this.flowParseRestrictedIdentifier(true);
            for (; this.eat(16); ) {
              let n = this.startNodeAt(e);
              n.qualification = r, n.id = this.flowParseRestrictedIdentifier(true), r = this.finishNode(n, "QualifiedTypeIdentifier");
            }
            return r;
          }
          flowParseGenericType(e, s) {
            let i = this.startNodeAt(e);
            return i.typeParameters = null, i.id = this.flowParseQualifiedTypeIdentifier(e, s), this.match(47) && (i.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(i, "GenericTypeAnnotation");
          }
          flowParseTypeofType() {
            let e = this.startNode();
            return this.expect(87), e.argument = this.flowParsePrimaryType(), this.finishNode(e, "TypeofTypeAnnotation");
          }
          flowParseTupleType() {
            let e = this.startNode();
            for (e.types = [], this.expect(0); this.state.pos < this.length && !this.match(3) && (e.types.push(this.flowParseType()), !this.match(3)); ) this.expect(12);
            return this.expect(3), this.finishNode(e, "TupleTypeAnnotation");
          }
          flowParseFunctionTypeParam(e) {
            let s = null, i = false, r = null, n = this.startNode(), o = this.lookahead(), h = this.state.type === 78;
            return o.type === 14 || o.type === 17 ? (h && !e && this.raise(g.ThisParamMustBeFirst, n), s = this.parseIdentifier(h), this.eat(17) && (i = true, h && this.raise(g.ThisParamMayNotBeOptional, n)), r = this.flowParseTypeInitialiser()) : r = this.flowParseType(), n.name = s, n.optional = i, n.typeAnnotation = r, this.finishNode(n, "FunctionTypeParam");
          }
          reinterpretTypeAsFunctionTypeParam(e) {
            let s = this.startNodeAt(e.loc.start);
            return s.name = null, s.optional = false, s.typeAnnotation = e, this.finishNode(s, "FunctionTypeParam");
          }
          flowParseFunctionTypeParams(e = []) {
            let s = null, i = null;
            for (this.match(78) && (i = this.flowParseFunctionTypeParam(true), i.name = null, this.match(11) || this.expect(12)); !this.match(11) && !this.match(21); ) e.push(this.flowParseFunctionTypeParam(false)), this.match(11) || this.expect(12);
            return this.eat(21) && (s = this.flowParseFunctionTypeParam(false)), { params: e, rest: s, _this: i };
          }
          flowIdentToTypeAnnotation(e, s, i) {
            switch (i.name) {
              case "any":
                return this.finishNode(s, "AnyTypeAnnotation");
              case "bool":
              case "boolean":
                return this.finishNode(s, "BooleanTypeAnnotation");
              case "mixed":
                return this.finishNode(s, "MixedTypeAnnotation");
              case "empty":
                return this.finishNode(s, "EmptyTypeAnnotation");
              case "number":
                return this.finishNode(s, "NumberTypeAnnotation");
              case "string":
                return this.finishNode(s, "StringTypeAnnotation");
              case "symbol":
                return this.finishNode(s, "SymbolTypeAnnotation");
              default:
                return this.checkNotUnderscore(i.name), this.flowParseGenericType(e, i);
            }
          }
          flowParsePrimaryType() {
            let e = this.state.startLoc, s = this.startNode(), i, r, n = false, o = this.state.noAnonFunctionType;
            switch (this.state.type) {
              case 5:
                return this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: true, allowProto: false, allowInexact: true });
              case 6:
                return this.flowParseObjectType({ allowStatic: false, allowExact: true, allowSpread: true, allowProto: false, allowInexact: false });
              case 0:
                return this.state.noAnonFunctionType = false, r = this.flowParseTupleType(), this.state.noAnonFunctionType = o, r;
              case 47: {
                let h = this.startNode();
                return h.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(10), i = this.flowParseFunctionTypeParams(), h.params = i.params, h.rest = i.rest, h.this = i._this, this.expect(11), this.expect(19), h.returnType = this.flowParseType(), this.finishNode(h, "FunctionTypeAnnotation");
              }
              case 10: {
                let h = this.startNode();
                if (this.next(), !this.match(11) && !this.match(21)) if (w(this.state.type) || this.match(78)) {
                  let c2 = this.lookahead().type;
                  n = c2 !== 17 && c2 !== 14;
                } else n = true;
                if (n) {
                  if (this.state.noAnonFunctionType = false, r = this.flowParseType(), this.state.noAnonFunctionType = o, this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) return this.expect(11), r;
                  this.eat(12);
                }
                return r ? i = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(r)]) : i = this.flowParseFunctionTypeParams(), h.params = i.params, h.rest = i.rest, h.this = i._this, this.expect(11), this.expect(19), h.returnType = this.flowParseType(), h.typeParameters = null, this.finishNode(h, "FunctionTypeAnnotation");
              }
              case 133:
                return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
              case 85:
              case 86:
                return s.value = this.match(85), this.next(), this.finishNode(s, "BooleanLiteralTypeAnnotation");
              case 53:
                if (this.state.value === "-") {
                  if (this.next(), this.match(134)) return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", s);
                  if (this.match(135)) return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", s);
                  throw this.raise(g.UnexpectedSubtractionOperand, this.state.startLoc);
                }
                this.unexpected();
                return;
              case 134:
                return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
              case 135:
                return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
              case 88:
                return this.next(), this.finishNode(s, "VoidTypeAnnotation");
              case 84:
                return this.next(), this.finishNode(s, "NullLiteralTypeAnnotation");
              case 78:
                return this.next(), this.finishNode(s, "ThisTypeAnnotation");
              case 55:
                return this.next(), this.finishNode(s, "ExistsTypeAnnotation");
              case 87:
                return this.flowParseTypeofType();
              default:
                if (Pt2(this.state.type)) {
                  let h = K2(this.state.type);
                  return this.next(), super.createIdentifier(s, h);
                } else if (w(this.state.type)) return this.isContextual(129) ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(e, s, this.parseIdentifier());
            }
            this.unexpected();
          }
          flowParsePostfixType() {
            let e = this.state.startLoc, s = this.flowParsePrimaryType(), i = false;
            for (; (this.match(0) || this.match(18)) && !this.canInsertSemicolon(); ) {
              let r = this.startNodeAt(e), n = this.eat(18);
              i = i || n, this.expect(0), !n && this.match(3) ? (r.elementType = s, this.next(), s = this.finishNode(r, "ArrayTypeAnnotation")) : (r.objectType = s, r.indexType = this.flowParseType(), this.expect(3), i ? (r.optional = n, s = this.finishNode(r, "OptionalIndexedAccessType")) : s = this.finishNode(r, "IndexedAccessType"));
            }
            return s;
          }
          flowParsePrefixType() {
            let e = this.startNode();
            return this.eat(17) ? (e.typeAnnotation = this.flowParsePrefixType(), this.finishNode(e, "NullableTypeAnnotation")) : this.flowParsePostfixType();
          }
          flowParseAnonFunctionWithoutParens() {
            let e = this.flowParsePrefixType();
            if (!this.state.noAnonFunctionType && this.eat(19)) {
              let s = this.startNodeAt(e.loc.start);
              return s.params = [this.reinterpretTypeAsFunctionTypeParam(e)], s.rest = null, s.this = null, s.returnType = this.flowParseType(), s.typeParameters = null, this.finishNode(s, "FunctionTypeAnnotation");
            }
            return e;
          }
          flowParseIntersectionType() {
            let e = this.startNode();
            this.eat(45);
            let s = this.flowParseAnonFunctionWithoutParens();
            for (e.types = [s]; this.eat(45); ) e.types.push(this.flowParseAnonFunctionWithoutParens());
            return e.types.length === 1 ? s : this.finishNode(e, "IntersectionTypeAnnotation");
          }
          flowParseUnionType() {
            let e = this.startNode();
            this.eat(43);
            let s = this.flowParseIntersectionType();
            for (e.types = [s]; this.eat(43); ) e.types.push(this.flowParseIntersectionType());
            return e.types.length === 1 ? s : this.finishNode(e, "UnionTypeAnnotation");
          }
          flowParseType() {
            let e = this.state.inType;
            this.state.inType = true;
            let s = this.flowParseUnionType();
            return this.state.inType = e, s;
          }
          flowParseTypeOrImplicitInstantiation() {
            if (this.state.type === 132 && this.state.value === "_") {
              let e = this.state.startLoc, s = this.parseIdentifier();
              return this.flowParseGenericType(e, s);
            } else return this.flowParseType();
          }
          flowParseTypeAnnotation() {
            let e = this.startNode();
            return e.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(e, "TypeAnnotation");
          }
          flowParseTypeAnnotatableIdentifier(e) {
            let s = e ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
            return this.match(14) && (s.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(s)), s;
          }
          typeCastToParameter(e) {
            return e.expression.typeAnnotation = e.typeAnnotation, this.resetEndLocation(e.expression, e.typeAnnotation.loc.end), e.expression;
          }
          flowParseVariance() {
            let e = null;
            return this.match(53) ? (e = this.startNode(), this.state.value === "+" ? e.kind = "plus" : e.kind = "minus", this.next(), this.finishNode(e, "Variance")) : e;
          }
          parseFunctionBody(e, s, i = false) {
            if (s) {
              this.forwardNoArrowParamsConversionAt(e, () => super.parseFunctionBody(e, true, i));
              return;
            }
            super.parseFunctionBody(e, false, i);
          }
          parseFunctionBodyAndFinish(e, s, i = false) {
            if (this.match(14)) {
              let r = this.startNode();
              [r.typeAnnotation, e.predicate] = this.flowParseTypeAndPredicateInitialiser(), e.returnType = r.typeAnnotation ? this.finishNode(r, "TypeAnnotation") : null;
            }
            return super.parseFunctionBodyAndFinish(e, s, i);
          }
          parseStatementLike(e) {
            if (this.state.strict && this.isContextual(129)) {
              let i = this.lookahead();
              if (M2(i.type)) {
                let r = this.startNode();
                return this.next(), this.flowParseInterface(r);
              }
            } else if (this.shouldParseEnums() && this.isContextual(126)) {
              let i = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(i);
            }
            let s = super.parseStatementLike(e);
            return this.flowPragma === void 0 && !this.isValidDirective(s) && (this.flowPragma = null), s;
          }
          parseExpressionStatement(e, s, i) {
            if (s.type === "Identifier") {
              if (s.name === "declare") {
                if (this.match(80) || w(this.state.type) || this.match(68) || this.match(74) || this.match(82)) return this.flowParseDeclare(e);
              } else if (w(this.state.type)) {
                if (s.name === "interface") return this.flowParseInterface(e);
                if (s.name === "type") return this.flowParseTypeAlias(e);
                if (s.name === "opaque") return this.flowParseOpaqueType(e, false);
              }
            }
            return super.parseExpressionStatement(e, s, i);
          }
          shouldParseExportDeclaration() {
            let { type: e } = this.state;
            return Ft2(e) || this.shouldParseEnums() && e === 126 ? !this.state.containsEsc : super.shouldParseExportDeclaration();
          }
          isExportDefaultSpecifier() {
            let { type: e } = this.state;
            return Ft2(e) || this.shouldParseEnums() && e === 126 ? this.state.containsEsc : super.isExportDefaultSpecifier();
          }
          parseExportDefaultExpression() {
            if (this.shouldParseEnums() && this.isContextual(126)) {
              let e = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(e);
            }
            return super.parseExportDefaultExpression();
          }
          parseConditional(e, s, i) {
            if (!this.match(17)) return e;
            if (this.state.maybeInArrowParameters) {
              let f = this.lookaheadCharCode();
              if (f === 44 || f === 61 || f === 58 || f === 41) return this.setOptionalParametersError(i), e;
            }
            this.expect(17);
            let r = this.state.clone(), n = this.state.noArrowAt, o = this.startNodeAt(s), { consequent: h, failed: c2 } = this.tryParseConditionalConsequent(), [l, u] = this.getArrowLikeExpressions(h);
            if (c2 || u.length > 0) {
              let f = [...n];
              if (u.length > 0) {
                this.state = r, this.state.noArrowAt = f;
                for (let d = 0; d < u.length; d++) f.push(u[d].start);
                ({ consequent: h, failed: c2 } = this.tryParseConditionalConsequent()), [l, u] = this.getArrowLikeExpressions(h);
              }
              c2 && l.length > 1 && this.raise(g.AmbiguousConditionalArrow, r.startLoc), c2 && l.length === 1 && (this.state = r, f.push(l[0].start), this.state.noArrowAt = f, { consequent: h, failed: c2 } = this.tryParseConditionalConsequent());
            }
            return this.getArrowLikeExpressions(h, true), this.state.noArrowAt = n, this.expect(14), o.test = e, o.consequent = h, o.alternate = this.forwardNoArrowParamsConversionAt(o, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(o, "ConditionalExpression");
          }
          tryParseConditionalConsequent() {
            this.state.noArrowParamsConversionAt.push(this.state.start);
            let e = this.parseMaybeAssignAllowIn(), s = !this.match(14);
            return this.state.noArrowParamsConversionAt.pop(), { consequent: e, failed: s };
          }
          getArrowLikeExpressions(e, s) {
            let i = [e], r = [];
            for (; i.length !== 0; ) {
              let n = i.pop();
              n.type === "ArrowFunctionExpression" && n.body.type !== "BlockStatement" ? (n.typeParameters || !n.returnType ? this.finishArrowValidation(n) : r.push(n), i.push(n.body)) : n.type === "ConditionalExpression" && (i.push(n.consequent), i.push(n.alternate));
            }
            return s ? (r.forEach((n) => this.finishArrowValidation(n)), [r, []]) : $i(r, (n) => n.params.every((o) => this.isAssignable(o, true)));
          }
          finishArrowValidation(e) {
            var s;
            this.toAssignableList(e.params, (s = e.extra) == null ? void 0 : s.trailingCommaLoc, false), this.scope.enter(6), super.checkParams(e, false, true), this.scope.exit();
          }
          forwardNoArrowParamsConversionAt(e, s) {
            let i;
            return this.state.noArrowParamsConversionAt.includes(e.start) ? (this.state.noArrowParamsConversionAt.push(this.state.start), i = s(), this.state.noArrowParamsConversionAt.pop()) : i = s(), i;
          }
          parseParenItem(e, s) {
            let i = super.parseParenItem(e, s);
            if (this.eat(17) && (i.optional = true, this.resetEndLocation(e)), this.match(14)) {
              let r = this.startNodeAt(s);
              return r.expression = i, r.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(r, "TypeCastExpression");
            }
            return i;
          }
          assertModuleNodeAllowed(e) {
            e.type === "ImportDeclaration" && (e.importKind === "type" || e.importKind === "typeof") || e.type === "ExportNamedDeclaration" && e.exportKind === "type" || e.type === "ExportAllDeclaration" && e.exportKind === "type" || super.assertModuleNodeAllowed(e);
          }
          parseExportDeclaration(e) {
            if (this.isContextual(130)) {
              e.exportKind = "type";
              let s = this.startNode();
              return this.next(), this.match(5) ? (e.specifiers = this.parseExportSpecifiers(true), super.parseExportFrom(e), null) : this.flowParseTypeAlias(s);
            } else if (this.isContextual(131)) {
              e.exportKind = "type";
              let s = this.startNode();
              return this.next(), this.flowParseOpaqueType(s, false);
            } else if (this.isContextual(129)) {
              e.exportKind = "type";
              let s = this.startNode();
              return this.next(), this.flowParseInterface(s);
            } else if (this.shouldParseEnums() && this.isContextual(126)) {
              e.exportKind = "value";
              let s = this.startNode();
              return this.next(), this.flowParseEnumDeclaration(s);
            } else return super.parseExportDeclaration(e);
          }
          eatExportStar(e) {
            return super.eatExportStar(e) ? true : this.isContextual(130) && this.lookahead().type === 55 ? (e.exportKind = "type", this.next(), this.next(), true) : false;
          }
          maybeParseExportNamespaceSpecifier(e) {
            let { startLoc: s } = this.state, i = super.maybeParseExportNamespaceSpecifier(e);
            return i && e.exportKind === "type" && this.unexpected(s), i;
          }
          parseClassId(e, s, i) {
            super.parseClassId(e, s, i), this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration());
          }
          parseClassMember(e, s, i) {
            let { startLoc: r } = this.state;
            if (this.isContextual(125)) {
              if (super.parseClassMemberFromModifier(e, s)) return;
              s.declare = true;
            }
            super.parseClassMember(e, s, i), s.declare && (s.type !== "ClassProperty" && s.type !== "ClassPrivateProperty" && s.type !== "PropertyDefinition" ? this.raise(g.DeclareClassElement, r) : s.value && this.raise(g.DeclareClassFieldInitializer, s.value));
          }
          isIterator(e) {
            return e === "iterator" || e === "asyncIterator";
          }
          readIterator() {
            let e = super.readWord1(), s = "@@" + e;
            (!this.isIterator(e) || !this.state.inType) && this.raise(p.InvalidIdentifier, this.state.curPosition(), { identifierName: s }), this.finishToken(132, s);
          }
          getTokenFromCode(e) {
            let s = this.input.charCodeAt(this.state.pos + 1);
            e === 123 && s === 124 ? this.finishOp(6, 2) : this.state.inType && (e === 62 || e === 60) ? this.finishOp(e === 62 ? 48 : 47, 1) : this.state.inType && e === 63 ? s === 46 ? this.finishOp(18, 2) : this.finishOp(17, 1) : wi(e, s, this.input.charCodeAt(this.state.pos + 2)) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(e);
          }
          isAssignable(e, s) {
            return e.type === "TypeCastExpression" ? this.isAssignable(e.expression, s) : super.isAssignable(e, s);
          }
          toAssignable(e, s = false) {
            !s && e.type === "AssignmentExpression" && e.left.type === "TypeCastExpression" && (e.left = this.typeCastToParameter(e.left)), super.toAssignable(e, s);
          }
          toAssignableList(e, s, i) {
            for (let r = 0; r < e.length; r++) {
              let n = e[r];
              (n == null ? void 0 : n.type) === "TypeCastExpression" && (e[r] = this.typeCastToParameter(n));
            }
            super.toAssignableList(e, s, i);
          }
          toReferencedList(e, s) {
            for (let r = 0; r < e.length; r++) {
              var i;
              let n = e[r];
              n && n.type === "TypeCastExpression" && !((i = n.extra) != null && i.parenthesized) && (e.length > 1 || !s) && this.raise(g.TypeCastInPattern, n.typeAnnotation);
            }
            return e;
          }
          parseArrayLike(e, s, i, r) {
            let n = super.parseArrayLike(e, s, i, r);
            return s && !this.state.maybeInArrowParameters && this.toReferencedList(n.elements), n;
          }
          isValidLVal(e, s, i) {
            return e === "TypeCastExpression" || super.isValidLVal(e, s, i);
          }
          parseClassProperty(e) {
            return this.match(14) && (e.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(e);
          }
          parseClassPrivateProperty(e) {
            return this.match(14) && (e.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(e);
          }
          isClassMethod() {
            return this.match(47) || super.isClassMethod();
          }
          isClassProperty() {
            return this.match(14) || super.isClassProperty();
          }
          isNonstaticConstructor(e) {
            return !this.match(14) && super.isNonstaticConstructor(e);
          }
          pushClassMethod(e, s, i, r, n, o) {
            if (s.variance && this.unexpected(s.variance.loc.start), delete s.variance, this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(e, s, i, r, n, o), s.params && n) {
              let h = s.params;
              h.length > 0 && this.isThisParam(h[0]) && this.raise(g.ThisParamBannedInConstructor, s);
            } else if (s.type === "MethodDefinition" && n && s.value.params) {
              let h = s.value.params;
              h.length > 0 && this.isThisParam(h[0]) && this.raise(g.ThisParamBannedInConstructor, s);
            }
          }
          pushClassPrivateMethod(e, s, i, r) {
            s.variance && this.unexpected(s.variance.loc.start), delete s.variance, this.match(47) && (s.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(e, s, i, r);
          }
          parseClassSuper(e) {
            if (super.parseClassSuper(e), e.superClass && this.match(47) && (e.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual(113)) {
              this.next();
              let s = e.implements = [];
              do {
                let i = this.startNode();
                i.id = this.flowParseRestrictedIdentifier(true), this.match(47) ? i.typeParameters = this.flowParseTypeParameterInstantiation() : i.typeParameters = null, s.push(this.finishNode(i, "ClassImplements"));
              } while (this.eat(12));
            }
          }
          checkGetterSetterParams(e) {
            super.checkGetterSetterParams(e);
            let s = this.getObjectOrClassMethodParams(e);
            if (s.length > 0) {
              let i = s[0];
              this.isThisParam(i) && e.kind === "get" ? this.raise(g.GetterMayNotHaveThisParam, i) : this.isThisParam(i) && this.raise(g.SetterMayNotHaveThisParam, i);
            }
          }
          parsePropertyNamePrefixOperator(e) {
            e.variance = this.flowParseVariance();
          }
          parseObjPropValue(e, s, i, r, n, o, h) {
            e.variance && this.unexpected(e.variance.loc.start), delete e.variance;
            let c2;
            this.match(47) && !o && (c2 = this.flowParseTypeParameterDeclaration(), this.match(10) || this.unexpected());
            let l = super.parseObjPropValue(e, s, i, r, n, o, h);
            return c2 && ((l.value || l).typeParameters = c2), l;
          }
          parseAssignableListItemTypes(e) {
            return this.eat(17) && (e.type !== "Identifier" && this.raise(g.PatternIsOptional, e), this.isThisParam(e) && this.raise(g.ThisParamMayNotBeOptional, e), e.optional = true), this.match(14) ? e.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(e) && this.raise(g.ThisParamAnnotationRequired, e), this.match(29) && this.isThisParam(e) && this.raise(g.ThisParamNoDefault, e), this.resetEndLocation(e), e;
          }
          parseMaybeDefault(e, s) {
            let i = super.parseMaybeDefault(e, s);
            return i.type === "AssignmentPattern" && i.typeAnnotation && i.right.start < i.typeAnnotation.start && this.raise(g.TypeBeforeInitializer, i.typeAnnotation), i;
          }
          checkImportReflection(e) {
            super.checkImportReflection(e), e.module && e.importKind !== "value" && this.raise(g.ImportReflectionHasImportType, e.specifiers[0].loc.start);
          }
          parseImportSpecifierLocal(e, s, i) {
            s.local = _t2(e) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier(), e.specifiers.push(this.finishImportSpecifier(s, i));
          }
          isPotentialImportPhase(e) {
            if (super.isPotentialImportPhase(e)) return true;
            if (this.isContextual(130)) {
              if (!e) return true;
              let s = this.lookaheadCharCode();
              return s === 123 || s === 42;
            }
            return !e && this.isContextual(87);
          }
          applyImportPhase(e, s, i, r) {
            if (super.applyImportPhase(e, s, i, r), s) {
              if (!i && this.match(65)) return;
              e.exportKind = i === "type" ? i : "value";
            } else i === "type" && this.match(55) && this.unexpected(), e.importKind = i === "type" || i === "typeof" ? i : "value";
          }
          parseImportSpecifier(e, s, i, r, n) {
            let o = e.imported, h = null;
            o.type === "Identifier" && (o.name === "type" ? h = "type" : o.name === "typeof" && (h = "typeof"));
            let c2 = false;
            if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
              let u = this.parseIdentifier(true);
              h !== null && !M2(this.state.type) ? (e.imported = u, e.importKind = h, e.local = $(u)) : (e.imported = o, e.importKind = null, e.local = this.parseIdentifier());
            } else {
              if (h !== null && M2(this.state.type)) e.imported = this.parseIdentifier(true), e.importKind = h;
              else {
                if (s) throw this.raise(p.ImportBindingIsString, e, { importName: o.value });
                e.imported = o, e.importKind = null;
              }
              this.eatContextual(93) ? e.local = this.parseIdentifier() : (c2 = true, e.local = $(e.imported));
            }
            let l = _t2(e);
            return i && l && this.raise(g.ImportTypeShorthandOnlyInPureImport, e), (i || l) && this.checkReservedType(e.local.name, e.local.loc.start, true), c2 && !i && !l && this.checkReservedWord(e.local.name, e.loc.start, true, true), this.finishImportSpecifier(e, "ImportSpecifier");
          }
          parseBindingAtom() {
            switch (this.state.type) {
              case 78:
                return this.parseIdentifier(true);
              default:
                return super.parseBindingAtom();
            }
          }
          parseFunctionParams(e, s) {
            let i = e.kind;
            i !== "get" && i !== "set" && this.match(47) && (e.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(e, s);
          }
          parseVarId(e, s) {
            super.parseVarId(e, s), this.match(14) && (e.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(e.id));
          }
          parseAsyncArrowFromCallExpression(e, s) {
            if (this.match(14)) {
              let i = this.state.noAnonFunctionType;
              this.state.noAnonFunctionType = true, e.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = i;
            }
            return super.parseAsyncArrowFromCallExpression(e, s);
          }
          shouldParseAsyncArrow() {
            return this.match(14) || super.shouldParseAsyncArrow();
          }
          parseMaybeAssign(e, s) {
            var i;
            let r = null, n;
            if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
              if (r = this.state.clone(), n = this.tryParse(() => super.parseMaybeAssign(e, s), r), !n.error) return n.node;
              let { context: c2 } = this.state, l = c2[c2.length - 1];
              (l === C.j_oTag || l === C.j_expr) && c2.pop();
            }
            if ((i = n) != null && i.error || this.match(47)) {
              var o, h;
              r = r || this.state.clone();
              let c2, l = this.tryParse((f) => {
                var d;
                c2 = this.flowParseTypeParameterDeclaration();
                let y2 = this.forwardNoArrowParamsConversionAt(c2, () => {
                  let L2 = super.parseMaybeAssign(e, s);
                  return this.resetStartLocationFromNode(L2, c2), L2;
                });
                (d = y2.extra) != null && d.parenthesized && f();
                let E = this.maybeUnwrapTypeCastExpression(y2);
                return E.type !== "ArrowFunctionExpression" && f(), E.typeParameters = c2, this.resetStartLocationFromNode(E, c2), y2;
              }, r), u = null;
              if (l.node && this.maybeUnwrapTypeCastExpression(l.node).type === "ArrowFunctionExpression") {
                if (!l.error && !l.aborted) return l.node.async && this.raise(g.UnexpectedTypeParameterBeforeAsyncArrowFunction, c2), l.node;
                u = l.node;
              }
              if ((o = n) != null && o.node) return this.state = n.failState, n.node;
              if (u) return this.state = l.failState, u;
              throw (h = n) != null && h.thrown ? n.error : l.thrown ? l.error : this.raise(g.UnexpectedTokenAfterTypeParameter, c2);
            }
            return super.parseMaybeAssign(e, s);
          }
          parseArrow(e) {
            if (this.match(14)) {
              let s = this.tryParse(() => {
                let i = this.state.noAnonFunctionType;
                this.state.noAnonFunctionType = true;
                let r = this.startNode();
                return [r.typeAnnotation, e.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = i, this.canInsertSemicolon() && this.unexpected(), this.match(19) || this.unexpected(), r;
              });
              if (s.thrown) return null;
              s.error && (this.state = s.failState), e.returnType = s.node.typeAnnotation ? this.finishNode(s.node, "TypeAnnotation") : null;
            }
            return super.parseArrow(e);
          }
          shouldParseArrow(e) {
            return this.match(14) || super.shouldParseArrow(e);
          }
          setArrowFunctionParameters(e, s) {
            this.state.noArrowParamsConversionAt.includes(e.start) ? e.params = s : super.setArrowFunctionParameters(e, s);
          }
          checkParams(e, s, i, r = true) {
            if (!(i && this.state.noArrowParamsConversionAt.includes(e.start))) {
              for (let n = 0; n < e.params.length; n++) this.isThisParam(e.params[n]) && n > 0 && this.raise(g.ThisParamMustBeFirst, e.params[n]);
              super.checkParams(e, s, i, r);
            }
          }
          parseParenAndDistinguishExpression(e) {
            return super.parseParenAndDistinguishExpression(e && !this.state.noArrowAt.includes(this.state.start));
          }
          parseSubscripts(e, s, i) {
            if (e.type === "Identifier" && e.name === "async" && this.state.noArrowAt.includes(s.index)) {
              this.next();
              let r = this.startNodeAt(s);
              r.callee = e, r.arguments = super.parseCallExpressionArguments(11, false), e = this.finishNode(r, "CallExpression");
            } else if (e.type === "Identifier" && e.name === "async" && this.match(47)) {
              let r = this.state.clone(), n = this.tryParse((h) => this.parseAsyncArrowWithTypeParameters(s) || h(), r);
              if (!n.error && !n.aborted) return n.node;
              let o = this.tryParse(() => super.parseSubscripts(e, s, i), r);
              if (o.node && !o.error) return o.node;
              if (n.node) return this.state = n.failState, n.node;
              if (o.node) return this.state = o.failState, o.node;
              throw n.error || o.error;
            }
            return super.parseSubscripts(e, s, i);
          }
          parseSubscript(e, s, i, r) {
            if (this.match(18) && this.isLookaheadToken_lt()) {
              if (r.optionalChainMember = true, i) return r.stop = true, e;
              this.next();
              let n = this.startNodeAt(s);
              return n.callee = e, n.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(10), n.arguments = this.parseCallExpressionArguments(11, false), n.optional = true, this.finishCallExpression(n, true);
            } else if (!i && this.shouldParseTypes() && this.match(47)) {
              let n = this.startNodeAt(s);
              n.callee = e;
              let o = this.tryParse(() => (n.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(10), n.arguments = super.parseCallExpressionArguments(11, false), r.optionalChainMember && (n.optional = false), this.finishCallExpression(n, r.optionalChainMember)));
              if (o.node) return o.error && (this.state = o.failState), o.node;
            }
            return super.parseSubscript(e, s, i, r);
          }
          parseNewCallee(e) {
            super.parseNewCallee(e);
            let s = null;
            this.shouldParseTypes() && this.match(47) && (s = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), e.typeArguments = s;
          }
          parseAsyncArrowWithTypeParameters(e) {
            let s = this.startNodeAt(e);
            if (this.parseFunctionParams(s, false), !!this.parseArrow(s)) return super.parseArrowExpression(s, void 0, true);
          }
          readToken_mult_modulo(e) {
            let s = this.input.charCodeAt(this.state.pos + 1);
            if (e === 42 && s === 47 && this.state.hasFlowComment) {
              this.state.hasFlowComment = false, this.state.pos += 2, this.nextToken();
              return;
            }
            super.readToken_mult_modulo(e);
          }
          readToken_pipe_amp(e) {
            let s = this.input.charCodeAt(this.state.pos + 1);
            if (e === 124 && s === 125) {
              this.finishOp(9, 2);
              return;
            }
            super.readToken_pipe_amp(e);
          }
          parseTopLevel(e, s) {
            let i = super.parseTopLevel(e, s);
            return this.state.hasFlowComment && this.raise(g.UnterminatedFlowComment, this.state.curPosition()), i;
          }
          skipBlockComment() {
            if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
              if (this.state.hasFlowComment) throw this.raise(g.NestedFlowComment, this.state.startLoc);
              this.hasFlowCommentCompletion();
              let e = this.skipFlowComment();
              e && (this.state.pos += e, this.state.hasFlowComment = true);
              return;
            }
            return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
          }
          skipFlowComment() {
            let { pos: e } = this.state, s = 2;
            for (; [32, 9].includes(this.input.charCodeAt(e + s)); ) s++;
            let i = this.input.charCodeAt(s + e), r = this.input.charCodeAt(s + e + 1);
            return i === 58 && r === 58 ? s + 2 : this.input.slice(s + e, s + e + 12) === "flow-include" ? s + 12 : i === 58 && r !== 58 ? s : false;
          }
          hasFlowCommentCompletion() {
            if (this.input.indexOf("*/", this.state.pos) === -1) throw this.raise(p.UnterminatedComment, this.state.curPosition());
          }
          flowEnumErrorBooleanMemberNotInitialized(e, { enumName: s, memberName: i }) {
            this.raise(g.EnumBooleanMemberNotInitialized, e, { memberName: i, enumName: s });
          }
          flowEnumErrorInvalidMemberInitializer(e, s) {
            return this.raise(s.explicitType ? s.explicitType === "symbol" ? g.EnumInvalidMemberInitializerSymbolType : g.EnumInvalidMemberInitializerPrimaryType : g.EnumInvalidMemberInitializerUnknownType, e, s);
          }
          flowEnumErrorNumberMemberNotInitialized(e, s) {
            this.raise(g.EnumNumberMemberNotInitialized, e, s);
          }
          flowEnumErrorStringMemberInconsistentlyInitialized(e, s) {
            this.raise(g.EnumStringMemberInconsistentlyInitialized, e, s);
          }
          flowEnumMemberInit() {
            let e = this.state.startLoc, s = () => this.match(12) || this.match(8);
            switch (this.state.type) {
              case 134: {
                let i = this.parseNumericLiteral(this.state.value);
                return s() ? { type: "number", loc: i.loc.start, value: i } : { type: "invalid", loc: e };
              }
              case 133: {
                let i = this.parseStringLiteral(this.state.value);
                return s() ? { type: "string", loc: i.loc.start, value: i } : { type: "invalid", loc: e };
              }
              case 85:
              case 86: {
                let i = this.parseBooleanLiteral(this.match(85));
                return s() ? { type: "boolean", loc: i.loc.start, value: i } : { type: "invalid", loc: e };
              }
              default:
                return { type: "invalid", loc: e };
            }
          }
          flowEnumMemberRaw() {
            let e = this.state.startLoc, s = this.parseIdentifier(true), i = this.eat(29) ? this.flowEnumMemberInit() : { type: "none", loc: e };
            return { id: s, init: i };
          }
          flowEnumCheckExplicitTypeMismatch(e, s, i) {
            let { explicitType: r } = s;
            r !== null && r !== i && this.flowEnumErrorInvalidMemberInitializer(e, s);
          }
          flowEnumMembers({ enumName: e, explicitType: s }) {
            let i = /* @__PURE__ */ new Set(), r = { booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: [] }, n = false;
            for (; !this.match(8); ) {
              if (this.eat(21)) {
                n = true;
                break;
              }
              let o = this.startNode(), { id: h, init: c2 } = this.flowEnumMemberRaw(), l = h.name;
              if (l === "") continue;
              /^[a-z]/.test(l) && this.raise(g.EnumInvalidMemberName, h, { memberName: l, suggestion: l[0].toUpperCase() + l.slice(1), enumName: e }), i.has(l) && this.raise(g.EnumDuplicateMemberName, h, { memberName: l, enumName: e }), i.add(l);
              let u = { enumName: e, explicitType: s, memberName: l };
              switch (o.id = h, c2.type) {
                case "boolean": {
                  this.flowEnumCheckExplicitTypeMismatch(c2.loc, u, "boolean"), o.init = c2.value, r.booleanMembers.push(this.finishNode(o, "EnumBooleanMember"));
                  break;
                }
                case "number": {
                  this.flowEnumCheckExplicitTypeMismatch(c2.loc, u, "number"), o.init = c2.value, r.numberMembers.push(this.finishNode(o, "EnumNumberMember"));
                  break;
                }
                case "string": {
                  this.flowEnumCheckExplicitTypeMismatch(c2.loc, u, "string"), o.init = c2.value, r.stringMembers.push(this.finishNode(o, "EnumStringMember"));
                  break;
                }
                case "invalid":
                  throw this.flowEnumErrorInvalidMemberInitializer(c2.loc, u);
                case "none":
                  switch (s) {
                    case "boolean":
                      this.flowEnumErrorBooleanMemberNotInitialized(c2.loc, u);
                      break;
                    case "number":
                      this.flowEnumErrorNumberMemberNotInitialized(c2.loc, u);
                      break;
                    default:
                      r.defaultedMembers.push(this.finishNode(o, "EnumDefaultedMember"));
                  }
              }
              this.match(8) || this.expect(12);
            }
            return { members: r, hasUnknownMembers: n };
          }
          flowEnumStringMembers(e, s, { enumName: i }) {
            if (e.length === 0) return s;
            if (s.length === 0) return e;
            if (s.length > e.length) {
              for (let r of e) this.flowEnumErrorStringMemberInconsistentlyInitialized(r, { enumName: i });
              return s;
            } else {
              for (let r of s) this.flowEnumErrorStringMemberInconsistentlyInitialized(r, { enumName: i });
              return e;
            }
          }
          flowEnumParseExplicitType({ enumName: e }) {
            if (!this.eatContextual(102)) return null;
            if (!w(this.state.type)) throw this.raise(g.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, { enumName: e });
            let { value: s } = this.state;
            return this.next(), s !== "boolean" && s !== "number" && s !== "string" && s !== "symbol" && this.raise(g.EnumInvalidExplicitType, this.state.startLoc, { enumName: e, invalidEnumType: s }), s;
          }
          flowEnumBody(e, s) {
            let i = s.name, r = s.loc.start, n = this.flowEnumParseExplicitType({ enumName: i });
            this.expect(5);
            let { members: o, hasUnknownMembers: h } = this.flowEnumMembers({ enumName: i, explicitType: n });
            switch (e.hasUnknownMembers = h, n) {
              case "boolean":
                return e.explicitType = true, e.members = o.booleanMembers, this.expect(8), this.finishNode(e, "EnumBooleanBody");
              case "number":
                return e.explicitType = true, e.members = o.numberMembers, this.expect(8), this.finishNode(e, "EnumNumberBody");
              case "string":
                return e.explicitType = true, e.members = this.flowEnumStringMembers(o.stringMembers, o.defaultedMembers, { enumName: i }), this.expect(8), this.finishNode(e, "EnumStringBody");
              case "symbol":
                return e.members = o.defaultedMembers, this.expect(8), this.finishNode(e, "EnumSymbolBody");
              default: {
                let c2 = () => (e.members = [], this.expect(8), this.finishNode(e, "EnumStringBody"));
                e.explicitType = false;
                let l = o.booleanMembers.length, u = o.numberMembers.length, f = o.stringMembers.length, d = o.defaultedMembers.length;
                if (!l && !u && !f && !d) return c2();
                if (!l && !u) return e.members = this.flowEnumStringMembers(o.stringMembers, o.defaultedMembers, { enumName: i }), this.expect(8), this.finishNode(e, "EnumStringBody");
                if (!u && !f && l >= d) {
                  for (let y2 of o.defaultedMembers) this.flowEnumErrorBooleanMemberNotInitialized(y2.loc.start, { enumName: i, memberName: y2.id.name });
                  return e.members = o.booleanMembers, this.expect(8), this.finishNode(e, "EnumBooleanBody");
                } else if (!l && !f && u >= d) {
                  for (let y2 of o.defaultedMembers) this.flowEnumErrorNumberMemberNotInitialized(y2.loc.start, { enumName: i, memberName: y2.id.name });
                  return e.members = o.numberMembers, this.expect(8), this.finishNode(e, "EnumNumberBody");
                } else return this.raise(g.EnumInconsistentMemberValues, r, { enumName: i }), c2();
              }
            }
          }
          flowParseEnumDeclaration(e) {
            let s = this.parseIdentifier();
            return e.id = s, e.body = this.flowEnumBody(this.startNode(), s), this.finishNode(e, "EnumDeclaration");
          }
          isLookaheadToken_lt() {
            let e = this.nextTokenStart();
            if (this.input.charCodeAt(e) === 60) {
              let s = this.input.charCodeAt(e + 1);
              return s !== 60 && s !== 61;
            }
            return false;
          }
          maybeUnwrapTypeCastExpression(e) {
            return e.type === "TypeCastExpression" ? e.expression : e;
          }
        }, W2 = j2`jsx`({ AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.", MissingClosingTagElement: ({ openingTagName: a }) => `Expected corresponding JSX closing tag for <${a}>.`, MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.", UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?", UnexpectedToken: ({ unexpected: a, HTMLEntity: t }) => `Unexpected token \`${a}\`. Did you mean \`${t}\` or \`{'${a}'}\`?`, UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.", UnterminatedJsxContent: "Unterminated JSX contents.", UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?" });
        function z2(a) {
          return a ? a.type === "JSXOpeningFragment" || a.type === "JSXClosingFragment" : false;
        }
        function Y2(a) {
          if (a.type === "JSXIdentifier") return a.name;
          if (a.type === "JSXNamespacedName") return a.namespace.name + ":" + a.name.name;
          if (a.type === "JSXMemberExpression") return Y2(a.object) + "." + Y2(a.property);
          throw new Error("Node had unexpected type: " + a.type);
        }
        var zi = (a) => class extends a {
          jsxReadToken() {
            let e = "", s = this.state.pos;
            for (; ; ) {
              if (this.state.pos >= this.length) throw this.raise(W2.UnterminatedJsxContent, this.state.startLoc);
              let i = this.input.charCodeAt(this.state.pos);
              switch (i) {
                case 60:
                case 123:
                  if (this.state.pos === this.state.start) {
                    i === 60 && this.state.canStartJSXElement ? (++this.state.pos, this.finishToken(142)) : super.getTokenFromCode(i);
                    return;
                  }
                  e += this.input.slice(s, this.state.pos), this.finishToken(141, e);
                  return;
                case 38:
                  e += this.input.slice(s, this.state.pos), e += this.jsxReadEntity(), s = this.state.pos;
                  break;
                case 62:
                case 125:
                default:
                  fe2(i) ? (e += this.input.slice(s, this.state.pos), e += this.jsxReadNewLine(true), s = this.state.pos) : ++this.state.pos;
              }
            }
          }
          jsxReadNewLine(e) {
            let s = this.input.charCodeAt(this.state.pos), i;
            return ++this.state.pos, s === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, i = e ? `
` : `\r
`) : i = String.fromCharCode(s), ++this.state.curLine, this.state.lineStart = this.state.pos, i;
          }
          jsxReadString(e) {
            let s = "", i = ++this.state.pos;
            for (; ; ) {
              if (this.state.pos >= this.length) throw this.raise(p.UnterminatedString, this.state.startLoc);
              let r = this.input.charCodeAt(this.state.pos);
              if (r === e) break;
              r === 38 ? (s += this.input.slice(i, this.state.pos), s += this.jsxReadEntity(), i = this.state.pos) : fe2(r) ? (s += this.input.slice(i, this.state.pos), s += this.jsxReadNewLine(false), i = this.state.pos) : ++this.state.pos;
            }
            s += this.input.slice(i, this.state.pos++), this.finishToken(133, s);
          }
          jsxReadEntity() {
            let e = ++this.state.pos;
            if (this.codePointAtPos(this.state.pos) === 35) {
              ++this.state.pos;
              let s = 10;
              this.codePointAtPos(this.state.pos) === 120 && (s = 16, ++this.state.pos);
              let i = this.readInt(s, void 0, false, "bail");
              if (i !== null && this.codePointAtPos(this.state.pos) === 59) return ++this.state.pos, String.fromCodePoint(i);
            } else {
              let s = 0, i = false;
              for (; s++ < 10 && this.state.pos < this.length && !(i = this.codePointAtPos(this.state.pos) === 59); ) ++this.state.pos;
              if (i) {
                let r = this.input.slice(e, this.state.pos), n = void 0;
                if (++this.state.pos, n) return n;
              }
            }
            return this.state.pos = e, "&";
          }
          jsxReadWord() {
            let e, s = this.state.pos;
            do
              e = this.input.charCodeAt(++this.state.pos);
            while (Q2(e) || e === 45);
            this.finishToken(140, this.input.slice(s, this.state.pos));
          }
          jsxParseIdentifier() {
            let e = this.startNode();
            return this.match(140) ? e.name = this.state.value : Pt2(this.state.type) ? e.name = K2(this.state.type) : this.unexpected(), this.next(), this.finishNode(e, "JSXIdentifier");
          }
          jsxParseNamespacedName() {
            let e = this.state.startLoc, s = this.jsxParseIdentifier();
            if (!this.eat(14)) return s;
            let i = this.startNodeAt(e);
            return i.namespace = s, i.name = this.jsxParseIdentifier(), this.finishNode(i, "JSXNamespacedName");
          }
          jsxParseElementName() {
            let e = this.state.startLoc, s = this.jsxParseNamespacedName();
            if (s.type === "JSXNamespacedName") return s;
            for (; this.eat(16); ) {
              let i = this.startNodeAt(e);
              i.object = s, i.property = this.jsxParseIdentifier(), s = this.finishNode(i, "JSXMemberExpression");
            }
            return s;
          }
          jsxParseAttributeValue() {
            let e;
            switch (this.state.type) {
              case 5:
                return e = this.startNode(), this.setContext(C.brace), this.next(), e = this.jsxParseExpressionContainer(e, C.j_oTag), e.expression.type === "JSXEmptyExpression" && this.raise(W2.AttributeIsEmpty, e), e;
              case 142:
              case 133:
                return this.parseExprAtom();
              default:
                throw this.raise(W2.UnsupportedJsxValue, this.state.startLoc);
            }
          }
          jsxParseEmptyExpression() {
            let e = this.startNodeAt(this.state.lastTokEndLoc);
            return this.finishNodeAt(e, "JSXEmptyExpression", this.state.startLoc);
          }
          jsxParseSpreadChild(e) {
            return this.next(), e.expression = this.parseExpression(), this.setContext(C.j_expr), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e, "JSXSpreadChild");
          }
          jsxParseExpressionContainer(e, s) {
            if (this.match(8)) e.expression = this.jsxParseEmptyExpression();
            else {
              let i = this.parseExpression();
              e.expression = i;
            }
            return this.setContext(s), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e, "JSXExpressionContainer");
          }
          jsxParseAttribute() {
            let e = this.startNode();
            return this.match(5) ? (this.setContext(C.brace), this.next(), this.expect(21), e.argument = this.parseMaybeAssignAllowIn(), this.setContext(C.j_oTag), this.state.canStartJSXElement = true, this.expect(8), this.finishNode(e, "JSXSpreadAttribute")) : (e.name = this.jsxParseNamespacedName(), e.value = this.eat(29) ? this.jsxParseAttributeValue() : null, this.finishNode(e, "JSXAttribute"));
          }
          jsxParseOpeningElementAt(e) {
            let s = this.startNodeAt(e);
            return this.eat(143) ? this.finishNode(s, "JSXOpeningFragment") : (s.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(s));
          }
          jsxParseOpeningElementAfterName(e) {
            let s = [];
            for (; !this.match(56) && !this.match(143); ) s.push(this.jsxParseAttribute());
            return e.attributes = s, e.selfClosing = this.eat(56), this.expect(143), this.finishNode(e, "JSXOpeningElement");
          }
          jsxParseClosingElementAt(e) {
            let s = this.startNodeAt(e);
            return this.eat(143) ? this.finishNode(s, "JSXClosingFragment") : (s.name = this.jsxParseElementName(), this.expect(143), this.finishNode(s, "JSXClosingElement"));
          }
          jsxParseElementAt(e) {
            let s = this.startNodeAt(e), i = [], r = this.jsxParseOpeningElementAt(e), n = null;
            if (!r.selfClosing) {
              e: for (; ; ) switch (this.state.type) {
                case 142:
                  if (e = this.state.startLoc, this.next(), this.eat(56)) {
                    n = this.jsxParseClosingElementAt(e);
                    break e;
                  }
                  i.push(this.jsxParseElementAt(e));
                  break;
                case 141:
                  i.push(this.parseLiteral(this.state.value, "JSXText"));
                  break;
                case 5: {
                  let o = this.startNode();
                  this.setContext(C.brace), this.next(), this.match(21) ? i.push(this.jsxParseSpreadChild(o)) : i.push(this.jsxParseExpressionContainer(o, C.j_expr));
                  break;
                }
                default:
                  this.unexpected();
              }
              z2(r) && !z2(n) && n !== null ? this.raise(W2.MissingClosingTagFragment, n) : !z2(r) && z2(n) ? this.raise(W2.MissingClosingTagElement, n, { openingTagName: Y2(r.name) }) : !z2(r) && !z2(n) && Y2(n.name) !== Y2(r.name) && this.raise(W2.MissingClosingTagElement, n, { openingTagName: Y2(r.name) });
            }
            if (z2(r) ? (s.openingFragment = r, s.closingFragment = n) : (s.openingElement = r, s.closingElement = n), s.children = i, this.match(47)) throw this.raise(W2.UnwrappedAdjacentJSXElements, this.state.startLoc);
            return z2(r) ? this.finishNode(s, "JSXFragment") : this.finishNode(s, "JSXElement");
          }
          jsxParseElement() {
            let e = this.state.startLoc;
            return this.next(), this.jsxParseElementAt(e);
          }
          setContext(e) {
            let { context: s } = this.state;
            s[s.length - 1] = e;
          }
          parseExprAtom(e) {
            return this.match(142) ? this.jsxParseElement() : this.match(47) && this.input.charCodeAt(this.state.pos) !== 33 ? (this.replaceToken(142), this.jsxParseElement()) : super.parseExprAtom(e);
          }
          skipSpace() {
            this.curContext().preserveSpace || super.skipSpace();
          }
          getTokenFromCode(e) {
            let s = this.curContext();
            if (s === C.j_expr) {
              this.jsxReadToken();
              return;
            }
            if (s === C.j_oTag || s === C.j_cTag) {
              if (_2(e)) {
                this.jsxReadWord();
                return;
              }
              if (e === 62) {
                ++this.state.pos, this.finishToken(143);
                return;
              }
              if ((e === 34 || e === 39) && s === C.j_oTag) {
                this.jsxReadString(e);
                return;
              }
            }
            if (e === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
              ++this.state.pos, this.finishToken(142);
              return;
            }
            super.getTokenFromCode(e);
          }
          updateContext(e) {
            let { context: s, type: i } = this.state;
            if (i === 56 && e === 142) s.splice(-2, 2, C.j_cTag), this.state.canStartJSXElement = false;
            else if (i === 142) s.push(C.j_oTag);
            else if (i === 143) {
              let r = s[s.length - 1];
              r === C.j_oTag && e === 56 || r === C.j_cTag ? (s.pop(), this.state.canStartJSXElement = s[s.length - 1] === C.j_expr) : (this.setContext(C.j_expr), this.state.canStartJSXElement = true);
            } else this.state.canStartJSXElement = hi2(i);
          }
        }, ot2 = class extends de2 {
          constructor(...t) {
            super(...t), this.tsNames = /* @__PURE__ */ new Map();
          }
        }, ht2 = class extends me2 {
          constructor(...t) {
            super(...t), this.importsStack = [];
          }
          createScope(t) {
            return this.importsStack.push(/* @__PURE__ */ new Set()), new ot2(t);
          }
          enter(t) {
            t === 256 && this.importsStack.push(/* @__PURE__ */ new Set()), super.enter(t);
          }
          exit() {
            let t = super.exit();
            return t === 256 && this.importsStack.pop(), t;
          }
          hasImport(t, e) {
            let s = this.importsStack.length;
            if (this.importsStack[s - 1].has(t)) return true;
            if (!e && s > 1) {
              for (let i = 0; i < s - 1; i++) if (this.importsStack[i].has(t)) return true;
            }
            return false;
          }
          declareName(t, e, s) {
            if (e & 4096) {
              this.hasImport(t, true) && this.parser.raise(p.VarRedeclaration, s, { identifierName: t }), this.importsStack[this.importsStack.length - 1].add(t);
              return;
            }
            let i = this.currentScope(), r = i.tsNames.get(t) || 0;
            if (e & 1024) {
              this.maybeExportDefined(i, t), i.tsNames.set(t, r | 16);
              return;
            }
            super.declareName(t, e, s), e & 2 && (e & 1 || (this.checkRedeclarationInScope(i, t, e, s), this.maybeExportDefined(i, t)), r = r | 1), e & 256 && (r = r | 2), e & 512 && (r = r | 4), e & 128 && (r = r | 8), r && i.tsNames.set(t, r);
          }
          isRedeclaredInScope(t, e, s) {
            let i = t.tsNames.get(e);
            if ((i & 2) > 0) {
              if (s & 256) {
                let r = !!(s & 512), n = (i & 4) > 0;
                return r !== n;
              }
              return true;
            }
            return s & 128 && (i & 8) > 0 ? t.names.get(e) & 2 ? !!(s & 1) : false : s & 2 && (i & 1) > 0 ? true : super.isRedeclaredInScope(t, e, s);
          }
          checkLocalExport(t) {
            let { name: e } = t;
            if (this.hasImport(e)) return;
            let s = this.scopeStack.length;
            for (let i = s - 1; i >= 0; i--) {
              let n = this.scopeStack[i].tsNames.get(e);
              if ((n & 1) > 0 || (n & 16) > 0) return;
            }
            super.checkLocalExport(t);
          }
        }, Ki = (a, t) => hasOwnProperty.call(a, t) && a[t], as = (a) => a.type === "ParenthesizedExpression" ? as(a.expression) : a, lt2 = class extends nt2 {
          toAssignable(t, e = false) {
            var s, i;
            let r;
            switch ((t.type === "ParenthesizedExpression" || (s = t.extra) != null && s.parenthesized) && (r = as(t), e ? r.type === "Identifier" ? this.expressionScope.recordArrowParameterBindingError(p.InvalidParenthesizedAssignment, t) : r.type !== "MemberExpression" && !this.isOptionalMemberExpression(r) && this.raise(p.InvalidParenthesizedAssignment, t) : this.raise(p.InvalidParenthesizedAssignment, t)), t.type) {
              case "Identifier":
              case "ObjectPattern":
              case "ArrayPattern":
              case "AssignmentPattern":
              case "RestElement":
                break;
              case "ObjectExpression":
                t.type = "ObjectPattern";
                for (let o = 0, h = t.properties.length, c2 = h - 1; o < h; o++) {
                  var n;
                  let l = t.properties[o], u = o === c2;
                  this.toAssignableObjectExpressionProp(l, u, e), u && l.type === "RestElement" && (n = t.extra) != null && n.trailingCommaLoc && this.raise(p.RestTrailingComma, t.extra.trailingCommaLoc);
                }
                break;
              case "ObjectProperty": {
                let { key: o, value: h } = t;
                this.isPrivateName(o) && this.classScope.usePrivateName(this.getPrivateNameSV(o), o.loc.start), this.toAssignable(h, e);
                break;
              }
              case "SpreadElement":
                throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
              case "ArrayExpression":
                t.type = "ArrayPattern", this.toAssignableList(t.elements, (i = t.extra) == null ? void 0 : i.trailingCommaLoc, e);
                break;
              case "AssignmentExpression":
                t.operator !== "=" && this.raise(p.MissingEqInAssignment, t.left.loc.end), t.type = "AssignmentPattern", delete t.operator, this.toAssignable(t.left, e);
                break;
              case "ParenthesizedExpression":
                this.toAssignable(r, e);
                break;
            }
          }
          toAssignableObjectExpressionProp(t, e, s) {
            if (t.type === "ObjectMethod") this.raise(t.kind === "get" || t.kind === "set" ? p.PatternHasAccessor : p.PatternHasMethod, t.key);
            else if (t.type === "SpreadElement") {
              t.type = "RestElement";
              let i = t.argument;
              this.checkToRestConversion(i, false), this.toAssignable(i, s), e || this.raise(p.RestTrailingComma, t);
            } else this.toAssignable(t, s);
          }
          toAssignableList(t, e, s) {
            let i = t.length - 1;
            for (let r = 0; r <= i; r++) {
              let n = t[r];
              if (n) {
                if (n.type === "SpreadElement") {
                  n.type = "RestElement";
                  let o = n.argument;
                  this.checkToRestConversion(o, true), this.toAssignable(o, s);
                } else this.toAssignable(n, s);
                n.type === "RestElement" && (r < i ? this.raise(p.RestTrailingComma, n) : e && this.raise(p.RestTrailingComma, e));
              }
            }
          }
          isAssignable(t, e) {
            switch (t.type) {
              case "Identifier":
              case "ObjectPattern":
              case "ArrayPattern":
              case "AssignmentPattern":
              case "RestElement":
                return true;
              case "ObjectExpression": {
                let s = t.properties.length - 1;
                return t.properties.every((i, r) => i.type !== "ObjectMethod" && (r === s || i.type !== "SpreadElement") && this.isAssignable(i));
              }
              case "ObjectProperty":
                return this.isAssignable(t.value);
              case "SpreadElement":
                return this.isAssignable(t.argument);
              case "ArrayExpression":
                return t.elements.every((s) => s === null || this.isAssignable(s));
              case "AssignmentExpression":
                return t.operator === "=";
              case "ParenthesizedExpression":
                return this.isAssignable(t.expression);
              case "MemberExpression":
              case "OptionalMemberExpression":
                return !e;
              default:
                return false;
            }
          }
          toReferencedList(t, e) {
            return t;
          }
          toReferencedListDeep(t, e) {
            this.toReferencedList(t, e);
            for (let s of t) (s == null ? void 0 : s.type) === "ArrayExpression" && this.toReferencedListDeep(s.elements);
          }
          parseSpread(t) {
            let e = this.startNode();
            return this.next(), e.argument = this.parseMaybeAssignAllowIn(t, void 0), this.finishNode(e, "SpreadElement");
          }
          parseRestBinding() {
            let t = this.startNode();
            return this.next(), t.argument = this.parseBindingAtom(), this.finishNode(t, "RestElement");
          }
          parseBindingAtom() {
            switch (this.state.type) {
              case 0: {
                let t = this.startNode();
                return this.next(), t.elements = this.parseBindingList(3, 93, 1), this.finishNode(t, "ArrayPattern");
              }
              case 5:
                return this.parseObjectLike(8, true);
            }
            return this.parseIdentifier();
          }
          parseBindingList(t, e, s) {
            let i = s & 1, r = [], n = true;
            for (; !this.eat(t); ) if (n ? n = false : this.expect(12), i && this.match(12)) r.push(null);
            else {
              if (this.eat(t)) break;
              if (this.match(21)) {
                if (r.push(this.parseAssignableListItemTypes(this.parseRestBinding(), s)), !this.checkCommaAfterRest(e)) {
                  this.expect(t);
                  break;
                }
              } else {
                let o = [];
                for (this.match(26) && this.hasPlugin("decorators") && this.raise(p.UnsupportedParameterDecorator, this.state.startLoc); this.match(26); ) o.push(this.parseDecorator());
                r.push(this.parseAssignableListItem(s, o));
              }
            }
            return r;
          }
          parseBindingRestProperty(t) {
            return this.next(), t.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(t, "RestElement");
          }
          parseBindingProperty() {
            let { type: t, startLoc: e } = this.state;
            if (t === 21) return this.parseBindingRestProperty(this.startNode());
            let s = this.startNode();
            return t === 138 ? (this.expectPlugin("destructuringPrivate", e), this.classScope.usePrivateName(this.state.value, e), s.key = this.parsePrivateName()) : this.parsePropertyName(s), s.method = false, this.parseObjPropValue(s, e, false, false, true, false);
          }
          parseAssignableListItem(t, e) {
            let s = this.parseMaybeDefault();
            this.parseAssignableListItemTypes(s, t);
            let i = this.parseMaybeDefault(s.loc.start, s);
            return e.length && (s.decorators = e), i;
          }
          parseAssignableListItemTypes(t, e) {
            return t;
          }
          parseMaybeDefault(t, e) {
            var s, i;
            if ((s = t) != null || (t = this.state.startLoc), e = (i = e) != null ? i : this.parseBindingAtom(), !this.eat(29)) return e;
            let r = this.startNodeAt(t);
            return r.left = e, r.right = this.parseMaybeAssignAllowIn(), this.finishNode(r, "AssignmentPattern");
          }
          isValidLVal(t, e, s) {
            return Ki({ AssignmentPattern: "left", RestElement: "argument", ObjectProperty: "value", ParenthesizedExpression: "expression", ArrayPattern: "elements", ObjectPattern: "properties" }, t);
          }
          isOptionalMemberExpression(t) {
            return t.type === "OptionalMemberExpression";
          }
          checkLVal(t, { in: e, binding: s = 64, checkClashes: i = false, strictModeChanged: r = false, hasParenthesizedAncestor: n = false }) {
            var o;
            let h = t.type;
            if (this.isObjectMethod(t)) return;
            let c2 = this.isOptionalMemberExpression(t);
            if (c2 || h === "MemberExpression") {
              c2 && (this.expectPlugin("optionalChainingAssign", t.loc.start), e.type !== "AssignmentExpression" && this.raise(p.InvalidLhsOptionalChaining, t, { ancestor: e })), s !== 64 && this.raise(p.InvalidPropertyBindingPattern, t);
              return;
            }
            if (h === "Identifier") {
              this.checkIdentifier(t, s, r);
              let { name: y2 } = t;
              i && (i.has(y2) ? this.raise(p.ParamDupe, t) : i.add(y2));
              return;
            }
            let l = this.isValidLVal(h, !(n || (o = t.extra) != null && o.parenthesized) && e.type === "AssignmentExpression", s);
            if (l === true) return;
            if (l === false) {
              let y2 = s === 64 ? p.InvalidLhs : p.InvalidLhsBinding;
              this.raise(y2, t, { ancestor: e });
              return;
            }
            let [u, f] = Array.isArray(l) ? l : [l, h === "ParenthesizedExpression"], d = h === "ArrayPattern" || h === "ObjectPattern" ? { type: h } : e;
            for (let y2 of [].concat(t[u])) y2 && this.checkLVal(y2, { in: d, binding: s, checkClashes: i, strictModeChanged: r, hasParenthesizedAncestor: f });
          }
          checkIdentifier(t, e, s = false) {
            this.state.strict && (s ? Zt(t.name, this.inModule) : Qt2(t.name)) && (e === 64 ? this.raise(p.StrictEvalArguments, t, { referenceName: t.name }) : this.raise(p.StrictEvalArgumentsBinding, t, { bindingName: t.name })), e & 8192 && t.name === "let" && this.raise(p.LetInLexicalBinding, t), e & 64 || this.declareNameFromIdentifier(t, e);
          }
          declareNameFromIdentifier(t, e) {
            this.scope.declareName(t.name, e, t.loc.start);
          }
          checkToRestConversion(t, e) {
            switch (t.type) {
              case "ParenthesizedExpression":
                this.checkToRestConversion(t.expression, e);
                break;
              case "Identifier":
              case "MemberExpression":
                break;
              case "ArrayExpression":
              case "ObjectExpression":
                if (e) break;
              default:
                this.raise(p.InvalidRestAssignmentPattern, t);
            }
          }
          checkCommaAfterRest(t) {
            return this.match(12) ? (this.raise(this.lookaheadCharCode() === t ? p.RestTrailingComma : p.ElementAfterRest, this.state.startLoc), true) : false;
          }
        }, Hi = (a, t) => hasOwnProperty.call(a, t) && a[t];
        function Wi(a) {
          if (a == null) throw new Error(`Unexpected ${a} value.`);
          return a;
        }
        function jt2(a) {
          if (!a) throw new Error("Assert fail");
        }
        var x2 = j2`typescript`({ AbstractMethodHasImplementation: ({ methodName: a }) => `Method '${a}' cannot have an implementation because it is marked abstract.`, AbstractPropertyHasInitializer: ({ propertyName: a }) => `Property '${a}' cannot have an initializer because it is marked abstract.`, AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.", AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.", AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.", ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.", ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.", ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.", ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.", DeclareAccessor: ({ kind: a }) => `'declare' is not allowed in ${a}ters.`, DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.", DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.", DuplicateAccessibilityModifier: ({ modifier: a }) => "Accessibility modifier already seen.", DuplicateModifier: ({ modifier: a }) => `Duplicate modifier: '${a}'.`, EmptyHeritageClauseType: ({ token: a }) => `'${a}' list cannot be empty.`, EmptyTypeArguments: "Type argument list cannot be empty.", EmptyTypeParameters: "Type parameter list cannot be empty.", ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.", ImportAliasHasImportType: "An import alias can not use 'import type'.", ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier", IncompatibleModifiers: ({ modifiers: a }) => `'${a[0]}' modifier cannot be used with '${a[1]}' modifier.`, IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.", IndexSignatureHasAccessibility: ({ modifier: a }) => `Index signatures cannot have an accessibility modifier ('${a}').`, IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.", IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.", IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.", InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.", InvalidModifierOnTypeMember: ({ modifier: a }) => `'${a}' modifier cannot appear on a type member.`, InvalidModifierOnTypeParameter: ({ modifier: a }) => `'${a}' modifier cannot appear on a type parameter.`, InvalidModifierOnTypeParameterPositions: ({ modifier: a }) => `'${a}' modifier can only appear on a type parameter of a class, interface or type alias.`, InvalidModifiersOrder: ({ orderedModifiers: a }) => `'${a[0]}' modifier must precede '${a[1]}' modifier.`, InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.", InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.", MissingInterfaceName: "'interface' declarations must be followed by an identifier.", NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.", NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.", OptionalTypeBeforeRequired: "A required element cannot follow an optional element.", OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.", PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.", PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.", PrivateElementHasAccessibility: ({ modifier: a }) => `Private elements cannot have an accessibility modifier ('${a}').`, ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.", ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.", ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.", SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.", SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.", SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.", SingleTypeParameterWithoutTrailingComma: ({ typeParameterName: a }) => `Single type parameter ${a} should have a trailing comma. Example usage: <${a},>.`, StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.", TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).", TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.", TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.", TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.", UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.", UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.", UnexpectedTypeAnnotation: "Did not expect a type annotation here.", UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.", UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.", UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.", UnsupportedSignatureParameterKind: ({ type: a }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${a}.` });
        function Ji(a) {
          switch (a) {
            case "any":
              return "TSAnyKeyword";
            case "boolean":
              return "TSBooleanKeyword";
            case "bigint":
              return "TSBigIntKeyword";
            case "never":
              return "TSNeverKeyword";
            case "number":
              return "TSNumberKeyword";
            case "object":
              return "TSObjectKeyword";
            case "string":
              return "TSStringKeyword";
            case "symbol":
              return "TSSymbolKeyword";
            case "undefined":
              return "TSUndefinedKeyword";
            case "unknown":
              return "TSUnknownKeyword";
            default:
              return;
          }
        }
        function $t2(a) {
          return a === "private" || a === "public" || a === "protected";
        }
        function Xi(a) {
          return a === "in" || a === "out";
        }
        var Gi = (a) => class extends a {
          constructor(...e) {
            super(...e), this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out"], disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: x2.InvalidModifierOnTypeParameter }), this.tsParseConstModifier = this.tsParseModifiers.bind(this, { allowedModifiers: ["const"], disallowedModifiers: ["in", "out"], errorTemplate: x2.InvalidModifierOnTypeParameterPositions }), this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, { allowedModifiers: ["in", "out", "const"], disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"], errorTemplate: x2.InvalidModifierOnTypeParameter });
          }
          getScopeHandler() {
            return ht2;
          }
          tsIsIdentifier() {
            return w(this.state.type);
          }
          tsTokenCanFollowModifier() {
            return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(138) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
          }
          tsNextTokenCanFollowModifier() {
            return this.next(), this.tsTokenCanFollowModifier();
          }
          tsParseModifier(e, s) {
            if (!w(this.state.type) && this.state.type !== 58 && this.state.type !== 75) return;
            let i = this.state.value;
            if (e.includes(i)) {
              if (s && this.tsIsStartOfStaticBlocks()) return;
              if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) return i;
            }
          }
          tsParseModifiers({ allowedModifiers: e, disallowedModifiers: s, stopOnStartOfClassStaticBlock: i, errorTemplate: r = x2.InvalidModifierOnTypeMember }, n) {
            let o = (c2, l, u, f) => {
              l === u && n[f] && this.raise(x2.InvalidModifiersOrder, c2, { orderedModifiers: [u, f] });
            }, h = (c2, l, u, f) => {
              (n[u] && l === f || n[f] && l === u) && this.raise(x2.IncompatibleModifiers, c2, { modifiers: [u, f] });
            };
            for (; ; ) {
              let { startLoc: c2 } = this.state, l = this.tsParseModifier(e.concat(s ?? []), i);
              if (!l) break;
              $t2(l) ? n.accessibility ? this.raise(x2.DuplicateAccessibilityModifier, c2, { modifier: l }) : (o(c2, l, l, "override"), o(c2, l, l, "static"), o(c2, l, l, "readonly"), n.accessibility = l) : Xi(l) ? (n[l] && this.raise(x2.DuplicateModifier, c2, { modifier: l }), n[l] = true, o(c2, l, "in", "out")) : (hasOwnProperty.call(n, l) ? this.raise(x2.DuplicateModifier, c2, { modifier: l }) : (o(c2, l, "static", "readonly"), o(c2, l, "static", "override"), o(c2, l, "override", "readonly"), o(c2, l, "abstract", "override"), h(c2, l, "declare", "override"), h(c2, l, "static", "abstract")), n[l] = true), s != null && s.includes(l) && this.raise(r, c2, { modifier: l });
            }
          }
          tsIsListTerminator(e) {
            switch (e) {
              case "EnumMembers":
              case "TypeMembers":
                return this.match(8);
              case "HeritageClauseElement":
                return this.match(5);
              case "TupleElementTypes":
                return this.match(3);
              case "TypeParametersOrArguments":
                return this.match(48);
            }
          }
          tsParseList(e, s) {
            let i = [];
            for (; !this.tsIsListTerminator(e); ) i.push(s());
            return i;
          }
          tsParseDelimitedList(e, s, i) {
            return Wi(this.tsParseDelimitedListWorker(e, s, true, i));
          }
          tsParseDelimitedListWorker(e, s, i, r) {
            let n = [], o = -1;
            for (; !this.tsIsListTerminator(e); ) {
              o = -1;
              let h = s();
              if (h == null) return;
              if (n.push(h), this.eat(12)) {
                o = this.state.lastTokStartLoc.index;
                continue;
              }
              if (this.tsIsListTerminator(e)) break;
              i && this.expect(12);
              return;
            }
            return r && (r.value = o), n;
          }
          tsParseBracketedList(e, s, i, r, n) {
            r || (i ? this.expect(0) : this.expect(47));
            let o = this.tsParseDelimitedList(e, s, n);
            return i ? this.expect(3) : this.expect(48), o;
          }
          tsParseImportType() {
            let e = this.startNode();
            return this.expect(83), this.expect(10), this.match(133) || this.raise(x2.UnsupportedImportTypeArgument, this.state.startLoc), e.argument = super.parseExprAtom(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (e.options = null), this.eat(12) && (this.expectImportAttributesPlugin(), this.match(11) || (e.options = super.parseMaybeAssignAllowIn(), this.eat(12))), this.expect(11), this.eat(16) && (e.qualifier = this.tsParseEntityName()), this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, "TSImportType");
          }
          tsParseEntityName(e = true) {
            let s = this.parseIdentifier(e);
            for (; this.eat(16); ) {
              let i = this.startNodeAtNode(s);
              i.left = s, i.right = this.parseIdentifier(e), s = this.finishNode(i, "TSQualifiedName");
            }
            return s;
          }
          tsParseTypeReference() {
            let e = this.startNode();
            return e.typeName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, "TSTypeReference");
          }
          tsParseThisTypePredicate(e) {
            this.next();
            let s = this.startNodeAtNode(e);
            return s.parameterName = e, s.typeAnnotation = this.tsParseTypeAnnotation(false), s.asserts = false, this.finishNode(s, "TSTypePredicate");
          }
          tsParseThisTypeNode() {
            let e = this.startNode();
            return this.next(), this.finishNode(e, "TSThisType");
          }
          tsParseTypeQuery() {
            let e = this.startNode();
            return this.expect(87), this.match(83) ? e.exprName = this.tsParseImportType() : e.exprName = this.tsParseEntityName(), !this.hasPrecedingLineBreak() && this.match(47) && (e.typeParameters = this.tsParseTypeArguments()), this.finishNode(e, "TSTypeQuery");
          }
          tsParseTypeParameter(e) {
            let s = this.startNode();
            return e(s), s.name = this.tsParseTypeParameterName(), s.constraint = this.tsEatThenParseType(81), s.default = this.tsEatThenParseType(29), this.finishNode(s, "TSTypeParameter");
          }
          tsTryParseTypeParameters(e) {
            if (this.match(47)) return this.tsParseTypeParameters(e);
          }
          tsParseTypeParameters(e) {
            let s = this.startNode();
            this.match(47) || this.match(142) ? this.next() : this.unexpected();
            let i = { value: -1 };
            return s.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, e), false, true, i), s.params.length === 0 && this.raise(x2.EmptyTypeParameters, s), i.value !== -1 && this.addExtra(s, "trailingComma", i.value), this.finishNode(s, "TSTypeParameterDeclaration");
          }
          tsFillSignature(e, s) {
            let i = e === 19, r = "parameters", n = "typeAnnotation";
            s.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier), this.expect(10), s[r] = this.tsParseBindingListForSignature(), i ? s[n] = this.tsParseTypeOrTypePredicateAnnotation(e) : this.match(e) && (s[n] = this.tsParseTypeOrTypePredicateAnnotation(e));
          }
          tsParseBindingListForSignature() {
            let e = super.parseBindingList(11, 41, 2);
            for (let s of e) {
              let { type: i } = s;
              (i === "AssignmentPattern" || i === "TSParameterProperty") && this.raise(x2.UnsupportedSignatureParameterKind, s, { type: i });
            }
            return e;
          }
          tsParseTypeMemberSemicolon() {
            !this.eat(12) && !this.isLineTerminator() && this.expect(13);
          }
          tsParseSignatureMember(e, s) {
            return this.tsFillSignature(14, s), this.tsParseTypeMemberSemicolon(), this.finishNode(s, e);
          }
          tsIsUnambiguouslyIndexSignature() {
            return this.next(), w(this.state.type) ? (this.next(), this.match(14)) : false;
          }
          tsTryParseIndexSignature(e) {
            if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) return;
            this.expect(0);
            let s = this.parseIdentifier();
            s.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(s), this.expect(3), e.parameters = [s];
            let i = this.tsTryParseTypeAnnotation();
            return i && (e.typeAnnotation = i), this.tsParseTypeMemberSemicolon(), this.finishNode(e, "TSIndexSignature");
          }
          tsParsePropertyOrMethodSignature(e, s) {
            this.eat(17) && (e.optional = true);
            let i = e;
            if (this.match(10) || this.match(47)) {
              s && this.raise(x2.ReadonlyForMethodSignature, e);
              let r = i;
              r.kind && this.match(47) && this.raise(x2.AccesorCannotHaveTypeParameters, this.state.curPosition()), this.tsFillSignature(14, r), this.tsParseTypeMemberSemicolon();
              let n = "parameters", o = "typeAnnotation";
              if (r.kind === "get") r[n].length > 0 && (this.raise(p.BadGetterArity, this.state.curPosition()), this.isThisParam(r[n][0]) && this.raise(x2.AccesorCannotDeclareThisParameter, this.state.curPosition()));
              else if (r.kind === "set") {
                if (r[n].length !== 1) this.raise(p.BadSetterArity, this.state.curPosition());
                else {
                  let h = r[n][0];
                  this.isThisParam(h) && this.raise(x2.AccesorCannotDeclareThisParameter, this.state.curPosition()), h.type === "Identifier" && h.optional && this.raise(x2.SetAccesorCannotHaveOptionalParameter, this.state.curPosition()), h.type === "RestElement" && this.raise(x2.SetAccesorCannotHaveRestParameter, this.state.curPosition());
                }
                r[o] && this.raise(x2.SetAccesorCannotHaveReturnType, r[o]);
              } else r.kind = "method";
              return this.finishNode(r, "TSMethodSignature");
            } else {
              let r = i;
              s && (r.readonly = true);
              let n = this.tsTryParseTypeAnnotation();
              return n && (r.typeAnnotation = n), this.tsParseTypeMemberSemicolon(), this.finishNode(r, "TSPropertySignature");
            }
          }
          tsParseTypeMember() {
            let e = this.startNode();
            if (this.match(10) || this.match(47)) return this.tsParseSignatureMember("TSCallSignatureDeclaration", e);
            if (this.match(77)) {
              let i = this.startNode();
              return this.next(), this.match(10) || this.match(47) ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", e) : (e.key = this.createIdentifier(i, "new"), this.tsParsePropertyOrMethodSignature(e, false));
            }
            this.tsParseModifiers({ allowedModifiers: ["readonly"], disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"] }, e);
            let s = this.tsTryParseIndexSignature(e);
            return s || (super.parsePropertyName(e), !e.computed && e.key.type === "Identifier" && (e.key.name === "get" || e.key.name === "set") && this.tsTokenCanFollowModifier() && (e.kind = e.key.name, super.parsePropertyName(e)), this.tsParsePropertyOrMethodSignature(e, !!e.readonly));
          }
          tsParseTypeLiteral() {
            let e = this.startNode();
            return e.members = this.tsParseObjectTypeMembers(), this.finishNode(e, "TSTypeLiteral");
          }
          tsParseObjectTypeMembers() {
            this.expect(5);
            let e = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
            return this.expect(8), e;
          }
          tsIsStartOfMappedType() {
            return this.next(), this.eat(53) ? this.isContextual(122) : (this.isContextual(122) && this.next(), !this.match(0) || (this.next(), !this.tsIsIdentifier()) ? false : (this.next(), this.match(58)));
          }
          tsParseMappedTypeParameter() {
            let e = this.startNode();
            return e.name = this.tsParseTypeParameterName(), e.constraint = this.tsExpectThenParseType(58), this.finishNode(e, "TSTypeParameter");
          }
          tsParseMappedType() {
            let e = this.startNode();
            return this.expect(5), this.match(53) ? (e.readonly = this.state.value, this.next(), this.expectContextual(122)) : this.eatContextual(122) && (e.readonly = true), this.expect(0), e.typeParameter = this.tsParseMappedTypeParameter(), e.nameType = this.eatContextual(93) ? this.tsParseType() : null, this.expect(3), this.match(53) ? (e.optional = this.state.value, this.next(), this.expect(17)) : this.eat(17) && (e.optional = true), e.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(8), this.finishNode(e, "TSMappedType");
          }
          tsParseTupleType() {
            let e = this.startNode();
            e.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
            let s = false;
            return e.elementTypes.forEach((i) => {
              let { type: r } = i;
              s && r !== "TSRestType" && r !== "TSOptionalType" && !(r === "TSNamedTupleMember" && i.optional) && this.raise(x2.OptionalTypeBeforeRequired, i), s || (s = r === "TSNamedTupleMember" && i.optional || r === "TSOptionalType");
            }), this.finishNode(e, "TSTupleType");
          }
          tsParseTupleElementType() {
            let { startLoc: e } = this.state, s = this.eat(21), i, r, n, o, c2 = M2(this.state.type) ? this.lookaheadCharCode() : null;
            if (c2 === 58) i = true, n = false, r = this.parseIdentifier(true), this.expect(14), o = this.tsParseType();
            else if (c2 === 63) {
              n = true;
              let l = this.state.startLoc, u = this.state.value, f = this.tsParseNonArrayType();
              this.lookaheadCharCode() === 58 ? (i = true, r = this.createIdentifier(this.startNodeAt(l), u), this.expect(17), this.expect(14), o = this.tsParseType()) : (i = false, o = f, this.expect(17));
            } else o = this.tsParseType(), n = this.eat(17), i = this.eat(14);
            if (i) {
              let l;
              r ? (l = this.startNodeAtNode(r), l.optional = n, l.label = r, l.elementType = o, this.eat(17) && (l.optional = true, this.raise(x2.TupleOptionalAfterType, this.state.lastTokStartLoc))) : (l = this.startNodeAtNode(o), l.optional = n, this.raise(x2.InvalidTupleMemberLabel, o), l.label = o, l.elementType = this.tsParseType()), o = this.finishNode(l, "TSNamedTupleMember");
            } else if (n) {
              let l = this.startNodeAtNode(o);
              l.typeAnnotation = o, o = this.finishNode(l, "TSOptionalType");
            }
            if (s) {
              let l = this.startNodeAt(e);
              l.typeAnnotation = o, o = this.finishNode(l, "TSRestType");
            }
            return o;
          }
          tsParseParenthesizedType() {
            let e = this.startNode();
            return this.expect(10), e.typeAnnotation = this.tsParseType(), this.expect(11), this.finishNode(e, "TSParenthesizedType");
          }
          tsParseFunctionOrConstructorType(e, s) {
            let i = this.startNode();
            return e === "TSConstructorType" && (i.abstract = !!s, s && this.next(), this.next()), this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, i)), this.finishNode(i, e);
          }
          tsParseLiteralTypeNode() {
            let e = this.startNode();
            switch (this.state.type) {
              case 134:
              case 135:
              case 133:
              case 85:
              case 86:
                e.literal = super.parseExprAtom();
                break;
              default:
                this.unexpected();
            }
            return this.finishNode(e, "TSLiteralType");
          }
          tsParseTemplateLiteralType() {
            let e = this.startNode();
            return e.literal = super.parseTemplate(false), this.finishNode(e, "TSLiteralType");
          }
          parseTemplateSubstitution() {
            return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
          }
          tsParseThisTypeOrThisTypePredicate() {
            let e = this.tsParseThisTypeNode();
            return this.isContextual(116) && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(e) : e;
          }
          tsParseNonArrayType() {
            switch (this.state.type) {
              case 133:
              case 134:
              case 135:
              case 85:
              case 86:
                return this.tsParseLiteralTypeNode();
              case 53:
                if (this.state.value === "-") {
                  let e = this.startNode(), s = this.lookahead();
                  return s.type !== 134 && s.type !== 135 && this.unexpected(), e.literal = this.parseMaybeUnary(), this.finishNode(e, "TSLiteralType");
                }
                break;
              case 78:
                return this.tsParseThisTypeOrThisTypePredicate();
              case 87:
                return this.tsParseTypeQuery();
              case 83:
                return this.tsParseImportType();
              case 5:
                return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
              case 0:
                return this.tsParseTupleType();
              case 10:
                return this.tsParseParenthesizedType();
              case 25:
              case 24:
                return this.tsParseTemplateLiteralType();
              default: {
                let { type: e } = this.state;
                if (w(e) || e === 88 || e === 84) {
                  let s = e === 88 ? "TSVoidKeyword" : e === 84 ? "TSNullKeyword" : Ji(this.state.value);
                  if (s !== void 0 && this.lookaheadCharCode() !== 46) {
                    let i = this.startNode();
                    return this.next(), this.finishNode(i, s);
                  }
                  return this.tsParseTypeReference();
                }
              }
            }
            this.unexpected();
          }
          tsParseArrayTypeOrHigher() {
            let e = this.tsParseNonArrayType();
            for (; !this.hasPrecedingLineBreak() && this.eat(0); ) if (this.match(3)) {
              let s = this.startNodeAtNode(e);
              s.elementType = e, this.expect(3), e = this.finishNode(s, "TSArrayType");
            } else {
              let s = this.startNodeAtNode(e);
              s.objectType = e, s.indexType = this.tsParseType(), this.expect(3), e = this.finishNode(s, "TSIndexedAccessType");
            }
            return e;
          }
          tsParseTypeOperator() {
            let e = this.startNode(), s = this.state.value;
            return this.next(), e.operator = s, e.typeAnnotation = this.tsParseTypeOperatorOrHigher(), s === "readonly" && this.tsCheckTypeAnnotationForReadOnly(e), this.finishNode(e, "TSTypeOperator");
          }
          tsCheckTypeAnnotationForReadOnly(e) {
            switch (e.typeAnnotation.type) {
              case "TSTupleType":
              case "TSArrayType":
                return;
              default:
                this.raise(x2.UnexpectedReadonly, e);
            }
          }
          tsParseInferType() {
            let e = this.startNode();
            this.expectContextual(115);
            let s = this.startNode();
            return s.name = this.tsParseTypeParameterName(), s.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType()), e.typeParameter = this.finishNode(s, "TSTypeParameter"), this.finishNode(e, "TSInferType");
          }
          tsParseConstraintForInferType() {
            if (this.eat(81)) {
              let e = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
              if (this.state.inDisallowConditionalTypesContext || !this.match(17)) return e;
            }
          }
          tsParseTypeOperatorOrHigher() {
            return di2(this.state.type) && !this.state.containsEsc ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
          }
          tsParseUnionOrIntersectionType(e, s, i) {
            let r = this.startNode(), n = this.eat(i), o = [];
            do
              o.push(s());
            while (this.eat(i));
            return o.length === 1 && !n ? o[0] : (r.types = o, this.finishNode(r, e));
          }
          tsParseIntersectionTypeOrHigher() {
            return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
          }
          tsParseUnionTypeOrHigher() {
            return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
          }
          tsIsStartOfFunctionType() {
            return this.match(47) ? true : this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
          }
          tsSkipParameterStart() {
            if (w(this.state.type) || this.match(78)) return this.next(), true;
            if (this.match(5)) {
              let { errors: e } = this.state, s = e.length;
              try {
                return this.parseObjectLike(8, true), e.length === s;
              } catch {
                return false;
              }
            }
            if (this.match(0)) {
              this.next();
              let { errors: e } = this.state, s = e.length;
              try {
                return super.parseBindingList(3, 93, 1), e.length === s;
              } catch {
                return false;
              }
            }
            return false;
          }
          tsIsUnambiguouslyStartOfFunctionType() {
            return this.next(), !!(this.match(11) || this.match(21) || this.tsSkipParameterStart() && (this.match(14) || this.match(12) || this.match(17) || this.match(29) || this.match(11) && (this.next(), this.match(19))));
          }
          tsParseTypeOrTypePredicateAnnotation(e) {
            return this.tsInType(() => {
              let s = this.startNode();
              this.expect(e);
              let i = this.startNode(), r = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
              if (r && this.match(78)) {
                let h = this.tsParseThisTypeOrThisTypePredicate();
                return h.type === "TSThisType" ? (i.parameterName = h, i.asserts = true, i.typeAnnotation = null, h = this.finishNode(i, "TSTypePredicate")) : (this.resetStartLocationFromNode(h, i), h.asserts = true), s.typeAnnotation = h, this.finishNode(s, "TSTypeAnnotation");
              }
              let n = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
              if (!n) return r ? (i.parameterName = this.parseIdentifier(), i.asserts = r, i.typeAnnotation = null, s.typeAnnotation = this.finishNode(i, "TSTypePredicate"), this.finishNode(s, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(false, s);
              let o = this.tsParseTypeAnnotation(false);
              return i.parameterName = n, i.typeAnnotation = o, i.asserts = r, s.typeAnnotation = this.finishNode(i, "TSTypePredicate"), this.finishNode(s, "TSTypeAnnotation");
            });
          }
          tsTryParseTypeOrTypePredicateAnnotation() {
            if (this.match(14)) return this.tsParseTypeOrTypePredicateAnnotation(14);
          }
          tsTryParseTypeAnnotation() {
            if (this.match(14)) return this.tsParseTypeAnnotation();
          }
          tsTryParseType() {
            return this.tsEatThenParseType(14);
          }
          tsParseTypePredicatePrefix() {
            let e = this.parseIdentifier();
            if (this.isContextual(116) && !this.hasPrecedingLineBreak()) return this.next(), e;
          }
          tsParseTypePredicateAsserts() {
            if (this.state.type !== 109) return false;
            let e = this.state.containsEsc;
            return this.next(), !w(this.state.type) && !this.match(78) ? false : (e && this.raise(p.InvalidEscapedReservedWord, this.state.lastTokStartLoc, { reservedWord: "asserts" }), true);
          }
          tsParseTypeAnnotation(e = true, s = this.startNode()) {
            return this.tsInType(() => {
              e && this.expect(14), s.typeAnnotation = this.tsParseType();
            }), this.finishNode(s, "TSTypeAnnotation");
          }
          tsParseType() {
            jt2(this.state.inType);
            let e = this.tsParseNonConditionalType();
            if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) return e;
            let s = this.startNodeAtNode(e);
            return s.checkType = e, s.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType()), this.expect(17), s.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.expect(14), s.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType()), this.finishNode(s, "TSConditionalType");
          }
          isAbstractConstructorSignature() {
            return this.isContextual(124) && this.lookahead().type === 77;
          }
          tsParseNonConditionalType() {
            return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(77) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", true) : this.tsParseUnionTypeOrHigher();
          }
          tsParseTypeAssertion() {
            this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(x2.ReservedTypeAssertion, this.state.startLoc);
            let e = this.startNode();
            return e.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? this.tsParseTypeReference() : this.tsParseType())), this.expect(48), e.expression = this.parseMaybeUnary(), this.finishNode(e, "TSTypeAssertion");
          }
          tsParseHeritageClause(e) {
            let s = this.state.startLoc, i = this.tsParseDelimitedList("HeritageClauseElement", () => {
              let r = this.startNode();
              return r.expression = this.tsParseEntityName(), this.match(47) && (r.typeParameters = this.tsParseTypeArguments()), this.finishNode(r, "TSExpressionWithTypeArguments");
            });
            return i.length || this.raise(x2.EmptyHeritageClauseType, s, { token: e }), i;
          }
          tsParseInterfaceDeclaration(e, s = {}) {
            if (this.hasFollowingLineBreak()) return null;
            this.expectContextual(129), s.declare && (e.declare = true), w(this.state.type) ? (e.id = this.parseIdentifier(), this.checkIdentifier(e.id, 130)) : (e.id = null, this.raise(x2.MissingInterfaceName, this.state.startLoc)), e.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers), this.eat(81) && (e.extends = this.tsParseHeritageClause("extends"));
            let i = this.startNode();
            return i.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), e.body = this.finishNode(i, "TSInterfaceBody"), this.finishNode(e, "TSInterfaceDeclaration");
          }
          tsParseTypeAliasDeclaration(e) {
            return e.id = this.parseIdentifier(), this.checkIdentifier(e.id, 2), e.typeAnnotation = this.tsInType(() => {
              if (e.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers), this.expect(29), this.isContextual(114) && this.lookahead().type !== 16) {
                let s = this.startNode();
                return this.next(), this.finishNode(s, "TSIntrinsicKeyword");
              }
              return this.tsParseType();
            }), this.semicolon(), this.finishNode(e, "TSTypeAliasDeclaration");
          }
          tsInNoContext(e) {
            let s = this.state.context;
            this.state.context = [s[0]];
            try {
              return e();
            } finally {
              this.state.context = s;
            }
          }
          tsInType(e) {
            let s = this.state.inType;
            this.state.inType = true;
            try {
              return e();
            } finally {
              this.state.inType = s;
            }
          }
          tsInDisallowConditionalTypesContext(e) {
            let s = this.state.inDisallowConditionalTypesContext;
            this.state.inDisallowConditionalTypesContext = true;
            try {
              return e();
            } finally {
              this.state.inDisallowConditionalTypesContext = s;
            }
          }
          tsInAllowConditionalTypesContext(e) {
            let s = this.state.inDisallowConditionalTypesContext;
            this.state.inDisallowConditionalTypesContext = false;
            try {
              return e();
            } finally {
              this.state.inDisallowConditionalTypesContext = s;
            }
          }
          tsEatThenParseType(e) {
            if (this.match(e)) return this.tsNextThenParseType();
          }
          tsExpectThenParseType(e) {
            return this.tsInType(() => (this.expect(e), this.tsParseType()));
          }
          tsNextThenParseType() {
            return this.tsInType(() => (this.next(), this.tsParseType()));
          }
          tsParseEnumMember() {
            let e = this.startNode();
            return e.id = this.match(133) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true), this.eat(29) && (e.initializer = super.parseMaybeAssignAllowIn()), this.finishNode(e, "TSEnumMember");
          }
          tsParseEnumDeclaration(e, s = {}) {
            return s.const && (e.const = true), s.declare && (e.declare = true), this.expectContextual(126), e.id = this.parseIdentifier(), this.checkIdentifier(e.id, e.const ? 8971 : 8459), this.expect(5), e.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(8), this.finishNode(e, "TSEnumDeclaration");
          }
          tsParseModuleBlock() {
            let e = this.startNode();
            return this.scope.enter(0), this.expect(5), super.parseBlockOrModuleBlockBody(e.body = [], void 0, true, 8), this.scope.exit(), this.finishNode(e, "TSModuleBlock");
          }
          tsParseModuleOrNamespaceDeclaration(e, s = false) {
            if (e.id = this.parseIdentifier(), s || this.checkIdentifier(e.id, 1024), this.eat(16)) {
              let i = this.startNode();
              this.tsParseModuleOrNamespaceDeclaration(i, true), e.body = i;
            } else this.scope.enter(256), this.prodParam.enter(0), e.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
            return this.finishNode(e, "TSModuleDeclaration");
          }
          tsParseAmbientExternalModuleDeclaration(e) {
            return this.isContextual(112) ? (e.global = true, e.id = this.parseIdentifier()) : this.match(133) ? e.id = super.parseStringLiteral(this.state.value) : this.unexpected(), this.match(5) ? (this.scope.enter(256), this.prodParam.enter(0), e.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(e, "TSModuleDeclaration");
          }
          tsParseImportEqualsDeclaration(e, s, i) {
            e.isExport = i || false, e.id = s || this.parseIdentifier(), this.checkIdentifier(e.id, 4096), this.expect(29);
            let r = this.tsParseModuleReference();
            return e.importKind === "type" && r.type !== "TSExternalModuleReference" && this.raise(x2.ImportAliasHasImportType, r), e.moduleReference = r, this.semicolon(), this.finishNode(e, "TSImportEqualsDeclaration");
          }
          tsIsExternalModuleReference() {
            return this.isContextual(119) && this.lookaheadCharCode() === 40;
          }
          tsParseModuleReference() {
            return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
          }
          tsParseExternalModuleReference() {
            let e = this.startNode();
            return this.expectContextual(119), this.expect(10), this.match(133) || this.unexpected(), e.expression = super.parseExprAtom(), this.expect(11), this.sawUnambiguousESM = true, this.finishNode(e, "TSExternalModuleReference");
          }
          tsLookAhead(e) {
            let s = this.state.clone(), i = e();
            return this.state = s, i;
          }
          tsTryParseAndCatch(e) {
            let s = this.tryParse((i) => e() || i());
            if (!(s.aborted || !s.node)) return s.error && (this.state = s.failState), s.node;
          }
          tsTryParse(e) {
            let s = this.state.clone(), i = e();
            if (i !== void 0 && i !== false) return i;
            this.state = s;
          }
          tsTryParseDeclare(e) {
            if (this.isLineTerminator()) return;
            let s = this.state.type, i;
            return this.isContextual(100) && (s = 74, i = "let"), this.tsInAmbientContext(() => {
              switch (s) {
                case 68:
                  return e.declare = true, super.parseFunctionStatement(e, false, false);
                case 80:
                  return e.declare = true, this.parseClass(e, true, false);
                case 126:
                  return this.tsParseEnumDeclaration(e, { declare: true });
                case 112:
                  return this.tsParseAmbientExternalModuleDeclaration(e);
                case 75:
                case 74:
                  return !this.match(75) || !this.isLookaheadContextual("enum") ? (e.declare = true, this.parseVarStatement(e, i || this.state.value, true)) : (this.expect(75), this.tsParseEnumDeclaration(e, { const: true, declare: true }));
                case 129: {
                  let r = this.tsParseInterfaceDeclaration(e, { declare: true });
                  if (r) return r;
                }
                default:
                  if (w(s)) return this.tsParseDeclaration(e, this.state.value, true, null);
              }
            });
          }
          tsTryParseExportDeclaration() {
            return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);
          }
          tsParseExpressionStatement(e, s, i) {
            switch (s.name) {
              case "declare": {
                let r = this.tsTryParseDeclare(e);
                return r && (r.declare = true), r;
              }
              case "global":
                if (this.match(5)) {
                  this.scope.enter(256), this.prodParam.enter(0);
                  let r = e;
                  return r.global = true, r.id = s, r.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(r, "TSModuleDeclaration");
                }
                break;
              default:
                return this.tsParseDeclaration(e, s.name, false, i);
            }
          }
          tsParseDeclaration(e, s, i, r) {
            switch (s) {
              case "abstract":
                if (this.tsCheckLineTerminator(i) && (this.match(80) || w(this.state.type))) return this.tsParseAbstractDeclaration(e, r);
                break;
              case "module":
                if (this.tsCheckLineTerminator(i)) {
                  if (this.match(133)) return this.tsParseAmbientExternalModuleDeclaration(e);
                  if (w(this.state.type)) return this.tsParseModuleOrNamespaceDeclaration(e);
                }
                break;
              case "namespace":
                if (this.tsCheckLineTerminator(i) && w(this.state.type)) return this.tsParseModuleOrNamespaceDeclaration(e);
                break;
              case "type":
                if (this.tsCheckLineTerminator(i) && w(this.state.type)) return this.tsParseTypeAliasDeclaration(e);
                break;
            }
          }
          tsCheckLineTerminator(e) {
            return e ? this.hasFollowingLineBreak() ? false : (this.next(), true) : !this.isLineTerminator();
          }
          tsTryParseGenericAsyncArrowFunction(e) {
            if (!this.match(47)) return;
            let s = this.state.maybeInArrowParameters;
            this.state.maybeInArrowParameters = true;
            let i = this.tsTryParseAndCatch(() => {
              let r = this.startNodeAt(e);
              return r.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier), super.parseFunctionParams(r), r.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(19), r;
            });
            if (this.state.maybeInArrowParameters = s, !!i) return super.parseArrowExpression(i, null, true);
          }
          tsParseTypeArgumentsInExpression() {
            if (this.reScan_lt() === 47) return this.tsParseTypeArguments();
          }
          tsParseTypeArguments() {
            let e = this.startNode();
            return e.params = this.tsInType(() => this.tsInNoContext(() => (this.expect(47), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), e.params.length === 0 ? this.raise(x2.EmptyTypeArguments, e) : !this.state.inType && this.curContext() === C.brace && this.reScan_lt_gt(), this.expect(48), this.finishNode(e, "TSTypeParameterInstantiation");
          }
          tsIsDeclarationStart() {
            return mi(this.state.type);
          }
          isExportDefaultSpecifier() {
            return this.tsIsDeclarationStart() ? false : super.isExportDefaultSpecifier();
          }
          parseAssignableListItem(e, s) {
            let i = this.state.startLoc, r = {};
            this.tsParseModifiers({ allowedModifiers: ["public", "private", "protected", "override", "readonly"] }, r);
            let n = r.accessibility, o = r.override, h = r.readonly;
            !(e & 4) && (n || h || o) && this.raise(x2.UnexpectedParameterModifier, i);
            let c2 = this.parseMaybeDefault();
            this.parseAssignableListItemTypes(c2, e);
            let l = this.parseMaybeDefault(c2.loc.start, c2);
            if (n || h || o) {
              let u = this.startNodeAt(i);
              return s.length && (u.decorators = s), n && (u.accessibility = n), h && (u.readonly = h), o && (u.override = o), l.type !== "Identifier" && l.type !== "AssignmentPattern" && this.raise(x2.UnsupportedParameterPropertyKind, u), u.parameter = l, this.finishNode(u, "TSParameterProperty");
            }
            return s.length && (c2.decorators = s), l;
          }
          isSimpleParameter(e) {
            return e.type === "TSParameterProperty" && super.isSimpleParameter(e.parameter) || super.isSimpleParameter(e);
          }
          tsDisallowOptionalPattern(e) {
            for (let s of e.params) s.type !== "Identifier" && s.optional && !this.state.isAmbientContext && this.raise(x2.PatternIsOptional, s);
          }
          setArrowFunctionParameters(e, s, i) {
            super.setArrowFunctionParameters(e, s, i), this.tsDisallowOptionalPattern(e);
          }
          parseFunctionBodyAndFinish(e, s, i = false) {
            this.match(14) && (e.returnType = this.tsParseTypeOrTypePredicateAnnotation(14));
            let r = s === "FunctionDeclaration" ? "TSDeclareFunction" : s === "ClassMethod" || s === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
            return r && !this.match(5) && this.isLineTerminator() ? this.finishNode(e, r) : r === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(x2.DeclareFunctionHasImplementation, e), e.declare) ? super.parseFunctionBodyAndFinish(e, r, i) : (this.tsDisallowOptionalPattern(e), super.parseFunctionBodyAndFinish(e, s, i));
          }
          registerFunctionStatementId(e) {
            !e.body && e.id ? this.checkIdentifier(e.id, 1024) : super.registerFunctionStatementId(e);
          }
          tsCheckForInvalidTypeCasts(e) {
            e.forEach((s) => {
              (s == null ? void 0 : s.type) === "TSTypeCastExpression" && this.raise(x2.UnexpectedTypeAnnotation, s.typeAnnotation);
            });
          }
          toReferencedList(e, s) {
            return this.tsCheckForInvalidTypeCasts(e), e;
          }
          parseArrayLike(e, s, i, r) {
            let n = super.parseArrayLike(e, s, i, r);
            return n.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(n.elements), n;
          }
          parseSubscript(e, s, i, r) {
            if (!this.hasPrecedingLineBreak() && this.match(35)) {
              this.state.canStartJSXElement = false, this.next();
              let o = this.startNodeAt(s);
              return o.expression = e, this.finishNode(o, "TSNonNullExpression");
            }
            let n = false;
            if (this.match(18) && this.lookaheadCharCode() === 60) {
              if (i) return r.stop = true, e;
              r.optionalChainMember = n = true, this.next();
            }
            if (this.match(47) || this.match(51)) {
              let o, h = this.tsTryParseAndCatch(() => {
                if (!i && this.atPossibleAsyncArrow(e)) {
                  let f = this.tsTryParseGenericAsyncArrowFunction(s);
                  if (f) return f;
                }
                let c2 = this.tsParseTypeArgumentsInExpression();
                if (!c2) return;
                if (n && !this.match(10)) {
                  o = this.state.curPosition();
                  return;
                }
                if (Le2(this.state.type)) {
                  let f = super.parseTaggedTemplateExpression(e, s, r);
                  return f.typeParameters = c2, f;
                }
                if (!i && this.eat(10)) {
                  let f = this.startNodeAt(s);
                  return f.callee = e, f.arguments = this.parseCallExpressionArguments(11, false), this.tsCheckForInvalidTypeCasts(f.arguments), f.typeParameters = c2, r.optionalChainMember && (f.optional = n), this.finishCallExpression(f, r.optionalChainMember);
                }
                let l = this.state.type;
                if (l === 48 || l === 52 || l !== 10 && He2(l) && !this.hasPrecedingLineBreak()) return;
                let u = this.startNodeAt(s);
                return u.expression = e, u.typeParameters = c2, this.finishNode(u, "TSInstantiationExpression");
              });
              if (o && this.unexpected(o, 10), h) return h.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) && this.raise(x2.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc), h;
            }
            return super.parseSubscript(e, s, i, r);
          }
          parseNewCallee(e) {
            var s;
            super.parseNewCallee(e);
            let { callee: i } = e;
            i.type === "TSInstantiationExpression" && !((s = i.extra) != null && s.parenthesized) && (e.typeParameters = i.typeParameters, e.callee = i.expression);
          }
          parseExprOp(e, s, i) {
            let r;
            if (Ie2(58) > i && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (r = this.isContextual(120)))) {
              let n = this.startNodeAt(s);
              return n.expression = e, n.typeAnnotation = this.tsInType(() => (this.next(), this.match(75) ? (r && this.raise(p.UnexpectedKeyword, this.state.startLoc, { keyword: "const" }), this.tsParseTypeReference()) : this.tsParseType())), this.finishNode(n, r ? "TSSatisfiesExpression" : "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(n, s, i);
            }
            return super.parseExprOp(e, s, i);
          }
          checkReservedWord(e, s, i, r) {
            this.state.isAmbientContext || super.checkReservedWord(e, s, i, r);
          }
          checkImportReflection(e) {
            super.checkImportReflection(e), e.module && e.importKind !== "value" && this.raise(x2.ImportReflectionHasImportType, e.specifiers[0].loc.start);
          }
          checkDuplicateExports() {
          }
          isPotentialImportPhase(e) {
            if (super.isPotentialImportPhase(e)) return true;
            if (this.isContextual(130)) {
              let s = this.lookaheadCharCode();
              return e ? s === 123 || s === 42 : s !== 61;
            }
            return !e && this.isContextual(87);
          }
          applyImportPhase(e, s, i, r) {
            super.applyImportPhase(e, s, i, r), s ? e.exportKind = i === "type" ? "type" : "value" : e.importKind = i === "type" || i === "typeof" ? i : "value";
          }
          parseImport(e) {
            if (this.match(133)) return e.importKind = "value", super.parseImport(e);
            let s;
            if (w(this.state.type) && this.lookaheadCharCode() === 61) return e.importKind = "value", this.tsParseImportEqualsDeclaration(e);
            if (this.isContextual(130)) {
              let i = this.parseMaybeImportPhase(e, false);
              if (this.lookaheadCharCode() === 61) return this.tsParseImportEqualsDeclaration(e, i);
              s = super.parseImportSpecifiersAndAfter(e, i);
            } else s = super.parseImport(e);
            return s.importKind === "type" && s.specifiers.length > 1 && s.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(x2.TypeImportCannotSpecifyDefaultAndNamed, s), s;
          }
          parseExport(e, s) {
            if (this.match(83)) {
              this.next();
              let i = e, r = null;
              return this.isContextual(130) && this.isPotentialImportPhase(false) ? r = this.parseMaybeImportPhase(i, false) : i.importKind = "value", this.tsParseImportEqualsDeclaration(i, r, true);
            } else if (this.eat(29)) {
              let i = e;
              return i.expression = super.parseExpression(), this.semicolon(), this.sawUnambiguousESM = true, this.finishNode(i, "TSExportAssignment");
            } else if (this.eatContextual(93)) {
              let i = e;
              return this.expectContextual(128), i.id = this.parseIdentifier(), this.semicolon(), this.finishNode(i, "TSNamespaceExportDeclaration");
            } else return super.parseExport(e, s);
          }
          isAbstractClass() {
            return this.isContextual(124) && this.lookahead().type === 80;
          }
          parseExportDefaultExpression() {
            if (this.isAbstractClass()) {
              let e = this.startNode();
              return this.next(), e.abstract = true, this.parseClass(e, true, true);
            }
            if (this.match(129)) {
              let e = this.tsParseInterfaceDeclaration(this.startNode());
              if (e) return e;
            }
            return super.parseExportDefaultExpression();
          }
          parseVarStatement(e, s, i = false) {
            let { isAmbientContext: r } = this.state, n = super.parseVarStatement(e, s, i || r);
            if (!r) return n;
            for (let { id: o, init: h } of n.declarations) h && (s !== "const" || o.typeAnnotation ? this.raise(x2.InitializerNotAllowedInAmbientContext, h) : Qi(h, this.hasPlugin("estree")) || this.raise(x2.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, h));
            return n;
          }
          parseStatementContent(e, s) {
            if (this.match(75) && this.isLookaheadContextual("enum")) {
              let i = this.startNode();
              return this.expect(75), this.tsParseEnumDeclaration(i, { const: true });
            }
            if (this.isContextual(126)) return this.tsParseEnumDeclaration(this.startNode());
            if (this.isContextual(129)) {
              let i = this.tsParseInterfaceDeclaration(this.startNode());
              if (i) return i;
            }
            return super.parseStatementContent(e, s);
          }
          parseAccessModifier() {
            return this.tsParseModifier(["public", "protected", "private"]);
          }
          tsHasSomeModifiers(e, s) {
            return s.some((i) => $t2(i) ? e.accessibility === i : !!e[i]);
          }
          tsIsStartOfStaticBlocks() {
            return this.isContextual(106) && this.lookaheadCharCode() === 123;
          }
          parseClassMember(e, s, i) {
            let r = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
            this.tsParseModifiers({ allowedModifiers: r, disallowedModifiers: ["in", "out"], stopOnStartOfClassStaticBlock: true, errorTemplate: x2.InvalidModifierOnTypeParameterPositions }, s);
            let n = () => {
              this.tsIsStartOfStaticBlocks() ? (this.next(), this.next(), this.tsHasSomeModifiers(s, r) && this.raise(x2.StaticBlockCannotHaveModifier, this.state.curPosition()), super.parseClassStaticBlock(e, s)) : this.parseClassMemberWithIsStatic(e, s, i, !!s.static);
            };
            s.declare ? this.tsInAmbientContext(n) : n();
          }
          parseClassMemberWithIsStatic(e, s, i, r) {
            let n = this.tsTryParseIndexSignature(s);
            if (n) {
              e.body.push(n), s.abstract && this.raise(x2.IndexSignatureHasAbstract, s), s.accessibility && this.raise(x2.IndexSignatureHasAccessibility, s, { modifier: s.accessibility }), s.declare && this.raise(x2.IndexSignatureHasDeclare, s), s.override && this.raise(x2.IndexSignatureHasOverride, s);
              return;
            }
            !this.state.inAbstractClass && s.abstract && this.raise(x2.NonAbstractClassHasAbstractMethod, s), s.override && (i.hadSuperClass || this.raise(x2.OverrideNotInSubClass, s)), super.parseClassMemberWithIsStatic(e, s, i, r);
          }
          parsePostMemberNameModifiers(e) {
            this.eat(17) && (e.optional = true), e.readonly && this.match(10) && this.raise(x2.ClassMethodHasReadonly, e), e.declare && this.match(10) && this.raise(x2.ClassMethodHasDeclare, e);
          }
          parseExpressionStatement(e, s, i) {
            return (s.type === "Identifier" ? this.tsParseExpressionStatement(e, s, i) : void 0) || super.parseExpressionStatement(e, s, i);
          }
          shouldParseExportDeclaration() {
            return this.tsIsDeclarationStart() ? true : super.shouldParseExportDeclaration();
          }
          parseConditional(e, s, i) {
            if (!this.state.maybeInArrowParameters || !this.match(17)) return super.parseConditional(e, s, i);
            let r = this.tryParse(() => super.parseConditional(e, s));
            return r.node ? (r.error && (this.state = r.failState), r.node) : (r.error && super.setOptionalParametersError(i, r.error), e);
          }
          parseParenItem(e, s) {
            let i = super.parseParenItem(e, s);
            if (this.eat(17) && (i.optional = true, this.resetEndLocation(e)), this.match(14)) {
              let r = this.startNodeAt(s);
              return r.expression = e, r.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(r, "TSTypeCastExpression");
            }
            return e;
          }
          parseExportDeclaration(e) {
            if (!this.state.isAmbientContext && this.isContextual(125)) return this.tsInAmbientContext(() => this.parseExportDeclaration(e));
            let s = this.state.startLoc, i = this.eatContextual(125);
            if (i && (this.isContextual(125) || !this.shouldParseExportDeclaration())) throw this.raise(x2.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
            let n = w(this.state.type) && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(e);
            return n ? ((n.type === "TSInterfaceDeclaration" || n.type === "TSTypeAliasDeclaration" || i) && (e.exportKind = "type"), i && (this.resetStartLocation(n, s), n.declare = true), n) : null;
          }
          parseClassId(e, s, i, r) {
            if ((!s || i) && this.isContextual(113)) return;
            super.parseClassId(e, s, i, e.declare ? 1024 : 8331);
            let n = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
            n && (e.typeParameters = n);
          }
          parseClassPropertyAnnotation(e) {
            e.optional || (this.eat(35) ? e.definite = true : this.eat(17) && (e.optional = true));
            let s = this.tsTryParseTypeAnnotation();
            s && (e.typeAnnotation = s);
          }
          parseClassProperty(e) {
            if (this.parseClassPropertyAnnotation(e), this.state.isAmbientContext && !(e.readonly && !e.typeAnnotation) && this.match(29) && this.raise(x2.DeclareClassFieldHasInitializer, this.state.startLoc), e.abstract && this.match(29)) {
              let { key: s } = e;
              this.raise(x2.AbstractPropertyHasInitializer, this.state.startLoc, { propertyName: s.type === "Identifier" && !e.computed ? s.name : `[${this.input.slice(s.start, s.end)}]` });
            }
            return super.parseClassProperty(e);
          }
          parseClassPrivateProperty(e) {
            return e.abstract && this.raise(x2.PrivateElementHasAbstract, e), e.accessibility && this.raise(x2.PrivateElementHasAccessibility, e, { modifier: e.accessibility }), this.parseClassPropertyAnnotation(e), super.parseClassPrivateProperty(e);
          }
          parseClassAccessorProperty(e) {
            return this.parseClassPropertyAnnotation(e), e.optional && this.raise(x2.AccessorCannotBeOptional, e), super.parseClassAccessorProperty(e);
          }
          pushClassMethod(e, s, i, r, n, o) {
            let h = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            h && n && this.raise(x2.ConstructorHasTypeParameters, h);
            let { declare: c2 = false, kind: l } = s;
            c2 && (l === "get" || l === "set") && this.raise(x2.DeclareAccessor, s, { kind: l }), h && (s.typeParameters = h), super.pushClassMethod(e, s, i, r, n, o);
          }
          pushClassPrivateMethod(e, s, i, r) {
            let n = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            n && (s.typeParameters = n), super.pushClassPrivateMethod(e, s, i, r);
          }
          declareClassPrivateMethodInScope(e, s) {
            e.type !== "TSDeclareMethod" && (e.type === "MethodDefinition" && !hasOwnProperty.call(e.value, "body") || super.declareClassPrivateMethodInScope(e, s));
          }
          parseClassSuper(e) {
            super.parseClassSuper(e), e.superClass && (this.match(47) || this.match(51)) && (e.superTypeParameters = this.tsParseTypeArgumentsInExpression()), this.eatContextual(113) && (e.implements = this.tsParseHeritageClause("implements"));
          }
          parseObjPropValue(e, s, i, r, n, o, h) {
            let c2 = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            return c2 && (e.typeParameters = c2), super.parseObjPropValue(e, s, i, r, n, o, h);
          }
          parseFunctionParams(e, s) {
            let i = this.tsTryParseTypeParameters(this.tsParseConstModifier);
            i && (e.typeParameters = i), super.parseFunctionParams(e, s);
          }
          parseVarId(e, s) {
            super.parseVarId(e, s), e.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35) && (e.definite = true);
            let i = this.tsTryParseTypeAnnotation();
            i && (e.id.typeAnnotation = i, this.resetEndLocation(e.id));
          }
          parseAsyncArrowFromCallExpression(e, s) {
            return this.match(14) && (e.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(e, s);
          }
          parseMaybeAssign(e, s) {
            var i, r, n, o, h;
            let c2, l, u;
            if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
              if (c2 = this.state.clone(), l = this.tryParse(() => super.parseMaybeAssign(e, s), c2), !l.error) return l.node;
              let { context: y2 } = this.state, E = y2[y2.length - 1];
              (E === C.j_oTag || E === C.j_expr) && y2.pop();
            }
            if (!((i = l) != null && i.error) && !this.match(47)) return super.parseMaybeAssign(e, s);
            (!c2 || c2 === this.state) && (c2 = this.state.clone());
            let f, d = this.tryParse((y2) => {
              var E, L2;
              f = this.tsParseTypeParameters(this.tsParseConstModifier);
              let S2 = super.parseMaybeAssign(e, s);
              return (S2.type !== "ArrowFunctionExpression" || (E = S2.extra) != null && E.parenthesized) && y2(), ((L2 = f) == null ? void 0 : L2.params.length) !== 0 && this.resetStartLocationFromNode(S2, f), S2.typeParameters = f, S2;
            }, c2);
            if (!d.error && !d.aborted) return f && this.reportReservedArrowTypeParam(f), d.node;
            if (!l && (jt2(!this.hasPlugin("jsx")), u = this.tryParse(() => super.parseMaybeAssign(e, s), c2), !u.error)) return u.node;
            if ((r = l) != null && r.node) return this.state = l.failState, l.node;
            if (d.node) return this.state = d.failState, f && this.reportReservedArrowTypeParam(f), d.node;
            if ((n = u) != null && n.node) return this.state = u.failState, u.node;
            throw ((o = l) == null ? void 0 : o.error) || d.error || ((h = u) == null ? void 0 : h.error);
          }
          reportReservedArrowTypeParam(e) {
            var s;
            e.params.length === 1 && !e.params[0].constraint && !((s = e.extra) != null && s.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike") && this.raise(x2.ReservedArrowTypeParam, e);
          }
          parseMaybeUnary(e, s) {
            return !this.hasPlugin("jsx") && this.match(47) ? this.tsParseTypeAssertion() : super.parseMaybeUnary(e, s);
          }
          parseArrow(e) {
            if (this.match(14)) {
              let s = this.tryParse((i) => {
                let r = this.tsParseTypeOrTypePredicateAnnotation(14);
                return (this.canInsertSemicolon() || !this.match(19)) && i(), r;
              });
              if (s.aborted) return;
              s.thrown || (s.error && (this.state = s.failState), e.returnType = s.node);
            }
            return super.parseArrow(e);
          }
          parseAssignableListItemTypes(e, s) {
            if (!(s & 2)) return e;
            this.eat(17) && (e.optional = true);
            let i = this.tsTryParseTypeAnnotation();
            return i && (e.typeAnnotation = i), this.resetEndLocation(e), e;
          }
          isAssignable(e, s) {
            switch (e.type) {
              case "TSTypeCastExpression":
                return this.isAssignable(e.expression, s);
              case "TSParameterProperty":
                return true;
              default:
                return super.isAssignable(e, s);
            }
          }
          toAssignable(e, s = false) {
            switch (e.type) {
              case "ParenthesizedExpression":
                this.toAssignableParenthesizedExpression(e, s);
                break;
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "TSNonNullExpression":
              case "TSTypeAssertion":
                s ? this.expressionScope.recordArrowParameterBindingError(x2.UnexpectedTypeCastInParameter, e) : this.raise(x2.UnexpectedTypeCastInParameter, e), this.toAssignable(e.expression, s);
                break;
              case "AssignmentExpression":
                !s && e.left.type === "TSTypeCastExpression" && (e.left = this.typeCastToParameter(e.left));
              default:
                super.toAssignable(e, s);
            }
          }
          toAssignableParenthesizedExpression(e, s) {
            switch (e.expression.type) {
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "TSNonNullExpression":
              case "TSTypeAssertion":
              case "ParenthesizedExpression":
                this.toAssignable(e.expression, s);
                break;
              default:
                super.toAssignable(e, s);
            }
          }
          checkToRestConversion(e, s) {
            switch (e.type) {
              case "TSAsExpression":
              case "TSSatisfiesExpression":
              case "TSTypeAssertion":
              case "TSNonNullExpression":
                this.checkToRestConversion(e.expression, false);
                break;
              default:
                super.checkToRestConversion(e, s);
            }
          }
          isValidLVal(e, s, i) {
            return Hi({ TSTypeCastExpression: true, TSParameterProperty: "parameter", TSNonNullExpression: "expression", TSInstantiationExpression: "expression", TSAsExpression: (i !== 64 || !s) && ["expression", true], TSSatisfiesExpression: (i !== 64 || !s) && ["expression", true], TSTypeAssertion: (i !== 64 || !s) && ["expression", true] }, e) || super.isValidLVal(e, s, i);
          }
          parseBindingAtom() {
            return this.state.type === 78 ? this.parseIdentifier(true) : super.parseBindingAtom();
          }
          parseMaybeDecoratorArguments(e) {
            if (this.match(47) || this.match(51)) {
              let s = this.tsParseTypeArgumentsInExpression();
              if (this.match(10)) {
                let i = super.parseMaybeDecoratorArguments(e);
                return i.typeParameters = s, i;
              }
              this.unexpected(null, 10);
            }
            return super.parseMaybeDecoratorArguments(e);
          }
          checkCommaAfterRest(e) {
            return this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === e ? (this.next(), false) : super.checkCommaAfterRest(e);
          }
          isClassMethod() {
            return this.match(47) || super.isClassMethod();
          }
          isClassProperty() {
            return this.match(35) || this.match(14) || super.isClassProperty();
          }
          parseMaybeDefault(e, s) {
            let i = super.parseMaybeDefault(e, s);
            return i.type === "AssignmentPattern" && i.typeAnnotation && i.right.start < i.typeAnnotation.start && this.raise(x2.TypeAnnotationAfterAssign, i.typeAnnotation), i;
          }
          getTokenFromCode(e) {
            if (this.state.inType) {
              if (e === 62) {
                this.finishOp(48, 1);
                return;
              }
              if (e === 60) {
                this.finishOp(47, 1);
                return;
              }
            }
            super.getTokenFromCode(e);
          }
          reScan_lt_gt() {
            let { type: e } = this.state;
            e === 47 ? (this.state.pos -= 1, this.readToken_lt()) : e === 48 && (this.state.pos -= 1, this.readToken_gt());
          }
          reScan_lt() {
            let { type: e } = this.state;
            return e === 51 ? (this.state.pos -= 2, this.finishOp(47, 1), 47) : e;
          }
          toAssignableList(e, s, i) {
            for (let r = 0; r < e.length; r++) {
              let n = e[r];
              (n == null ? void 0 : n.type) === "TSTypeCastExpression" && (e[r] = this.typeCastToParameter(n));
            }
            super.toAssignableList(e, s, i);
          }
          typeCastToParameter(e) {
            return e.expression.typeAnnotation = e.typeAnnotation, this.resetEndLocation(e.expression, e.typeAnnotation.loc.end), e.expression;
          }
          shouldParseArrow(e) {
            return this.match(14) ? e.every((s) => this.isAssignable(s, true)) : super.shouldParseArrow(e);
          }
          shouldParseAsyncArrow() {
            return this.match(14) || super.shouldParseAsyncArrow();
          }
          canHaveLeadingDecorator() {
            return super.canHaveLeadingDecorator() || this.isAbstractClass();
          }
          jsxParseOpeningElementAfterName(e) {
            if (this.match(47) || this.match(51)) {
              let s = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
              s && (e.typeParameters = s);
            }
            return super.jsxParseOpeningElementAfterName(e);
          }
          getGetterSetterExpectedParamCount(e) {
            let s = super.getGetterSetterExpectedParamCount(e), r = this.getObjectOrClassMethodParams(e)[0];
            return r && this.isThisParam(r) ? s + 1 : s;
          }
          parseCatchClauseParam() {
            let e = super.parseCatchClauseParam(), s = this.tsTryParseTypeAnnotation();
            return s && (e.typeAnnotation = s, this.resetEndLocation(e)), e;
          }
          tsInAmbientContext(e) {
            let { isAmbientContext: s, strict: i } = this.state;
            this.state.isAmbientContext = true, this.state.strict = false;
            try {
              return e();
            } finally {
              this.state.isAmbientContext = s, this.state.strict = i;
            }
          }
          parseClass(e, s, i) {
            let r = this.state.inAbstractClass;
            this.state.inAbstractClass = !!e.abstract;
            try {
              return super.parseClass(e, s, i);
            } finally {
              this.state.inAbstractClass = r;
            }
          }
          tsParseAbstractDeclaration(e, s) {
            if (this.match(80)) return e.abstract = true, this.maybeTakeDecorators(s, this.parseClass(e, true, false));
            if (this.isContextual(129)) {
              if (!this.hasFollowingLineBreak()) return e.abstract = true, this.raise(x2.NonClassMethodPropertyHasAbstractModifer, e), this.tsParseInterfaceDeclaration(e);
            } else this.unexpected(null, 80);
          }
          parseMethod(e, s, i, r, n, o, h) {
            let c2 = super.parseMethod(e, s, i, r, n, o, h);
            if (c2.abstract && (this.hasPlugin("estree") ? !!c2.value.body : !!c2.body)) {
              let { key: u } = c2;
              this.raise(x2.AbstractMethodHasImplementation, c2, { methodName: u.type === "Identifier" && !c2.computed ? u.name : `[${this.input.slice(u.start, u.end)}]` });
            }
            return c2;
          }
          tsParseTypeParameterName() {
            return this.parseIdentifier().name;
          }
          shouldParseAsAmbientContext() {
            return !!this.getPluginOption("typescript", "dts");
          }
          parse() {
            return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.parse();
          }
          getExpression() {
            return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.getExpression();
          }
          parseExportSpecifier(e, s, i, r) {
            return !s && r ? (this.parseTypeOnlyImportExportSpecifier(e, false, i), this.finishNode(e, "ExportSpecifier")) : (e.exportKind = "value", super.parseExportSpecifier(e, s, i, r));
          }
          parseImportSpecifier(e, s, i, r, n) {
            return !s && r ? (this.parseTypeOnlyImportExportSpecifier(e, true, i), this.finishNode(e, "ImportSpecifier")) : (e.importKind = "value", super.parseImportSpecifier(e, s, i, r, i ? 4098 : 4096));
          }
          parseTypeOnlyImportExportSpecifier(e, s, i) {
            let r = s ? "imported" : "local", n = s ? "local" : "exported", o = e[r], h, c2 = false, l = true, u = o.loc.start;
            if (this.isContextual(93)) {
              let d = this.parseIdentifier();
              if (this.isContextual(93)) {
                let y2 = this.parseIdentifier();
                M2(this.state.type) ? (c2 = true, o = d, h = s ? this.parseIdentifier() : this.parseModuleExportName(), l = false) : (h = y2, l = false);
              } else M2(this.state.type) ? (l = false, h = s ? this.parseIdentifier() : this.parseModuleExportName()) : (c2 = true, o = d);
            } else M2(this.state.type) && (c2 = true, s ? (o = this.parseIdentifier(true), this.isContextual(93) || this.checkReservedWord(o.name, o.loc.start, true, true)) : o = this.parseModuleExportName());
            c2 && i && this.raise(s ? x2.TypeModifierIsUsedInTypeImports : x2.TypeModifierIsUsedInTypeExports, u), e[r] = o, e[n] = h;
            let f = s ? "importKind" : "exportKind";
            e[f] = c2 ? "type" : "value", l && this.eatContextual(93) && (e[n] = s ? this.parseIdentifier() : this.parseModuleExportName()), e[n] || (e[n] = $(e[r])), s && this.checkIdentifier(e[n], c2 ? 4098 : 4096);
          }
        };
        function Yi(a) {
          if (a.type !== "MemberExpression") return false;
          let { computed: t, property: e } = a;
          return t && e.type !== "StringLiteral" && (e.type !== "TemplateLiteral" || e.expressions.length > 0) ? false : os(a.object);
        }
        function Qi(a, t) {
          var e;
          let { type: s } = a;
          if ((e = a.extra) != null && e.parenthesized) return false;
          if (t) {
            if (s === "Literal") {
              let { value: i } = a;
              if (typeof i == "string" || typeof i == "boolean") return true;
            }
          } else if (s === "StringLiteral" || s === "BooleanLiteral") return true;
          return !!(ns(a, t) || Zi(a, t) || s === "TemplateLiteral" && a.expressions.length === 0 || Yi(a));
        }
        function ns(a, t) {
          return t ? a.type === "Literal" && (typeof a.value == "number" || "bigint" in a) : a.type === "NumericLiteral" || a.type === "BigIntLiteral";
        }
        function Zi(a, t) {
          if (a.type === "UnaryExpression") {
            let { operator: e, argument: s } = a;
            if (e === "-" && ns(s, t)) return true;
          }
          return false;
        }
        function os(a) {
          return a.type === "Identifier" ? true : a.type !== "MemberExpression" || a.computed ? false : os(a.object);
        }
        var Vt2 = j2`placeholders`({ ClassNameIsRequired: "A class name is required.", UnexpectedSpace: "Unexpected space in placeholder." }), er2 = (a) => class extends a {
          parsePlaceholder(e) {
            if (this.match(144)) {
              let s = this.startNode();
              return this.next(), this.assertNoSpace(), s.name = super.parseIdentifier(true), this.assertNoSpace(), this.expect(144), this.finishPlaceholder(s, e);
            }
          }
          finishPlaceholder(e, s) {
            let i = e;
            return (!i.expectedNode || !i.type) && (i = this.finishNode(i, "Placeholder")), i.expectedNode = s, i;
          }
          getTokenFromCode(e) {
            e === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(144, 2) : super.getTokenFromCode(e);
          }
          parseExprAtom(e) {
            return this.parsePlaceholder("Expression") || super.parseExprAtom(e);
          }
          parseIdentifier(e) {
            return this.parsePlaceholder("Identifier") || super.parseIdentifier(e);
          }
          checkReservedWord(e, s, i, r) {
            e !== void 0 && super.checkReservedWord(e, s, i, r);
          }
          parseBindingAtom() {
            return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
          }
          isValidLVal(e, s, i) {
            return e === "Placeholder" || super.isValidLVal(e, s, i);
          }
          toAssignable(e, s) {
            e && e.type === "Placeholder" && e.expectedNode === "Expression" ? e.expectedNode = "Pattern" : super.toAssignable(e, s);
          }
          chStartsBindingIdentifier(e, s) {
            return !!(super.chStartsBindingIdentifier(e, s) || this.lookahead().type === 144);
          }
          verifyBreakContinue(e, s) {
            e.label && e.label.type === "Placeholder" || super.verifyBreakContinue(e, s);
          }
          parseExpressionStatement(e, s) {
            var i;
            if (s.type !== "Placeholder" || (i = s.extra) != null && i.parenthesized) return super.parseExpressionStatement(e, s);
            if (this.match(14)) {
              let n = e;
              return n.label = this.finishPlaceholder(s, "Identifier"), this.next(), n.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration(), this.finishNode(n, "LabeledStatement");
            }
            this.semicolon();
            let r = e;
            return r.name = s.name, this.finishPlaceholder(r, "Statement");
          }
          parseBlock(e, s, i) {
            return this.parsePlaceholder("BlockStatement") || super.parseBlock(e, s, i);
          }
          parseFunctionId(e) {
            return this.parsePlaceholder("Identifier") || super.parseFunctionId(e);
          }
          parseClass(e, s, i) {
            let r = s ? "ClassDeclaration" : "ClassExpression";
            this.next();
            let n = this.state.strict, o = this.parsePlaceholder("Identifier");
            if (o) if (this.match(81) || this.match(144) || this.match(5)) e.id = o;
            else {
              if (i || !s) return e.id = null, e.body = this.finishPlaceholder(o, "ClassBody"), this.finishNode(e, r);
              throw this.raise(Vt2.ClassNameIsRequired, this.state.startLoc);
            }
            else this.parseClassId(e, s, i);
            return super.parseClassSuper(e), e.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!e.superClass, n), this.finishNode(e, r);
          }
          parseExport(e, s) {
            let i = this.parsePlaceholder("Identifier");
            if (!i) return super.parseExport(e, s);
            let r = e;
            if (!this.isContextual(98) && !this.match(12)) return r.specifiers = [], r.source = null, r.declaration = this.finishPlaceholder(i, "Declaration"), this.finishNode(r, "ExportNamedDeclaration");
            this.expectPlugin("exportDefaultFrom");
            let n = this.startNode();
            return n.exported = i, r.specifiers = [this.finishNode(n, "ExportDefaultSpecifier")], super.parseExport(r, s);
          }
          isExportDefaultSpecifier() {
            if (this.match(65)) {
              let e = this.nextTokenStart();
              if (this.isUnparsedContextual(e, "from") && this.input.startsWith(K2(144), this.nextTokenStartSince(e + 4))) return true;
            }
            return super.isExportDefaultSpecifier();
          }
          maybeParseExportDefaultSpecifier(e, s) {
            var i;
            return (i = e.specifiers) != null && i.length ? true : super.maybeParseExportDefaultSpecifier(e, s);
          }
          checkExport(e) {
            let { specifiers: s } = e;
            s != null && s.length && (e.specifiers = s.filter((i) => i.exported.type === "Placeholder")), super.checkExport(e), e.specifiers = s;
          }
          parseImport(e) {
            let s = this.parsePlaceholder("Identifier");
            if (!s) return super.parseImport(e);
            if (e.specifiers = [], !this.isContextual(98) && !this.match(12)) return e.source = this.finishPlaceholder(s, "StringLiteral"), this.semicolon(), this.finishNode(e, "ImportDeclaration");
            let i = this.startNodeAtNode(s);
            return i.local = s, e.specifiers.push(this.finishNode(i, "ImportDefaultSpecifier")), this.eat(12) && (this.maybeParseStarImportSpecifier(e) || this.parseNamedImportSpecifiers(e)), this.expectContextual(98), e.source = this.parseImportSource(), this.semicolon(), this.finishNode(e, "ImportDeclaration");
          }
          parseImportSource() {
            return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
          }
          assertNoSpace() {
            this.state.start > this.state.lastTokEndLoc.index && this.raise(Vt2.UnexpectedSpace, this.state.lastTokEndLoc);
          }
        }, tr2 = (a) => class extends a {
          parseV8Intrinsic() {
            if (this.match(54)) {
              let e = this.state.startLoc, s = this.startNode();
              if (this.next(), w(this.state.type)) {
                let i = this.parseIdentifierName(), r = this.createIdentifier(s, i);
                if (r.type = "V8IntrinsicIdentifier", this.match(10)) return r;
              }
              this.unexpected(e);
            }
          }
          parseExprAtom(e) {
            return this.parseV8Intrinsic() || super.parseExprAtom(e);
          }
        };
        function N2(a, t) {
          let [e, s] = typeof t == "string" ? [t, {}] : t, i = Object.keys(s), r = i.length === 0;
          return a.some((n) => {
            if (typeof n == "string") return r && n === e;
            {
              let [o, h] = n;
              if (o !== e) return false;
              for (let c2 of i) if (h[c2] !== s[c2]) return false;
              return true;
            }
          });
        }
        function J2(a, t, e) {
          let s = a.find((i) => Array.isArray(i) ? i[0] === t : i === t);
          return s && Array.isArray(s) && s.length > 1 ? s[1][e] : null;
        }
        var qt2 = ["minimal", "fsharp", "hack", "smart"], zt2 = ["^^", "@@", "^", "%", "#"];
        function sr2(a) {
          if (N2(a, "decorators")) {
            if (N2(a, "decorators-legacy")) throw new Error("Cannot use the decorators and decorators-legacy plugin together");
            let t = J2(a, "decorators", "decoratorsBeforeExport");
            if (t != null && typeof t != "boolean") throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
            let e = J2(a, "decorators", "allowCallParenthesized");
            if (e != null && typeof e != "boolean") throw new Error("'allowCallParenthesized' must be a boolean.");
          }
          if (N2(a, "flow") && N2(a, "typescript")) throw new Error("Cannot combine flow and typescript plugins.");
          if (N2(a, "placeholders") && N2(a, "v8intrinsic")) throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
          if (N2(a, "pipelineOperator")) {
            let t = J2(a, "pipelineOperator", "proposal");
            if (!qt2.includes(t)) {
              let i = qt2.map((r) => `"${r}"`).join(", ");
              throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${i}.`);
            }
            let e = ["recordAndTuple", { syntaxType: "hash" }], s = N2(a, e);
            if (t === "hack") {
              if (N2(a, "placeholders")) throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
              if (N2(a, "v8intrinsic")) throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
              let i = J2(a, "pipelineOperator", "topicToken");
              if (!zt2.includes(i)) {
                let r = zt2.map((n) => `"${n}"`).join(", ");
                throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${r}.`);
              }
              if (i === "#" && s) throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(e)}\`.`);
            } else if (t === "smart" && s) throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(e)}\`.`);
          }
          if (N2(a, "moduleAttributes")) {
            if (N2(a, "importAssertions") || N2(a, "importAttributes")) throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
            if (J2(a, "moduleAttributes", "version") !== "may-2020") throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
          }
          if (N2(a, "importAssertions") && N2(a, "importAttributes")) throw new Error("Cannot combine importAssertions and importAttributes plugins.");
          if (N2(a, "recordAndTuple")) {
            let t = J2(a, "recordAndTuple", "syntaxType");
            if (t != null) {
              let e = ["hash", "bar"];
              if (!e.includes(t)) throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + e.map((s) => `'${s}'`).join(", "));
            }
          }
          if (N2(a, "asyncDoExpressions") && !N2(a, "doExpressions")) {
            let t = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
            throw t.missingPlugins = "doExpressions", t;
          }
          if (N2(a, "optionalChainingAssign") && J2(a, "optionalChainingAssign", "version") !== "2023-07") throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
        }
        var hs = { estree: ri2, jsx: zi, flow: qi, typescript: Gi, v8intrinsic: tr2, placeholders: er2 }, ir2 = Object.keys(hs), qe2 = { sourceType: "script", sourceFilename: void 0, startColumn: 0, startLine: 1, allowAwaitOutsideFunction: false, allowReturnOutsideFunction: false, allowNewTargetOutsideFunction: false, allowImportExportEverywhere: false, allowSuperOutsideMethod: false, allowUndeclaredExports: false, plugins: [], strictMode: null, ranges: false, tokens: false, createImportExpressions: false, createParenthesizedExpressions: false, errorRecovery: false, attachComment: true, annexB: true };
        function rr2(a) {
          if (a == null) return Object.assign({}, qe2);
          if (a.annexB != null && a.annexB !== false) throw new Error("The `annexB` option can only be set to `false`.");
          let t = {};
          for (let s of Object.keys(qe2)) {
            var e;
            t[s] = (e = a[s]) != null ? e : qe2[s];
          }
          return t;
        }
        var ct2 = class extends lt2 {
          checkProto(t, e, s, i) {
            if (t.type === "SpreadElement" || this.isObjectMethod(t) || t.computed || t.shorthand) return;
            let r = t.key;
            if ((r.type === "Identifier" ? r.name : r.value) === "__proto__") {
              if (e) {
                this.raise(p.RecordNoProto, r);
                return;
              }
              s.used && (i ? i.doubleProtoLoc === null && (i.doubleProtoLoc = r.loc.start) : this.raise(p.DuplicateProto, r)), s.used = true;
            }
          }
          shouldExitDescending(t, e) {
            return t.type === "ArrowFunctionExpression" && t.start === e;
          }
          getExpression() {
            this.enterInitialScopes(), this.nextToken();
            let t = this.parseExpression();
            return this.match(139) || this.unexpected(), this.finalizeRemainingComments(), t.comments = this.comments, t.errors = this.state.errors, this.options.tokens && (t.tokens = this.tokens), t;
          }
          parseExpression(t, e) {
            return t ? this.disallowInAnd(() => this.parseExpressionBase(e)) : this.allowInAnd(() => this.parseExpressionBase(e));
          }
          parseExpressionBase(t) {
            let e = this.state.startLoc, s = this.parseMaybeAssign(t);
            if (this.match(12)) {
              let i = this.startNodeAt(e);
              for (i.expressions = [s]; this.eat(12); ) i.expressions.push(this.parseMaybeAssign(t));
              return this.toReferencedList(i.expressions), this.finishNode(i, "SequenceExpression");
            }
            return s;
          }
          parseMaybeAssignDisallowIn(t, e) {
            return this.disallowInAnd(() => this.parseMaybeAssign(t, e));
          }
          parseMaybeAssignAllowIn(t, e) {
            return this.allowInAnd(() => this.parseMaybeAssign(t, e));
          }
          setOptionalParametersError(t, e) {
            var s;
            t.optionalParametersLoc = (s = e == null ? void 0 : e.loc) != null ? s : this.state.startLoc;
          }
          parseMaybeAssign(t, e) {
            let s = this.state.startLoc;
            if (this.isContextual(108) && this.prodParam.hasYield) {
              let o = this.parseYield();
              return e && (o = e.call(this, o, s)), o;
            }
            let i;
            t ? i = false : (t = new Z2(), i = true);
            let { type: r } = this.state;
            (r === 10 || w(r)) && (this.state.potentialArrowAt = this.state.start);
            let n = this.parseMaybeConditional(t);
            if (e && (n = e.call(this, n, s)), li2(this.state.type)) {
              let o = this.startNodeAt(s), h = this.state.value;
              if (o.operator = h, this.match(29)) {
                this.toAssignable(n, true), o.left = n;
                let c2 = s.index;
                t.doubleProtoLoc != null && t.doubleProtoLoc.index >= c2 && (t.doubleProtoLoc = null), t.shorthandAssignLoc != null && t.shorthandAssignLoc.index >= c2 && (t.shorthandAssignLoc = null), t.privateKeyLoc != null && t.privateKeyLoc.index >= c2 && (this.checkDestructuringPrivate(t), t.privateKeyLoc = null);
              } else o.left = n;
              return this.next(), o.right = this.parseMaybeAssign(), this.checkLVal(n, { in: this.finishNode(o, "AssignmentExpression") }), o;
            } else i && this.checkExpressionErrors(t, true);
            return n;
          }
          parseMaybeConditional(t) {
            let e = this.state.startLoc, s = this.state.potentialArrowAt, i = this.parseExprOps(t);
            return this.shouldExitDescending(i, s) ? i : this.parseConditional(i, e, t);
          }
          parseConditional(t, e, s) {
            if (this.eat(17)) {
              let i = this.startNodeAt(e);
              return i.test = t, i.consequent = this.parseMaybeAssignAllowIn(), this.expect(14), i.alternate = this.parseMaybeAssign(), this.finishNode(i, "ConditionalExpression");
            }
            return t;
          }
          parseMaybeUnaryOrPrivate(t) {
            return this.match(138) ? this.parsePrivateName() : this.parseMaybeUnary(t);
          }
          parseExprOps(t) {
            let e = this.state.startLoc, s = this.state.potentialArrowAt, i = this.parseMaybeUnaryOrPrivate(t);
            return this.shouldExitDescending(i, s) ? i : this.parseExprOp(i, e, -1);
          }
          parseExprOp(t, e, s) {
            if (this.isPrivateName(t)) {
              let r = this.getPrivateNameSV(t);
              (s >= Ie2(58) || !this.prodParam.hasIn || !this.match(58)) && this.raise(p.PrivateInExpectedIn, t, { identifierName: r }), this.classScope.usePrivateName(r, t.loc.start);
            }
            let i = this.state.type;
            if (pi2(i) && (this.prodParam.hasIn || !this.match(58))) {
              let r = Ie2(i);
              if (r > s) {
                if (i === 39) {
                  if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody) return t;
                  this.checkPipelineAtInfixOperator(t, e);
                }
                let n = this.startNodeAt(e);
                n.left = t, n.operator = this.state.value;
                let o = i === 41 || i === 42, h = i === 40;
                if (h && (r = Ie2(42)), this.next(), i === 39 && this.hasPlugin(["pipelineOperator", { proposal: "minimal" }]) && this.state.type === 96 && this.prodParam.hasAwait) throw this.raise(p.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
                n.right = this.parseExprOpRightExpr(i, r);
                let c2 = this.finishNode(n, o || h ? "LogicalExpression" : "BinaryExpression"), l = this.state.type;
                if (h && (l === 41 || l === 42) || o && l === 40) throw this.raise(p.MixingCoalesceWithLogical, this.state.startLoc);
                return this.parseExprOp(c2, e, s);
              }
            }
            return t;
          }
          parseExprOpRightExpr(t, e) {
            let s = this.state.startLoc;
            switch (t) {
              case 39:
                switch (this.getPluginOption("pipelineOperator", "proposal")) {
                  case "hack":
                    return this.withTopicBindingContext(() => this.parseHackPipeBody());
                  case "smart":
                    return this.withTopicBindingContext(() => {
                      if (this.prodParam.hasYield && this.isContextual(108)) throw this.raise(p.PipeBodyIsTighter, this.state.startLoc);
                      return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(t, e), s);
                    });
                  case "fsharp":
                    return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(e));
                }
              default:
                return this.parseExprOpBaseRightExpr(t, e);
            }
          }
          parseExprOpBaseRightExpr(t, e) {
            let s = this.state.startLoc;
            return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), s, yi(t) ? e - 1 : e);
          }
          parseHackPipeBody() {
            var t;
            let { startLoc: e } = this.state, s = this.parseMaybeAssign();
            return Qs.has(s.type) && !((t = s.extra) != null && t.parenthesized) && this.raise(p.PipeUnparenthesizedBody, e, { type: s.type }), this.topicReferenceWasUsedInCurrentContext() || this.raise(p.PipeTopicUnused, e), s;
          }
          checkExponentialAfterUnary(t) {
            this.match(57) && this.raise(p.UnexpectedTokenUnaryExponentiation, t.argument);
          }
          parseMaybeUnary(t, e) {
            let s = this.state.startLoc, i = this.isContextual(96);
            if (i && this.isAwaitAllowed()) {
              this.next();
              let h = this.parseAwait(s);
              return e || this.checkExponentialAfterUnary(h), h;
            }
            let r = this.match(34), n = this.startNode();
            if (fi2(this.state.type)) {
              n.operator = this.state.value, n.prefix = true, this.match(72) && this.expectPlugin("throwExpressions");
              let h = this.match(89);
              if (this.next(), n.argument = this.parseMaybeUnary(null, true), this.checkExpressionErrors(t, true), this.state.strict && h) {
                let c2 = n.argument;
                c2.type === "Identifier" ? this.raise(p.StrictDelete, n) : this.hasPropertyAsPrivateName(c2) && this.raise(p.DeletePrivateField, n);
              }
              if (!r) return e || this.checkExponentialAfterUnary(n), this.finishNode(n, "UnaryExpression");
            }
            let o = this.parseUpdate(n, r, t);
            if (i) {
              let { type: h } = this.state;
              if ((this.hasPlugin("v8intrinsic") ? He2(h) : He2(h) && !this.match(54)) && !this.isAmbiguousAwait()) return this.raiseOverwrite(p.AwaitNotInAsyncContext, s), this.parseAwait(s);
            }
            return o;
          }
          parseUpdate(t, e, s) {
            if (e) {
              let n = t;
              return this.checkLVal(n.argument, { in: this.finishNode(n, "UpdateExpression") }), t;
            }
            let i = this.state.startLoc, r = this.parseExprSubscripts(s);
            if (this.checkExpressionErrors(s, false)) return r;
            for (; ui2(this.state.type) && !this.canInsertSemicolon(); ) {
              let n = this.startNodeAt(i);
              n.operator = this.state.value, n.prefix = false, n.argument = r, this.next(), this.checkLVal(r, { in: r = this.finishNode(n, "UpdateExpression") });
            }
            return r;
          }
          parseExprSubscripts(t) {
            let e = this.state.startLoc, s = this.state.potentialArrowAt, i = this.parseExprAtom(t);
            return this.shouldExitDescending(i, s) ? i : this.parseSubscripts(i, e);
          }
          parseSubscripts(t, e, s) {
            let i = { optionalChainMember: false, maybeAsyncArrow: this.atPossibleAsyncArrow(t), stop: false };
            do
              t = this.parseSubscript(t, e, s, i), i.maybeAsyncArrow = false;
            while (!i.stop);
            return t;
          }
          parseSubscript(t, e, s, i) {
            let { type: r } = this.state;
            if (!s && r === 15) return this.parseBind(t, e, s, i);
            if (Le2(r)) return this.parseTaggedTemplateExpression(t, e, i);
            let n = false;
            if (r === 18) {
              if (s && (this.raise(p.OptionalChainingNoNew, this.state.startLoc), this.lookaheadCharCode() === 40)) return i.stop = true, t;
              i.optionalChainMember = n = true, this.next();
            }
            if (!s && this.match(10)) return this.parseCoverCallAndAsyncArrowHead(t, e, i, n);
            {
              let o = this.eat(0);
              return o || n || this.eat(16) ? this.parseMember(t, e, i, o, n) : (i.stop = true, t);
            }
          }
          parseMember(t, e, s, i, r) {
            let n = this.startNodeAt(e);
            return n.object = t, n.computed = i, i ? (n.property = this.parseExpression(), this.expect(3)) : this.match(138) ? (t.type === "Super" && this.raise(p.SuperPrivateField, e), this.classScope.usePrivateName(this.state.value, this.state.startLoc), n.property = this.parsePrivateName()) : n.property = this.parseIdentifier(true), s.optionalChainMember ? (n.optional = r, this.finishNode(n, "OptionalMemberExpression")) : this.finishNode(n, "MemberExpression");
          }
          parseBind(t, e, s, i) {
            let r = this.startNodeAt(e);
            return r.object = t, this.next(), r.callee = this.parseNoCallExpr(), i.stop = true, this.parseSubscripts(this.finishNode(r, "BindExpression"), e, s);
          }
          parseCoverCallAndAsyncArrowHead(t, e, s, i) {
            let r = this.state.maybeInArrowParameters, n = null;
            this.state.maybeInArrowParameters = true, this.next();
            let o = this.startNodeAt(e);
            o.callee = t;
            let { maybeAsyncArrow: h, optionalChainMember: c2 } = s;
            h && (this.expressionScope.enter(Fi()), n = new Z2()), c2 && (o.optional = i), i ? o.arguments = this.parseCallExpressionArguments(11) : o.arguments = this.parseCallExpressionArguments(11, t.type === "Import", t.type !== "Super", o, n);
            let l = this.finishCallExpression(o, c2);
            return h && this.shouldParseAsyncArrow() && !i ? (s.stop = true, this.checkDestructuringPrivate(n), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), l = this.parseAsyncArrowFromCallExpression(this.startNodeAt(e), l)) : (h && (this.checkExpressionErrors(n, true), this.expressionScope.exit()), this.toReferencedArguments(l)), this.state.maybeInArrowParameters = r, l;
          }
          toReferencedArguments(t, e) {
            this.toReferencedListDeep(t.arguments, e);
          }
          parseTaggedTemplateExpression(t, e, s) {
            let i = this.startNodeAt(e);
            return i.tag = t, i.quasi = this.parseTemplate(true), s.optionalChainMember && this.raise(p.OptionalChainingNoTemplate, e), this.finishNode(i, "TaggedTemplateExpression");
          }
          atPossibleAsyncArrow(t) {
            return t.type === "Identifier" && t.name === "async" && this.state.lastTokEndLoc.index === t.end && !this.canInsertSemicolon() && t.end - t.start === 5 && t.start === this.state.potentialArrowAt;
          }
          expectImportAttributesPlugin() {
            this.hasPlugin("importAssertions") || this.expectPlugin("importAttributes");
          }
          finishCallExpression(t, e) {
            if (t.callee.type === "Import") if (t.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectImportAttributesPlugin()), t.arguments.length === 0 || t.arguments.length > 2) this.raise(p.ImportCallArity, t, { maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1 });
            else for (let s of t.arguments) s.type === "SpreadElement" && this.raise(p.ImportCallSpreadArgument, s);
            return this.finishNode(t, e ? "OptionalCallExpression" : "CallExpression");
          }
          parseCallExpressionArguments(t, e, s, i, r) {
            let n = [], o = true, h = this.state.inFSharpPipelineDirectBody;
            for (this.state.inFSharpPipelineDirectBody = false; !this.eat(t); ) {
              if (o) o = false;
              else if (this.expect(12), this.match(t)) {
                e && !this.hasPlugin("importAttributes") && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes") && this.raise(p.ImportCallArgumentTrailingComma, this.state.lastTokStartLoc), i && this.addTrailingCommaExtraToNode(i), this.next();
                break;
              }
              n.push(this.parseExprListItem(false, r, s));
            }
            return this.state.inFSharpPipelineDirectBody = h, n;
          }
          shouldParseAsyncArrow() {
            return this.match(19) && !this.canInsertSemicolon();
          }
          parseAsyncArrowFromCallExpression(t, e) {
            var s;
            return this.resetPreviousNodeTrailingComments(e), this.expect(19), this.parseArrowExpression(t, e.arguments, true, (s = e.extra) == null ? void 0 : s.trailingCommaLoc), e.innerComments && ye(t, e.innerComments), e.callee.trailingComments && ye(t, e.callee.trailingComments), t;
          }
          parseNoCallExpr() {
            let t = this.state.startLoc;
            return this.parseSubscripts(this.parseExprAtom(), t, true);
          }
          parseExprAtom(t) {
            let e, s = null, { type: i } = this.state;
            switch (i) {
              case 79:
                return this.parseSuper();
              case 83:
                return e = this.startNode(), this.next(), this.match(16) ? this.parseImportMetaProperty(e) : this.match(10) ? this.options.createImportExpressions ? this.parseImportCall(e) : this.finishNode(e, "Import") : (this.raise(p.UnsupportedImport, this.state.lastTokStartLoc), this.finishNode(e, "Import"));
              case 78:
                return e = this.startNode(), this.next(), this.finishNode(e, "ThisExpression");
              case 90:
                return this.parseDo(this.startNode(), false);
              case 56:
              case 31:
                return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
              case 134:
                return this.parseNumericLiteral(this.state.value);
              case 135:
                return this.parseBigIntLiteral(this.state.value);
              case 136:
                return this.parseDecimalLiteral(this.state.value);
              case 133:
                return this.parseStringLiteral(this.state.value);
              case 84:
                return this.parseNullLiteral();
              case 85:
                return this.parseBooleanLiteral(true);
              case 86:
                return this.parseBooleanLiteral(false);
              case 10: {
                let r = this.state.potentialArrowAt === this.state.start;
                return this.parseParenAndDistinguishExpression(r);
              }
              case 2:
              case 1:
                return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
              case 0:
                return this.parseArrayLike(3, true, false, t);
              case 6:
              case 7:
                return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
              case 5:
                return this.parseObjectLike(8, false, false, t);
              case 68:
                return this.parseFunctionOrFunctionSent();
              case 26:
                s = this.parseDecorators();
              case 80:
                return this.parseClass(this.maybeTakeDecorators(s, this.startNode()), false);
              case 77:
                return this.parseNewOrNewTarget();
              case 25:
              case 24:
                return this.parseTemplate(false);
              case 15: {
                e = this.startNode(), this.next(), e.object = null;
                let r = e.callee = this.parseNoCallExpr();
                if (r.type === "MemberExpression") return this.finishNode(e, "BindExpression");
                throw this.raise(p.UnsupportedBind, r);
              }
              case 138:
                return this.raise(p.PrivateInExpectedIn, this.state.startLoc, { identifierName: this.state.value }), this.parsePrivateName();
              case 33:
                return this.parseTopicReferenceThenEqualsSign(54, "%");
              case 32:
                return this.parseTopicReferenceThenEqualsSign(44, "^");
              case 37:
              case 38:
                return this.parseTopicReference("hack");
              case 44:
              case 54:
              case 27: {
                let r = this.getPluginOption("pipelineOperator", "proposal");
                if (r) return this.parseTopicReference(r);
                this.unexpected();
                break;
              }
              case 47: {
                let r = this.input.codePointAt(this.nextTokenStart());
                _2(r) || r === 62 ? this.expectOnePlugin(["jsx", "flow", "typescript"]) : this.unexpected();
                break;
              }
              default:
                if (w(i)) {
                  if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123) return this.parseModuleExpression();
                  let r = this.state.potentialArrowAt === this.state.start, n = this.state.containsEsc, o = this.parseIdentifier();
                  if (!n && o.name === "async" && !this.canInsertSemicolon()) {
                    let { type: h } = this.state;
                    if (h === 68) return this.resetPreviousNodeTrailingComments(o), this.next(), this.parseAsyncFunctionExpression(this.startNodeAtNode(o));
                    if (w(h)) return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(o)) : o;
                    if (h === 90) return this.resetPreviousNodeTrailingComments(o), this.parseDo(this.startNodeAtNode(o), true);
                  }
                  return r && this.match(19) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(o), [o], false)) : o;
                } else this.unexpected();
            }
          }
          parseTopicReferenceThenEqualsSign(t, e) {
            let s = this.getPluginOption("pipelineOperator", "proposal");
            if (s) return this.state.type = t, this.state.value = e, this.state.pos--, this.state.end--, this.state.endLoc = v(this.state.endLoc, -1), this.parseTopicReference(s);
            this.unexpected();
          }
          parseTopicReference(t) {
            let e = this.startNode(), s = this.state.startLoc, i = this.state.type;
            return this.next(), this.finishTopicReference(e, s, t, i);
          }
          finishTopicReference(t, e, s, i) {
            if (this.testTopicReferenceConfiguration(s, e, i)) {
              let r = s === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
              return this.topicReferenceIsAllowedInCurrentContext() || this.raise(s === "smart" ? p.PrimaryTopicNotAllowed : p.PipeTopicUnbound, e), this.registerTopicReference(), this.finishNode(t, r);
            } else throw this.raise(p.PipeTopicUnconfiguredToken, e, { token: K2(i) });
          }
          testTopicReferenceConfiguration(t, e, s) {
            switch (t) {
              case "hack":
                return this.hasPlugin(["pipelineOperator", { topicToken: K2(s) }]);
              case "smart":
                return s === 27;
              default:
                throw this.raise(p.PipeTopicRequiresHackPipes, e);
            }
          }
          parseAsyncArrowUnaryFunction(t) {
            this.prodParam.enter(ke2(true, this.prodParam.hasYield));
            let e = [this.parseIdentifier()];
            return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(p.LineTerminatorBeforeArrow, this.state.curPosition()), this.expect(19), this.parseArrowExpression(t, e, true);
          }
          parseDo(t, e) {
            this.expectPlugin("doExpressions"), e && this.expectPlugin("asyncDoExpressions"), t.async = e, this.next();
            let s = this.state.labels;
            return this.state.labels = [], e ? (this.prodParam.enter(2), t.body = this.parseBlock(), this.prodParam.exit()) : t.body = this.parseBlock(), this.state.labels = s, this.finishNode(t, "DoExpression");
          }
          parseSuper() {
            let t = this.startNode();
            return this.next(), this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod ? this.raise(p.SuperNotAllowed, t) : !this.scope.allowSuper && !this.options.allowSuperOutsideMethod && this.raise(p.UnexpectedSuper, t), !this.match(10) && !this.match(0) && !this.match(16) && this.raise(p.UnsupportedSuper, t), this.finishNode(t, "Super");
          }
          parsePrivateName() {
            let t = this.startNode(), e = this.startNodeAt(v(this.state.startLoc, 1)), s = this.state.value;
            return this.next(), t.id = this.createIdentifier(e, s), this.finishNode(t, "PrivateName");
          }
          parseFunctionOrFunctionSent() {
            let t = this.startNode();
            if (this.next(), this.prodParam.hasYield && this.match(16)) {
              let e = this.createIdentifier(this.startNodeAtNode(t), "function");
              return this.next(), this.match(103) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected(), this.parseMetaProperty(t, e, "sent");
            }
            return this.parseFunction(t);
          }
          parseMetaProperty(t, e, s) {
            t.meta = e;
            let i = this.state.containsEsc;
            return t.property = this.parseIdentifier(true), (t.property.name !== s || i) && this.raise(p.UnsupportedMetaProperty, t.property, { target: e.name, onlyValidPropertyName: s }), this.finishNode(t, "MetaProperty");
          }
          parseImportMetaProperty(t) {
            let e = this.createIdentifier(this.startNodeAtNode(t), "import");
            if (this.next(), this.isContextual(101)) this.inModule || this.raise(p.ImportMetaOutsideModule, e), this.sawUnambiguousESM = true;
            else if (this.isContextual(105) || this.isContextual(97)) {
              let s = this.isContextual(105);
              if (s || this.unexpected(), this.expectPlugin(s ? "sourcePhaseImports" : "deferredImportEvaluation"), !this.options.createImportExpressions) throw this.raise(p.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, { phase: this.state.value });
              return this.next(), t.phase = s ? "source" : "defer", this.parseImportCall(t);
            }
            return this.parseMetaProperty(t, e, "meta");
          }
          parseLiteralAtNode(t, e, s) {
            return this.addExtra(s, "rawValue", t), this.addExtra(s, "raw", this.input.slice(s.start, this.state.end)), s.value = t, this.next(), this.finishNode(s, e);
          }
          parseLiteral(t, e) {
            let s = this.startNode();
            return this.parseLiteralAtNode(t, e, s);
          }
          parseStringLiteral(t) {
            return this.parseLiteral(t, "StringLiteral");
          }
          parseNumericLiteral(t) {
            return this.parseLiteral(t, "NumericLiteral");
          }
          parseBigIntLiteral(t) {
            return this.parseLiteral(t, "BigIntLiteral");
          }
          parseDecimalLiteral(t) {
            return this.parseLiteral(t, "DecimalLiteral");
          }
          parseRegExpLiteral(t) {
            let e = this.startNode();
            return this.addExtra(e, "raw", this.input.slice(e.start, this.state.end)), e.pattern = t.pattern, e.flags = t.flags, this.next(), this.finishNode(e, "RegExpLiteral");
          }
          parseBooleanLiteral(t) {
            let e = this.startNode();
            return e.value = t, this.next(), this.finishNode(e, "BooleanLiteral");
          }
          parseNullLiteral() {
            let t = this.startNode();
            return this.next(), this.finishNode(t, "NullLiteral");
          }
          parseParenAndDistinguishExpression(t) {
            let e = this.state.startLoc, s;
            this.next(), this.expressionScope.enter(Oi());
            let i = this.state.maybeInArrowParameters, r = this.state.inFSharpPipelineDirectBody;
            this.state.maybeInArrowParameters = true, this.state.inFSharpPipelineDirectBody = false;
            let n = this.state.startLoc, o = [], h = new Z2(), c2 = true, l, u;
            for (; !this.match(11); ) {
              if (c2) c2 = false;
              else if (this.expect(12, h.optionalParametersLoc === null ? null : h.optionalParametersLoc), this.match(11)) {
                u = this.state.startLoc;
                break;
              }
              if (this.match(21)) {
                let y2 = this.state.startLoc;
                if (l = this.state.startLoc, o.push(this.parseParenItem(this.parseRestBinding(), y2)), !this.checkCommaAfterRest(41)) break;
              } else o.push(this.parseMaybeAssignAllowIn(h, this.parseParenItem));
            }
            let f = this.state.lastTokEndLoc;
            this.expect(11), this.state.maybeInArrowParameters = i, this.state.inFSharpPipelineDirectBody = r;
            let d = this.startNodeAt(e);
            return t && this.shouldParseArrow(o) && (d = this.parseArrow(d)) ? (this.checkDestructuringPrivate(h), this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(d, o, false), d) : (this.expressionScope.exit(), o.length || this.unexpected(this.state.lastTokStartLoc), u && this.unexpected(u), l && this.unexpected(l), this.checkExpressionErrors(h, true), this.toReferencedListDeep(o, true), o.length > 1 ? (s = this.startNodeAt(n), s.expressions = o, this.finishNode(s, "SequenceExpression"), this.resetEndLocation(s, f)) : s = o[0], this.wrapParenthesis(e, s));
          }
          wrapParenthesis(t, e) {
            if (!this.options.createParenthesizedExpressions) return this.addExtra(e, "parenthesized", true), this.addExtra(e, "parenStart", t.index), this.takeSurroundingComments(e, t.index, this.state.lastTokEndLoc.index), e;
            let s = this.startNodeAt(t);
            return s.expression = e, this.finishNode(s, "ParenthesizedExpression");
          }
          shouldParseArrow(t) {
            return !this.canInsertSemicolon();
          }
          parseArrow(t) {
            if (this.eat(19)) return t;
          }
          parseParenItem(t, e) {
            return t;
          }
          parseNewOrNewTarget() {
            let t = this.startNode();
            if (this.next(), this.match(16)) {
              let e = this.createIdentifier(this.startNodeAtNode(t), "new");
              this.next();
              let s = this.parseMetaProperty(t, e, "target");
              return !this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction && this.raise(p.UnexpectedNewTarget, s), s;
            }
            return this.parseNew(t);
          }
          parseNew(t) {
            if (this.parseNewCallee(t), this.eat(10)) {
              let e = this.parseExprList(11);
              this.toReferencedList(e), t.arguments = e;
            } else t.arguments = [];
            return this.finishNode(t, "NewExpression");
          }
          parseNewCallee(t) {
            let e = this.match(83), s = this.parseNoCallExpr();
            t.callee = s, e && (s.type === "Import" || s.type === "ImportExpression") && this.raise(p.ImportCallNotNewExpression, s);
          }
          parseTemplateElement(t) {
            let { start: e, startLoc: s, end: i, value: r } = this.state, n = e + 1, o = this.startNodeAt(v(s, 1));
            r === null && (t || this.raise(p.InvalidEscapeSequenceTemplate, v(this.state.firstInvalidTemplateEscapePos, 1)));
            let h = this.match(24), c2 = h ? -1 : -2, l = i + c2;
            o.value = { raw: this.input.slice(n, l).replace(/\r\n?/g, `
`), cooked: r === null ? null : r.slice(1, c2) }, o.tail = h, this.next();
            let u = this.finishNode(o, "TemplateElement");
            return this.resetEndLocation(u, v(this.state.lastTokEndLoc, c2)), u;
          }
          parseTemplate(t) {
            let e = this.startNode(), s = this.parseTemplateElement(t), i = [s], r = [];
            for (; !s.tail; ) r.push(this.parseTemplateSubstitution()), this.readTemplateContinuation(), i.push(s = this.parseTemplateElement(t));
            return e.expressions = r, e.quasis = i, this.finishNode(e, "TemplateLiteral");
          }
          parseTemplateSubstitution() {
            return this.parseExpression();
          }
          parseObjectLike(t, e, s, i) {
            s && this.expectPlugin("recordAndTuple");
            let r = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = false;
            let n = /* @__PURE__ */ Object.create(null), o = true, h = this.startNode();
            for (h.properties = [], this.next(); !this.match(t); ) {
              if (o) o = false;
              else if (this.expect(12), this.match(t)) {
                this.addTrailingCommaExtraToNode(h);
                break;
              }
              let l;
              e ? l = this.parseBindingProperty() : (l = this.parsePropertyDefinition(i), this.checkProto(l, s, n, i)), s && !this.isObjectProperty(l) && l.type !== "SpreadElement" && this.raise(p.InvalidRecordProperty, l), l.shorthand && this.addExtra(l, "shorthand", true), h.properties.push(l);
            }
            this.next(), this.state.inFSharpPipelineDirectBody = r;
            let c2 = "ObjectExpression";
            return e ? c2 = "ObjectPattern" : s && (c2 = "RecordExpression"), this.finishNode(h, c2);
          }
          addTrailingCommaExtraToNode(t) {
            this.addExtra(t, "trailingComma", this.state.lastTokStartLoc.index), this.addExtra(t, "trailingCommaLoc", this.state.lastTokStartLoc, false);
          }
          maybeAsyncOrAccessorProp(t) {
            return !t.computed && t.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
          }
          parsePropertyDefinition(t) {
            let e = [];
            if (this.match(26)) for (this.hasPlugin("decorators") && this.raise(p.UnsupportedPropertyDecorator, this.state.startLoc); this.match(26); ) e.push(this.parseDecorator());
            let s = this.startNode(), i = false, r = false, n;
            if (this.match(21)) return e.length && this.unexpected(), this.parseSpread();
            e.length && (s.decorators = e, e = []), s.method = false, t && (n = this.state.startLoc);
            let o = this.eat(55);
            this.parsePropertyNamePrefixOperator(s);
            let h = this.state.containsEsc;
            if (this.parsePropertyName(s, t), !o && !h && this.maybeAsyncOrAccessorProp(s)) {
              let { key: c2 } = s, l = c2.name;
              l === "async" && !this.hasPrecedingLineBreak() && (i = true, this.resetPreviousNodeTrailingComments(c2), o = this.eat(55), this.parsePropertyName(s)), (l === "get" || l === "set") && (r = true, this.resetPreviousNodeTrailingComments(c2), s.kind = l, this.match(55) && (o = true, this.raise(p.AccessorIsGenerator, this.state.curPosition(), { kind: l }), this.next()), this.parsePropertyName(s));
            }
            return this.parseObjPropValue(s, n, o, i, false, r, t);
          }
          getGetterSetterExpectedParamCount(t) {
            return t.kind === "get" ? 0 : 1;
          }
          getObjectOrClassMethodParams(t) {
            return t.params;
          }
          checkGetterSetterParams(t) {
            var e;
            let s = this.getGetterSetterExpectedParamCount(t), i = this.getObjectOrClassMethodParams(t);
            i.length !== s && this.raise(t.kind === "get" ? p.BadGetterArity : p.BadSetterArity, t), t.kind === "set" && ((e = i[i.length - 1]) == null ? void 0 : e.type) === "RestElement" && this.raise(p.BadSetterRestParameter, t);
          }
          parseObjectMethod(t, e, s, i, r) {
            if (r) {
              let n = this.parseMethod(t, e, false, false, false, "ObjectMethod");
              return this.checkGetterSetterParams(n), n;
            }
            if (s || e || this.match(10)) return i && this.unexpected(), t.kind = "method", t.method = true, this.parseMethod(t, e, s, false, false, "ObjectMethod");
          }
          parseObjectProperty(t, e, s, i) {
            if (t.shorthand = false, this.eat(14)) return t.value = s ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(i), this.finishNode(t, "ObjectProperty");
            if (!t.computed && t.key.type === "Identifier") {
              if (this.checkReservedWord(t.key.name, t.key.loc.start, true, false), s) t.value = this.parseMaybeDefault(e, $(t.key));
              else if (this.match(29)) {
                let r = this.state.startLoc;
                i != null ? i.shorthandAssignLoc === null && (i.shorthandAssignLoc = r) : this.raise(p.InvalidCoverInitializedName, r), t.value = this.parseMaybeDefault(e, $(t.key));
              } else t.value = $(t.key);
              return t.shorthand = true, this.finishNode(t, "ObjectProperty");
            }
          }
          parseObjPropValue(t, e, s, i, r, n, o) {
            let h = this.parseObjectMethod(t, s, i, r, n) || this.parseObjectProperty(t, e, r, o);
            return h || this.unexpected(), h;
          }
          parsePropertyName(t, e) {
            if (this.eat(0)) t.computed = true, t.key = this.parseMaybeAssignAllowIn(), this.expect(3);
            else {
              let { type: s, value: i } = this.state, r;
              if (M2(s)) r = this.parseIdentifier(true);
              else switch (s) {
                case 134:
                  r = this.parseNumericLiteral(i);
                  break;
                case 133:
                  r = this.parseStringLiteral(i);
                  break;
                case 135:
                  r = this.parseBigIntLiteral(i);
                  break;
                case 136:
                  r = this.parseDecimalLiteral(i);
                  break;
                case 138: {
                  let n = this.state.startLoc;
                  e != null ? e.privateKeyLoc === null && (e.privateKeyLoc = n) : this.raise(p.UnexpectedPrivateField, n), r = this.parsePrivateName();
                  break;
                }
                default:
                  this.unexpected();
              }
              t.key = r, s !== 138 && (t.computed = false);
            }
          }
          initFunction(t, e) {
            t.id = null, t.generator = false, t.async = e;
          }
          parseMethod(t, e, s, i, r, n, o = false) {
            this.initFunction(t, s), t.generator = e, this.scope.enter(18 | (o ? 64 : 0) | (r ? 32 : 0)), this.prodParam.enter(ke2(s, t.generator)), this.parseFunctionParams(t, i);
            let h = this.parseFunctionBodyAndFinish(t, n, true);
            return this.prodParam.exit(), this.scope.exit(), h;
          }
          parseArrayLike(t, e, s, i) {
            s && this.expectPlugin("recordAndTuple");
            let r = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = false;
            let n = this.startNode();
            return this.next(), n.elements = this.parseExprList(t, !s, i, n), this.state.inFSharpPipelineDirectBody = r, this.finishNode(n, s ? "TupleExpression" : "ArrayExpression");
          }
          parseArrowExpression(t, e, s, i) {
            this.scope.enter(6);
            let r = ke2(s, false);
            !this.match(5) && this.prodParam.hasIn && (r |= 8), this.prodParam.enter(r), this.initFunction(t, s);
            let n = this.state.maybeInArrowParameters;
            return e && (this.state.maybeInArrowParameters = true, this.setArrowFunctionParameters(t, e, i)), this.state.maybeInArrowParameters = false, this.parseFunctionBody(t, true), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = n, this.finishNode(t, "ArrowFunctionExpression");
          }
          setArrowFunctionParameters(t, e, s) {
            this.toAssignableList(e, s, false), t.params = e;
          }
          parseFunctionBodyAndFinish(t, e, s = false) {
            return this.parseFunctionBody(t, false, s), this.finishNode(t, e);
          }
          parseFunctionBody(t, e, s = false) {
            let i = e && !this.match(5);
            if (this.expressionScope.enter(rs()), i) t.body = this.parseMaybeAssign(), this.checkParams(t, false, e, false);
            else {
              let r = this.state.strict, n = this.state.labels;
              this.state.labels = [], this.prodParam.enter(this.prodParam.currentFlags() | 4), t.body = this.parseBlock(true, false, (o) => {
                let h = !this.isSimpleParamList(t.params);
                o && h && this.raise(p.IllegalLanguageModeDirective, (t.kind === "method" || t.kind === "constructor") && t.key ? t.key.loc.end : t);
                let c2 = !r && this.state.strict;
                this.checkParams(t, !this.state.strict && !e && !s && !h, e, c2), this.state.strict && t.id && this.checkIdentifier(t.id, 65, c2);
              }), this.prodParam.exit(), this.state.labels = n;
            }
            this.expressionScope.exit();
          }
          isSimpleParameter(t) {
            return t.type === "Identifier";
          }
          isSimpleParamList(t) {
            for (let e = 0, s = t.length; e < s; e++) if (!this.isSimpleParameter(t[e])) return false;
            return true;
          }
          checkParams(t, e, s, i = true) {
            let r = !e && /* @__PURE__ */ new Set(), n = { type: "FormalParameters" };
            for (let o of t.params) this.checkLVal(o, { in: n, binding: 5, checkClashes: r, strictModeChanged: i });
          }
          parseExprList(t, e, s, i) {
            let r = [], n = true;
            for (; !this.eat(t); ) {
              if (n) n = false;
              else if (this.expect(12), this.match(t)) {
                i && this.addTrailingCommaExtraToNode(i), this.next();
                break;
              }
              r.push(this.parseExprListItem(e, s));
            }
            return r;
          }
          parseExprListItem(t, e, s) {
            let i;
            if (this.match(12)) t || this.raise(p.UnexpectedToken, this.state.curPosition(), { unexpected: "," }), i = null;
            else if (this.match(21)) {
              let r = this.state.startLoc;
              i = this.parseParenItem(this.parseSpread(e), r);
            } else if (this.match(17)) {
              this.expectPlugin("partialApplication"), s || this.raise(p.UnexpectedArgumentPlaceholder, this.state.startLoc);
              let r = this.startNode();
              this.next(), i = this.finishNode(r, "ArgumentPlaceholder");
            } else i = this.parseMaybeAssignAllowIn(e, this.parseParenItem);
            return i;
          }
          parseIdentifier(t) {
            let e = this.startNode(), s = this.parseIdentifierName(t);
            return this.createIdentifier(e, s);
          }
          createIdentifier(t, e) {
            return t.name = e, t.loc.identifierName = e, this.finishNode(t, "Identifier");
          }
          parseIdentifierName(t) {
            let e, { startLoc: s, type: i } = this.state;
            M2(i) ? e = this.state.value : this.unexpected();
            let r = oi2(i);
            return t ? r && this.replaceToken(132) : this.checkReservedWord(e, s, r, false), this.next(), e;
          }
          checkReservedWord(t, e, s, i) {
            if (t.length > 10 || !Ei(t)) return;
            if (s && Si(t)) {
              this.raise(p.UnexpectedKeyword, e, { keyword: t });
              return;
            }
            if ((this.state.strict ? i ? Zt : Yt2 : Gt2)(t, this.inModule)) {
              this.raise(p.UnexpectedReservedWord, e, { reservedWord: t });
              return;
            } else if (t === "yield") {
              if (this.prodParam.hasYield) {
                this.raise(p.YieldBindingIdentifier, e);
                return;
              }
            } else if (t === "await") {
              if (this.prodParam.hasAwait) {
                this.raise(p.AwaitBindingIdentifier, e);
                return;
              }
              if (this.scope.inStaticBlock) {
                this.raise(p.AwaitBindingIdentifierInStaticBlock, e);
                return;
              }
              this.expressionScope.recordAsyncArrowParametersError(e);
            } else if (t === "arguments" && this.scope.inClassAndNotInNonArrowFunction) {
              this.raise(p.ArgumentsInClass, e);
              return;
            }
          }
          isAwaitAllowed() {
            return !!(this.prodParam.hasAwait || this.options.allowAwaitOutsideFunction && !this.scope.inFunction);
          }
          parseAwait(t) {
            let e = this.startNodeAt(t);
            return this.expressionScope.recordParameterInitializerError(p.AwaitExpressionFormalParameter, e), this.eat(55) && this.raise(p.ObsoleteAwaitStar, e), !this.scope.inFunction && !this.options.allowAwaitOutsideFunction && (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = true : this.sawUnambiguousESM = true), this.state.soloAwait || (e.argument = this.parseMaybeUnary(null, true)), this.finishNode(e, "AwaitExpression");
          }
          isAmbiguousAwait() {
            if (this.hasPrecedingLineBreak()) return true;
            let { type: t } = this.state;
            return t === 53 || t === 10 || t === 0 || Le2(t) || t === 102 && !this.state.containsEsc || t === 137 || t === 56 || this.hasPlugin("v8intrinsic") && t === 54;
          }
          parseYield() {
            let t = this.startNode();
            this.expressionScope.recordParameterInitializerError(p.YieldInParameter, t), this.next();
            let e = false, s = null;
            if (!this.hasPrecedingLineBreak()) switch (e = this.eat(55), this.state.type) {
              case 13:
              case 139:
              case 8:
              case 11:
              case 3:
              case 9:
              case 14:
              case 12:
                if (!e) break;
              default:
                s = this.parseMaybeAssign();
            }
            return t.delegate = e, t.argument = s, this.finishNode(t, "YieldExpression");
          }
          parseImportCall(t) {
            return this.next(), t.source = this.parseMaybeAssignAllowIn(), (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) && (t.options = null), this.eat(12) && (this.expectImportAttributesPlugin(), this.match(11) || (t.options = this.parseMaybeAssignAllowIn(), this.eat(12))), this.expect(11), this.finishNode(t, "ImportExpression");
          }
          checkPipelineAtInfixOperator(t, e) {
            this.hasPlugin(["pipelineOperator", { proposal: "smart" }]) && t.type === "SequenceExpression" && this.raise(p.PipelineHeadSequenceExpression, e);
          }
          parseSmartPipelineBodyInStyle(t, e) {
            if (this.isSimpleReference(t)) {
              let s = this.startNodeAt(e);
              return s.callee = t, this.finishNode(s, "PipelineBareFunction");
            } else {
              let s = this.startNodeAt(e);
              return this.checkSmartPipeTopicBodyEarlyErrors(e), s.expression = t, this.finishNode(s, "PipelineTopicExpression");
            }
          }
          isSimpleReference(t) {
            switch (t.type) {
              case "MemberExpression":
                return !t.computed && this.isSimpleReference(t.object);
              case "Identifier":
                return true;
              default:
                return false;
            }
          }
          checkSmartPipeTopicBodyEarlyErrors(t) {
            if (this.match(19)) throw this.raise(p.PipelineBodyNoArrow, this.state.startLoc);
            this.topicReferenceWasUsedInCurrentContext() || this.raise(p.PipelineTopicUnused, t);
          }
          withTopicBindingContext(t) {
            let e = this.state.topicContext;
            this.state.topicContext = { maxNumOfResolvableTopics: 1, maxTopicIndex: null };
            try {
              return t();
            } finally {
              this.state.topicContext = e;
            }
          }
          withSmartMixTopicForbiddingContext(t) {
            if (this.hasPlugin(["pipelineOperator", { proposal: "smart" }])) {
              let e = this.state.topicContext;
              this.state.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null };
              try {
                return t();
              } finally {
                this.state.topicContext = e;
              }
            } else return t();
          }
          withSoloAwaitPermittingContext(t) {
            let e = this.state.soloAwait;
            this.state.soloAwait = true;
            try {
              return t();
            } finally {
              this.state.soloAwait = e;
            }
          }
          allowInAnd(t) {
            let e = this.prodParam.currentFlags();
            if (8 & ~e) {
              this.prodParam.enter(e | 8);
              try {
                return t();
              } finally {
                this.prodParam.exit();
              }
            }
            return t();
          }
          disallowInAnd(t) {
            let e = this.prodParam.currentFlags();
            if (8 & e) {
              this.prodParam.enter(e & -9);
              try {
                return t();
              } finally {
                this.prodParam.exit();
              }
            }
            return t();
          }
          registerTopicReference() {
            this.state.topicContext.maxTopicIndex = 0;
          }
          topicReferenceIsAllowedInCurrentContext() {
            return this.state.topicContext.maxNumOfResolvableTopics >= 1;
          }
          topicReferenceWasUsedInCurrentContext() {
            return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
          }
          parseFSharpPipelineBody(t) {
            let e = this.state.startLoc;
            this.state.potentialArrowAt = this.state.start;
            let s = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = true;
            let i = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), e, t);
            return this.state.inFSharpPipelineDirectBody = s, i;
          }
          parseModuleExpression() {
            this.expectPlugin("moduleBlocks");
            let t = this.startNode();
            this.next(), this.match(5) || this.unexpected(null, 5);
            let e = this.startNodeAt(this.state.endLoc);
            this.next();
            let s = this.initializeScopes(true);
            this.enterInitialScopes();
            try {
              t.body = this.parseProgram(e, 8, "module");
            } finally {
              s();
            }
            return this.finishNode(t, "ModuleExpression");
          }
          parsePropertyNamePrefixOperator(t) {
          }
        }, ze2 = { kind: 1 }, ar2 = { kind: 2 }, nr2 = /[\uD800-\uDFFF]/u, Ke2 = /in(?:stanceof)?/y;
        function or2(a, t) {
          for (let e = 0; e < a.length; e++) {
            let s = a[e], { type: i } = s;
            if (typeof i == "number") {
              {
                if (i === 138) {
                  let { loc: r, start: n, value: o, end: h } = s, c2 = n + 1, l = v(r.start, 1);
                  a.splice(e, 1, new O2({ type: R2(27), value: "#", start: n, end: c2, startLoc: r.start, endLoc: l }), new O2({ type: R2(132), value: o, start: c2, end: h, startLoc: l, endLoc: r.end })), e++;
                  continue;
                }
                if (Le2(i)) {
                  let { loc: r, start: n, value: o, end: h } = s, c2 = n + 1, l = v(r.start, 1), u;
                  t.charCodeAt(n) === 96 ? u = new O2({ type: R2(22), value: "`", start: n, end: c2, startLoc: r.start, endLoc: l }) : u = new O2({ type: R2(8), value: "}", start: n, end: c2, startLoc: r.start, endLoc: l });
                  let f, d, y2, E;
                  i === 24 ? (d = h - 1, y2 = v(r.end, -1), f = o === null ? null : o.slice(1, -1), E = new O2({ type: R2(22), value: "`", start: d, end: h, startLoc: y2, endLoc: r.end })) : (d = h - 2, y2 = v(r.end, -2), f = o === null ? null : o.slice(1, -2), E = new O2({ type: R2(23), value: "${", start: d, end: h, startLoc: y2, endLoc: r.end })), a.splice(e, 1, u, new O2({ type: R2(20), value: f, start: c2, end: d, startLoc: l, endLoc: y2 }), E), e += 2;
                  continue;
                }
              }
              s.type = R2(i);
            }
          }
          return a;
        }
        var pt2 = class extends ct2 {
          parseTopLevel(t, e) {
            return t.program = this.parseProgram(e), t.comments = this.comments, this.options.tokens && (t.tokens = or2(this.tokens, this.input)), this.finishNode(t, "File");
          }
          parseProgram(t, e = 139, s = this.options.sourceType) {
            if (t.sourceType = s, t.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(t, true, true, e), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) for (let [r, n] of Array.from(this.scope.undefinedExports)) this.raise(p.ModuleExportUndefined, n, { localName: r });
            let i;
            return e === 139 ? i = this.finishNode(t, "Program") : i = this.finishNodeAt(t, "Program", v(this.state.startLoc, -1)), i;
          }
          stmtToDirective(t) {
            let e = t;
            e.type = "Directive", e.value = e.expression, delete e.expression;
            let s = e.value, i = s.value, r = this.input.slice(s.start, s.end), n = s.value = r.slice(1, -1);
            return this.addExtra(s, "raw", r), this.addExtra(s, "rawValue", n), this.addExtra(s, "expressionValue", i), s.type = "DirectiveLiteral", e;
          }
          parseInterpreterDirective() {
            if (!this.match(28)) return null;
            let t = this.startNode();
            return t.value = this.state.value, this.next(), this.finishNode(t, "InterpreterDirective");
          }
          isLet() {
            return this.isContextual(100) ? this.hasFollowingBindingAtom() : false;
          }
          chStartsBindingIdentifier(t, e) {
            if (_2(t)) {
              if (Ke2.lastIndex = e, Ke2.test(this.input)) {
                let s = this.codePointAtPos(Ke2.lastIndex);
                if (!Q2(s) && s !== 92) return false;
              }
              return true;
            } else return t === 92;
          }
          chStartsBindingPattern(t) {
            return t === 91 || t === 123;
          }
          hasFollowingBindingAtom() {
            let t = this.nextTokenStart(), e = this.codePointAtPos(t);
            return this.chStartsBindingPattern(e) || this.chStartsBindingIdentifier(e, t);
          }
          hasInLineFollowingBindingIdentifierOrBrace() {
            let t = this.nextTokenInLineStart(), e = this.codePointAtPos(t);
            return e === 123 || this.chStartsBindingIdentifier(e, t);
          }
          startsUsingForOf() {
            let { type: t, containsEsc: e } = this.lookahead();
            if (t === 102 && !e) return false;
            if (w(t) && !this.hasFollowingLineBreak()) return this.expectPlugin("explicitResourceManagement"), true;
          }
          startsAwaitUsing() {
            let t = this.nextTokenInLineStart();
            if (this.isUnparsedContextual(t, "using")) {
              t = this.nextTokenInLineStartSince(t + 5);
              let e = this.codePointAtPos(t);
              if (this.chStartsBindingIdentifier(e, t)) return this.expectPlugin("explicitResourceManagement"), true;
            }
            return false;
          }
          parseModuleItem() {
            return this.parseStatementLike(15);
          }
          parseStatementListItem() {
            return this.parseStatementLike(6 | (!this.options.annexB || this.state.strict ? 0 : 8));
          }
          parseStatementOrSloppyAnnexBFunctionDeclaration(t = false) {
            let e = 0;
            return this.options.annexB && !this.state.strict && (e |= 4, t && (e |= 8)), this.parseStatementLike(e);
          }
          parseStatement() {
            return this.parseStatementLike(0);
          }
          parseStatementLike(t) {
            let e = null;
            return this.match(26) && (e = this.parseDecorators(true)), this.parseStatementContent(t, e);
          }
          parseStatementContent(t, e) {
            let s = this.state.type, i = this.startNode(), r = !!(t & 2), n = !!(t & 4), o = t & 1;
            switch (s) {
              case 60:
                return this.parseBreakContinueStatement(i, true);
              case 63:
                return this.parseBreakContinueStatement(i, false);
              case 64:
                return this.parseDebuggerStatement(i);
              case 90:
                return this.parseDoWhileStatement(i);
              case 91:
                return this.parseForStatement(i);
              case 68:
                if (this.lookaheadCharCode() === 46) break;
                return n || this.raise(this.state.strict ? p.StrictFunction : this.options.annexB ? p.SloppyFunctionAnnexB : p.SloppyFunction, this.state.startLoc), this.parseFunctionStatement(i, false, !r && n);
              case 80:
                return r || this.unexpected(), this.parseClass(this.maybeTakeDecorators(e, i), true);
              case 69:
                return this.parseIfStatement(i);
              case 70:
                return this.parseReturnStatement(i);
              case 71:
                return this.parseSwitchStatement(i);
              case 72:
                return this.parseThrowStatement(i);
              case 73:
                return this.parseTryStatement(i);
              case 96:
                if (!this.state.containsEsc && this.startsAwaitUsing()) return this.isAwaitAllowed() ? r || this.raise(p.UnexpectedLexicalDeclaration, i) : this.raise(p.AwaitUsingNotInAsyncContext, i), this.next(), this.parseVarStatement(i, "await using");
                break;
              case 107:
                if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace()) break;
                return this.expectPlugin("explicitResourceManagement"), !this.scope.inModule && this.scope.inTopLevel ? this.raise(p.UnexpectedUsingDeclaration, this.state.startLoc) : r || this.raise(p.UnexpectedLexicalDeclaration, this.state.startLoc), this.parseVarStatement(i, "using");
              case 100: {
                if (this.state.containsEsc) break;
                let l = this.nextTokenStart(), u = this.codePointAtPos(l);
                if (u !== 91 && (!r && this.hasFollowingLineBreak() || !this.chStartsBindingIdentifier(u, l) && u !== 123)) break;
              }
              case 75:
                r || this.raise(p.UnexpectedLexicalDeclaration, this.state.startLoc);
              case 74: {
                let l = this.state.value;
                return this.parseVarStatement(i, l);
              }
              case 92:
                return this.parseWhileStatement(i);
              case 76:
                return this.parseWithStatement(i);
              case 5:
                return this.parseBlock();
              case 13:
                return this.parseEmptyStatement(i);
              case 83: {
                let l = this.lookaheadCharCode();
                if (l === 40 || l === 46) break;
              }
              case 82: {
                !this.options.allowImportExportEverywhere && !o && this.raise(p.UnexpectedImportExport, this.state.startLoc), this.next();
                let l;
                return s === 83 ? (l = this.parseImport(i), l.type === "ImportDeclaration" && (!l.importKind || l.importKind === "value") && (this.sawUnambiguousESM = true)) : (l = this.parseExport(i, e), (l.type === "ExportNamedDeclaration" && (!l.exportKind || l.exportKind === "value") || l.type === "ExportAllDeclaration" && (!l.exportKind || l.exportKind === "value") || l.type === "ExportDefaultDeclaration") && (this.sawUnambiguousESM = true)), this.assertModuleNodeAllowed(l), l;
              }
              default:
                if (this.isAsyncFunction()) return r || this.raise(p.AsyncFunctionInSingleStatementContext, this.state.startLoc), this.next(), this.parseFunctionStatement(i, true, !r && n);
            }
            let h = this.state.value, c2 = this.parseExpression();
            return w(s) && c2.type === "Identifier" && this.eat(14) ? this.parseLabeledStatement(i, h, c2, t) : this.parseExpressionStatement(i, c2, e);
          }
          assertModuleNodeAllowed(t) {
            !this.options.allowImportExportEverywhere && !this.inModule && this.raise(p.ImportOutsideModule, t);
          }
          decoratorsEnabledBeforeExport() {
            return this.hasPlugin("decorators-legacy") ? true : this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== false;
          }
          maybeTakeDecorators(t, e, s) {
            return t && (e.decorators && e.decorators.length > 0 ? (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") != "boolean" && this.raise(p.DecoratorsBeforeAfterExport, e.decorators[0]), e.decorators.unshift(...t)) : e.decorators = t, this.resetStartLocationFromNode(e, t[0]), s && this.resetStartLocationFromNode(s, e)), e;
          }
          canHaveLeadingDecorator() {
            return this.match(80);
          }
          parseDecorators(t) {
            let e = [];
            do
              e.push(this.parseDecorator());
            while (this.match(26));
            if (this.match(82)) t || this.unexpected(), this.decoratorsEnabledBeforeExport() || this.raise(p.DecoratorExportClass, this.state.startLoc);
            else if (!this.canHaveLeadingDecorator()) throw this.raise(p.UnexpectedLeadingDecorator, this.state.startLoc);
            return e;
          }
          parseDecorator() {
            this.expectOnePlugin(["decorators", "decorators-legacy"]);
            let t = this.startNode();
            if (this.next(), this.hasPlugin("decorators")) {
              let e = this.state.startLoc, s;
              if (this.match(10)) {
                let i = this.state.startLoc;
                this.next(), s = this.parseExpression(), this.expect(11), s = this.wrapParenthesis(i, s);
                let r = this.state.startLoc;
                t.expression = this.parseMaybeDecoratorArguments(s), this.getPluginOption("decorators", "allowCallParenthesized") === false && t.expression !== s && this.raise(p.DecoratorArgumentsOutsideParentheses, r);
              } else {
                for (s = this.parseIdentifier(false); this.eat(16); ) {
                  let i = this.startNodeAt(e);
                  i.object = s, this.match(138) ? (this.classScope.usePrivateName(this.state.value, this.state.startLoc), i.property = this.parsePrivateName()) : i.property = this.parseIdentifier(true), i.computed = false, s = this.finishNode(i, "MemberExpression");
                }
                t.expression = this.parseMaybeDecoratorArguments(s);
              }
            } else t.expression = this.parseExprSubscripts();
            return this.finishNode(t, "Decorator");
          }
          parseMaybeDecoratorArguments(t) {
            if (this.eat(10)) {
              let e = this.startNodeAtNode(t);
              return e.callee = t, e.arguments = this.parseCallExpressionArguments(11, false), this.toReferencedList(e.arguments), this.finishNode(e, "CallExpression");
            }
            return t;
          }
          parseBreakContinueStatement(t, e) {
            return this.next(), this.isLineTerminator() ? t.label = null : (t.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(t, e), this.finishNode(t, e ? "BreakStatement" : "ContinueStatement");
          }
          verifyBreakContinue(t, e) {
            let s;
            for (s = 0; s < this.state.labels.length; ++s) {
              let i = this.state.labels[s];
              if ((t.label == null || i.name === t.label.name) && (i.kind != null && (e || i.kind === 1) || t.label && e)) break;
            }
            if (s === this.state.labels.length) {
              let i = e ? "BreakStatement" : "ContinueStatement";
              this.raise(p.IllegalBreakContinue, t, { type: i });
            }
          }
          parseDebuggerStatement(t) {
            return this.next(), this.semicolon(), this.finishNode(t, "DebuggerStatement");
          }
          parseHeaderExpression() {
            this.expect(10);
            let t = this.parseExpression();
            return this.expect(11), t;
          }
          parseDoWhileStatement(t) {
            return this.next(), this.state.labels.push(ze2), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.expect(92), t.test = this.parseHeaderExpression(), this.eat(13), this.finishNode(t, "DoWhileStatement");
          }
          parseForStatement(t) {
            this.next(), this.state.labels.push(ze2);
            let e = null;
            if (this.isAwaitAllowed() && this.eatContextual(96) && (e = this.state.lastTokStartLoc), this.scope.enter(0), this.expect(10), this.match(13)) return e !== null && this.unexpected(e), this.parseFor(t, null);
            let s = this.isContextual(100);
            {
              let h = this.isContextual(96) && this.startsAwaitUsing(), c2 = h || this.isContextual(107) && this.startsUsingForOf(), l = s && this.hasFollowingBindingAtom() || c2;
              if (this.match(74) || this.match(75) || l) {
                let u = this.startNode(), f;
                h ? (f = "await using", this.isAwaitAllowed() || this.raise(p.AwaitUsingNotInAsyncContext, this.state.startLoc), this.next()) : f = this.state.value, this.next(), this.parseVar(u, true, f);
                let d = this.finishNode(u, "VariableDeclaration"), y2 = this.match(58);
                return y2 && c2 && this.raise(p.ForInUsing, d), (y2 || this.isContextual(102)) && d.declarations.length === 1 ? this.parseForIn(t, d, e) : (e !== null && this.unexpected(e), this.parseFor(t, d));
              }
            }
            let i = this.isContextual(95), r = new Z2(), n = this.parseExpression(true, r), o = this.isContextual(102);
            if (o && (s && this.raise(p.ForOfLet, n), e === null && i && n.type === "Identifier" && this.raise(p.ForOfAsync, n)), o || this.match(58)) {
              this.checkDestructuringPrivate(r), this.toAssignable(n, true);
              let h = o ? "ForOfStatement" : "ForInStatement";
              return this.checkLVal(n, { in: { type: h } }), this.parseForIn(t, n, e);
            } else this.checkExpressionErrors(r, true);
            return e !== null && this.unexpected(e), this.parseFor(t, n);
          }
          parseFunctionStatement(t, e, s) {
            return this.next(), this.parseFunction(t, 1 | (s ? 2 : 0) | (e ? 8 : 0));
          }
          parseIfStatement(t) {
            return this.next(), t.test = this.parseHeaderExpression(), t.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration(), t.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null, this.finishNode(t, "IfStatement");
          }
          parseReturnStatement(t) {
            return !this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction && this.raise(p.IllegalReturn, this.state.startLoc), this.next(), this.isLineTerminator() ? t.argument = null : (t.argument = this.parseExpression(), this.semicolon()), this.finishNode(t, "ReturnStatement");
          }
          parseSwitchStatement(t) {
            this.next(), t.discriminant = this.parseHeaderExpression();
            let e = t.cases = [];
            this.expect(5), this.state.labels.push(ar2), this.scope.enter(0);
            let s;
            for (let i; !this.match(8); ) if (this.match(61) || this.match(65)) {
              let r = this.match(61);
              s && this.finishNode(s, "SwitchCase"), e.push(s = this.startNode()), s.consequent = [], this.next(), r ? s.test = this.parseExpression() : (i && this.raise(p.MultipleDefaultsInSwitch, this.state.lastTokStartLoc), i = true, s.test = null), this.expect(14);
            } else s ? s.consequent.push(this.parseStatementListItem()) : this.unexpected();
            return this.scope.exit(), s && this.finishNode(s, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(t, "SwitchStatement");
          }
          parseThrowStatement(t) {
            return this.next(), this.hasPrecedingLineBreak() && this.raise(p.NewlineAfterThrow, this.state.lastTokEndLoc), t.argument = this.parseExpression(), this.semicolon(), this.finishNode(t, "ThrowStatement");
          }
          parseCatchClauseParam() {
            let t = this.parseBindingAtom();
            return this.scope.enter(this.options.annexB && t.type === "Identifier" ? 8 : 0), this.checkLVal(t, { in: { type: "CatchClause" }, binding: 9 }), t;
          }
          parseTryStatement(t) {
            if (this.next(), t.block = this.parseBlock(), t.handler = null, this.match(62)) {
              let e = this.startNode();
              this.next(), this.match(10) ? (this.expect(10), e.param = this.parseCatchClauseParam(), this.expect(11)) : (e.param = null, this.scope.enter(0)), e.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false)), this.scope.exit(), t.handler = this.finishNode(e, "CatchClause");
            }
            return t.finalizer = this.eat(67) ? this.parseBlock() : null, !t.handler && !t.finalizer && this.raise(p.NoCatchOrFinally, t), this.finishNode(t, "TryStatement");
          }
          parseVarStatement(t, e, s = false) {
            return this.next(), this.parseVar(t, false, e, s), this.semicolon(), this.finishNode(t, "VariableDeclaration");
          }
          parseWhileStatement(t) {
            return this.next(), t.test = this.parseHeaderExpression(), this.state.labels.push(ze2), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.state.labels.pop(), this.finishNode(t, "WhileStatement");
          }
          parseWithStatement(t) {
            return this.state.strict && this.raise(p.StrictWith, this.state.startLoc), this.next(), t.object = this.parseHeaderExpression(), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.finishNode(t, "WithStatement");
          }
          parseEmptyStatement(t) {
            return this.next(), this.finishNode(t, "EmptyStatement");
          }
          parseLabeledStatement(t, e, s, i) {
            for (let n of this.state.labels) n.name === e && this.raise(p.LabelRedeclaration, s, { labelName: e });
            let r = ci2(this.state.type) ? 1 : this.match(71) ? 2 : null;
            for (let n = this.state.labels.length - 1; n >= 0; n--) {
              let o = this.state.labels[n];
              if (o.statementStart === t.start) o.statementStart = this.state.start, o.kind = r;
              else break;
            }
            return this.state.labels.push({ name: e, kind: r, statementStart: this.state.start }), t.body = i & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement(), this.state.labels.pop(), t.label = s, this.finishNode(t, "LabeledStatement");
          }
          parseExpressionStatement(t, e, s) {
            return t.expression = e, this.semicolon(), this.finishNode(t, "ExpressionStatement");
          }
          parseBlock(t = false, e = true, s) {
            let i = this.startNode();
            return t && this.state.strictErrors.clear(), this.expect(5), e && this.scope.enter(0), this.parseBlockBody(i, t, false, 8, s), e && this.scope.exit(), this.finishNode(i, "BlockStatement");
          }
          isValidDirective(t) {
            return t.type === "ExpressionStatement" && t.expression.type === "StringLiteral" && !t.expression.extra.parenthesized;
          }
          parseBlockBody(t, e, s, i, r) {
            let n = t.body = [], o = t.directives = [];
            this.parseBlockOrModuleBlockBody(n, e ? o : void 0, s, i, r);
          }
          parseBlockOrModuleBlockBody(t, e, s, i, r) {
            let n = this.state.strict, o = false, h = false;
            for (; !this.match(i); ) {
              let c2 = s ? this.parseModuleItem() : this.parseStatementListItem();
              if (e && !h) {
                if (this.isValidDirective(c2)) {
                  let l = this.stmtToDirective(c2);
                  e.push(l), !o && l.value.value === "use strict" && (o = true, this.setStrict(true));
                  continue;
                }
                h = true, this.state.strictErrors.clear();
              }
              t.push(c2);
            }
            r == null || r.call(this, o), n || this.setStrict(false), this.next();
          }
          parseFor(t, e) {
            return t.init = e, this.semicolon(false), t.test = this.match(13) ? null : this.parseExpression(), this.semicolon(false), t.update = this.match(11) ? null : this.parseExpression(), this.expect(11), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, "ForStatement");
          }
          parseForIn(t, e, s) {
            let i = this.match(58);
            return this.next(), i ? s !== null && this.unexpected(s) : t.await = s !== null, e.type === "VariableDeclaration" && e.declarations[0].init != null && (!i || !this.options.annexB || this.state.strict || e.kind !== "var" || e.declarations[0].id.type !== "Identifier") && this.raise(p.ForInOfLoopInitializer, e, { type: i ? "ForInStatement" : "ForOfStatement" }), e.type === "AssignmentPattern" && this.raise(p.InvalidLhs, e, { ancestor: { type: "ForStatement" } }), t.left = e, t.right = i ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(11), t.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement()), this.scope.exit(), this.state.labels.pop(), this.finishNode(t, i ? "ForInStatement" : "ForOfStatement");
          }
          parseVar(t, e, s, i = false) {
            let r = t.declarations = [];
            for (t.kind = s; ; ) {
              let n = this.startNode();
              if (this.parseVarId(n, s), n.init = this.eat(29) ? e ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : null, n.init === null && !i && (n.id.type !== "Identifier" && !(e && (this.match(58) || this.isContextual(102))) ? this.raise(p.DeclarationMissingInitializer, this.state.lastTokEndLoc, { kind: "destructuring" }) : (s === "const" || s === "using" || s === "await using") && !(this.match(58) || this.isContextual(102)) && this.raise(p.DeclarationMissingInitializer, this.state.lastTokEndLoc, { kind: s })), r.push(this.finishNode(n, "VariableDeclarator")), !this.eat(12)) break;
            }
            return t;
          }
          parseVarId(t, e) {
            let s = this.parseBindingAtom();
            (e === "using" || e === "await using") && (s.type === "ArrayPattern" || s.type === "ObjectPattern") && this.raise(p.UsingDeclarationHasBindingPattern, s.loc.start), this.checkLVal(s, { in: { type: "VariableDeclarator" }, binding: e === "var" ? 5 : 8201 }), t.id = s;
          }
          parseAsyncFunctionExpression(t) {
            return this.parseFunction(t, 8);
          }
          parseFunction(t, e = 0) {
            let s = e & 2, i = !!(e & 1), r = i && !(e & 4), n = !!(e & 8);
            this.initFunction(t, n), this.match(55) && (s && this.raise(p.GeneratorInSingleStatementContext, this.state.startLoc), this.next(), t.generator = true), i && (t.id = this.parseFunctionId(r));
            let o = this.state.maybeInArrowParameters;
            return this.state.maybeInArrowParameters = false, this.scope.enter(2), this.prodParam.enter(ke2(n, t.generator)), i || (t.id = this.parseFunctionId()), this.parseFunctionParams(t, false), this.withSmartMixTopicForbiddingContext(() => {
              this.parseFunctionBodyAndFinish(t, i ? "FunctionDeclaration" : "FunctionExpression");
            }), this.prodParam.exit(), this.scope.exit(), i && !s && this.registerFunctionStatementId(t), this.state.maybeInArrowParameters = o, t;
          }
          parseFunctionId(t) {
            return t || w(this.state.type) ? this.parseIdentifier() : null;
          }
          parseFunctionParams(t, e) {
            this.expect(10), this.expressionScope.enter(Mi()), t.params = this.parseBindingList(11, 41, 2 | (e ? 4 : 0)), this.expressionScope.exit();
          }
          registerFunctionStatementId(t) {
            t.id && this.scope.declareName(t.id.name, !this.options.annexB || this.state.strict || t.generator || t.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, t.id.loc.start);
          }
          parseClass(t, e, s) {
            this.next();
            let i = this.state.strict;
            return this.state.strict = true, this.parseClassId(t, e, s), this.parseClassSuper(t), t.body = this.parseClassBody(!!t.superClass, i), this.finishNode(t, e ? "ClassDeclaration" : "ClassExpression");
          }
          isClassProperty() {
            return this.match(29) || this.match(13) || this.match(8);
          }
          isClassMethod() {
            return this.match(10);
          }
          nameIsConstructor(t) {
            return t.type === "Identifier" && t.name === "constructor" || t.type === "StringLiteral" && t.value === "constructor";
          }
          isNonstaticConstructor(t) {
            return !t.computed && !t.static && this.nameIsConstructor(t.key);
          }
          parseClassBody(t, e) {
            this.classScope.enter();
            let s = { hadConstructor: false, hadSuperClass: t }, i = [], r = this.startNode();
            if (r.body = [], this.expect(5), this.withSmartMixTopicForbiddingContext(() => {
              for (; !this.match(8); ) {
                if (this.eat(13)) {
                  if (i.length > 0) throw this.raise(p.DecoratorSemicolon, this.state.lastTokEndLoc);
                  continue;
                }
                if (this.match(26)) {
                  i.push(this.parseDecorator());
                  continue;
                }
                let n = this.startNode();
                i.length && (n.decorators = i, this.resetStartLocationFromNode(n, i[0]), i = []), this.parseClassMember(r, n, s), n.kind === "constructor" && n.decorators && n.decorators.length > 0 && this.raise(p.DecoratorConstructor, n);
              }
            }), this.state.strict = e, this.next(), i.length) throw this.raise(p.TrailingDecorator, this.state.startLoc);
            return this.classScope.exit(), this.finishNode(r, "ClassBody");
          }
          parseClassMemberFromModifier(t, e) {
            let s = this.parseIdentifier(true);
            if (this.isClassMethod()) {
              let i = e;
              return i.kind = "method", i.computed = false, i.key = s, i.static = false, this.pushClassMethod(t, i, false, false, false, false), true;
            } else if (this.isClassProperty()) {
              let i = e;
              return i.computed = false, i.key = s, i.static = false, t.body.push(this.parseClassProperty(i)), true;
            }
            return this.resetPreviousNodeTrailingComments(s), false;
          }
          parseClassMember(t, e, s) {
            let i = this.isContextual(106);
            if (i) {
              if (this.parseClassMemberFromModifier(t, e)) return;
              if (this.eat(5)) {
                this.parseClassStaticBlock(t, e);
                return;
              }
            }
            this.parseClassMemberWithIsStatic(t, e, s, i);
          }
          parseClassMemberWithIsStatic(t, e, s, i) {
            let r = e, n = e, o = e, h = e, c2 = e, l = r, u = r;
            if (e.static = i, this.parsePropertyNamePrefixOperator(e), this.eat(55)) {
              l.kind = "method";
              let S2 = this.match(138);
              if (this.parseClassElementName(l), S2) {
                this.pushClassPrivateMethod(t, n, true, false);
                return;
              }
              this.isNonstaticConstructor(r) && this.raise(p.ConstructorIsGenerator, r.key), this.pushClassMethod(t, r, true, false, false, false);
              return;
            }
            let f = !this.state.containsEsc && w(this.state.type), d = this.parseClassElementName(e), y2 = f ? d.name : null, E = this.isPrivateName(d), L2 = this.state.startLoc;
            if (this.parsePostMemberNameModifiers(u), this.isClassMethod()) {
              if (l.kind = "method", E) {
                this.pushClassPrivateMethod(t, n, false, false);
                return;
              }
              let S2 = this.isNonstaticConstructor(r), I2 = false;
              S2 && (r.kind = "constructor", s.hadConstructor && !this.hasPlugin("typescript") && this.raise(p.DuplicateConstructor, d), S2 && this.hasPlugin("typescript") && e.override && this.raise(p.OverrideOnConstructor, d), s.hadConstructor = true, I2 = s.hadSuperClass), this.pushClassMethod(t, r, false, false, S2, I2);
            } else if (this.isClassProperty()) E ? this.pushClassPrivateProperty(t, h) : this.pushClassProperty(t, o);
            else if (y2 === "async" && !this.isLineTerminator()) {
              this.resetPreviousNodeTrailingComments(d);
              let S2 = this.eat(55);
              u.optional && this.unexpected(L2), l.kind = "method";
              let I2 = this.match(138);
              this.parseClassElementName(l), this.parsePostMemberNameModifiers(u), I2 ? this.pushClassPrivateMethod(t, n, S2, true) : (this.isNonstaticConstructor(r) && this.raise(p.ConstructorIsAsync, r.key), this.pushClassMethod(t, r, S2, true, false, false));
            } else if ((y2 === "get" || y2 === "set") && !(this.match(55) && this.isLineTerminator())) {
              this.resetPreviousNodeTrailingComments(d), l.kind = y2;
              let S2 = this.match(138);
              this.parseClassElementName(r), S2 ? this.pushClassPrivateMethod(t, n, false, false) : (this.isNonstaticConstructor(r) && this.raise(p.ConstructorIsAccessor, r.key), this.pushClassMethod(t, r, false, false, false, false)), this.checkGetterSetterParams(r);
            } else if (y2 === "accessor" && !this.isLineTerminator()) {
              this.expectPlugin("decoratorAutoAccessors"), this.resetPreviousNodeTrailingComments(d);
              let S2 = this.match(138);
              this.parseClassElementName(o), this.pushClassAccessorProperty(t, c2, S2);
            } else this.isLineTerminator() ? E ? this.pushClassPrivateProperty(t, h) : this.pushClassProperty(t, o) : this.unexpected();
          }
          parseClassElementName(t) {
            let { type: e, value: s } = this.state;
            if ((e === 132 || e === 133) && t.static && s === "prototype" && this.raise(p.StaticPrototype, this.state.startLoc), e === 138) {
              s === "constructor" && this.raise(p.ConstructorClassPrivateField, this.state.startLoc);
              let i = this.parsePrivateName();
              return t.key = i, i;
            }
            return this.parsePropertyName(t), t.key;
          }
          parseClassStaticBlock(t, e) {
            var s;
            this.scope.enter(208);
            let i = this.state.labels;
            this.state.labels = [], this.prodParam.enter(0);
            let r = e.body = [];
            this.parseBlockOrModuleBlockBody(r, void 0, false, 8), this.prodParam.exit(), this.scope.exit(), this.state.labels = i, t.body.push(this.finishNode(e, "StaticBlock")), (s = e.decorators) != null && s.length && this.raise(p.DecoratorStaticBlock, e);
          }
          pushClassProperty(t, e) {
            !e.computed && this.nameIsConstructor(e.key) && this.raise(p.ConstructorClassField, e.key), t.body.push(this.parseClassProperty(e));
          }
          pushClassPrivateProperty(t, e) {
            let s = this.parseClassPrivateProperty(e);
            t.body.push(s), this.classScope.declarePrivateName(this.getPrivateNameSV(s.key), 0, s.key.loc.start);
          }
          pushClassAccessorProperty(t, e, s) {
            !s && !e.computed && this.nameIsConstructor(e.key) && this.raise(p.ConstructorClassField, e.key);
            let i = this.parseClassAccessorProperty(e);
            t.body.push(i), s && this.classScope.declarePrivateName(this.getPrivateNameSV(i.key), 0, i.key.loc.start);
          }
          pushClassMethod(t, e, s, i, r, n) {
            t.body.push(this.parseMethod(e, s, i, r, n, "ClassMethod", true));
          }
          pushClassPrivateMethod(t, e, s, i) {
            let r = this.parseMethod(e, s, i, false, false, "ClassPrivateMethod", true);
            t.body.push(r);
            let n = r.kind === "get" ? r.static ? 6 : 2 : r.kind === "set" ? r.static ? 5 : 1 : 0;
            this.declareClassPrivateMethodInScope(r, n);
          }
          declareClassPrivateMethodInScope(t, e) {
            this.classScope.declarePrivateName(this.getPrivateNameSV(t.key), e, t.key.loc.start);
          }
          parsePostMemberNameModifiers(t) {
          }
          parseClassPrivateProperty(t) {
            return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassPrivateProperty");
          }
          parseClassProperty(t) {
            return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassProperty");
          }
          parseClassAccessorProperty(t) {
            return this.parseInitializer(t), this.semicolon(), this.finishNode(t, "ClassAccessorProperty");
          }
          parseInitializer(t) {
            this.scope.enter(80), this.expressionScope.enter(rs()), this.prodParam.enter(0), t.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
          }
          parseClassId(t, e, s, i = 8331) {
            if (w(this.state.type)) t.id = this.parseIdentifier(), e && this.declareNameFromIdentifier(t.id, i);
            else if (s || !e) t.id = null;
            else throw this.raise(p.MissingClassName, this.state.startLoc);
          }
          parseClassSuper(t) {
            t.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
          }
          parseExport(t, e) {
            let s = this.parseMaybeImportPhase(t, true), i = this.maybeParseExportDefaultSpecifier(t, s), r = !i || this.eat(12), n = r && this.eatExportStar(t), o = n && this.maybeParseExportNamespaceSpecifier(t), h = r && (!o || this.eat(12)), c2 = i || n;
            if (n && !o) {
              if (i && this.unexpected(), e) throw this.raise(p.UnsupportedDecoratorExport, t);
              return this.parseExportFrom(t, true), this.finishNode(t, "ExportAllDeclaration");
            }
            let l = this.maybeParseExportNamedSpecifiers(t);
            i && r && !n && !l && this.unexpected(null, 5), o && h && this.unexpected(null, 98);
            let u;
            if (c2 || l) {
              if (u = false, e) throw this.raise(p.UnsupportedDecoratorExport, t);
              this.parseExportFrom(t, c2);
            } else u = this.maybeParseExportDeclaration(t);
            if (c2 || l || u) {
              var f;
              let d = t;
              if (this.checkExport(d, true, false, !!d.source), ((f = d.declaration) == null ? void 0 : f.type) === "ClassDeclaration") this.maybeTakeDecorators(e, d.declaration, d);
              else if (e) throw this.raise(p.UnsupportedDecoratorExport, t);
              return this.finishNode(d, "ExportNamedDeclaration");
            }
            if (this.eat(65)) {
              let d = t, y2 = this.parseExportDefaultExpression();
              if (d.declaration = y2, y2.type === "ClassDeclaration") this.maybeTakeDecorators(e, y2, d);
              else if (e) throw this.raise(p.UnsupportedDecoratorExport, t);
              return this.checkExport(d, true, true), this.finishNode(d, "ExportDefaultDeclaration");
            }
            this.unexpected(null, 5);
          }
          eatExportStar(t) {
            return this.eat(55);
          }
          maybeParseExportDefaultSpecifier(t, e) {
            if (e || this.isExportDefaultSpecifier()) {
              this.expectPlugin("exportDefaultFrom", e == null ? void 0 : e.loc.start);
              let s = e || this.parseIdentifier(true), i = this.startNodeAtNode(s);
              return i.exported = s, t.specifiers = [this.finishNode(i, "ExportDefaultSpecifier")], true;
            }
            return false;
          }
          maybeParseExportNamespaceSpecifier(t) {
            if (this.isContextual(93)) {
              var e, s;
              (s = (e = t).specifiers) != null || (e.specifiers = []);
              let i = this.startNodeAt(this.state.lastTokStartLoc);
              return this.next(), i.exported = this.parseModuleExportName(), t.specifiers.push(this.finishNode(i, "ExportNamespaceSpecifier")), true;
            }
            return false;
          }
          maybeParseExportNamedSpecifiers(t) {
            if (this.match(5)) {
              let e = t;
              e.specifiers || (e.specifiers = []);
              let s = e.exportKind === "type";
              return e.specifiers.push(...this.parseExportSpecifiers(s)), e.source = null, e.declaration = null, this.hasPlugin("importAssertions") && (e.assertions = []), true;
            }
            return false;
          }
          maybeParseExportDeclaration(t) {
            return this.shouldParseExportDeclaration() ? (t.specifiers = [], t.source = null, this.hasPlugin("importAssertions") && (t.assertions = []), t.declaration = this.parseExportDeclaration(t), true) : false;
          }
          isAsyncFunction() {
            if (!this.isContextual(95)) return false;
            let t = this.nextTokenInLineStart();
            return this.isUnparsedContextual(t, "function");
          }
          parseExportDefaultExpression() {
            let t = this.startNode();
            if (this.match(68)) return this.next(), this.parseFunction(t, 5);
            if (this.isAsyncFunction()) return this.next(), this.next(), this.parseFunction(t, 13);
            if (this.match(80)) return this.parseClass(t, true, true);
            if (this.match(26)) return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === true && this.raise(p.DecoratorBeforeExport, this.state.startLoc), this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);
            if (this.match(75) || this.match(74) || this.isLet()) throw this.raise(p.UnsupportedDefaultExport, this.state.startLoc);
            let e = this.parseMaybeAssignAllowIn();
            return this.semicolon(), e;
          }
          parseExportDeclaration(t) {
            return this.match(80) ? this.parseClass(this.startNode(), true, false) : this.parseStatementListItem();
          }
          isExportDefaultSpecifier() {
            let { type: t } = this.state;
            if (w(t)) {
              if (t === 95 && !this.state.containsEsc || t === 100) return false;
              if ((t === 130 || t === 129) && !this.state.containsEsc) {
                let { type: i } = this.lookahead();
                if (w(i) && i !== 98 || i === 5) return this.expectOnePlugin(["flow", "typescript"]), false;
              }
            } else if (!this.match(65)) return false;
            let e = this.nextTokenStart(), s = this.isUnparsedContextual(e, "from");
            if (this.input.charCodeAt(e) === 44 || w(this.state.type) && s) return true;
            if (this.match(65) && s) {
              let i = this.input.charCodeAt(this.nextTokenStartSince(e + 4));
              return i === 34 || i === 39;
            }
            return false;
          }
          parseExportFrom(t, e) {
            this.eatContextual(98) ? (t.source = this.parseImportSource(), this.checkExport(t), this.maybeParseImportAttributes(t), this.checkJSONModuleImport(t)) : e && this.unexpected(), this.semicolon();
          }
          shouldParseExportDeclaration() {
            let { type: t } = this.state;
            return t === 26 && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators")) ? (this.getPluginOption("decorators", "decoratorsBeforeExport") === true && this.raise(p.DecoratorBeforeExport, this.state.startLoc), true) : this.isContextual(107) ? (this.raise(p.UsingDeclarationExport, this.state.startLoc), true) : this.isContextual(96) && this.startsAwaitUsing() ? (this.raise(p.UsingDeclarationExport, this.state.startLoc), true) : t === 74 || t === 75 || t === 68 || t === 80 || this.isLet() || this.isAsyncFunction();
          }
          checkExport(t, e, s, i) {
            if (e) {
              var r;
              if (s) {
                if (this.checkDuplicateExports(t, "default"), this.hasPlugin("exportDefaultFrom")) {
                  var n;
                  let o = t.declaration;
                  o.type === "Identifier" && o.name === "from" && o.end - o.start === 4 && !((n = o.extra) != null && n.parenthesized) && this.raise(p.ExportDefaultFromAsIdentifier, o);
                }
              } else if ((r = t.specifiers) != null && r.length) for (let o of t.specifiers) {
                let { exported: h } = o, c2 = h.type === "Identifier" ? h.name : h.value;
                if (this.checkDuplicateExports(o, c2), !i && o.local) {
                  let { local: l } = o;
                  l.type !== "Identifier" ? this.raise(p.ExportBindingIsString, o, { localName: l.value, exportName: c2 }) : (this.checkReservedWord(l.name, l.loc.start, true, false), this.scope.checkLocalExport(l));
                }
              }
              else if (t.declaration) {
                let o = t.declaration;
                if (o.type === "FunctionDeclaration" || o.type === "ClassDeclaration") {
                  let { id: h } = o;
                  if (!h) throw new Error("Assertion failure");
                  this.checkDuplicateExports(t, h.name);
                } else if (o.type === "VariableDeclaration") for (let h of o.declarations) this.checkDeclaration(h.id);
              }
            }
          }
          checkDeclaration(t) {
            if (t.type === "Identifier") this.checkDuplicateExports(t, t.name);
            else if (t.type === "ObjectPattern") for (let e of t.properties) this.checkDeclaration(e);
            else if (t.type === "ArrayPattern") for (let e of t.elements) e && this.checkDeclaration(e);
            else t.type === "ObjectProperty" ? this.checkDeclaration(t.value) : t.type === "RestElement" ? this.checkDeclaration(t.argument) : t.type === "AssignmentPattern" && this.checkDeclaration(t.left);
          }
          checkDuplicateExports(t, e) {
            this.exportedIdentifiers.has(e) && (e === "default" ? this.raise(p.DuplicateDefaultExport, t) : this.raise(p.DuplicateExport, t, { exportName: e })), this.exportedIdentifiers.add(e);
          }
          parseExportSpecifiers(t) {
            let e = [], s = true;
            for (this.expect(5); !this.eat(8); ) {
              if (s) s = false;
              else if (this.expect(12), this.eat(8)) break;
              let i = this.isContextual(130), r = this.match(133), n = this.startNode();
              n.local = this.parseModuleExportName(), e.push(this.parseExportSpecifier(n, r, t, i));
            }
            return e;
          }
          parseExportSpecifier(t, e, s, i) {
            return this.eatContextual(93) ? t.exported = this.parseModuleExportName() : e ? t.exported = Ri(t.local) : t.exported || (t.exported = $(t.local)), this.finishNode(t, "ExportSpecifier");
          }
          parseModuleExportName() {
            if (this.match(133)) {
              let t = this.parseStringLiteral(this.state.value), e = nr2.exec(t.value);
              return e && this.raise(p.ModuleExportNameHasLoneSurrogate, t, { surrogateCharCode: e[0].charCodeAt(0) }), t;
            }
            return this.parseIdentifier(true);
          }
          isJSONModuleImport(t) {
            return t.assertions != null ? t.assertions.some(({ key: e, value: s }) => s.value === "json" && (e.type === "Identifier" ? e.name === "type" : e.value === "type")) : false;
          }
          checkImportReflection(t) {
            let { specifiers: e } = t, s = e.length === 1 ? e[0].type : null;
            if (t.phase === "source") s !== "ImportDefaultSpecifier" && this.raise(p.SourcePhaseImportRequiresDefault, e[0].loc.start);
            else if (t.phase === "defer") s !== "ImportNamespaceSpecifier" && this.raise(p.DeferImportRequiresNamespace, e[0].loc.start);
            else if (t.module) {
              var i;
              s !== "ImportDefaultSpecifier" && this.raise(p.ImportReflectionNotBinding, e[0].loc.start), ((i = t.assertions) == null ? void 0 : i.length) > 0 && this.raise(p.ImportReflectionHasAssertion, e[0].loc.start);
            }
          }
          checkJSONModuleImport(t) {
            if (this.isJSONModuleImport(t) && t.type !== "ExportAllDeclaration") {
              let { specifiers: e } = t;
              if (e != null) {
                let s = e.find((i) => {
                  let r;
                  if (i.type === "ExportSpecifier" ? r = i.local : i.type === "ImportSpecifier" && (r = i.imported), r !== void 0) return r.type === "Identifier" ? r.name !== "default" : r.value !== "default";
                });
                s !== void 0 && this.raise(p.ImportJSONBindingNotDefault, s.loc.start);
              }
            }
          }
          isPotentialImportPhase(t) {
            return t ? false : this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
          }
          applyImportPhase(t, e, s, i) {
            e || (s === "module" ? (this.expectPlugin("importReflection", i), t.module = true) : this.hasPlugin("importReflection") && (t.module = false), s === "source" ? (this.expectPlugin("sourcePhaseImports", i), t.phase = "source") : s === "defer" ? (this.expectPlugin("deferredImportEvaluation", i), t.phase = "defer") : this.hasPlugin("sourcePhaseImports") && (t.phase = null));
          }
          parseMaybeImportPhase(t, e) {
            if (!this.isPotentialImportPhase(e)) return this.applyImportPhase(t, e, null), null;
            let s = this.parseIdentifier(true), { type: i } = this.state;
            return (M2(i) ? i !== 98 || this.lookaheadCharCode() === 102 : i !== 12) ? (this.resetPreviousIdentifierLeadingComments(s), this.applyImportPhase(t, e, s.name, s.loc.start), null) : (this.applyImportPhase(t, e, null), s);
          }
          isPrecedingIdImportPhase(t) {
            let { type: e } = this.state;
            return w(e) ? e !== 98 || this.lookaheadCharCode() === 102 : e !== 12;
          }
          parseImport(t) {
            return this.match(133) ? this.parseImportSourceAndAttributes(t) : this.parseImportSpecifiersAndAfter(t, this.parseMaybeImportPhase(t, false));
          }
          parseImportSpecifiersAndAfter(t, e) {
            t.specifiers = [];
            let i = !this.maybeParseDefaultImportSpecifier(t, e) || this.eat(12), r = i && this.maybeParseStarImportSpecifier(t);
            return i && !r && this.parseNamedImportSpecifiers(t), this.expectContextual(98), this.parseImportSourceAndAttributes(t);
          }
          parseImportSourceAndAttributes(t) {
            var e;
            return (e = t.specifiers) != null || (t.specifiers = []), t.source = this.parseImportSource(), this.maybeParseImportAttributes(t), this.checkImportReflection(t), this.checkJSONModuleImport(t), this.semicolon(), this.finishNode(t, "ImportDeclaration");
          }
          parseImportSource() {
            return this.match(133) || this.unexpected(), this.parseExprAtom();
          }
          parseImportSpecifierLocal(t, e, s) {
            e.local = this.parseIdentifier(), t.specifiers.push(this.finishImportSpecifier(e, s));
          }
          finishImportSpecifier(t, e, s = 8201) {
            return this.checkLVal(t.local, { in: { type: e }, binding: s }), this.finishNode(t, e);
          }
          parseImportAttributes() {
            this.expect(5);
            let t = [], e = /* @__PURE__ */ new Set();
            do {
              if (this.match(8)) break;
              let s = this.startNode(), i = this.state.value;
              if (e.has(i) && this.raise(p.ModuleAttributesWithDuplicateKeys, this.state.startLoc, { key: i }), e.add(i), this.match(133) ? s.key = this.parseStringLiteral(i) : s.key = this.parseIdentifier(true), this.expect(14), !this.match(133)) throw this.raise(p.ModuleAttributeInvalidValue, this.state.startLoc);
              s.value = this.parseStringLiteral(this.state.value), t.push(this.finishNode(s, "ImportAttribute"));
            } while (this.eat(12));
            return this.expect(8), t;
          }
          parseModuleAttributes() {
            let t = [], e = /* @__PURE__ */ new Set();
            do {
              let s = this.startNode();
              if (s.key = this.parseIdentifier(true), s.key.name !== "type" && this.raise(p.ModuleAttributeDifferentFromType, s.key), e.has(s.key.name) && this.raise(p.ModuleAttributesWithDuplicateKeys, s.key, { key: s.key.name }), e.add(s.key.name), this.expect(14), !this.match(133)) throw this.raise(p.ModuleAttributeInvalidValue, this.state.startLoc);
              s.value = this.parseStringLiteral(this.state.value), t.push(this.finishNode(s, "ImportAttribute"));
            } while (this.eat(12));
            return t;
          }
          maybeParseImportAttributes(t) {
            let e, s = false;
            if (this.match(76)) {
              if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) return;
              this.next(), this.hasPlugin("moduleAttributes") ? e = this.parseModuleAttributes() : (this.expectImportAttributesPlugin(), e = this.parseImportAttributes()), s = true;
            } else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) this.hasPlugin("importAttributes") ? (this.getPluginOption("importAttributes", "deprecatedAssertSyntax") !== true && this.raise(p.ImportAttributesUseAssert, this.state.startLoc), this.addExtra(t, "deprecatedAssertSyntax", true)) : this.expectOnePlugin(["importAttributes", "importAssertions"]), this.next(), e = this.parseImportAttributes();
            else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) e = [];
            else if (this.hasPlugin("moduleAttributes")) e = [];
            else return;
            !s && this.hasPlugin("importAssertions") ? t.assertions = e : t.attributes = e;
          }
          maybeParseDefaultImportSpecifier(t, e) {
            if (e) {
              let s = this.startNodeAtNode(e);
              return s.local = e, t.specifiers.push(this.finishImportSpecifier(s, "ImportDefaultSpecifier")), true;
            } else if (M2(this.state.type)) return this.parseImportSpecifierLocal(t, this.startNode(), "ImportDefaultSpecifier"), true;
            return false;
          }
          maybeParseStarImportSpecifier(t) {
            if (this.match(55)) {
              let e = this.startNode();
              return this.next(), this.expectContextual(93), this.parseImportSpecifierLocal(t, e, "ImportNamespaceSpecifier"), true;
            }
            return false;
          }
          parseNamedImportSpecifiers(t) {
            let e = true;
            for (this.expect(5); !this.eat(8); ) {
              if (e) e = false;
              else {
                if (this.eat(14)) throw this.raise(p.DestructureNamedImport, this.state.startLoc);
                if (this.expect(12), this.eat(8)) break;
              }
              let s = this.startNode(), i = this.match(133), r = this.isContextual(130);
              s.imported = this.parseModuleExportName();
              let n = this.parseImportSpecifier(s, i, t.importKind === "type" || t.importKind === "typeof", r, void 0);
              t.specifiers.push(n);
            }
          }
          parseImportSpecifier(t, e, s, i, r) {
            if (this.eatContextual(93)) t.local = this.parseIdentifier();
            else {
              let { imported: n } = t;
              if (e) throw this.raise(p.ImportBindingIsString, t, { importName: n.value });
              this.checkReservedWord(n.name, t.loc.start, true, true), t.local || (t.local = $(n));
            }
            return this.finishImportSpecifier(t, "ImportSpecifier", r);
          }
          isThisParam(t) {
            return t.type === "Identifier" && t.name === "this";
          }
        }, Me2 = class extends pt2 {
          constructor(t, e) {
            t = rr2(t), super(t, e), this.options = t, this.initializeScopes(), this.plugins = hr2(this.options.plugins), this.filename = t.sourceFilename;
          }
          getScopeHandler() {
            return me2;
          }
          parse() {
            this.enterInitialScopes();
            let t = this.startNode(), e = this.startNode();
            return this.nextToken(), t.errors = null, this.parseTopLevel(t, e), t.errors = this.state.errors, t.comments.length = this.state.commentsLen, t;
          }
        };
        function hr2(a) {
          let t = /* @__PURE__ */ new Map();
          for (let e of a) {
            let [s, i] = Array.isArray(e) ? e : [e, {}];
            t.has(s) || t.set(s, i || {});
          }
          return t;
        }
        function lr2(a, t) {
          var e;
          if (((e = t) == null ? void 0 : e.sourceType) === "unambiguous") {
            t = Object.assign({}, t);
            try {
              t.sourceType = "module";
              let s = pe2(t, a), i = s.parse();
              if (s.sawUnambiguousESM) return i;
              if (s.ambiguousScriptDifferentAst) try {
                return t.sourceType = "script", pe2(t, a).parse();
              } catch {
              }
              else i.program.sourceType = "script";
              return i;
            } catch (s) {
              try {
                return t.sourceType = "script", pe2(t, a).parse();
              } catch {
              }
              throw s;
            }
          } else return pe2(t, a).parse();
        }
        function cr2(a, t) {
          let e = pe2(t, a);
          return e.options.strictMode && (e.state.strict = true), e.getExpression();
        }
        function pr2(a) {
          let t = {};
          for (let e of Object.keys(a)) t[e] = R2(a[e]);
          return t;
        }
        var ur2 = pr2(ni2);
        function pe2(a, t) {
          let e = Me2;
          return a != null && a.plugins && (sr2(a.plugins), e = fr2(a.plugins)), new e(a, t);
        }
        var Kt2 = {};
        function fr2(a) {
          let t = ir2.filter((i) => N2(a, i)), e = t.join("/"), s = Kt2[e];
          if (!s) {
            s = Me2;
            for (let i of t) s = hs[i](s);
            Kt2[e] = s;
          }
          return s;
        }
        xe2.parse = lr2;
        xe2.parseExpression = cr2;
        xe2.tokTypes = ur2;
      });
      var Zr2 = {};
      Ws(Zr2, { parsers: () => Qr2 });
      var je2 = vt2(At2(), 1);
      function Oe2(a) {
        return (t, e, s) => {
          let i = !!(s != null && s.backwards);
          if (e === false) return false;
          let { length: r } = t, n = e;
          for (; n >= 0 && n < r; ) {
            let o = t.charAt(n);
            if (a instanceof RegExp) {
              if (!a.test(o)) return n;
            } else if (!a.includes(o)) return n;
            i ? n-- : n++;
          }
          return n === -1 || n === r ? n : false;
        };
      }
      var ha = Oe2(/\s/u), ls = Oe2(" 	"), la = Oe2(",; 	"), cs = Oe2(/[^\n\r]/u);
      function dr2(a, t) {
        if (t === false) return false;
        if (a.charAt(t) === "/" && a.charAt(t + 1) === "*") {
          for (let e = t + 2; e < a.length; ++e) if (a.charAt(e) === "*" && a.charAt(e + 1) === "/") return e + 2;
        }
        return t;
      }
      var ps = dr2;
      function mr2(a, t, e) {
        let s = !!(e != null && e.backwards);
        if (t === false) return false;
        let i = a.charAt(t);
        if (s) {
          if (a.charAt(t - 1) === "\r" && i === `
`) return t - 2;
          if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029") return t - 1;
        } else {
          if (i === "\r" && a.charAt(t + 1) === `
`) return t + 2;
          if (i === `
` || i === "\r" || i === "\u2028" || i === "\u2029") return t + 1;
        }
        return t;
      }
      var us = mr2;
      function yr2(a, t) {
        return t === false ? false : a.charAt(t) === "/" && a.charAt(t + 1) === "/" ? cs(a, t) : t;
      }
      var fs = yr2;
      function xr2(a, t) {
        let e = null, s = t;
        for (; s !== e; ) e = s, s = ls(a, s), s = ps(a, s), s = fs(a, s), s = us(a, s);
        return s;
      }
      var ds = xr2;
      function Pr2(a) {
        let t = [];
        for (let e of a) try {
          return e();
        } catch (s) {
          t.push(s);
        }
        throw Object.assign(new Error("All combinations failed"), { errors: t });
      }
      var ms = Pr2;
      function gr2(a) {
        if (!a.startsWith("#!")) return "";
        let t = a.indexOf(`
`);
        return t === -1 ? a : a.slice(0, t);
      }
      var Fe2 = gr2;
      var Tr2 = (a, t, e) => {
        if (!(a && t == null)) return Array.isArray(t) || typeof t == "string" ? t[e < 0 ? t.length + e : e] : t.at(e);
      }, St2 = Tr2;
      function br2(a) {
        return Array.isArray(a) && a.length > 0;
      }
      var Pe2 = br2;
      function D(a) {
        var s, i, r;
        let t = ((s = a.range) == null ? void 0 : s[0]) ?? a.start, e = (r = ((i = a.declaration) == null ? void 0 : i.decorators) ?? a.decorators) == null ? void 0 : r[0];
        return e ? Math.min(D(e), t) : t;
      }
      function B2(a) {
        var t;
        return ((t = a.range) == null ? void 0 : t[1]) ?? a.end;
      }
      function Ar2(a) {
        let t = new Set(a);
        return (e) => t.has(e == null ? void 0 : e.type);
      }
      var ys = Ar2;
      var Sr2 = ys(["Block", "CommentBlock", "MultiLine"]), ge2 = Sr2;
      function wr2(a) {
        let t = `*${a.value}*`.split(`
`);
        return t.length > 1 && t.every((e) => e.trimStart()[0] === "*");
      }
      var wt2 = wr2;
      function Cr2(a) {
        return ge2(a) && a.value[0] === "*" && /@(?:type|satisfies)\b/u.test(a.value);
      }
      var xs = Cr2;
      var Te2 = null;
      function be2(a) {
        if (Te2 !== null && typeof Te2.property) {
          let t = Te2;
          return Te2 = be2.prototype = null, t;
        }
        return Te2 = be2.prototype = a ?? /* @__PURE__ */ Object.create(null), new be2();
      }
      var Er2 = 10;
      for (let a = 0; a <= Er2; a++) be2();
      function Ct(a) {
        return be2(a);
      }
      function Ir2(a, t = "type") {
        Ct(a);
        function e(s) {
          let i = s[t], r = a[i];
          if (!Array.isArray(r)) throw Object.assign(new Error(`Missing visitor keys for '${i}'.`), { node: s });
          return r;
        }
        return e;
      }
      var Ps = Ir2;
      var gs = { ArrayExpression: ["elements"], AssignmentExpression: ["left", "right"], BinaryExpression: ["left", "right"], InterpreterDirective: [], Directive: ["value"], DirectiveLiteral: [], BlockStatement: ["directives", "body"], BreakStatement: ["label"], CallExpression: ["callee", "arguments", "typeParameters", "typeArguments"], CatchClause: ["param", "body"], ConditionalExpression: ["test", "consequent", "alternate"], ContinueStatement: ["label"], DebuggerStatement: [], DoWhileStatement: ["test", "body"], EmptyStatement: [], ExpressionStatement: ["expression"], File: ["program"], ForInStatement: ["left", "right", "body"], ForStatement: ["init", "test", "update", "body"], FunctionDeclaration: ["id", "params", "body", "returnType", "typeParameters", "predicate"], FunctionExpression: ["id", "params", "body", "returnType", "typeParameters"], Identifier: ["typeAnnotation", "decorators"], IfStatement: ["test", "consequent", "alternate"], LabeledStatement: ["label", "body"], StringLiteral: [], NumericLiteral: [], NullLiteral: [], BooleanLiteral: [], RegExpLiteral: [], LogicalExpression: ["left", "right"], MemberExpression: ["object", "property"], NewExpression: ["callee", "arguments", "typeParameters", "typeArguments"], Program: ["directives", "body"], ObjectExpression: ["properties"], ObjectMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], ObjectProperty: ["key", "value", "decorators"], RestElement: ["argument", "typeAnnotation", "decorators"], ReturnStatement: ["argument"], SequenceExpression: ["expressions"], ParenthesizedExpression: ["expression"], SwitchCase: ["test", "consequent"], SwitchStatement: ["discriminant", "cases"], ThisExpression: [], ThrowStatement: ["argument"], TryStatement: ["block", "handler", "finalizer"], UnaryExpression: ["argument"], UpdateExpression: ["argument"], VariableDeclaration: ["declarations"], VariableDeclarator: ["id", "init"], WhileStatement: ["test", "body"], WithStatement: ["object", "body"], AssignmentPattern: ["left", "right", "decorators", "typeAnnotation"], ArrayPattern: ["elements", "typeAnnotation", "decorators"], ArrowFunctionExpression: ["params", "body", "returnType", "typeParameters", "predicate"], ClassBody: ["body"], ClassExpression: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators", "superTypeArguments"], ClassDeclaration: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators", "superTypeArguments"], ExportAllDeclaration: ["source", "attributes", "exported"], ExportDefaultDeclaration: ["declaration"], ExportNamedDeclaration: ["declaration", "specifiers", "source", "attributes"], ExportSpecifier: ["local", "exported"], ForOfStatement: ["left", "right", "body"], ImportDeclaration: ["specifiers", "source", "attributes"], ImportDefaultSpecifier: ["local"], ImportNamespaceSpecifier: ["local"], ImportSpecifier: ["local", "imported"], ImportExpression: ["source", "options", "attributes"], MetaProperty: ["meta", "property"], ClassMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], ObjectPattern: ["properties", "typeAnnotation", "decorators"], SpreadElement: ["argument"], Super: [], TaggedTemplateExpression: ["tag", "quasi", "typeParameters", "typeArguments"], TemplateElement: [], TemplateLiteral: ["quasis", "expressions"], YieldExpression: ["argument"], AwaitExpression: ["argument"], Import: [], BigIntLiteral: [], ExportNamespaceSpecifier: ["exported"], OptionalMemberExpression: ["object", "property"], OptionalCallExpression: ["callee", "arguments", "typeParameters", "typeArguments"], ClassProperty: ["key", "value", "typeAnnotation", "decorators", "variance"], ClassAccessorProperty: ["key", "value", "typeAnnotation", "decorators"], ClassPrivateProperty: ["key", "value", "decorators", "typeAnnotation", "variance"], ClassPrivateMethod: ["key", "params", "body", "decorators", "returnType", "typeParameters"], PrivateName: ["id"], StaticBlock: ["body"], AnyTypeAnnotation: [], ArrayTypeAnnotation: ["elementType"], BooleanTypeAnnotation: [], BooleanLiteralTypeAnnotation: [], NullLiteralTypeAnnotation: [], ClassImplements: ["id", "typeParameters"], DeclareClass: ["id", "typeParameters", "extends", "mixins", "implements", "body"], DeclareFunction: ["id", "predicate"], DeclareInterface: ["id", "typeParameters", "extends", "body"], DeclareModule: ["id", "body"], DeclareModuleExports: ["typeAnnotation"], DeclareTypeAlias: ["id", "typeParameters", "right"], DeclareOpaqueType: ["id", "typeParameters", "supertype"], DeclareVariable: ["id"], DeclareExportDeclaration: ["declaration", "specifiers", "source"], DeclareExportAllDeclaration: ["source"], DeclaredPredicate: ["value"], ExistsTypeAnnotation: [], FunctionTypeAnnotation: ["typeParameters", "params", "rest", "returnType", "this"], FunctionTypeParam: ["name", "typeAnnotation"], GenericTypeAnnotation: ["id", "typeParameters"], InferredPredicate: [], InterfaceExtends: ["id", "typeParameters"], InterfaceDeclaration: ["id", "typeParameters", "extends", "body"], InterfaceTypeAnnotation: ["extends", "body"], IntersectionTypeAnnotation: ["types"], MixedTypeAnnotation: [], EmptyTypeAnnotation: [], NullableTypeAnnotation: ["typeAnnotation"], NumberLiteralTypeAnnotation: [], NumberTypeAnnotation: [], ObjectTypeAnnotation: ["properties", "indexers", "callProperties", "internalSlots"], ObjectTypeInternalSlot: ["id", "value"], ObjectTypeCallProperty: ["value"], ObjectTypeIndexer: ["id", "key", "value", "variance"], ObjectTypeProperty: ["key", "value", "variance"], ObjectTypeSpreadProperty: ["argument"], OpaqueType: ["id", "typeParameters", "supertype", "impltype"], QualifiedTypeIdentifier: ["id", "qualification"], StringLiteralTypeAnnotation: [], StringTypeAnnotation: [], SymbolTypeAnnotation: [], ThisTypeAnnotation: [], TupleTypeAnnotation: ["types", "elementTypes"], TypeofTypeAnnotation: ["argument", "typeArguments"], TypeAlias: ["id", "typeParameters", "right"], TypeAnnotation: ["typeAnnotation"], TypeCastExpression: ["expression", "typeAnnotation"], TypeParameter: ["bound", "default", "variance"], TypeParameterDeclaration: ["params"], TypeParameterInstantiation: ["params"], UnionTypeAnnotation: ["types"], Variance: [], VoidTypeAnnotation: [], EnumDeclaration: ["id", "body"], EnumBooleanBody: ["members"], EnumNumberBody: ["members"], EnumStringBody: ["members"], EnumSymbolBody: ["members"], EnumBooleanMember: ["id", "init"], EnumNumberMember: ["id", "init"], EnumStringMember: ["id", "init"], EnumDefaultedMember: ["id"], IndexedAccessType: ["objectType", "indexType"], OptionalIndexedAccessType: ["objectType", "indexType"], JSXAttribute: ["name", "value"], JSXClosingElement: ["name"], JSXElement: ["openingElement", "children", "closingElement"], JSXEmptyExpression: [], JSXExpressionContainer: ["expression"], JSXSpreadChild: ["expression"], JSXIdentifier: [], JSXMemberExpression: ["object", "property"], JSXNamespacedName: ["namespace", "name"], JSXOpeningElement: ["name", "attributes", "typeArguments", "typeParameters"], JSXSpreadAttribute: ["argument"], JSXText: [], JSXFragment: ["openingFragment", "children", "closingFragment"], JSXOpeningFragment: [], JSXClosingFragment: [], Noop: [], Placeholder: [], V8IntrinsicIdentifier: [], ArgumentPlaceholder: [], BindExpression: ["object", "callee"], ImportAttribute: ["key", "value"], Decorator: ["expression"], DoExpression: ["body"], ExportDefaultSpecifier: ["exported"], RecordExpression: ["properties"], TupleExpression: ["elements"], DecimalLiteral: [], ModuleExpression: ["body"], TopicReference: [], PipelineTopicExpression: ["expression"], PipelineBareFunction: ["callee"], PipelinePrimaryTopicReference: [], TSParameterProperty: ["parameter", "decorators"], TSDeclareFunction: ["id", "typeParameters", "params", "returnType", "body"], TSDeclareMethod: ["decorators", "key", "typeParameters", "params", "returnType"], TSQualifiedName: ["left", "right"], TSCallSignatureDeclaration: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSConstructSignatureDeclaration: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSPropertySignature: ["key", "typeAnnotation"], TSMethodSignature: ["key", "typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSIndexSignature: ["parameters", "typeAnnotation"], TSAnyKeyword: [], TSBooleanKeyword: [], TSBigIntKeyword: [], TSIntrinsicKeyword: [], TSNeverKeyword: [], TSNullKeyword: [], TSNumberKeyword: [], TSObjectKeyword: [], TSStringKeyword: [], TSSymbolKeyword: [], TSUndefinedKeyword: [], TSUnknownKeyword: [], TSVoidKeyword: [], TSThisType: [], TSFunctionType: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSConstructorType: ["typeParameters", "parameters", "typeAnnotation", "params", "returnType"], TSTypeReference: ["typeName", "typeParameters", "typeArguments"], TSTypePredicate: ["parameterName", "typeAnnotation"], TSTypeQuery: ["exprName", "typeParameters", "typeArguments"], TSTypeLiteral: ["members"], TSArrayType: ["elementType"], TSTupleType: ["elementTypes"], TSOptionalType: ["typeAnnotation"], TSRestType: ["typeAnnotation"], TSNamedTupleMember: ["label", "elementType"], TSUnionType: ["types"], TSIntersectionType: ["types"], TSConditionalType: ["checkType", "extendsType", "trueType", "falseType"], TSInferType: ["typeParameter"], TSParenthesizedType: ["typeAnnotation"], TSTypeOperator: ["typeAnnotation"], TSIndexedAccessType: ["objectType", "indexType"], TSMappedType: ["typeParameter", "typeAnnotation", "nameType"], TSLiteralType: ["literal"], TSExpressionWithTypeArguments: ["expression", "typeParameters"], TSInterfaceDeclaration: ["id", "typeParameters", "extends", "body"], TSInterfaceBody: ["body"], TSTypeAliasDeclaration: ["id", "typeParameters", "typeAnnotation"], TSInstantiationExpression: ["expression", "typeParameters", "typeArguments"], TSAsExpression: ["expression", "typeAnnotation"], TSSatisfiesExpression: ["expression", "typeAnnotation"], TSTypeAssertion: ["typeAnnotation", "expression"], TSEnumDeclaration: ["id", "members"], TSEnumMember: ["id", "initializer"], TSModuleDeclaration: ["id", "body"], TSModuleBlock: ["body"], TSImportType: ["argument", "qualifier", "typeParameters", "typeArguments"], TSImportEqualsDeclaration: ["id", "moduleReference"], TSExternalModuleReference: ["expression"], TSNonNullExpression: ["expression"], TSExportAssignment: ["expression"], TSNamespaceExportDeclaration: ["id"], TSTypeAnnotation: ["typeAnnotation"], TSTypeParameterInstantiation: ["params"], TSTypeParameterDeclaration: ["params"], TSTypeParameter: ["constraint", "default", "name"], ChainExpression: ["expression"], ExperimentalRestProperty: ["argument"], ExperimentalSpreadProperty: ["argument"], Literal: [], MethodDefinition: ["decorators", "key", "value"], PrivateIdentifier: [], Property: ["key", "value"], PropertyDefinition: ["decorators", "key", "typeAnnotation", "value", "variance"], AccessorProperty: ["decorators", "key", "typeAnnotation", "value"], TSAbstractAccessorProperty: ["decorators", "key", "typeAnnotation"], TSAbstractKeyword: [], TSAbstractMethodDefinition: ["key", "value"], TSAbstractPropertyDefinition: ["decorators", "key", "typeAnnotation"], TSAsyncKeyword: [], TSClassImplements: ["expression", "typeArguments", "typeParameters"], TSDeclareKeyword: [], TSEmptyBodyFunctionExpression: ["id", "typeParameters", "params", "returnType"], TSEnumBody: ["members"], TSExportKeyword: [], TSInterfaceHeritage: ["expression", "typeArguments", "typeParameters"], TSPrivateKeyword: [], TSProtectedKeyword: [], TSPublicKeyword: [], TSReadonlyKeyword: [], TSStaticKeyword: [], TSTemplateLiteralType: ["quasis", "types"], AsConstExpression: ["expression"], AsExpression: ["expression", "typeAnnotation"], BigIntLiteralTypeAnnotation: [], BigIntTypeAnnotation: [], ComponentDeclaration: ["id", "params", "body", "typeParameters", "rendersType"], ComponentParameter: ["name", "local"], ComponentTypeAnnotation: ["params", "rest", "typeParameters", "rendersType"], ComponentTypeParameter: ["name", "typeAnnotation"], ConditionalTypeAnnotation: ["checkType", "extendsType", "trueType", "falseType"], DeclareComponent: ["id", "params", "rest", "typeParameters", "rendersType"], DeclareEnum: ["id", "body"], DeclareHook: ["id"], DeclareNamespace: ["id", "body"], EnumBigIntBody: ["members"], EnumBigIntMember: ["id", "init"], HookDeclaration: ["id", "params", "body", "typeParameters", "returnType"], HookTypeAnnotation: ["params", "returnType", "rest", "typeParameters"], InferTypeAnnotation: ["typeParameter"], KeyofTypeAnnotation: ["argument"], ObjectTypeMappedTypeProperty: ["keyTparam", "propType", "sourceType", "variance"], QualifiedTypeofIdentifier: ["qualification", "id"], TupleTypeLabeledElement: ["label", "elementType", "variance"], TupleTypeSpreadElement: ["label", "typeAnnotation"], TypeOperator: ["typeAnnotation"], TypePredicate: ["parameterName", "typeAnnotation", "asserts"], NGRoot: ["node"], NGPipeExpression: ["left", "right", "arguments"], NGChainedExpression: ["expressions"], NGEmptyExpression: [], NGMicrosyntax: ["body"], NGMicrosyntaxKey: [], NGMicrosyntaxExpression: ["expression", "alias"], NGMicrosyntaxKeyedExpression: ["key", "expression"], NGMicrosyntaxLet: ["key", "value"], NGMicrosyntaxAs: ["key", "alias"], JsExpressionRoot: ["node"], JsonRoot: ["node"], TSJSDocAllType: [], TSJSDocUnknownType: [], TSJSDocNullableType: ["typeAnnotation"], TSJSDocNonNullableType: ["typeAnnotation"], NeverTypeAnnotation: [], UndefinedTypeAnnotation: [], UnknownTypeAnnotation: [], SatisfiesExpression: ["expression", "typeAnnotation"] };
      var Nr2 = Ps(gs), Ts = Nr2;
      function Et2(a, t) {
        if (!(a !== null && typeof a == "object")) return a;
        if (Array.isArray(a)) {
          for (let s = 0; s < a.length; s++) a[s] = Et2(a[s], t);
          return a;
        }
        let e = Ts(a);
        for (let s = 0; s < e.length; s++) a[e[s]] = Et2(a[e[s]], t);
        return t(a) || a;
      }
      var Be2 = Et2;
      function kr2(a, t) {
        let { parser: e, text: s } = t;
        if (a.type === "File" && a.program.interpreter) {
          let { program: { interpreter: i }, comments: r } = a;
          delete a.program.interpreter, r.unshift(i);
        }
        if (e === "babel") {
          let i = /* @__PURE__ */ new Set();
          a = Be2(a, (r) => {
            var n;
            (n = r.leadingComments) != null && n.some(xs) && i.add(D(r));
          }), a = Be2(a, (r) => {
            if (r.type === "ParenthesizedExpression") {
              let { expression: n } = r;
              if (n.type === "TypeCastExpression") return n.range = [...r.range], n;
              let o = D(r);
              if (!i.has(o)) return n.extra = { ...n.extra, parenthesized: true }, n;
            }
          });
        }
        if (a = Be2(a, (i) => {
          var r;
          switch (i.type) {
            case "LogicalExpression":
              if (bs(i)) return It2(i);
              break;
            case "VariableDeclaration": {
              let n = St2(false, i.declarations, -1);
              n != null && n.init && s[B2(n)] !== ";" && (i.range = [D(i), B2(n)]);
              break;
            }
            case "TSParenthesizedType":
              return i.typeAnnotation;
            case "TSTypeParameter":
              if (typeof i.name == "string") {
                let n = D(i);
                i.name = { type: "Identifier", name: i.name, range: [n, n + i.name.length] };
              }
              break;
            case "TopicReference":
              a.extra = { ...a.extra, __isUsingHackPipeline: true };
              break;
            case "ExportAllDeclaration":
              if (e === "meriyah" && ((r = i.exported) == null ? void 0 : r.type) === "Identifier") {
                let { exported: n } = i, o = s.slice(D(n), B2(n));
                (o.startsWith('"') || o.startsWith("'")) && (i.exported = { ...i.exported, type: "Literal", value: i.exported.name, raw: o });
              }
              break;
            case "TSUnionType":
            case "TSIntersectionType":
              if (i.types.length === 1) return i.types[0];
              break;
          }
        }), Pe2(a.comments)) {
          let i = St2(false, a.comments, -1);
          for (let r = a.comments.length - 2; r >= 0; r--) {
            let n = a.comments[r];
            B2(n) === D(i) && ge2(n) && ge2(i) && wt2(n) && wt2(i) && (a.comments.splice(r + 1, 1), n.value += "*//*" + i.value, n.range = [D(n), B2(i)]), i = n;
          }
        }
        return a.type === "Program" && (a.range = [0, s.length]), a;
      }
      function bs(a) {
        return a.type === "LogicalExpression" && a.right.type === "LogicalExpression" && a.operator === a.right.operator;
      }
      function It2(a) {
        return bs(a) ? It2({ type: "LogicalExpression", operator: a.operator, left: It2({ type: "LogicalExpression", operator: a.operator, left: a.left, right: a.right.left, range: [D(a.left), B2(a.right.left)] }), right: a.right.right, range: [D(a), B2(a)] }) : a;
      }
      var As = kr2;
      function vr2(a, t) {
        let e = new SyntaxError(a + " (" + t.loc.start.line + ":" + t.loc.start.column + ")");
        return Object.assign(e, t);
      }
      var Re2 = vr2;
      function Lr2(a) {
        let { message: t, loc: { line: e, column: s }, reasonCode: i } = a, r = a;
        (i === "MissingPlugin" || i === "MissingOneOfPlugins") && (t = "Unexpected token.", r = void 0);
        let n = ` (${e}:${s})`;
        return t.endsWith(n) && (t = t.slice(0, -n.length)), Re2(t, { loc: { start: { line: e, column: s + 1 } }, cause: r });
      }
      var Ue2 = Lr2;
      var Dr2 = (a, t, e, s) => {
        if (!(a && t == null)) return t.replaceAll ? t.replaceAll(e, s) : e.global ? t.replace(e, s) : t.split(e).join(s);
      }, ie2 = Dr2;
      var Mr2 = /\*\/$/, Or2 = /^\/\*\*?/, Fr2 = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/, Br2 = /(^|\s+)\/\/([^\n\r]*)/g, Ss = /^(\r?\n)+/, Rr2 = /(?:^|\r?\n) *(@[^\n\r]*?) *\r?\n *(?![^\n\r@]*\/\/[^]*)([^\s@][^\n\r@]+?) *\r?\n/g, ws = /(?:^|\r?\n) *@(\S+) *([^\n\r]*)/g, Ur2 = /(\r?\n|^) *\* ?/g, _r2 = [];
      function Cs(a) {
        let t = a.match(Fr2);
        return t ? t[0].trimStart() : "";
      }
      function Es(a) {
        let t = `
`;
        a = ie2(false, a.replace(Or2, "").replace(Mr2, ""), Ur2, "$1");
        let e = "";
        for (; e !== a; ) e = a, a = ie2(false, a, Rr2, `${t}$1 $2${t}`);
        a = a.replace(Ss, "").trimEnd();
        let s = /* @__PURE__ */ Object.create(null), i = ie2(false, a, ws, "").replace(Ss, "").trimEnd(), r;
        for (; r = ws.exec(a); ) {
          let n = ie2(false, r[2], Br2, "");
          if (typeof s[r[1]] == "string" || Array.isArray(s[r[1]])) {
            let o = s[r[1]];
            s[r[1]] = [..._r2, ...Array.isArray(o) ? o : [o], n];
          } else s[r[1]] = n;
        }
        return { comments: i, pragmas: s };
      }
      function jr2(a) {
        let t = Fe2(a);
        t && (a = a.slice(t.length + 1));
        let e = Cs(a), { pragmas: s, comments: i } = Es(e);
        return { shebang: t, text: a, pragmas: s, comments: i };
      }
      function Is(a) {
        let { pragmas: t } = jr2(a);
        return Object.prototype.hasOwnProperty.call(t, "prettier") || Object.prototype.hasOwnProperty.call(t, "format");
      }
      function $r2(a) {
        return a = typeof a == "function" ? { parse: a } : a, { astFormat: "estree", hasPragma: Is, locStart: D, locEnd: B2, ...a };
      }
      var G2 = $r2;
      function Vr2(a) {
        let { filepath: t } = a;
        if (t) {
          if (t = t.toLowerCase(), t.endsWith(".cjs")) return "script";
          if (t.endsWith(".mjs")) return "module";
        }
      }
      var Ns = Vr2;
      function qr2(a, t) {
        let { type: e = "JsExpressionRoot", rootMarker: s, text: i } = t, { tokens: r, comments: n } = a;
        return delete a.tokens, delete a.comments, { tokens: r, comments: n, type: e, node: a, range: [0, i.length], rootMarker: s };
      }
      var _e2 = qr2;
      var re2 = (a) => G2(Jr2(a)), zr2 = { sourceType: "module", allowImportExportEverywhere: true, allowReturnOutsideFunction: true, allowNewTargetOutsideFunction: true, allowSuperOutsideMethod: true, allowUndeclaredExports: true, errorRecovery: true, createParenthesizedExpressions: true, createImportExpressions: true, plugins: ["doExpressions", "exportDefaultFrom", "functionBind", "functionSent", "throwExpressions", "partialApplication", "decorators", "decimal", "moduleBlocks", "asyncDoExpressions", "destructuringPrivate", "decoratorAutoAccessors", "importReflection", "explicitResourceManagement", ["importAttributes", { deprecatedAssertSyntax: true }], "sourcePhaseImports", "deferredImportEvaluation", ["optionalChainingAssign", { version: "2023-07" }], "recordAndTuple"], tokens: true, ranges: true }, ks = "v8intrinsic", vs = [["pipelineOperator", { proposal: "hack", topicToken: "%" }], ["pipelineOperator", { proposal: "minimal" }], ["pipelineOperator", { proposal: "fsharp" }]], V2 = (a, t = zr2) => ({ ...t, plugins: [...t.plugins, ...a] }), Kr2 = /@(?:no)?flow\b/u;
      function Hr2(a, t) {
        var i;
        if ((i = t.filepath) != null && i.endsWith(".js.flow")) return true;
        let e = Fe2(a);
        e && (a = a.slice(e.length));
        let s = ds(a, 0);
        return s !== false && (a = a.slice(0, s)), Kr2.test(a);
      }
      function Wr2(a, t, e) {
        let s = a(t, e), i = s.errors.find((r) => !Xr2.has(r.reasonCode));
        if (i) throw i;
        return s;
      }
      function Jr2({ isExpression: a = false, optionsCombinations: t }) {
        return (e, s = {}) => {
          if ((s.parser === "babel" || s.parser === "__babel_estree") && Hr2(e, s)) return s.parser = "babel-flow", Bs.parse(e, s);
          let i = t;
          (s.__babelSourceType ?? Ns(s)) === "script" && (i = i.map((c2) => ({ ...c2, sourceType: "script" })));
          let n = /%[A-Z]/u.test(e);
          e.includes("|>") ? i = (n ? [...vs, ks] : vs).flatMap((l) => i.map((u) => V2([l], u))) : n && (i = i.map((c2) => V2([ks], c2)));
          let o = a ? je2.parseExpression : je2.parse, h;
          try {
            h = ms(i.map((c2) => () => Wr2(o, e, c2)));
          } catch ({ errors: [c2] }) {
            throw Ue2(c2);
          }
          return a && (h = _e2(h, { text: e, rootMarker: s.rootMarker })), As(h, { parser: "babel", text: e });
        };
      }
      var Xr2 = /* @__PURE__ */ new Set(["StrictNumericEscape", "StrictWith", "StrictOctalLiteral", "StrictDelete", "StrictEvalArguments", "StrictEvalArgumentsBinding", "StrictFunction", "ForInOfLoopInitializer", "EmptyTypeArguments", "EmptyTypeParameters", "ConstructorHasTypeParameters", "UnsupportedParameterPropertyKind", "DecoratorExportClass", "ParamDupe", "InvalidDecimal", "RestTrailingComma", "UnsupportedParameterDecorator", "UnterminatedJsxContent", "UnexpectedReservedWord", "ModuleAttributesWithDuplicateKeys", "LineTerminatorBeforeArrow", "InvalidEscapeSequenceTemplate", "NonAbstractClassHasAbstractMethod", "OptionalTypeBeforeRequired", "PatternIsOptional", "OptionalBindingPattern", "DeclareClassFieldHasInitializer", "TypeImportCannotSpecifyDefaultAndNamed", "ConstructorClassField", "VarRedeclaration", "InvalidPrivateFieldResolution", "DuplicateExport"]), Fs = [V2(["jsx"])], Ls = re2({ optionsCombinations: Fs }), Ds = re2({ optionsCombinations: [V2(["jsx", "typescript"]), V2(["typescript"])] }), Ms = re2({ isExpression: true, optionsCombinations: [V2(["jsx"])] }), Os = re2({ isExpression: true, optionsCombinations: [V2(["typescript"])] }), Bs = re2({ optionsCombinations: [V2(["jsx", ["flow", { all: true, enums: true }], "flowComments"])] }), Gr2 = re2({ optionsCombinations: Fs.map((a) => V2(["estree"], a)) }), Rs = { babel: Ls, "babel-flow": Bs, "babel-ts": Ds, __js_expression: Ms, __ts_expression: Os, __vue_expression: Ms, __vue_ts_expression: Os, __vue_event_binding: Ls, __vue_ts_event_binding: Ds, __babel_estree: Gr2 };
      var Us = vt2(At2(), 1);
      function _s(a = {}) {
        let { allowComments: t = true } = a;
        return function(s) {
          let i;
          try {
            i = (0, Us.parseExpression)(s, { tokens: true, ranges: true, attachComment: false });
          } catch (r) {
            throw Ue2(r);
          }
          if (!t && Pe2(i.comments)) throw H2(i.comments[0], "Comment");
          return ae2(i), _e2(i, { type: "JsonRoot", text: s });
        };
      }
      function H2(a, t) {
        let [e, s] = [a.loc.start, a.loc.end].map(({ line: i, column: r }) => ({ line: i, column: r + 1 }));
        return Re2(`${t} is not allowed in JSON.`, { loc: { start: e, end: s } });
      }
      function ae2(a) {
        switch (a.type) {
          case "ArrayExpression":
            for (let t of a.elements) t !== null && ae2(t);
            return;
          case "ObjectExpression":
            for (let t of a.properties) ae2(t);
            return;
          case "ObjectProperty":
            if (a.computed) throw H2(a.key, "Computed key");
            if (a.shorthand) throw H2(a.key, "Shorthand property");
            a.key.type !== "Identifier" && ae2(a.key), ae2(a.value);
            return;
          case "UnaryExpression": {
            let { operator: t, argument: e } = a;
            if (t !== "+" && t !== "-") throw H2(a, `Operator '${a.operator}'`);
            if (e.type === "NumericLiteral" || e.type === "Identifier" && (e.name === "Infinity" || e.name === "NaN")) return;
            throw H2(e, `Operator '${t}' before '${e.type}'`);
          }
          case "Identifier":
            if (a.name !== "Infinity" && a.name !== "NaN" && a.name !== "undefined") throw H2(a, `Identifier '${a.name}'`);
            return;
          case "TemplateLiteral":
            if (Pe2(a.expressions)) throw H2(a.expressions[0], "'TemplateLiteral' with expression");
            for (let t of a.quasis) ae2(t);
            return;
          case "NullLiteral":
          case "BooleanLiteral":
          case "NumericLiteral":
          case "StringLiteral":
          case "TemplateElement":
            return;
          default:
            throw H2(a, `'${a.type}'`);
        }
      }
      var Nt2 = _s(), Yr2 = { json: G2({ parse: Nt2, hasPragma() {
        return true;
      } }), json5: G2(Nt2), jsonc: G2(Nt2), "json-stringify": G2({ parse: _s({ allowComments: false }), astFormat: "estree-json" }) }, js = Yr2;
      var Qr2 = { ...Rs, ...js };
      return Js(Zr2);
    });
  }
});

// node_modules/minimalistic-assert/index.js
var require_minimalistic_assert = __commonJS({
  "node_modules/minimalistic-assert/index.js"(exports2, module2) {
    module2.exports = assert2;
    function assert2(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    assert2.equal = function assertEqual(l, r, msg) {
      if (l != r)
        throw new Error(msg || "Assertion failed: " + l + " != " + r);
    };
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/hash.js/lib/hash/utils.js
var require_utils = __commonJS({
  "node_modules/hash.js/lib/hash/utils.js"(exports2) {
    "use strict";
    var assert2 = require_minimalistic_assert();
    var inherits = require_inherits_browser();
    exports2.inherits = inherits;
    function isSurrogatePair(msg, i) {
      if ((msg.charCodeAt(i) & 64512) !== 55296) {
        return false;
      }
      if (i < 0 || i + 1 >= msg.length) {
        return false;
      }
      return (msg.charCodeAt(i + 1) & 64512) === 56320;
    }
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg === "string") {
        if (!enc) {
          var p = 0;
          for (var i = 0; i < msg.length; i++) {
            var c2 = msg.charCodeAt(i);
            if (c2 < 128) {
              res[p++] = c2;
            } else if (c2 < 2048) {
              res[p++] = c2 >> 6 | 192;
              res[p++] = c2 & 63 | 128;
            } else if (isSurrogatePair(msg, i)) {
              c2 = 65536 + ((c2 & 1023) << 10) + (msg.charCodeAt(++i) & 1023);
              res[p++] = c2 >> 18 | 240;
              res[p++] = c2 >> 12 & 63 | 128;
              res[p++] = c2 >> 6 & 63 | 128;
              res[p++] = c2 & 63 | 128;
            } else {
              res[p++] = c2 >> 12 | 224;
              res[p++] = c2 >> 6 & 63 | 128;
              res[p++] = c2 & 63 | 128;
            }
          }
        } else if (enc === "hex") {
          msg = msg.replace(/[^a-z0-9]+/ig, "");
          if (msg.length % 2 !== 0)
            msg = "0" + msg;
          for (i = 0; i < msg.length; i += 2)
            res.push(parseInt(msg[i] + msg[i + 1], 16));
        }
      } else {
        for (i = 0; i < msg.length; i++)
          res[i] = msg[i] | 0;
      }
      return res;
    }
    exports2.toArray = toArray;
    function toHex(msg) {
      var res = "";
      for (var i = 0; i < msg.length; i++)
        res += zero2(msg[i].toString(16));
      return res;
    }
    exports2.toHex = toHex;
    function htonl(w) {
      var res = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;
      return res >>> 0;
    }
    exports2.htonl = htonl;
    function toHex32(msg, endian) {
      var res = "";
      for (var i = 0; i < msg.length; i++) {
        var w = msg[i];
        if (endian === "little")
          w = htonl(w);
        res += zero8(w.toString(16));
      }
      return res;
    }
    exports2.toHex32 = toHex32;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    exports2.zero2 = zero2;
    function zero8(word) {
      if (word.length === 7)
        return "0" + word;
      else if (word.length === 6)
        return "00" + word;
      else if (word.length === 5)
        return "000" + word;
      else if (word.length === 4)
        return "0000" + word;
      else if (word.length === 3)
        return "00000" + word;
      else if (word.length === 2)
        return "000000" + word;
      else if (word.length === 1)
        return "0000000" + word;
      else
        return word;
    }
    exports2.zero8 = zero8;
    function join32(msg, start, end, endian) {
      var len = end - start;
      assert2(len % 4 === 0);
      var res = new Array(len / 4);
      for (var i = 0, k = start; i < res.length; i++, k += 4) {
        var w;
        if (endian === "big")
          w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
        else
          w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
        res[i] = w >>> 0;
      }
      return res;
    }
    exports2.join32 = join32;
    function split32(msg, endian) {
      var res = new Array(msg.length * 4);
      for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
        var m = msg[i];
        if (endian === "big") {
          res[k] = m >>> 24;
          res[k + 1] = m >>> 16 & 255;
          res[k + 2] = m >>> 8 & 255;
          res[k + 3] = m & 255;
        } else {
          res[k + 3] = m >>> 24;
          res[k + 2] = m >>> 16 & 255;
          res[k + 1] = m >>> 8 & 255;
          res[k] = m & 255;
        }
      }
      return res;
    }
    exports2.split32 = split32;
    function rotr32(w, b2) {
      return w >>> b2 | w << 32 - b2;
    }
    exports2.rotr32 = rotr32;
    function rotl32(w, b2) {
      return w << b2 | w >>> 32 - b2;
    }
    exports2.rotl32 = rotl32;
    function sum32(a, b2) {
      return a + b2 >>> 0;
    }
    exports2.sum32 = sum32;
    function sum32_3(a, b2, c2) {
      return a + b2 + c2 >>> 0;
    }
    exports2.sum32_3 = sum32_3;
    function sum32_4(a, b2, c2, d) {
      return a + b2 + c2 + d >>> 0;
    }
    exports2.sum32_4 = sum32_4;
    function sum32_5(a, b2, c2, d, e) {
      return a + b2 + c2 + d + e >>> 0;
    }
    exports2.sum32_5 = sum32_5;
    function sum64(buf, pos2, ah, al) {
      var bh = buf[pos2];
      var bl = buf[pos2 + 1];
      var lo2 = al + bl >>> 0;
      var hi2 = (lo2 < al ? 1 : 0) + ah + bh;
      buf[pos2] = hi2 >>> 0;
      buf[pos2 + 1] = lo2;
    }
    exports2.sum64 = sum64;
    function sum64_hi(ah, al, bh, bl) {
      var lo2 = al + bl >>> 0;
      var hi2 = (lo2 < al ? 1 : 0) + ah + bh;
      return hi2 >>> 0;
    }
    exports2.sum64_hi = sum64_hi;
    function sum64_lo(ah, al, bh, bl) {
      var lo2 = al + bl;
      return lo2 >>> 0;
    }
    exports2.sum64_lo = sum64_lo;
    function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
      var carry = 0;
      var lo2 = al;
      lo2 = lo2 + bl >>> 0;
      carry += lo2 < al ? 1 : 0;
      lo2 = lo2 + cl >>> 0;
      carry += lo2 < cl ? 1 : 0;
      lo2 = lo2 + dl >>> 0;
      carry += lo2 < dl ? 1 : 0;
      var hi2 = ah + bh + ch + dh + carry;
      return hi2 >>> 0;
    }
    exports2.sum64_4_hi = sum64_4_hi;
    function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
      var lo2 = al + bl + cl + dl;
      return lo2 >>> 0;
    }
    exports2.sum64_4_lo = sum64_4_lo;
    function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var carry = 0;
      var lo2 = al;
      lo2 = lo2 + bl >>> 0;
      carry += lo2 < al ? 1 : 0;
      lo2 = lo2 + cl >>> 0;
      carry += lo2 < cl ? 1 : 0;
      lo2 = lo2 + dl >>> 0;
      carry += lo2 < dl ? 1 : 0;
      lo2 = lo2 + el >>> 0;
      carry += lo2 < el ? 1 : 0;
      var hi2 = ah + bh + ch + dh + eh + carry;
      return hi2 >>> 0;
    }
    exports2.sum64_5_hi = sum64_5_hi;
    function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var lo2 = al + bl + cl + dl + el;
      return lo2 >>> 0;
    }
    exports2.sum64_5_lo = sum64_5_lo;
    function rotr64_hi(ah, al, num) {
      var r = al << 32 - num | ah >>> num;
      return r >>> 0;
    }
    exports2.rotr64_hi = rotr64_hi;
    function rotr64_lo(ah, al, num) {
      var r = ah << 32 - num | al >>> num;
      return r >>> 0;
    }
    exports2.rotr64_lo = rotr64_lo;
    function shr64_hi(ah, al, num) {
      return ah >>> num;
    }
    exports2.shr64_hi = shr64_hi;
    function shr64_lo(ah, al, num) {
      var r = ah << 32 - num | al >>> num;
      return r >>> 0;
    }
    exports2.shr64_lo = shr64_lo;
  }
});

// node_modules/hash.js/lib/hash/common.js
var require_common = __commonJS({
  "node_modules/hash.js/lib/hash/common.js"(exports2) {
    "use strict";
    var utils = require_utils();
    var assert2 = require_minimalistic_assert();
    function BlockHash() {
      this.pending = null;
      this.pendingTotal = 0;
      this.blockSize = this.constructor.blockSize;
      this.outSize = this.constructor.outSize;
      this.hmacStrength = this.constructor.hmacStrength;
      this.padLength = this.constructor.padLength / 8;
      this.endian = "big";
      this._delta8 = this.blockSize / 8;
      this._delta32 = this.blockSize / 32;
    }
    exports2.BlockHash = BlockHash;
    BlockHash.prototype.update = function update2(msg, enc) {
      msg = utils.toArray(msg, enc);
      if (!this.pending)
        this.pending = msg;
      else
        this.pending = this.pending.concat(msg);
      this.pendingTotal += msg.length;
      if (this.pending.length >= this._delta8) {
        msg = this.pending;
        var r = msg.length % this._delta8;
        this.pending = msg.slice(msg.length - r, msg.length);
        if (this.pending.length === 0)
          this.pending = null;
        msg = utils.join32(msg, 0, msg.length - r, this.endian);
        for (var i = 0; i < msg.length; i += this._delta32)
          this._update(msg, i, i + this._delta32);
      }
      return this;
    };
    BlockHash.prototype.digest = function digest(enc) {
      this.update(this._pad());
      assert2(this.pending === null);
      return this._digest(enc);
    };
    BlockHash.prototype._pad = function pad() {
      var len = this.pendingTotal;
      var bytes = this._delta8;
      var k = bytes - (len + this.padLength) % bytes;
      var res = new Array(k + this.padLength);
      res[0] = 128;
      for (var i = 1; i < k; i++)
        res[i] = 0;
      len <<= 3;
      if (this.endian === "big") {
        for (var t = 8; t < this.padLength; t++)
          res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = len >>> 24 & 255;
        res[i++] = len >>> 16 & 255;
        res[i++] = len >>> 8 & 255;
        res[i++] = len & 255;
      } else {
        res[i++] = len & 255;
        res[i++] = len >>> 8 & 255;
        res[i++] = len >>> 16 & 255;
        res[i++] = len >>> 24 & 255;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        for (t = 8; t < this.padLength; t++)
          res[i++] = 0;
      }
      return res;
    };
  }
});

// node_modules/hash.js/lib/hash/sha/common.js
var require_common2 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/common.js"(exports2) {
    "use strict";
    var utils = require_utils();
    var rotr32 = utils.rotr32;
    function ft_1(s, x2, y2, z2) {
      if (s === 0)
        return ch32(x2, y2, z2);
      if (s === 1 || s === 3)
        return p32(x2, y2, z2);
      if (s === 2)
        return maj32(x2, y2, z2);
    }
    exports2.ft_1 = ft_1;
    function ch32(x2, y2, z2) {
      return x2 & y2 ^ ~x2 & z2;
    }
    exports2.ch32 = ch32;
    function maj32(x2, y2, z2) {
      return x2 & y2 ^ x2 & z2 ^ y2 & z2;
    }
    exports2.maj32 = maj32;
    function p32(x2, y2, z2) {
      return x2 ^ y2 ^ z2;
    }
    exports2.p32 = p32;
    function s0_256(x2) {
      return rotr32(x2, 2) ^ rotr32(x2, 13) ^ rotr32(x2, 22);
    }
    exports2.s0_256 = s0_256;
    function s1_256(x2) {
      return rotr32(x2, 6) ^ rotr32(x2, 11) ^ rotr32(x2, 25);
    }
    exports2.s1_256 = s1_256;
    function g0_256(x2) {
      return rotr32(x2, 7) ^ rotr32(x2, 18) ^ x2 >>> 3;
    }
    exports2.g0_256 = g0_256;
    function g1_256(x2) {
      return rotr32(x2, 17) ^ rotr32(x2, 19) ^ x2 >>> 10;
    }
    exports2.g1_256 = g1_256;
  }
});

// node_modules/hash.js/lib/hash/sha/1.js
var require__ = __commonJS({
  "node_modules/hash.js/lib/hash/sha/1.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var common = require_common();
    var shaCommon = require_common2();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_5 = utils.sum32_5;
    var ft_1 = shaCommon.ft_1;
    var BlockHash = common.BlockHash;
    var sha1_K = [
      1518500249,
      1859775393,
      2400959708,
      3395469782
    ];
    function SHA1() {
      if (!(this instanceof SHA1))
        return new SHA1();
      BlockHash.call(this);
      this.h = [
        1732584193,
        4023233417,
        2562383102,
        271733878,
        3285377520
      ];
      this.W = new Array(80);
    }
    utils.inherits(SHA1, BlockHash);
    module2.exports = SHA1;
    SHA1.blockSize = 512;
    SHA1.outSize = 160;
    SHA1.hmacStrength = 80;
    SHA1.padLength = 64;
    SHA1.prototype._update = function _update(msg, start) {
      var W2 = this.W;
      for (var i = 0; i < 16; i++)
        W2[i] = msg[start + i];
      for (; i < W2.length; i++)
        W2[i] = rotl32(W2[i - 3] ^ W2[i - 8] ^ W2[i - 14] ^ W2[i - 16], 1);
      var a = this.h[0];
      var b2 = this.h[1];
      var c2 = this.h[2];
      var d = this.h[3];
      var e = this.h[4];
      for (i = 0; i < W2.length; i++) {
        var s = ~~(i / 20);
        var t = sum32_5(rotl32(a, 5), ft_1(s, b2, c2, d), e, W2[i], sha1_K[s]);
        e = d;
        d = c2;
        c2 = rotl32(b2, 30);
        b2 = a;
        a = t;
      }
      this.h[0] = sum32(this.h[0], a);
      this.h[1] = sum32(this.h[1], b2);
      this.h[2] = sum32(this.h[2], c2);
      this.h[3] = sum32(this.h[3], d);
      this.h[4] = sum32(this.h[4], e);
    };
    SHA1.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/256.js
var require__2 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/256.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var common = require_common();
    var shaCommon = require_common2();
    var assert2 = require_minimalistic_assert();
    var sum32 = utils.sum32;
    var sum32_4 = utils.sum32_4;
    var sum32_5 = utils.sum32_5;
    var ch32 = shaCommon.ch32;
    var maj32 = shaCommon.maj32;
    var s0_256 = shaCommon.s0_256;
    var s1_256 = shaCommon.s1_256;
    var g0_256 = shaCommon.g0_256;
    var g1_256 = shaCommon.g1_256;
    var BlockHash = common.BlockHash;
    var sha256_K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    function SHA256() {
      if (!(this instanceof SHA256))
        return new SHA256();
      BlockHash.call(this);
      this.h = [
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ];
      this.k = sha256_K;
      this.W = new Array(64);
    }
    utils.inherits(SHA256, BlockHash);
    module2.exports = SHA256;
    SHA256.blockSize = 512;
    SHA256.outSize = 256;
    SHA256.hmacStrength = 192;
    SHA256.padLength = 64;
    SHA256.prototype._update = function _update(msg, start) {
      var W2 = this.W;
      for (var i = 0; i < 16; i++)
        W2[i] = msg[start + i];
      for (; i < W2.length; i++)
        W2[i] = sum32_4(g1_256(W2[i - 2]), W2[i - 7], g0_256(W2[i - 15]), W2[i - 16]);
      var a = this.h[0];
      var b2 = this.h[1];
      var c2 = this.h[2];
      var d = this.h[3];
      var e = this.h[4];
      var f = this.h[5];
      var g = this.h[6];
      var h = this.h[7];
      assert2(this.k.length === W2.length);
      for (i = 0; i < W2.length; i++) {
        var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W2[i]);
        var T2 = sum32(s0_256(a), maj32(a, b2, c2));
        h = g;
        g = f;
        f = e;
        e = sum32(d, T1);
        d = c2;
        c2 = b2;
        b2 = a;
        a = sum32(T1, T2);
      }
      this.h[0] = sum32(this.h[0], a);
      this.h[1] = sum32(this.h[1], b2);
      this.h[2] = sum32(this.h[2], c2);
      this.h[3] = sum32(this.h[3], d);
      this.h[4] = sum32(this.h[4], e);
      this.h[5] = sum32(this.h[5], f);
      this.h[6] = sum32(this.h[6], g);
      this.h[7] = sum32(this.h[7], h);
    };
    SHA256.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/224.js
var require__3 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/224.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var SHA256 = require__2();
    function SHA224() {
      if (!(this instanceof SHA224))
        return new SHA224();
      SHA256.call(this);
      this.h = [
        3238371032,
        914150663,
        812702999,
        4144912697,
        4290775857,
        1750603025,
        1694076839,
        3204075428
      ];
    }
    utils.inherits(SHA224, SHA256);
    module2.exports = SHA224;
    SHA224.blockSize = 512;
    SHA224.outSize = 224;
    SHA224.hmacStrength = 192;
    SHA224.padLength = 64;
    SHA224.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 7), "big");
      else
        return utils.split32(this.h.slice(0, 7), "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/512.js
var require__4 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/512.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var common = require_common();
    var assert2 = require_minimalistic_assert();
    var rotr64_hi = utils.rotr64_hi;
    var rotr64_lo = utils.rotr64_lo;
    var shr64_hi = utils.shr64_hi;
    var shr64_lo = utils.shr64_lo;
    var sum64 = utils.sum64;
    var sum64_hi = utils.sum64_hi;
    var sum64_lo = utils.sum64_lo;
    var sum64_4_hi = utils.sum64_4_hi;
    var sum64_4_lo = utils.sum64_4_lo;
    var sum64_5_hi = utils.sum64_5_hi;
    var sum64_5_lo = utils.sum64_5_lo;
    var BlockHash = common.BlockHash;
    var sha512_K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function SHA512() {
      if (!(this instanceof SHA512))
        return new SHA512();
      BlockHash.call(this);
      this.h = [
        1779033703,
        4089235720,
        3144134277,
        2227873595,
        1013904242,
        4271175723,
        2773480762,
        1595750129,
        1359893119,
        2917565137,
        2600822924,
        725511199,
        528734635,
        4215389547,
        1541459225,
        327033209
      ];
      this.k = sha512_K;
      this.W = new Array(160);
    }
    utils.inherits(SHA512, BlockHash);
    module2.exports = SHA512;
    SHA512.blockSize = 1024;
    SHA512.outSize = 512;
    SHA512.hmacStrength = 192;
    SHA512.padLength = 128;
    SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
      var W2 = this.W;
      for (var i = 0; i < 32; i++)
        W2[i] = msg[start + i];
      for (; i < W2.length; i += 2) {
        var c0_hi = g1_512_hi(W2[i - 4], W2[i - 3]);
        var c0_lo = g1_512_lo(W2[i - 4], W2[i - 3]);
        var c1_hi = W2[i - 14];
        var c1_lo = W2[i - 13];
        var c2_hi = g0_512_hi(W2[i - 30], W2[i - 29]);
        var c2_lo = g0_512_lo(W2[i - 30], W2[i - 29]);
        var c3_hi = W2[i - 32];
        var c3_lo = W2[i - 31];
        W2[i] = sum64_4_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
        W2[i + 1] = sum64_4_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
      }
    };
    SHA512.prototype._update = function _update(msg, start) {
      this._prepareBlock(msg, start);
      var W2 = this.W;
      var ah = this.h[0];
      var al = this.h[1];
      var bh = this.h[2];
      var bl = this.h[3];
      var ch = this.h[4];
      var cl = this.h[5];
      var dh = this.h[6];
      var dl = this.h[7];
      var eh = this.h[8];
      var el = this.h[9];
      var fh = this.h[10];
      var fl = this.h[11];
      var gh = this.h[12];
      var gl = this.h[13];
      var hh = this.h[14];
      var hl = this.h[15];
      assert2(this.k.length === W2.length);
      for (var i = 0; i < W2.length; i += 2) {
        var c0_hi = hh;
        var c0_lo = hl;
        var c1_hi = s1_512_hi(eh, el);
        var c1_lo = s1_512_lo(eh, el);
        var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
        var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
        var c3_hi = this.k[i];
        var c3_lo = this.k[i + 1];
        var c4_hi = W2[i];
        var c4_lo = W2[i + 1];
        var T1_hi = sum64_5_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        var T1_lo = sum64_5_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        c0_hi = s0_512_hi(ah, al);
        c0_lo = s0_512_lo(ah, al);
        c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
        c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
        var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
        var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        eh = sum64_hi(dh, dl, T1_hi, T1_lo);
        el = sum64_lo(dl, dl, T1_hi, T1_lo);
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
        al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
      }
      sum64(this.h, 0, ah, al);
      sum64(this.h, 2, bh, bl);
      sum64(this.h, 4, ch, cl);
      sum64(this.h, 6, dh, dl);
      sum64(this.h, 8, eh, el);
      sum64(this.h, 10, fh, fl);
      sum64(this.h, 12, gh, gl);
      sum64(this.h, 14, hh, hl);
    };
    SHA512.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
    function ch64_hi(xh, xl, yh, yl, zh) {
      var r = xh & yh ^ ~xh & zh;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function ch64_lo(xh, xl, yh, yl, zh, zl) {
      var r = xl & yl ^ ~xl & zl;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function maj64_hi(xh, xl, yh, yl, zh) {
      var r = xh & yh ^ xh & zh ^ yh & zh;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function maj64_lo(xh, xl, yh, yl, zh, zl) {
      var r = xl & yl ^ xl & zl ^ yl & zl;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 28);
      var c1_hi = rotr64_hi(xl, xh, 2);
      var c2_hi = rotr64_hi(xl, xh, 7);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 28);
      var c1_lo = rotr64_lo(xl, xh, 2);
      var c2_lo = rotr64_lo(xl, xh, 7);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 14);
      var c1_hi = rotr64_hi(xh, xl, 18);
      var c2_hi = rotr64_hi(xl, xh, 9);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 14);
      var c1_lo = rotr64_lo(xh, xl, 18);
      var c2_lo = rotr64_lo(xl, xh, 9);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 1);
      var c1_hi = rotr64_hi(xh, xl, 8);
      var c2_hi = shr64_hi(xh, xl, 7);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 1);
      var c1_lo = rotr64_lo(xh, xl, 8);
      var c2_lo = shr64_lo(xh, xl, 7);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 19);
      var c1_hi = rotr64_hi(xl, xh, 29);
      var c2_hi = shr64_hi(xh, xl, 6);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 19);
      var c1_lo = rotr64_lo(xl, xh, 29);
      var c2_lo = shr64_lo(xh, xl, 6);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
  }
});

// node_modules/hash.js/lib/hash/sha/384.js
var require__5 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/384.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var SHA512 = require__4();
    function SHA384() {
      if (!(this instanceof SHA384))
        return new SHA384();
      SHA512.call(this);
      this.h = [
        3418070365,
        3238371032,
        1654270250,
        914150663,
        2438529370,
        812702999,
        355462360,
        4144912697,
        1731405415,
        4290775857,
        2394180231,
        1750603025,
        3675008525,
        1694076839,
        1203062813,
        3204075428
      ];
    }
    utils.inherits(SHA384, SHA512);
    module2.exports = SHA384;
    SHA384.blockSize = 1024;
    SHA384.outSize = 384;
    SHA384.hmacStrength = 192;
    SHA384.padLength = 128;
    SHA384.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 12), "big");
      else
        return utils.split32(this.h.slice(0, 12), "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha.js
var require_sha = __commonJS({
  "node_modules/hash.js/lib/hash/sha.js"(exports2) {
    "use strict";
    exports2.sha1 = require__();
    exports2.sha224 = require__3();
    exports2.sha256 = require__2();
    exports2.sha384 = require__5();
    exports2.sha512 = require__4();
  }
});

// node_modules/hash.js/lib/hash/ripemd.js
var require_ripemd = __commonJS({
  "node_modules/hash.js/lib/hash/ripemd.js"(exports2) {
    "use strict";
    var utils = require_utils();
    var common = require_common();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_3 = utils.sum32_3;
    var sum32_4 = utils.sum32_4;
    var BlockHash = common.BlockHash;
    function RIPEMD160() {
      if (!(this instanceof RIPEMD160))
        return new RIPEMD160();
      BlockHash.call(this);
      this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      this.endian = "little";
    }
    utils.inherits(RIPEMD160, BlockHash);
    exports2.ripemd160 = RIPEMD160;
    RIPEMD160.blockSize = 512;
    RIPEMD160.outSize = 160;
    RIPEMD160.hmacStrength = 192;
    RIPEMD160.padLength = 64;
    RIPEMD160.prototype._update = function update2(msg, start) {
      var A = this.h[0];
      var B2 = this.h[1];
      var C = this.h[2];
      var D = this.h[3];
      var E = this.h[4];
      var Ah = A;
      var Bh = B2;
      var Ch = C;
      var Dh = D;
      var Eh = E;
      for (var j2 = 0; j2 < 80; j2++) {
        var T2 = sum32(
          rotl32(
            sum32_4(A, f(j2, B2, C, D), msg[r[j2] + start], K2(j2)),
            s[j2]
          ),
          E
        );
        A = E;
        E = D;
        D = rotl32(C, 10);
        C = B2;
        B2 = T2;
        T2 = sum32(
          rotl32(
            sum32_4(Ah, f(79 - j2, Bh, Ch, Dh), msg[rh[j2] + start], Kh(j2)),
            sh[j2]
          ),
          Eh
        );
        Ah = Eh;
        Eh = Dh;
        Dh = rotl32(Ch, 10);
        Ch = Bh;
        Bh = T2;
      }
      T2 = sum32_3(this.h[1], C, Dh);
      this.h[1] = sum32_3(this.h[2], D, Eh);
      this.h[2] = sum32_3(this.h[3], E, Ah);
      this.h[3] = sum32_3(this.h[4], A, Bh);
      this.h[4] = sum32_3(this.h[0], B2, Ch);
      this.h[0] = T2;
    };
    RIPEMD160.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "little");
      else
        return utils.split32(this.h, "little");
    };
    function f(j2, x2, y2, z2) {
      if (j2 <= 15)
        return x2 ^ y2 ^ z2;
      else if (j2 <= 31)
        return x2 & y2 | ~x2 & z2;
      else if (j2 <= 47)
        return (x2 | ~y2) ^ z2;
      else if (j2 <= 63)
        return x2 & z2 | y2 & ~z2;
      else
        return x2 ^ (y2 | ~z2);
    }
    function K2(j2) {
      if (j2 <= 15)
        return 0;
      else if (j2 <= 31)
        return 1518500249;
      else if (j2 <= 47)
        return 1859775393;
      else if (j2 <= 63)
        return 2400959708;
      else
        return 2840853838;
    }
    function Kh(j2) {
      if (j2 <= 15)
        return 1352829926;
      else if (j2 <= 31)
        return 1548603684;
      else if (j2 <= 47)
        return 1836072691;
      else if (j2 <= 63)
        return 2053994217;
      else
        return 0;
    }
    var r = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8,
      3,
      10,
      14,
      4,
      9,
      15,
      8,
      1,
      2,
      7,
      0,
      6,
      13,
      11,
      5,
      12,
      1,
      9,
      11,
      10,
      0,
      8,
      12,
      4,
      13,
      3,
      7,
      15,
      14,
      5,
      6,
      2,
      4,
      0,
      5,
      9,
      7,
      12,
      2,
      10,
      14,
      1,
      3,
      8,
      11,
      6,
      15,
      13
    ];
    var rh = [
      5,
      14,
      7,
      0,
      9,
      2,
      11,
      4,
      13,
      6,
      15,
      8,
      1,
      10,
      3,
      12,
      6,
      11,
      3,
      7,
      0,
      13,
      5,
      10,
      14,
      15,
      8,
      12,
      4,
      9,
      1,
      2,
      15,
      5,
      1,
      3,
      7,
      14,
      6,
      9,
      11,
      8,
      12,
      2,
      10,
      0,
      4,
      13,
      8,
      6,
      4,
      1,
      3,
      11,
      15,
      0,
      5,
      12,
      2,
      13,
      9,
      7,
      10,
      14,
      12,
      15,
      10,
      4,
      1,
      5,
      8,
      7,
      6,
      2,
      13,
      14,
      0,
      3,
      9,
      11
    ];
    var s = [
      11,
      14,
      15,
      12,
      5,
      8,
      7,
      9,
      11,
      13,
      14,
      15,
      6,
      7,
      9,
      8,
      7,
      6,
      8,
      13,
      11,
      9,
      7,
      15,
      7,
      12,
      15,
      9,
      11,
      7,
      13,
      12,
      11,
      13,
      6,
      7,
      14,
      9,
      13,
      15,
      14,
      8,
      13,
      6,
      5,
      12,
      7,
      5,
      11,
      12,
      14,
      15,
      14,
      15,
      9,
      8,
      9,
      14,
      5,
      6,
      8,
      6,
      5,
      12,
      9,
      15,
      5,
      11,
      6,
      8,
      13,
      12,
      5,
      12,
      13,
      14,
      11,
      8,
      5,
      6
    ];
    var sh = [
      8,
      9,
      9,
      11,
      13,
      15,
      15,
      5,
      7,
      7,
      8,
      11,
      14,
      14,
      12,
      6,
      9,
      13,
      15,
      7,
      12,
      8,
      9,
      11,
      7,
      7,
      12,
      7,
      6,
      15,
      13,
      11,
      9,
      7,
      15,
      11,
      8,
      6,
      6,
      14,
      12,
      13,
      5,
      14,
      13,
      13,
      7,
      5,
      15,
      5,
      8,
      11,
      14,
      14,
      6,
      14,
      6,
      9,
      12,
      9,
      12,
      5,
      15,
      8,
      8,
      5,
      12,
      9,
      12,
      5,
      14,
      6,
      8,
      13,
      6,
      5,
      15,
      13,
      11,
      11
    ];
  }
});

// node_modules/hash.js/lib/hash/hmac.js
var require_hmac = __commonJS({
  "node_modules/hash.js/lib/hash/hmac.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var assert2 = require_minimalistic_assert();
    function Hmac(hash, key2, enc) {
      if (!(this instanceof Hmac))
        return new Hmac(hash, key2, enc);
      this.Hash = hash;
      this.blockSize = hash.blockSize / 8;
      this.outSize = hash.outSize / 8;
      this.inner = null;
      this.outer = null;
      this._init(utils.toArray(key2, enc));
    }
    module2.exports = Hmac;
    Hmac.prototype._init = function init(key2) {
      if (key2.length > this.blockSize)
        key2 = new this.Hash().update(key2).digest();
      assert2(key2.length <= this.blockSize);
      for (var i = key2.length; i < this.blockSize; i++)
        key2.push(0);
      for (i = 0; i < key2.length; i++)
        key2[i] ^= 54;
      this.inner = new this.Hash().update(key2);
      for (i = 0; i < key2.length; i++)
        key2[i] ^= 106;
      this.outer = new this.Hash().update(key2);
    };
    Hmac.prototype.update = function update2(msg, enc) {
      this.inner.update(msg, enc);
      return this;
    };
    Hmac.prototype.digest = function digest(enc) {
      this.outer.update(this.inner.digest());
      return this.outer.digest(enc);
    };
  }
});

// node_modules/hash.js/lib/hash.js
var require_hash = __commonJS({
  "node_modules/hash.js/lib/hash.js"(exports2) {
    var hash = exports2;
    hash.utils = require_utils();
    hash.common = require_common();
    hash.sha = require_sha();
    hash.ripemd = require_ripemd();
    hash.hmac = require_hmac();
    hash.sha1 = hash.sha.sha1;
    hash.sha256 = hash.sha.sha256;
    hash.sha224 = hash.sha.sha224;
    hash.sha384 = hash.sha.sha384;
    hash.sha512 = hash.sha.sha512;
    hash.ripemd160 = hash.ripemd.ripemd160;
  }
});

// node_modules/json-to-ts/build/src/model.js
var require_model = __commonJS({
  "node_modules/json-to-ts/build/src/model.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var TypeGroup;
    (function(TypeGroup2) {
      TypeGroup2[TypeGroup2["Primitive"] = 0] = "Primitive";
      TypeGroup2[TypeGroup2["Array"] = 1] = "Array";
      TypeGroup2[TypeGroup2["Object"] = 2] = "Object";
      TypeGroup2[TypeGroup2["Date"] = 3] = "Date";
    })(TypeGroup = exports2.TypeGroup || (exports2.TypeGroup = {}));
  }
});

// node_modules/json-to-ts/build/src/util.js
var require_util = __commonJS({
  "node_modules/json-to-ts/build/src/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var model_1 = require_model();
    function isHash(str) {
      return str.length === 40;
    }
    exports2.isHash = isHash;
    function onlyUnique(value, index, self2) {
      return self2.indexOf(value) === index;
    }
    exports2.onlyUnique = onlyUnique;
    function isArray(x2) {
      return Object.prototype.toString.call(x2) === "[object Array]";
    }
    exports2.isArray = isArray;
    function isNonArrayUnion(typeName) {
      var arrayUnionRegex = /^\(.*\)\[\]$/;
      return typeName.includes(" | ") && !arrayUnionRegex.test(typeName);
    }
    exports2.isNonArrayUnion = isNonArrayUnion;
    function isObject(x2) {
      return Object.prototype.toString.call(x2) === "[object Object]" && x2 !== null;
    }
    exports2.isObject = isObject;
    function isDate(x2) {
      return x2 instanceof Date;
    }
    exports2.isDate = isDate;
    function parseKeyMetaData(key2) {
      var isOptional = key2.endsWith("--?");
      if (isOptional) {
        return {
          isOptional,
          keyValue: key2.slice(0, -3)
        };
      } else {
        return {
          isOptional,
          keyValue: key2
        };
      }
    }
    exports2.parseKeyMetaData = parseKeyMetaData;
    function getTypeDescriptionGroup(desc) {
      if (desc === void 0) {
        return model_1.TypeGroup.Primitive;
      } else if (desc.arrayOfTypes !== void 0) {
        return model_1.TypeGroup.Array;
      } else {
        return model_1.TypeGroup.Object;
      }
    }
    exports2.getTypeDescriptionGroup = getTypeDescriptionGroup;
    function findTypeById(id, types) {
      return types.find(function(_2) {
        return _2.id === id;
      });
    }
    exports2.findTypeById = findTypeById;
  }
});

// node_modules/json-to-ts/build/src/get-type-structure.js
var require_get_type_structure = __commonJS({
  "node_modules/json-to-ts/build/src/get-type-structure.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __spreadArrays = exports2 && exports2.__spreadArrays || function() {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j2 = 0, jl = a.length; j2 < jl; j2++, k++)
          r[k] = a[j2];
      return r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var hash = require_hash();
    var util_1 = require_util();
    var model_1 = require_model();
    function createTypeDescription(typeObj, isUnion) {
      if (util_1.isArray(typeObj)) {
        return {
          id: Hash(JSON.stringify(__spreadArrays(typeObj, [isUnion]))),
          arrayOfTypes: typeObj,
          isUnion
        };
      } else {
        return {
          id: Hash(JSON.stringify(typeObj)),
          typeObj
        };
      }
    }
    function getIdByType(typeObj, types, isUnion) {
      if (isUnion === void 0) {
        isUnion = false;
      }
      var typeDesc = types.find(function(el) {
        return typeObjectMatchesTypeDesc(typeObj, el, isUnion);
      });
      if (!typeDesc) {
        typeDesc = createTypeDescription(typeObj, isUnion);
        types.push(typeDesc);
      }
      return typeDesc.id;
    }
    function Hash(content) {
      return hash.sha1().update(content).digest("hex");
    }
    function typeObjectMatchesTypeDesc(typeObj, typeDesc, isUnion) {
      if (util_1.isArray(typeObj)) {
        return arraysContainSameElements(typeObj, typeDesc.arrayOfTypes) && typeDesc.isUnion === isUnion;
      } else {
        return objectsHaveSameEntries(typeObj, typeDesc.typeObj);
      }
    }
    function arraysContainSameElements(arr1, arr2) {
      if (arr1 === void 0 || arr2 === void 0)
        return false;
      return arr1.sort().join("") === arr2.sort().join("");
    }
    function objectsHaveSameEntries(obj1, obj2) {
      if (obj1 === void 0 || obj2 === void 0)
        return false;
      var entries1 = Object.entries(obj1);
      var entries2 = Object.entries(obj2);
      var sameLength = entries1.length === entries2.length;
      var sameTypes = entries1.every(function(_a) {
        var key2 = _a[0], value = _a[1];
        return obj2[key2] === value;
      });
      return sameLength && sameTypes;
    }
    function getSimpleTypeName(value) {
      if (value === null) {
        return "null";
      } else if (value instanceof Date) {
        return "Date";
      } else {
        return typeof value;
      }
    }
    function getTypeGroup(value) {
      if (util_1.isDate(value)) {
        return model_1.TypeGroup.Date;
      } else if (util_1.isArray(value)) {
        return model_1.TypeGroup.Array;
      } else if (util_1.isObject(value)) {
        return model_1.TypeGroup.Object;
      } else {
        return model_1.TypeGroup.Primitive;
      }
    }
    function createTypeObject(obj, types) {
      return Object.entries(obj).reduce(function(typeObj, _a) {
        var _b;
        var key2 = _a[0], value = _a[1];
        var rootTypeId = getTypeStructure(value, types).rootTypeId;
        return __assign(__assign({}, typeObj), (_b = {}, _b[key2] = rootTypeId, _b));
      }, {});
    }
    function getMergedObjects(typesOfArray, types) {
      var typeObjects = typesOfArray.map(function(typeDesc) {
        return typeDesc.typeObj;
      });
      var allKeys = typeObjects.map(function(typeObj2) {
        return Object.keys(typeObj2);
      }).reduce(function(a, b2) {
        return __spreadArrays(a, b2);
      }, []).filter(util_1.onlyUnique);
      var commonKeys = typeObjects.reduce(function(commonKeys2, typeObj2) {
        var keys = Object.keys(typeObj2);
        return commonKeys2.filter(function(key2) {
          return keys.includes(key2);
        });
      }, allKeys);
      var getKeyType = function(key2) {
        var typesOfKey = typeObjects.filter(function(typeObj2) {
          return Object.keys(typeObj2).includes(key2);
        }).map(function(typeObj2) {
          return typeObj2[key2];
        }).filter(util_1.onlyUnique);
        if (typesOfKey.length === 1) {
          return typesOfKey.pop();
        } else {
          return getInnerArrayType(typesOfKey, types);
        }
      };
      var typeObj = allKeys.reduce(function(obj, key2) {
        var _a;
        var isMandatory = commonKeys.includes(key2);
        var type = getKeyType(key2);
        var keyValue = isMandatory ? key2 : toOptionalKey(key2);
        return __assign(__assign({}, obj), (_a = {}, _a[keyValue] = type, _a));
      }, {});
      return getIdByType(typeObj, types, true);
    }
    function toOptionalKey(key2) {
      return key2.endsWith("--?") ? key2 : key2 + "--?";
    }
    function getMergedArrays(typesOfArray, types) {
      var idsOfArrayTypes = typesOfArray.map(function(typeDesc) {
        return typeDesc.arrayOfTypes;
      }).reduce(function(a, b2) {
        return __spreadArrays(a, b2);
      }, []).filter(util_1.onlyUnique);
      if (idsOfArrayTypes.length === 1) {
        return getIdByType([idsOfArrayTypes.pop()], types);
      } else {
        return getIdByType([getInnerArrayType(idsOfArrayTypes, types)], types);
      }
    }
    function getMergedUnion(typesOfArray, types) {
      var innerUnionsTypes = typesOfArray.map(function(id) {
        return util_1.findTypeById(id, types);
      }).filter(function(_2) {
        return !!_2 && _2.isUnion;
      }).map(function(_2) {
        return _2.arrayOfTypes;
      }).reduce(function(a, b2) {
        return __spreadArrays(a, b2);
      }, []);
      var primitiveTypes = typesOfArray.filter(function(id) {
        return !util_1.findTypeById(id, types) || !util_1.findTypeById(id, types).isUnion;
      });
      return getIdByType(__spreadArrays(innerUnionsTypes, primitiveTypes), types, true);
    }
    function getInnerArrayType(typesOfArray, types) {
      var containsUndefined = typesOfArray.includes("undefined");
      var arrayTypesDescriptions = typesOfArray.map(function(id) {
        return util_1.findTypeById(id, types);
      }).filter(function(_2) {
        return !!_2;
      });
      var allArrayType = arrayTypesDescriptions.filter(function(typeDesc) {
        return util_1.getTypeDescriptionGroup(typeDesc) === model_1.TypeGroup.Array;
      }).length === typesOfArray.length;
      var allArrayTypeWithUndefined = arrayTypesDescriptions.filter(function(typeDesc) {
        return util_1.getTypeDescriptionGroup(typeDesc) === model_1.TypeGroup.Array;
      }).length + 1 === typesOfArray.length && containsUndefined;
      var allObjectTypeWithUndefined = arrayTypesDescriptions.filter(function(typeDesc) {
        return util_1.getTypeDescriptionGroup(typeDesc) === model_1.TypeGroup.Object;
      }).length + 1 === typesOfArray.length && containsUndefined;
      var allObjectType = arrayTypesDescriptions.filter(function(typeDesc) {
        return util_1.getTypeDescriptionGroup(typeDesc) === model_1.TypeGroup.Object;
      }).length === typesOfArray.length;
      if (typesOfArray.length === 0) {
        return getIdByType([], types, true);
      }
      if (typesOfArray.length === 1) {
        return typesOfArray.pop();
      }
      if (typesOfArray.length > 1) {
        if (allObjectType)
          return getMergedObjects(arrayTypesDescriptions, types);
        if (allArrayType)
          return getMergedArrays(arrayTypesDescriptions, types);
        if (allArrayTypeWithUndefined) {
          return getMergedUnion([getMergedArrays(arrayTypesDescriptions, types), "undefined"], types);
        }
        if (allObjectTypeWithUndefined) {
          return getMergedUnion([getMergedObjects(arrayTypesDescriptions, types), "undefined"], types);
        }
        return getMergedUnion(typesOfArray, types);
      }
    }
    function getTypeStructure(targetObj, types) {
      if (types === void 0) {
        types = [];
      }
      switch (getTypeGroup(targetObj)) {
        case model_1.TypeGroup.Array:
          var typesOfArray = targetObj.map(function(_2) {
            return getTypeStructure(_2, types).rootTypeId;
          }).filter(util_1.onlyUnique);
          var arrayInnerTypeId = getInnerArrayType(typesOfArray, types);
          var typeId = getIdByType([arrayInnerTypeId], types);
          return {
            rootTypeId: typeId,
            types
          };
        case model_1.TypeGroup.Object:
          var typeObj = createTypeObject(targetObj, types);
          var objType = getIdByType(typeObj, types);
          return {
            rootTypeId: objType,
            types
          };
        case model_1.TypeGroup.Primitive:
          return {
            rootTypeId: getSimpleTypeName(targetObj),
            types
          };
        case model_1.TypeGroup.Date:
          var dateType = getSimpleTypeName(targetObj);
          return {
            rootTypeId: dateType,
            types
          };
      }
    }
    exports2.getTypeStructure = getTypeStructure;
    function getAllUsedTypeIds(_a) {
      var rootTypeId = _a.rootTypeId, types = _a.types;
      var typeDesc = types.find(function(_2) {
        return _2.id === rootTypeId;
      });
      var subTypes = function(typeDesc2) {
        switch (util_1.getTypeDescriptionGroup(typeDesc2)) {
          case model_1.TypeGroup.Array:
            var arrSubTypes = typeDesc2.arrayOfTypes.filter(util_1.isHash).map(function(typeId) {
              var typeDesc3 = types.find(function(_2) {
                return _2.id === typeId;
              });
              return subTypes(typeDesc3);
            }).reduce(function(a, b2) {
              return __spreadArrays(a, b2);
            }, []);
            return __spreadArrays([typeDesc2.id], arrSubTypes);
          case model_1.TypeGroup.Object:
            var objSubTypes = Object.values(typeDesc2.typeObj).filter(util_1.isHash).map(function(typeId) {
              var typeDesc3 = types.find(function(_2) {
                return _2.id === typeId;
              });
              return subTypes(typeDesc3);
            }).reduce(function(a, b2) {
              return __spreadArrays(a, b2);
            }, []);
            return __spreadArrays([typeDesc2.id], objSubTypes);
        }
      };
      return subTypes(typeDesc);
    }
    function optimizeTypeStructure(typeStructure) {
      var usedTypeIds = getAllUsedTypeIds(typeStructure);
      var optimizedTypes = typeStructure.types.filter(function(typeDesc) {
        return usedTypeIds.includes(typeDesc.id);
      });
      typeStructure.types = optimizedTypes;
    }
    exports2.optimizeTypeStructure = optimizeTypeStructure;
  }
});

// node_modules/object-keys/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/object-keys/isArguments.js"(exports2, module2) {
    "use strict";
    var toStr = Object.prototype.toString;
    module2.exports = function isArguments(value) {
      var str = toStr.call(value);
      var isArgs = str === "[object Arguments]";
      if (!isArgs) {
        isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
      }
      return isArgs;
    };
  }
});

// node_modules/object-keys/implementation.js
var require_implementation = __commonJS({
  "node_modules/object-keys/implementation.js"(exports2, module2) {
    "use strict";
    var keysShim;
    if (!Object.keys) {
      has = Object.prototype.hasOwnProperty;
      toStr = Object.prototype.toString;
      isArgs = require_isArguments();
      isEnumerable = Object.prototype.propertyIsEnumerable;
      hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
      hasProtoEnumBug = isEnumerable.call(function() {
      }, "prototype");
      dontEnums = [
        "toString",
        "toLocaleString",
        "valueOf",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "constructor"
      ];
      equalsConstructorPrototype = function(o) {
        var ctor = o.constructor;
        return ctor && ctor.prototype === o;
      };
      excludedKeys = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true
      };
      hasAutomationEqualityBug = function() {
        if (typeof window === "undefined") {
          return false;
        }
        for (var k in window) {
          try {
            if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
              try {
                equalsConstructorPrototype(window[k]);
              } catch (e) {
                return true;
              }
            }
          } catch (e) {
            return true;
          }
        }
        return false;
      }();
      equalsConstructorPrototypeIfNotBuggy = function(o) {
        if (typeof window === "undefined" || !hasAutomationEqualityBug) {
          return equalsConstructorPrototype(o);
        }
        try {
          return equalsConstructorPrototype(o);
        } catch (e) {
          return false;
        }
      };
      keysShim = function keys(object) {
        var isObject = object !== null && typeof object === "object";
        var isFunction = toStr.call(object) === "[object Function]";
        var isArguments = isArgs(object);
        var isString = isObject && toStr.call(object) === "[object String]";
        var theKeys = [];
        if (!isObject && !isFunction && !isArguments) {
          throw new TypeError("Object.keys called on a non-object");
        }
        var skipProto = hasProtoEnumBug && isFunction;
        if (isString && object.length > 0 && !has.call(object, 0)) {
          for (var i = 0; i < object.length; ++i) {
            theKeys.push(String(i));
          }
        }
        if (isArguments && object.length > 0) {
          for (var j2 = 0; j2 < object.length; ++j2) {
            theKeys.push(String(j2));
          }
        } else {
          for (var name in object) {
            if (!(skipProto && name === "prototype") && has.call(object, name)) {
              theKeys.push(String(name));
            }
          }
        }
        if (hasDontEnumBug) {
          var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
          for (var k = 0; k < dontEnums.length; ++k) {
            if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object, dontEnums[k])) {
              theKeys.push(dontEnums[k]);
            }
          }
        }
        return theKeys;
      };
    }
    var has;
    var toStr;
    var isArgs;
    var isEnumerable;
    var hasDontEnumBug;
    var hasProtoEnumBug;
    var dontEnums;
    var equalsConstructorPrototype;
    var excludedKeys;
    var hasAutomationEqualityBug;
    var equalsConstructorPrototypeIfNotBuggy;
    module2.exports = keysShim;
  }
});

// node_modules/object-keys/index.js
var require_object_keys = __commonJS({
  "node_modules/object-keys/index.js"(exports2, module2) {
    "use strict";
    var slice = Array.prototype.slice;
    var isArgs = require_isArguments();
    var origKeys = Object.keys;
    var keysShim = origKeys ? function keys(o) {
      return origKeys(o);
    } : require_implementation();
    var originalKeys = Object.keys;
    keysShim.shim = function shimObjectKeys() {
      if (Object.keys) {
        var keysWorksWithArguments = function() {
          var args = Object.keys(arguments);
          return args && args.length === arguments.length;
        }(1, 2);
        if (!keysWorksWithArguments) {
          Object.keys = function keys(object) {
            if (isArgs(object)) {
              return originalKeys(slice.call(object));
            }
            return originalKeys(object);
          };
        }
      } else {
        Object.keys = keysShim;
      }
      return Object.keys || keysShim;
    };
    module2.exports = keysShim;
  }
});

// node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  "node_modules/es-errors/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Error;
  }
});

// node_modules/es-errors/eval.js
var require_eval = __commonJS({
  "node_modules/es-errors/eval.js"(exports2, module2) {
    "use strict";
    module2.exports = EvalError;
  }
});

// node_modules/es-errors/range.js
var require_range = __commonJS({
  "node_modules/es-errors/range.js"(exports2, module2) {
    "use strict";
    module2.exports = RangeError;
  }
});

// node_modules/es-errors/ref.js
var require_ref = __commonJS({
  "node_modules/es-errors/ref.js"(exports2, module2) {
    "use strict";
    module2.exports = ReferenceError;
  }
});

// node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "node_modules/es-errors/syntax.js"(exports2, module2) {
    "use strict";
    module2.exports = SyntaxError;
  }
});

// node_modules/es-errors/type.js
var require_type = __commonJS({
  "node_modules/es-errors/type.js"(exports2, module2) {
    "use strict";
    module2.exports = TypeError;
  }
});

// node_modules/es-errors/uri.js
var require_uri = __commonJS({
  "node_modules/es-errors/uri.js"(exports2, module2) {
    "use strict";
    module2.exports = URIError;
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports2, module2) {
    "use strict";
    module2.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports2, module2) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module2.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/has-proto/index.js
var require_has_proto = __commonJS({
  "node_modules/has-proto/index.js"(exports2, module2) {
    "use strict";
    var test = {
      __proto__: null,
      foo: {}
    };
    var $Object = Object;
    module2.exports = function hasProto() {
      return { __proto__: test }.foo === test.foo && !(test instanceof $Object);
    };
  }
});

// node_modules/function-bind/implementation.js
var require_implementation2 = __commonJS({
  "node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b2) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j2 = 0; j2 < b2.length; j2 += 1) {
        arr[j2 + a.length] = b2[j2];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j2 = 0; i < arrLike.length; i += 1, j2 += 1) {
        arr[j2] = arrLike[i];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation2();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/hasown/index.js
var require_hasown = __commonJS({
  "node_modules/hasown/index.js"(exports2, module2) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module2.exports = bind.call(call, $hasOwn);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports2, module2) {
    "use strict";
    var undefined2;
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range();
    var $ReferenceError = require_ref();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $URIError = require_uri();
    var $Function = Function;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var hasProto = require_has_proto()();
    var getProto = Object.getPrototypeOf || (hasProto ? function(x2) {
      return x2.__proto__;
    } : null);
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn2 = doEval2("%AsyncGeneratorFunction%");
        if (fn2) {
          value = fn2.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var $exec = bind.call(Function.call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module2.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "node_modules/es-define-property/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true) || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = false;
      }
    }
    module2.exports = $defineProperty;
  }
});

// node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/gopd/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module2.exports = $gOPD;
  }
});

// node_modules/define-data-property/index.js
var require_define_data_property = __commonJS({
  "node_modules/define-data-property/index.js"(exports2, module2) {
    "use strict";
    var $defineProperty = require_es_define_property();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var gopd = require_gopd();
    module2.exports = function defineDataProperty(obj, property, value) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new $TypeError("`obj` must be an object or a function`");
      }
      if (typeof property !== "string" && typeof property !== "symbol") {
        throw new $TypeError("`property` must be a string or a symbol`");
      }
      if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
        throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
        throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
        throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
        throw new $TypeError("`loose`, if provided, must be a boolean");
      }
      var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
      var nonWritable = arguments.length > 4 ? arguments[4] : null;
      var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
      var loose = arguments.length > 6 ? arguments[6] : false;
      var desc = !!gopd && gopd(obj, property);
      if ($defineProperty) {
        $defineProperty(obj, property, {
          configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
          enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
          value,
          writable: nonWritable === null && desc ? desc.writable : !nonWritable
        });
      } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
        obj[property] = value;
      } else {
        throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
      }
    };
  }
});

// node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "node_modules/has-property-descriptors/index.js"(exports2, module2) {
    "use strict";
    var $defineProperty = require_es_define_property();
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      return !!$defineProperty;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!$defineProperty) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e) {
        return true;
      }
    };
    module2.exports = hasPropertyDescriptors;
  }
});

// node_modules/define-properties/index.js
var require_define_properties = __commonJS({
  "node_modules/define-properties/index.js"(exports2, module2) {
    "use strict";
    var keys = require_object_keys();
    var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
    var toStr = Object.prototype.toString;
    var concat = Array.prototype.concat;
    var defineDataProperty = require_define_data_property();
    var isFunction = function(fn2) {
      return typeof fn2 === "function" && toStr.call(fn2) === "[object Function]";
    };
    var supportsDescriptors = require_has_property_descriptors()();
    var defineProperty = function(object, name, value, predicate) {
      if (name in object) {
        if (predicate === true) {
          if (object[name] === value) {
            return;
          }
        } else if (!isFunction(predicate) || !predicate()) {
          return;
        }
      }
      if (supportsDescriptors) {
        defineDataProperty(object, name, value, true);
      } else {
        defineDataProperty(object, name, value);
      }
    };
    var defineProperties = function(object, map) {
      var predicates = arguments.length > 2 ? arguments[2] : {};
      var props2 = keys(map);
      if (hasSymbols) {
        props2 = concat.call(props2, Object.getOwnPropertySymbols(map));
      }
      for (var i = 0; i < props2.length; i += 1) {
        defineProperty(object, props2[i], map[props2[i]], predicates[props2[i]]);
      }
    };
    defineProperties.supportsDescriptors = !!supportsDescriptors;
    module2.exports = defineProperties;
  }
});

// node_modules/es-object-atoms/RequireObjectCoercible.js
var require_RequireObjectCoercible = __commonJS({
  "node_modules/es-object-atoms/RequireObjectCoercible.js"(exports2, module2) {
    "use strict";
    var $TypeError = require_type();
    module2.exports = function RequireObjectCoercible(value) {
      if (value == null) {
        throw new $TypeError(arguments.length > 0 && arguments[1] || "Cannot call method on " + value);
      }
      return value;
    };
  }
});

// node_modules/set-function-length/index.js
var require_set_function_length = __commonJS({
  "node_modules/set-function-length/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var define2 = require_define_data_property();
    var hasDescriptors = require_has_property_descriptors()();
    var gOPD = require_gopd();
    var $TypeError = require_type();
    var $floor = GetIntrinsic("%Math.floor%");
    module2.exports = function setFunctionLength(fn2, length) {
      if (typeof fn2 !== "function") {
        throw new $TypeError("`fn` is not a function");
      }
      if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
        throw new $TypeError("`length` must be a positive 32-bit integer");
      }
      var loose = arguments.length > 2 && !!arguments[2];
      var functionLengthIsConfigurable = true;
      var functionLengthIsWritable = true;
      if ("length" in fn2 && gOPD) {
        var desc = gOPD(fn2, "length");
        if (desc && !desc.configurable) {
          functionLengthIsConfigurable = false;
        }
        if (desc && !desc.writable) {
          functionLengthIsWritable = false;
        }
      }
      if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
        if (hasDescriptors) {
          define2(
            /** @type {Parameters<define>[0]} */
            fn2,
            "length",
            length,
            true,
            true
          );
        } else {
          define2(
            /** @type {Parameters<define>[0]} */
            fn2,
            "length",
            length
          );
        }
      }
      return fn2;
    };
  }
});

// node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "node_modules/call-bind/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var GetIntrinsic = require_get_intrinsic();
    var setFunctionLength = require_set_function_length();
    var $TypeError = require_type();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $defineProperty = require_es_define_property();
    var $max = GetIntrinsic("%Math.max%");
    module2.exports = function callBind(originalFunction) {
      if (typeof originalFunction !== "function") {
        throw new $TypeError("a function is required");
      }
      var func = $reflectApply(bind, $call, arguments);
      return setFunctionLength(
        func,
        1 + $max(0, originalFunction.length - (arguments.length - 1)),
        true
      );
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module2.exports, "apply", { value: applyBind });
    } else {
      module2.exports.apply = applyBind;
    }
  }
});

// node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "node_modules/call-bind/callBound.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module2.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic(name, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// node_modules/es-abstract/helpers/isPrimitive.js
var require_isPrimitive = __commonJS({
  "node_modules/es-abstract/helpers/isPrimitive.js"(exports2, module2) {
    "use strict";
    module2.exports = function isPrimitive(value) {
      return value === null || typeof value !== "function" && typeof value !== "object";
    };
  }
});

// node_modules/es-to-primitive/helpers/isPrimitive.js
var require_isPrimitive2 = __commonJS({
  "node_modules/es-to-primitive/helpers/isPrimitive.js"(exports2, module2) {
    "use strict";
    module2.exports = function isPrimitive(value) {
      return value === null || typeof value !== "function" && typeof value !== "object";
    };
  }
});

// node_modules/is-callable/index.js
var require_is_callable = __commonJS({
  "node_modules/is-callable/index.js"(exports2, module2) {
    "use strict";
    var fnToStr = Function.prototype.toString;
    var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
    var badArrayLike;
    var isCallableMarker;
    if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
      try {
        badArrayLike = Object.defineProperty({}, "length", {
          get: function() {
            throw isCallableMarker;
          }
        });
        isCallableMarker = {};
        reflectApply(function() {
          throw 42;
        }, null, badArrayLike);
      } catch (_2) {
        if (_2 !== isCallableMarker) {
          reflectApply = null;
        }
      }
    } else {
      reflectApply = null;
    }
    var constructorRegex = /^\s*class\b/;
    var isES6ClassFn = function isES6ClassFunction(value) {
      try {
        var fnStr = fnToStr.call(value);
        return constructorRegex.test(fnStr);
      } catch (e) {
        return false;
      }
    };
    var tryFunctionObject = function tryFunctionToStr(value) {
      try {
        if (isES6ClassFn(value)) {
          return false;
        }
        fnToStr.call(value);
        return true;
      } catch (e) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var objectClass = "[object Object]";
    var fnClass = "[object Function]";
    var genClass = "[object GeneratorFunction]";
    var ddaClass = "[object HTMLAllCollection]";
    var ddaClass2 = "[object HTML document.all class]";
    var ddaClass3 = "[object HTMLCollection]";
    var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
    var isIE68 = !(0 in [,]);
    var isDDA = function isDocumentDotAll() {
      return false;
    };
    if (typeof document === "object") {
      all = document.all;
      if (toStr.call(all) === toStr.call(document.all)) {
        isDDA = function isDocumentDotAll(value) {
          if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
            try {
              var str = toStr.call(value);
              return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
            } catch (e) {
            }
          }
          return false;
        };
      }
    }
    var all;
    module2.exports = reflectApply ? function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      try {
        reflectApply(value, null, badArrayLike);
      } catch (e) {
        if (e !== isCallableMarker) {
          return false;
        }
      }
      return !isES6ClassFn(value) && tryFunctionObject(value);
    } : function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      if (hasToStringTag) {
        return tryFunctionObject(value);
      }
      if (isES6ClassFn(value)) {
        return false;
      }
      var strClass = toStr.call(value);
      if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
        return false;
      }
      return tryFunctionObject(value);
    };
  }
});

// node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  "node_modules/has-tostringtag/shams.js"(exports2, module2) {
    "use strict";
    var hasSymbols = require_shams();
    module2.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
});

// node_modules/is-date-object/index.js
var require_is_date_object = __commonJS({
  "node_modules/is-date-object/index.js"(exports2, module2) {
    "use strict";
    var getDay = Date.prototype.getDay;
    var tryDateObject = function tryDateGetDayCall(value) {
      try {
        getDay.call(value);
        return true;
      } catch (e) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var dateClass = "[object Date]";
    var hasToStringTag = require_shams2()();
    module2.exports = function isDateObject(value) {
      if (typeof value !== "object" || value === null) {
        return false;
      }
      return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
    };
  }
});

// node_modules/is-symbol/index.js
var require_is_symbol = __commonJS({
  "node_modules/is-symbol/index.js"(exports2, module2) {
    "use strict";
    var toStr = Object.prototype.toString;
    var hasSymbols = require_has_symbols()();
    if (hasSymbols) {
      symToStr = Symbol.prototype.toString;
      symStringRegex = /^Symbol\(.*\)$/;
      isSymbolObject = function isRealSymbolObject(value) {
        if (typeof value.valueOf() !== "symbol") {
          return false;
        }
        return symStringRegex.test(symToStr.call(value));
      };
      module2.exports = function isSymbol(value) {
        if (typeof value === "symbol") {
          return true;
        }
        if (toStr.call(value) !== "[object Symbol]") {
          return false;
        }
        try {
          return isSymbolObject(value);
        } catch (e) {
          return false;
        }
      };
    } else {
      module2.exports = function isSymbol(value) {
        return false;
      };
    }
    var symToStr;
    var symStringRegex;
    var isSymbolObject;
  }
});

// node_modules/es-to-primitive/es2015.js
var require_es2015 = __commonJS({
  "node_modules/es-to-primitive/es2015.js"(exports2, module2) {
    "use strict";
    var hasSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "symbol";
    var isPrimitive = require_isPrimitive2();
    var isCallable = require_is_callable();
    var isDate = require_is_date_object();
    var isSymbol = require_is_symbol();
    var ordinaryToPrimitive = function OrdinaryToPrimitive(O2, hint) {
      if (typeof O2 === "undefined" || O2 === null) {
        throw new TypeError("Cannot call method on " + O2);
      }
      if (typeof hint !== "string" || hint !== "number" && hint !== "string") {
        throw new TypeError('hint must be "string" or "number"');
      }
      var methodNames = hint === "string" ? ["toString", "valueOf"] : ["valueOf", "toString"];
      var method, result, i;
      for (i = 0; i < methodNames.length; ++i) {
        method = O2[methodNames[i]];
        if (isCallable(method)) {
          result = method.call(O2);
          if (isPrimitive(result)) {
            return result;
          }
        }
      }
      throw new TypeError("No default value");
    };
    var GetMethod = function GetMethod2(O2, P2) {
      var func = O2[P2];
      if (func !== null && typeof func !== "undefined") {
        if (!isCallable(func)) {
          throw new TypeError(func + " returned for property " + P2 + " of object " + O2 + " is not a function");
        }
        return func;
      }
      return void 0;
    };
    module2.exports = function ToPrimitive(input) {
      if (isPrimitive(input)) {
        return input;
      }
      var hint = "default";
      if (arguments.length > 1) {
        if (arguments[1] === String) {
          hint = "string";
        } else if (arguments[1] === Number) {
          hint = "number";
        }
      }
      var exoticToPrim;
      if (hasSymbols) {
        if (Symbol.toPrimitive) {
          exoticToPrim = GetMethod(input, Symbol.toPrimitive);
        } else if (isSymbol(input)) {
          exoticToPrim = Symbol.prototype.valueOf;
        }
      }
      if (typeof exoticToPrim !== "undefined") {
        var result = exoticToPrim.call(input, hint);
        if (isPrimitive(result)) {
          return result;
        }
        throw new TypeError("unable to convert exotic object to primitive");
      }
      if (hint === "default" && (isDate(input) || isSymbol(input))) {
        hint = "string";
      }
      return ordinaryToPrimitive(input, hint === "default" ? "number" : hint);
    };
  }
});

// node_modules/es-abstract/2024/ToPrimitive.js
var require_ToPrimitive = __commonJS({
  "node_modules/es-abstract/2024/ToPrimitive.js"(exports2, module2) {
    "use strict";
    var toPrimitive = require_es2015();
    module2.exports = function ToPrimitive(input) {
      if (arguments.length > 1) {
        return toPrimitive(input, arguments[1]);
      }
      return toPrimitive(input);
    };
  }
});

// node_modules/is-regex/index.js
var require_is_regex = __commonJS({
  "node_modules/is-regex/index.js"(exports2, module2) {
    "use strict";
    var callBound = require_callBound();
    var hasToStringTag = require_shams2()();
    var has;
    var $exec;
    var isRegexMarker;
    var badStringifier;
    if (hasToStringTag) {
      has = callBound("Object.prototype.hasOwnProperty");
      $exec = callBound("RegExp.prototype.exec");
      isRegexMarker = {};
      throwRegexMarker = function() {
        throw isRegexMarker;
      };
      badStringifier = {
        toString: throwRegexMarker,
        valueOf: throwRegexMarker
      };
      if (typeof Symbol.toPrimitive === "symbol") {
        badStringifier[Symbol.toPrimitive] = throwRegexMarker;
      }
    }
    var throwRegexMarker;
    var $toString = callBound("Object.prototype.toString");
    var gOPD = Object.getOwnPropertyDescriptor;
    var regexClass = "[object RegExp]";
    module2.exports = hasToStringTag ? function isRegex(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      var descriptor = gOPD(value, "lastIndex");
      var hasLastIndexDataProperty = descriptor && has(descriptor, "value");
      if (!hasLastIndexDataProperty) {
        return false;
      }
      try {
        $exec(value, badStringifier);
      } catch (e) {
        return e === isRegexMarker;
      }
    } : function isRegex(value) {
      if (!value || typeof value !== "object" && typeof value !== "function") {
        return false;
      }
      return $toString(value) === regexClass;
    };
  }
});

// node_modules/safe-regex-test/index.js
var require_safe_regex_test = __commonJS({
  "node_modules/safe-regex-test/index.js"(exports2, module2) {
    "use strict";
    var callBound = require_callBound();
    var isRegex = require_is_regex();
    var $exec = callBound("RegExp.prototype.exec");
    var $TypeError = require_type();
    module2.exports = function regexTester(regex) {
      if (!isRegex(regex)) {
        throw new $TypeError("`regex` must be a RegExp");
      }
      return function test(s) {
        return $exec(regex, s) !== null;
      };
    };
  }
});

// node_modules/es-abstract/2024/ToString.js
var require_ToString = __commonJS({
  "node_modules/es-abstract/2024/ToString.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $String = GetIntrinsic("%String%");
    var $TypeError = require_type();
    module2.exports = function ToString(argument) {
      if (typeof argument === "symbol") {
        throw new $TypeError("Cannot convert a Symbol value to a string");
      }
      return $String(argument);
    };
  }
});

// node_modules/string.prototype.trim/implementation.js
var require_implementation3 = __commonJS({
  "node_modules/string.prototype.trim/implementation.js"(exports2, module2) {
    "use strict";
    var RequireObjectCoercible = require_RequireObjectCoercible();
    var ToString = require_ToString();
    var callBound = require_callBound();
    var $replace = callBound("String.prototype.replace");
    var mvsIsWS = /^\s$/.test("᠎");
    var leftWhitespace = mvsIsWS ? /^[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+/ : /^[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+/;
    var rightWhitespace = mvsIsWS ? /[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+$/ : /[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+$/;
    module2.exports = function trim() {
      var S2 = ToString(RequireObjectCoercible(this));
      return $replace($replace(S2, leftWhitespace, ""), rightWhitespace, "");
    };
  }
});

// node_modules/string.prototype.trim/polyfill.js
var require_polyfill = __commonJS({
  "node_modules/string.prototype.trim/polyfill.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation3();
    var zeroWidthSpace = "​";
    var mongolianVowelSeparator = "᠎";
    module2.exports = function getPolyfill() {
      if (String.prototype.trim && zeroWidthSpace.trim() === zeroWidthSpace && mongolianVowelSeparator.trim() === mongolianVowelSeparator && ("_" + mongolianVowelSeparator).trim() === "_" + mongolianVowelSeparator && (mongolianVowelSeparator + "_").trim() === mongolianVowelSeparator + "_") {
        return String.prototype.trim;
      }
      return implementation;
    };
  }
});

// node_modules/string.prototype.trim/shim.js
var require_shim = __commonJS({
  "node_modules/string.prototype.trim/shim.js"(exports2, module2) {
    "use strict";
    var define2 = require_define_properties();
    var getPolyfill = require_polyfill();
    module2.exports = function shimStringTrim() {
      var polyfill = getPolyfill();
      define2(String.prototype, { trim: polyfill }, {
        trim: function testTrim() {
          return String.prototype.trim !== polyfill;
        }
      });
      return polyfill;
    };
  }
});

// node_modules/string.prototype.trim/index.js
var require_string_prototype = __commonJS({
  "node_modules/string.prototype.trim/index.js"(exports2, module2) {
    "use strict";
    var callBind = require_call_bind();
    var define2 = require_define_properties();
    var RequireObjectCoercible = require_RequireObjectCoercible();
    var implementation = require_implementation3();
    var getPolyfill = require_polyfill();
    var shim = require_shim();
    var bound = callBind(getPolyfill());
    var boundMethod = function trim(receiver) {
      RequireObjectCoercible(receiver);
      return bound(receiver);
    };
    define2(boundMethod, {
      getPolyfill,
      implementation,
      shim
    });
    module2.exports = boundMethod;
  }
});

// node_modules/es-abstract/2024/StringToNumber.js
var require_StringToNumber = __commonJS({
  "node_modules/es-abstract/2024/StringToNumber.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $Number = GetIntrinsic("%Number%");
    var $RegExp = GetIntrinsic("%RegExp%");
    var $TypeError = require_type();
    var $parseInteger = GetIntrinsic("%parseInt%");
    var callBound = require_callBound();
    var regexTester = require_safe_regex_test();
    var $strSlice = callBound("String.prototype.slice");
    var isBinary = regexTester(/^0b[01]+$/i);
    var isOctal = regexTester(/^0o[0-7]+$/i);
    var isInvalidHexLiteral = regexTester(/^[-+]0x[0-9a-f]+$/i);
    var nonWS = ["", "​", "￾"].join("");
    var nonWSregex = new $RegExp("[" + nonWS + "]", "g");
    var hasNonWS = regexTester(nonWSregex);
    var $trim = require_string_prototype();
    module2.exports = function StringToNumber(argument) {
      if (typeof argument !== "string") {
        throw new $TypeError("Assertion failed: `argument` is not a String");
      }
      if (isBinary(argument)) {
        return $Number($parseInteger($strSlice(argument, 2), 2));
      }
      if (isOctal(argument)) {
        return $Number($parseInteger($strSlice(argument, 2), 8));
      }
      if (hasNonWS(argument) || isInvalidHexLiteral(argument)) {
        return NaN;
      }
      var trimmed = $trim(argument);
      if (trimmed !== argument) {
        return StringToNumber(trimmed);
      }
      return $Number(argument);
    };
  }
});

// node_modules/es-abstract/2024/ToNumber.js
var require_ToNumber = __commonJS({
  "node_modules/es-abstract/2024/ToNumber.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = require_type();
    var $Number = GetIntrinsic("%Number%");
    var isPrimitive = require_isPrimitive();
    var ToPrimitive = require_ToPrimitive();
    var StringToNumber = require_StringToNumber();
    module2.exports = function ToNumber(argument) {
      var value = isPrimitive(argument) ? argument : ToPrimitive(argument, $Number);
      if (typeof value === "symbol") {
        throw new $TypeError("Cannot convert a Symbol value to a number");
      }
      if (typeof value === "bigint") {
        throw new $TypeError("Conversion from 'BigInt' to 'number' is not allowed.");
      }
      if (typeof value === "string") {
        return StringToNumber(value);
      }
      return $Number(value);
    };
  }
});

// node_modules/es-abstract/2024/floor.js
var require_floor = __commonJS({
  "node_modules/es-abstract/2024/floor.js"(exports2, module2) {
    "use strict";
    var $floor = Math.floor;
    module2.exports = function floor(x2) {
      if (typeof x2 === "bigint") {
        return x2;
      }
      return $floor(x2);
    };
  }
});

// node_modules/es-abstract/2024/truncate.js
var require_truncate = __commonJS({
  "node_modules/es-abstract/2024/truncate.js"(exports2, module2) {
    "use strict";
    var floor = require_floor();
    var $TypeError = require_type();
    module2.exports = function truncate(x2) {
      if (typeof x2 !== "number" && typeof x2 !== "bigint") {
        throw new $TypeError("argument must be a Number or a BigInt");
      }
      var result = x2 < 0 ? -floor(-x2) : floor(x2);
      return result === 0 ? 0 : result;
    };
  }
});

// node_modules/es-abstract/helpers/isNaN.js
var require_isNaN = __commonJS({
  "node_modules/es-abstract/helpers/isNaN.js"(exports2, module2) {
    "use strict";
    module2.exports = Number.isNaN || function isNaN2(a) {
      return a !== a;
    };
  }
});

// node_modules/es-abstract/helpers/isFinite.js
var require_isFinite = __commonJS({
  "node_modules/es-abstract/helpers/isFinite.js"(exports2, module2) {
    "use strict";
    var $isNaN = require_isNaN();
    module2.exports = function(x2) {
      return (typeof x2 === "number" || typeof x2 === "bigint") && !$isNaN(x2) && x2 !== Infinity && x2 !== -Infinity;
    };
  }
});

// node_modules/es-abstract/2024/ToIntegerOrInfinity.js
var require_ToIntegerOrInfinity = __commonJS({
  "node_modules/es-abstract/2024/ToIntegerOrInfinity.js"(exports2, module2) {
    "use strict";
    var ToNumber = require_ToNumber();
    var truncate = require_truncate();
    var $isNaN = require_isNaN();
    var $isFinite = require_isFinite();
    module2.exports = function ToIntegerOrInfinity(value) {
      var number = ToNumber(value);
      if ($isNaN(number) || number === 0) {
        return 0;
      }
      if (!$isFinite(number)) {
        return number;
      }
      return truncate(number);
    };
  }
});

// node_modules/es-abstract/helpers/maxSafeInteger.js
var require_maxSafeInteger = __commonJS({
  "node_modules/es-abstract/helpers/maxSafeInteger.js"(exports2, module2) {
    "use strict";
    module2.exports = Number.MAX_SAFE_INTEGER || 9007199254740991;
  }
});

// node_modules/es-abstract/2024/ToLength.js
var require_ToLength = __commonJS({
  "node_modules/es-abstract/2024/ToLength.js"(exports2, module2) {
    "use strict";
    var MAX_SAFE_INTEGER = require_maxSafeInteger();
    var ToIntegerOrInfinity = require_ToIntegerOrInfinity();
    module2.exports = function ToLength(argument) {
      var len = ToIntegerOrInfinity(argument);
      if (len <= 0) {
        return 0;
      }
      if (len > MAX_SAFE_INTEGER) {
        return MAX_SAFE_INTEGER;
      }
      return len;
    };
  }
});

// node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS({
  "node_modules/es-object-atoms/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Object;
  }
});

// node_modules/es-object-atoms/ToObject.js
var require_ToObject = __commonJS({
  "node_modules/es-object-atoms/ToObject.js"(exports2, module2) {
    "use strict";
    var $Object = require_es_object_atoms();
    var RequireObjectCoercible = require_RequireObjectCoercible();
    module2.exports = function ToObject(value) {
      RequireObjectCoercible(value);
      return $Object(value);
    };
  }
});

// node_modules/es-abstract/2024/SameValueZero.js
var require_SameValueZero = __commonJS({
  "node_modules/es-abstract/2024/SameValueZero.js"(exports2, module2) {
    "use strict";
    var $isNaN = require_isNaN();
    module2.exports = function SameValueZero(x2, y2) {
      return x2 === y2 || $isNaN(x2) && $isNaN(y2);
    };
  }
});

// node_modules/is-string/index.js
var require_is_string = __commonJS({
  "node_modules/is-string/index.js"(exports2, module2) {
    "use strict";
    var strValue = String.prototype.valueOf;
    var tryStringObject = function tryStringObject2(value) {
      try {
        strValue.call(value);
        return true;
      } catch (e) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var strClass = "[object String]";
    var hasToStringTag = require_shams2()();
    module2.exports = function isString(value) {
      if (typeof value === "string") {
        return true;
      }
      if (typeof value !== "object") {
        return false;
      }
      return hasToStringTag ? tryStringObject(value) : toStr.call(value) === strClass;
    };
  }
});

// node_modules/array-includes/implementation.js
var require_implementation4 = __commonJS({
  "node_modules/array-includes/implementation.js"(exports2, module2) {
    "use strict";
    var ToIntegerOrInfinity = require_ToIntegerOrInfinity();
    var ToLength = require_ToLength();
    var ToObject = require_ToObject();
    var SameValueZero = require_SameValueZero();
    var $isNaN = require_isNaN();
    var $isFinite = require_isFinite();
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var isString = require_is_string();
    var $charAt = callBound("String.prototype.charAt");
    var $indexOf = GetIntrinsic("%Array.prototype.indexOf%");
    var $max = GetIntrinsic("%Math.max%");
    module2.exports = function includes(searchElement) {
      var fromIndex = arguments.length > 1 ? ToIntegerOrInfinity(arguments[1]) : 0;
      if ($indexOf && !$isNaN(searchElement) && $isFinite(fromIndex) && typeof searchElement !== "undefined") {
        return $indexOf.apply(this, arguments) > -1;
      }
      var O2 = ToObject(this);
      var length = ToLength(O2.length);
      if (length === 0) {
        return false;
      }
      var k = fromIndex >= 0 ? fromIndex : $max(0, length + fromIndex);
      while (k < length) {
        if (SameValueZero(searchElement, isString(O2) ? $charAt(O2, k) : O2[k])) {
          return true;
        }
        k += 1;
      }
      return false;
    };
  }
});

// node_modules/array-includes/polyfill.js
var require_polyfill2 = __commonJS({
  "node_modules/array-includes/polyfill.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation4();
    module2.exports = function getPolyfill() {
      if (Array.prototype.includes && Array(1).includes(void 0)) {
        return Array.prototype.includes;
      }
      return implementation;
    };
  }
});

// node_modules/array-includes/shim.js
var require_shim2 = __commonJS({
  "node_modules/array-includes/shim.js"(exports2, module2) {
    "use strict";
    var define2 = require_define_properties();
    var getPolyfill = require_polyfill2();
    module2.exports = function shimArrayPrototypeIncludes() {
      var polyfill = getPolyfill();
      define2(
        Array.prototype,
        { includes: polyfill },
        { includes: function() {
          return Array.prototype.includes !== polyfill;
        } }
      );
      return polyfill;
    };
  }
});

// node_modules/array-includes/index.js
var require_array_includes = __commonJS({
  "node_modules/array-includes/index.js"(exports2, module2) {
    "use strict";
    var define2 = require_define_properties();
    var RequireObjectCoercible = require_RequireObjectCoercible();
    var callBind = require_call_bind();
    var callBound = require_callBound();
    var implementation = require_implementation4();
    var getPolyfill = require_polyfill2();
    var polyfill = callBind.apply(getPolyfill());
    var shim = require_shim2();
    var $slice = callBound("Array.prototype.slice");
    var boundShim = function includes(array, searchElement) {
      RequireObjectCoercible(array);
      return polyfill(array, $slice(arguments, 1));
    };
    define2(boundShim, {
      getPolyfill,
      implementation,
      shim
    });
    module2.exports = boundShim;
  }
});

// node_modules/es7-shim/Array.prototype.includes.js
var require_Array_prototype_includes = __commonJS({
  "node_modules/es7-shim/Array.prototype.includes.js"(exports2, module2) {
    "use strict";
    module2.exports = require_array_includes();
  }
});

// node_modules/es7-shim/Array.prototype.js
var require_Array_prototype = __commonJS({
  "node_modules/es7-shim/Array.prototype.js"(exports2, module2) {
    "use strict";
    var includes = require_Array_prototype_includes();
    module2.exports = {
      includes,
      shim: function shimArrayPrototype() {
        includes.shim();
      }
    };
  }
});

// node_modules/es7-shim/Array.js
var require_Array = __commonJS({
  "node_modules/es7-shim/Array.js"(exports2, module2) {
    "use strict";
    var proto = require_Array_prototype();
    module2.exports = {
      prototype: proto,
      shim: function shimArray() {
        proto.shim();
      }
    };
  }
});

// node_modules/es-abstract/2024/IsPropertyKey.js
var require_IsPropertyKey = __commonJS({
  "node_modules/es-abstract/2024/IsPropertyKey.js"(exports2, module2) {
    "use strict";
    module2.exports = function IsPropertyKey(argument) {
      return typeof argument === "string" || typeof argument === "symbol";
    };
  }
});

// node_modules/es-abstract/helpers/records/property-descriptor.js
var require_property_descriptor = __commonJS({
  "node_modules/es-abstract/helpers/records/property-descriptor.js"(exports2, module2) {
    "use strict";
    var $TypeError = require_type();
    var hasOwn = require_hasown();
    var allowed = {
      __proto__: null,
      "[[Configurable]]": true,
      "[[Enumerable]]": true,
      "[[Get]]": true,
      "[[Set]]": true,
      "[[Value]]": true,
      "[[Writable]]": true
    };
    module2.exports = function isPropertyDescriptor(Desc) {
      if (!Desc || typeof Desc !== "object") {
        return false;
      }
      for (var key2 in Desc) {
        if (hasOwn(Desc, key2) && !allowed[key2]) {
          return false;
        }
      }
      var isData = hasOwn(Desc, "[[Value]]") || hasOwn(Desc, "[[Writable]]");
      var IsAccessor = hasOwn(Desc, "[[Get]]") || hasOwn(Desc, "[[Set]]");
      if (isData && IsAccessor) {
        throw new $TypeError("Property Descriptors may not be both accessor and data descriptors");
      }
      return true;
    };
  }
});

// node_modules/es-abstract/2024/IsAccessorDescriptor.js
var require_IsAccessorDescriptor = __commonJS({
  "node_modules/es-abstract/2024/IsAccessorDescriptor.js"(exports2, module2) {
    "use strict";
    var $TypeError = require_type();
    var hasOwn = require_hasown();
    var isPropertyDescriptor = require_property_descriptor();
    module2.exports = function IsAccessorDescriptor(Desc) {
      if (typeof Desc === "undefined") {
        return false;
      }
      if (!isPropertyDescriptor(Desc)) {
        throw new $TypeError("Assertion failed: `Desc` must be a Property Descriptor");
      }
      if (!hasOwn(Desc, "[[Get]]") && !hasOwn(Desc, "[[Set]]")) {
        return false;
      }
      return true;
    };
  }
});

// node_modules/es-abstract/2024/IsExtensible.js
var require_IsExtensible = __commonJS({
  "node_modules/es-abstract/2024/IsExtensible.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $preventExtensions = GetIntrinsic("%Object.preventExtensions%", true);
    var $isExtensible = GetIntrinsic("%Object.isExtensible%", true);
    var isPrimitive = require_isPrimitive();
    module2.exports = $preventExtensions ? function IsExtensible(obj) {
      return !isPrimitive(obj) && $isExtensible(obj);
    } : function IsExtensible(obj) {
      return !isPrimitive(obj);
    };
  }
});

// node_modules/es-abstract/5/Type.js
var require_Type = __commonJS({
  "node_modules/es-abstract/5/Type.js"(exports2, module2) {
    "use strict";
    module2.exports = function Type(x2) {
      if (x2 === null) {
        return "Null";
      }
      if (typeof x2 === "undefined") {
        return "Undefined";
      }
      if (typeof x2 === "function" || typeof x2 === "object") {
        return "Object";
      }
      if (typeof x2 === "number") {
        return "Number";
      }
      if (typeof x2 === "boolean") {
        return "Boolean";
      }
      if (typeof x2 === "string") {
        return "String";
      }
    };
  }
});

// node_modules/es-abstract/2024/Type.js
var require_Type2 = __commonJS({
  "node_modules/es-abstract/2024/Type.js"(exports2, module2) {
    "use strict";
    var ES5Type = require_Type();
    module2.exports = function Type(x2) {
      if (typeof x2 === "symbol") {
        return "Symbol";
      }
      if (typeof x2 === "bigint") {
        return "BigInt";
      }
      return ES5Type(x2);
    };
  }
});

// node_modules/es-abstract/2024/ToBoolean.js
var require_ToBoolean = __commonJS({
  "node_modules/es-abstract/2024/ToBoolean.js"(exports2, module2) {
    "use strict";
    module2.exports = function ToBoolean(value) {
      return !!value;
    };
  }
});

// node_modules/es-abstract/2024/IsCallable.js
var require_IsCallable = __commonJS({
  "node_modules/es-abstract/2024/IsCallable.js"(exports2, module2) {
    "use strict";
    module2.exports = require_is_callable();
  }
});

// node_modules/es-abstract/2024/ToPropertyDescriptor.js
var require_ToPropertyDescriptor = __commonJS({
  "node_modules/es-abstract/2024/ToPropertyDescriptor.js"(exports2, module2) {
    "use strict";
    var hasOwn = require_hasown();
    var $TypeError = require_type();
    var Type = require_Type2();
    var ToBoolean = require_ToBoolean();
    var IsCallable = require_IsCallable();
    module2.exports = function ToPropertyDescriptor(Obj) {
      if (Type(Obj) !== "Object") {
        throw new $TypeError("ToPropertyDescriptor requires an object");
      }
      var desc = {};
      if (hasOwn(Obj, "enumerable")) {
        desc["[[Enumerable]]"] = ToBoolean(Obj.enumerable);
      }
      if (hasOwn(Obj, "configurable")) {
        desc["[[Configurable]]"] = ToBoolean(Obj.configurable);
      }
      if (hasOwn(Obj, "value")) {
        desc["[[Value]]"] = Obj.value;
      }
      if (hasOwn(Obj, "writable")) {
        desc["[[Writable]]"] = ToBoolean(Obj.writable);
      }
      if (hasOwn(Obj, "get")) {
        var getter = Obj.get;
        if (typeof getter !== "undefined" && !IsCallable(getter)) {
          throw new $TypeError("getter must be a function");
        }
        desc["[[Get]]"] = getter;
      }
      if (hasOwn(Obj, "set")) {
        var setter = Obj.set;
        if (typeof setter !== "undefined" && !IsCallable(setter)) {
          throw new $TypeError("setter must be a function");
        }
        desc["[[Set]]"] = setter;
      }
      if ((hasOwn(desc, "[[Get]]") || hasOwn(desc, "[[Set]]")) && (hasOwn(desc, "[[Value]]") || hasOwn(desc, "[[Writable]]"))) {
        throw new $TypeError("Invalid property descriptor. Cannot both specify accessors and a value or writable attribute");
      }
      return desc;
    };
  }
});

// node_modules/es-abstract/2024/SameValue.js
var require_SameValue = __commonJS({
  "node_modules/es-abstract/2024/SameValue.js"(exports2, module2) {
    "use strict";
    var $isNaN = require_isNaN();
    module2.exports = function SameValue(x2, y2) {
      if (x2 === y2) {
        if (x2 === 0) {
          return 1 / x2 === 1 / y2;
        }
        return true;
      }
      return $isNaN(x2) && $isNaN(y2);
    };
  }
});

// node_modules/es-abstract/helpers/IsArray.js
var require_IsArray = __commonJS({
  "node_modules/es-abstract/helpers/IsArray.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $Array = GetIntrinsic("%Array%");
    var toStr = !$Array.isArray && require_callBound()("Object.prototype.toString");
    module2.exports = $Array.isArray || function IsArray(argument) {
      return toStr(argument) === "[object Array]";
    };
  }
});

// node_modules/es-abstract/helpers/DefineOwnProperty.js
var require_DefineOwnProperty = __commonJS({
  "node_modules/es-abstract/helpers/DefineOwnProperty.js"(exports2, module2) {
    "use strict";
    var hasPropertyDescriptors = require_has_property_descriptors();
    var $defineProperty = require_es_define_property();
    var hasArrayLengthDefineBug = hasPropertyDescriptors.hasArrayLengthDefineBug();
    var isArray = hasArrayLengthDefineBug && require_IsArray();
    var callBound = require_callBound();
    var $isEnumerable = callBound("Object.prototype.propertyIsEnumerable");
    module2.exports = function DefineOwnProperty(IsDataDescriptor, SameValue, FromPropertyDescriptor, O2, P2, desc) {
      if (!$defineProperty) {
        if (!IsDataDescriptor(desc)) {
          return false;
        }
        if (!desc["[[Configurable]]"] || !desc["[[Writable]]"]) {
          return false;
        }
        if (P2 in O2 && $isEnumerable(O2, P2) !== !!desc["[[Enumerable]]"]) {
          return false;
        }
        var V2 = desc["[[Value]]"];
        O2[P2] = V2;
        return SameValue(O2[P2], V2);
      }
      if (hasArrayLengthDefineBug && P2 === "length" && "[[Value]]" in desc && isArray(O2) && O2.length !== desc["[[Value]]"]) {
        O2.length = desc["[[Value]]"];
        return O2.length === desc["[[Value]]"];
      }
      $defineProperty(O2, P2, FromPropertyDescriptor(desc));
      return true;
    };
  }
});

// node_modules/es-abstract/helpers/isFullyPopulatedPropertyDescriptor.js
var require_isFullyPopulatedPropertyDescriptor = __commonJS({
  "node_modules/es-abstract/helpers/isFullyPopulatedPropertyDescriptor.js"(exports2, module2) {
    "use strict";
    var isPropertyDescriptor = require_property_descriptor();
    module2.exports = function isFullyPopulatedPropertyDescriptor(ES, Desc) {
      return isPropertyDescriptor(Desc) && typeof Desc === "object" && "[[Enumerable]]" in Desc && "[[Configurable]]" in Desc && (ES.IsAccessorDescriptor(Desc) || ES.IsDataDescriptor(Desc));
    };
  }
});

// node_modules/es-abstract/helpers/fromPropertyDescriptor.js
var require_fromPropertyDescriptor = __commonJS({
  "node_modules/es-abstract/helpers/fromPropertyDescriptor.js"(exports2, module2) {
    "use strict";
    module2.exports = function fromPropertyDescriptor(Desc) {
      if (typeof Desc === "undefined") {
        return Desc;
      }
      var obj = {};
      if ("[[Value]]" in Desc) {
        obj.value = Desc["[[Value]]"];
      }
      if ("[[Writable]]" in Desc) {
        obj.writable = !!Desc["[[Writable]]"];
      }
      if ("[[Get]]" in Desc) {
        obj.get = Desc["[[Get]]"];
      }
      if ("[[Set]]" in Desc) {
        obj.set = Desc["[[Set]]"];
      }
      if ("[[Enumerable]]" in Desc) {
        obj.enumerable = !!Desc["[[Enumerable]]"];
      }
      if ("[[Configurable]]" in Desc) {
        obj.configurable = !!Desc["[[Configurable]]"];
      }
      return obj;
    };
  }
});

// node_modules/es-abstract/2024/FromPropertyDescriptor.js
var require_FromPropertyDescriptor = __commonJS({
  "node_modules/es-abstract/2024/FromPropertyDescriptor.js"(exports2, module2) {
    "use strict";
    var $TypeError = require_type();
    var isPropertyDescriptor = require_property_descriptor();
    var fromPropertyDescriptor = require_fromPropertyDescriptor();
    module2.exports = function FromPropertyDescriptor(Desc) {
      if (typeof Desc !== "undefined" && !isPropertyDescriptor(Desc)) {
        throw new $TypeError("Assertion failed: `Desc` must be a Property Descriptor");
      }
      return fromPropertyDescriptor(Desc);
    };
  }
});

// node_modules/es-abstract/2024/IsDataDescriptor.js
var require_IsDataDescriptor = __commonJS({
  "node_modules/es-abstract/2024/IsDataDescriptor.js"(exports2, module2) {
    "use strict";
    var $TypeError = require_type();
    var hasOwn = require_hasown();
    var isPropertyDescriptor = require_property_descriptor();
    module2.exports = function IsDataDescriptor(Desc) {
      if (typeof Desc === "undefined") {
        return false;
      }
      if (!isPropertyDescriptor(Desc)) {
        throw new $TypeError("Assertion failed: `Desc` must be a Property Descriptor");
      }
      if (!hasOwn(Desc, "[[Value]]") && !hasOwn(Desc, "[[Writable]]")) {
        return false;
      }
      return true;
    };
  }
});

// node_modules/es-abstract/2024/IsGenericDescriptor.js
var require_IsGenericDescriptor = __commonJS({
  "node_modules/es-abstract/2024/IsGenericDescriptor.js"(exports2, module2) {
    "use strict";
    var $TypeError = require_type();
    var IsAccessorDescriptor = require_IsAccessorDescriptor();
    var IsDataDescriptor = require_IsDataDescriptor();
    var isPropertyDescriptor = require_property_descriptor();
    module2.exports = function IsGenericDescriptor(Desc) {
      if (typeof Desc === "undefined") {
        return false;
      }
      if (!isPropertyDescriptor(Desc)) {
        throw new $TypeError("Assertion failed: `Desc` must be a Property Descriptor");
      }
      if (!IsAccessorDescriptor(Desc) && !IsDataDescriptor(Desc)) {
        return true;
      }
      return false;
    };
  }
});

// node_modules/es-abstract/2024/ValidateAndApplyPropertyDescriptor.js
var require_ValidateAndApplyPropertyDescriptor = __commonJS({
  "node_modules/es-abstract/2024/ValidateAndApplyPropertyDescriptor.js"(exports2, module2) {
    "use strict";
    var $TypeError = require_type();
    var DefineOwnProperty = require_DefineOwnProperty();
    var isFullyPopulatedPropertyDescriptor = require_isFullyPopulatedPropertyDescriptor();
    var isPropertyDescriptor = require_property_descriptor();
    var FromPropertyDescriptor = require_FromPropertyDescriptor();
    var IsAccessorDescriptor = require_IsAccessorDescriptor();
    var IsDataDescriptor = require_IsDataDescriptor();
    var IsGenericDescriptor = require_IsGenericDescriptor();
    var IsPropertyKey = require_IsPropertyKey();
    var SameValue = require_SameValue();
    var Type = require_Type2();
    module2.exports = function ValidateAndApplyPropertyDescriptor(O2, P2, extensible, Desc, current) {
      var oType = Type(O2);
      if (oType !== "Undefined" && oType !== "Object") {
        throw new $TypeError("Assertion failed: O must be undefined or an Object");
      }
      if (!IsPropertyKey(P2)) {
        throw new $TypeError("Assertion failed: P must be a Property Key");
      }
      if (typeof extensible !== "boolean") {
        throw new $TypeError("Assertion failed: extensible must be a Boolean");
      }
      if (!isPropertyDescriptor(Desc)) {
        throw new $TypeError("Assertion failed: Desc must be a Property Descriptor");
      }
      if (typeof current !== "undefined" && !isPropertyDescriptor(current)) {
        throw new $TypeError("Assertion failed: current must be a Property Descriptor, or undefined");
      }
      if (typeof current === "undefined") {
        if (!extensible) {
          return false;
        }
        if (oType === "Undefined") {
          return true;
        }
        if (IsAccessorDescriptor(Desc)) {
          return DefineOwnProperty(
            IsDataDescriptor,
            SameValue,
            FromPropertyDescriptor,
            O2,
            P2,
            Desc
          );
        }
        return DefineOwnProperty(
          IsDataDescriptor,
          SameValue,
          FromPropertyDescriptor,
          O2,
          P2,
          {
            "[[Configurable]]": !!Desc["[[Configurable]]"],
            "[[Enumerable]]": !!Desc["[[Enumerable]]"],
            "[[Value]]": Desc["[[Value]]"],
            "[[Writable]]": !!Desc["[[Writable]]"]
          }
        );
      }
      if (!isFullyPopulatedPropertyDescriptor(
        {
          IsAccessorDescriptor,
          IsDataDescriptor
        },
        current
      )) {
        throw new $TypeError("`current`, when present, must be a fully populated and valid Property Descriptor");
      }
      if (!current["[[Configurable]]"]) {
        if ("[[Configurable]]" in Desc && Desc["[[Configurable]]"]) {
          return false;
        }
        if ("[[Enumerable]]" in Desc && !SameValue(Desc["[[Enumerable]]"], current["[[Enumerable]]"])) {
          return false;
        }
        if (!IsGenericDescriptor(Desc) && !SameValue(IsAccessorDescriptor(Desc), IsAccessorDescriptor(current))) {
          return false;
        }
        if (IsAccessorDescriptor(current)) {
          if ("[[Get]]" in Desc && !SameValue(Desc["[[Get]]"], current["[[Get]]"])) {
            return false;
          }
          if ("[[Set]]" in Desc && !SameValue(Desc["[[Set]]"], current["[[Set]]"])) {
            return false;
          }
        } else if (!current["[[Writable]]"]) {
          if ("[[Writable]]" in Desc && Desc["[[Writable]]"]) {
            return false;
          }
          if ("[[Value]]" in Desc && !SameValue(Desc["[[Value]]"], current["[[Value]]"])) {
            return false;
          }
        }
      }
      if (oType !== "Undefined") {
        var configurable;
        var enumerable;
        if (IsDataDescriptor(current) && IsAccessorDescriptor(Desc)) {
          configurable = ("[[Configurable]]" in Desc ? Desc : current)["[[Configurable]]"];
          enumerable = ("[[Enumerable]]" in Desc ? Desc : current)["[[Enumerable]]"];
          return DefineOwnProperty(
            IsDataDescriptor,
            SameValue,
            FromPropertyDescriptor,
            O2,
            P2,
            {
              "[[Configurable]]": !!configurable,
              "[[Enumerable]]": !!enumerable,
              "[[Get]]": ("[[Get]]" in Desc ? Desc : current)["[[Get]]"],
              "[[Set]]": ("[[Set]]" in Desc ? Desc : current)["[[Set]]"]
            }
          );
        } else if (IsAccessorDescriptor(current) && IsDataDescriptor(Desc)) {
          configurable = ("[[Configurable]]" in Desc ? Desc : current)["[[Configurable]]"];
          enumerable = ("[[Enumerable]]" in Desc ? Desc : current)["[[Enumerable]]"];
          return DefineOwnProperty(
            IsDataDescriptor,
            SameValue,
            FromPropertyDescriptor,
            O2,
            P2,
            {
              "[[Configurable]]": !!configurable,
              "[[Enumerable]]": !!enumerable,
              "[[Value]]": ("[[Value]]" in Desc ? Desc : current)["[[Value]]"],
              "[[Writable]]": !!("[[Writable]]" in Desc ? Desc : current)["[[Writable]]"]
            }
          );
        }
        return DefineOwnProperty(
          IsDataDescriptor,
          SameValue,
          FromPropertyDescriptor,
          O2,
          P2,
          Desc
        );
      }
      return true;
    };
  }
});

// node_modules/es-abstract/2024/OrdinaryDefineOwnProperty.js
var require_OrdinaryDefineOwnProperty = __commonJS({
  "node_modules/es-abstract/2024/OrdinaryDefineOwnProperty.js"(exports2, module2) {
    "use strict";
    var $gOPD = require_gopd();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var isPropertyDescriptor = require_property_descriptor();
    var IsAccessorDescriptor = require_IsAccessorDescriptor();
    var IsExtensible = require_IsExtensible();
    var IsPropertyKey = require_IsPropertyKey();
    var ToPropertyDescriptor = require_ToPropertyDescriptor();
    var SameValue = require_SameValue();
    var Type = require_Type2();
    var ValidateAndApplyPropertyDescriptor = require_ValidateAndApplyPropertyDescriptor();
    module2.exports = function OrdinaryDefineOwnProperty(O2, P2, Desc) {
      if (Type(O2) !== "Object") {
        throw new $TypeError("Assertion failed: O must be an Object");
      }
      if (!IsPropertyKey(P2)) {
        throw new $TypeError("Assertion failed: P must be a Property Key");
      }
      if (!isPropertyDescriptor(Desc)) {
        throw new $TypeError("Assertion failed: Desc must be a Property Descriptor");
      }
      if (!$gOPD) {
        if (IsAccessorDescriptor(Desc)) {
          throw new $SyntaxError("This environment does not support accessor property descriptors.");
        }
        var creatingNormalDataProperty = !(P2 in O2) && Desc["[[Writable]]"] && Desc["[[Enumerable]]"] && Desc["[[Configurable]]"] && "[[Value]]" in Desc;
        var settingExistingDataProperty = P2 in O2 && (!("[[Configurable]]" in Desc) || Desc["[[Configurable]]"]) && (!("[[Enumerable]]" in Desc) || Desc["[[Enumerable]]"]) && (!("[[Writable]]" in Desc) || Desc["[[Writable]]"]) && "[[Value]]" in Desc;
        if (creatingNormalDataProperty || settingExistingDataProperty) {
          O2[P2] = Desc["[[Value]]"];
          return SameValue(O2[P2], Desc["[[Value]]"]);
        }
        throw new $SyntaxError("This environment does not support defining non-writable, non-enumerable, or non-configurable properties");
      }
      var desc = $gOPD(O2, P2);
      var current = desc && ToPropertyDescriptor(desc);
      var extensible = IsExtensible(O2);
      return ValidateAndApplyPropertyDescriptor(O2, P2, extensible, Desc, current);
    };
  }
});

// node_modules/es-abstract/2024/CreateDataProperty.js
var require_CreateDataProperty = __commonJS({
  "node_modules/es-abstract/2024/CreateDataProperty.js"(exports2, module2) {
    "use strict";
    var $TypeError = require_type();
    var IsPropertyKey = require_IsPropertyKey();
    var OrdinaryDefineOwnProperty = require_OrdinaryDefineOwnProperty();
    var Type = require_Type2();
    module2.exports = function CreateDataProperty(O2, P2, V2) {
      if (Type(O2) !== "Object") {
        throw new $TypeError("Assertion failed: Type(O) is not Object");
      }
      if (!IsPropertyKey(P2)) {
        throw new $TypeError("Assertion failed: IsPropertyKey(P) is not true");
      }
      var newDesc = {
        "[[Configurable]]": true,
        "[[Enumerable]]": true,
        "[[Value]]": V2,
        "[[Writable]]": true
      };
      return OrdinaryDefineOwnProperty(O2, P2, newDesc);
    };
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/isarray/index.js"(exports2, module2) {
    var toString = {}.toString;
    module2.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// node_modules/safe-array-concat/index.js
var require_safe_array_concat = __commonJS({
  "node_modules/safe-array-concat/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $concat = GetIntrinsic("%Array.prototype.concat%");
    var callBind = require_call_bind();
    var callBound = require_callBound();
    var $slice = callBound("Array.prototype.slice");
    var hasSymbols = require_shams()();
    var isConcatSpreadable = hasSymbols && Symbol.isConcatSpreadable;
    var empty = [];
    var $concatApply = isConcatSpreadable ? callBind.apply($concat, empty) : null;
    var isArray = isConcatSpreadable ? (
      /** @type {(value: unknown) => value is unknown[]} */
      require_isarray()
    ) : null;
    module2.exports = isConcatSpreadable ? function safeArrayConcat(item) {
      for (var i = 0; i < arguments.length; i += 1) {
        var arg = arguments[i];
        if (arg && typeof arg === "object" && typeof arg[isConcatSpreadable] === "boolean") {
          if (!empty[isConcatSpreadable]) {
            empty[isConcatSpreadable] = true;
          }
          var arr = isArray(arg) ? $slice(arg) : [arg];
          arr[isConcatSpreadable] = true;
          arguments[i] = arr;
        }
      }
      return $concatApply(arguments);
    } : callBind($concat, empty);
  }
});

// node_modules/es-abstract/2024/RequireObjectCoercible.js
var require_RequireObjectCoercible2 = __commonJS({
  "node_modules/es-abstract/2024/RequireObjectCoercible.js"(exports2, module2) {
    "use strict";
    module2.exports = require_RequireObjectCoercible();
  }
});

// node_modules/es-abstract/2024/IsArray.js
var require_IsArray2 = __commonJS({
  "node_modules/es-abstract/2024/IsArray.js"(exports2, module2) {
    "use strict";
    module2.exports = require_IsArray();
  }
});

// node_modules/es-abstract/2024/Call.js
var require_Call = __commonJS({
  "node_modules/es-abstract/2024/Call.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var $TypeError = require_type();
    var IsArray = require_IsArray2();
    var $apply = GetIntrinsic("%Reflect.apply%", true) || callBound("Function.prototype.apply");
    module2.exports = function Call(F, V2) {
      var argumentsList = arguments.length > 2 ? arguments[2] : [];
      if (!IsArray(argumentsList)) {
        throw new $TypeError("Assertion failed: optional `argumentsList`, if provided, must be a List");
      }
      return $apply(F, V2, argumentsList);
    };
  }
});

// (disabled):node_modules/object-inspect/util.inspect
var require_util2 = __commonJS({
  "(disabled):node_modules/object-inspect/util.inspect"() {
  }
});

// node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "node_modules/object-inspect/index.js"(exports2, module2) {
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O2) {
      return O2.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    var utilInspect = require_util2();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
    module2.exports = function inspect_(obj, options2, depth, seen) {
      var opts = options2 || {};
      if (has(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray(obj) ? "[Array]" : "[Object]";
      }
      var indent2 = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf2(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect(value, from, noIndent) {
        if (from) {
          seen = $arrSlice.call(seen);
          seen.push(from);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      if (typeof obj === "function" && !isRegExp(obj)) {
        var name = nameOf(obj);
        var keys = arrObjKeys(obj, inspect);
        return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
      }
      if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement2(obj)) {
        var s = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
          s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
        }
        s += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s += "...";
        }
        s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s;
      }
      if (isArray(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect);
        if (indent2 && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent2) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
          mapForEach.call(obj, function(value, key2) {
            mapParts.push(inspect(key2, obj, true) + " => " + inspect(value, obj));
          });
        }
        return collectionOf("Map", mapSize.call(obj), mapParts, indent2);
      }
      if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
          setForEach.call(obj, function(value) {
            setParts.push(inspect(value, obj));
          });
        }
        return collectionOf("Set", setSize.call(obj), setParts, indent2);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
      }
      if (isBoolean(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
      }
      if (typeof window !== "undefined" && obj === window) {
        return "{ [object Window] }";
      }
      if (typeof globalThis !== "undefined" && obj === globalThis || typeof global !== "undefined" && obj === global) {
        return "{ [object globalThis] }";
      }
      if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent2) {
          return tag + "{" + indentedJoin(ys, indent2) + "}";
        }
        return tag + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s, defaultStyle, opts) {
      var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
      return quoteChar + s + quoteChar;
    }
    function quote(s) {
      return $replace.call(String(s), /"/g, "&quot;");
    }
    function isArray(obj) {
      return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isDate(obj) {
      return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isRegExp(obj) {
      return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isError(obj) {
      return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isString(obj) {
      return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isNumber(obj) {
      return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isBoolean(obj) {
      return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isSymbol(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    var hasOwn = Object.prototype.hasOwnProperty || function(key2) {
      return key2 in this;
    };
    function has(obj, key2) {
      return hasOwn.call(obj, key2);
    }
    function toStr(obj) {
      return objectToString.call(obj);
    }
    function nameOf(f) {
      if (f.name) {
        return f.name;
      }
      var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
      if (m) {
        return m[1];
      }
      return null;
    }
    function indexOf2(xs, x2) {
      if (xs.indexOf) {
        return xs.indexOf(x2);
      }
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x2) {
          return i;
        }
      }
      return -1;
    }
    function isMap(x2) {
      if (!mapSize || !x2 || typeof x2 !== "object") {
        return false;
      }
      try {
        mapSize.call(x2);
        try {
          setSize.call(x2);
        } catch (s) {
          return true;
        }
        return x2 instanceof Map;
      } catch (e) {
      }
      return false;
    }
    function isWeakMap(x2) {
      if (!weakMapHas || !x2 || typeof x2 !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x2, weakMapHas);
        try {
          weakSetHas.call(x2, weakSetHas);
        } catch (s) {
          return true;
        }
        return x2 instanceof WeakMap;
      } catch (e) {
      }
      return false;
    }
    function isWeakRef(x2) {
      if (!weakRefDeref || !x2 || typeof x2 !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x2);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isSet(x2) {
      if (!setSize || !x2 || typeof x2 !== "object") {
        return false;
      }
      try {
        setSize.call(x2);
        try {
          mapSize.call(x2);
        } catch (m) {
          return true;
        }
        return x2 instanceof Set;
      } catch (e) {
      }
      return false;
    }
    function isWeakSet(x2) {
      if (!weakSetHas || !x2 || typeof x2 !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x2, weakSetHas);
        try {
          weakMapHas.call(x2, weakMapHas);
        } catch (s) {
          return true;
        }
        return x2 instanceof WeakSet;
      } catch (e) {
      }
      return false;
    }
    function isElement2(x2) {
      if (!x2 || typeof x2 !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x2 instanceof HTMLElement) {
        return true;
      }
      return typeof x2.nodeName === "string" && typeof x2.getAttribute === "function";
    }
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var s = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s, "single", opts);
    }
    function lowbyte(c2) {
      var n = c2.charCodeAt(0);
      var x2 = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n];
      if (x2) {
        return "\\" + x2;
      }
      return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
    }
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    function weakCollectionOf(type) {
      return type + " { ? }";
    }
    function collectionOf(type, size, entries, indent2) {
      var joinedEntries = indent2 ? indentedJoin(entries, indent2) : $join.call(entries, ", ");
      return type + " (" + size + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i = 0; i < xs.length; i++) {
        if (indexOf2(xs[i], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    function indentedJoin(xs, indent2) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent2.prev + indent2.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent2.prev;
    }
    function arrObjKeys(obj, inspect) {
      var isArr = isArray(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
          xs[i] = has(obj, i) ? inspect(obj[i], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
          symMap["$" + syms[k]] = syms[k];
        }
      }
      for (var key2 in obj) {
        if (!has(obj, key2)) {
          continue;
        }
        if (isArr && String(Number(key2)) === key2 && key2 < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key2] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key2)) {
          xs.push(inspect(key2, obj) + ": " + inspect(obj[key2], obj));
        } else {
          xs.push(key2 + ": " + inspect(obj[key2], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j2 = 0; j2 < syms.length; j2++) {
          if (isEnumerable.call(obj, syms[j2])) {
            xs.push("[" + inspect(syms[j2]) + "]: " + inspect(obj[syms[j2]], obj));
          }
        }
      }
      return xs;
    }
  }
});

// node_modules/es-abstract/2024/Get.js
var require_Get = __commonJS({
  "node_modules/es-abstract/2024/Get.js"(exports2, module2) {
    "use strict";
    var $TypeError = require_type();
    var inspect = require_object_inspect();
    var IsPropertyKey = require_IsPropertyKey();
    var Type = require_Type2();
    module2.exports = function Get(O2, P2) {
      if (Type(O2) !== "Object") {
        throw new $TypeError("Assertion failed: Type(O) is not Object");
      }
      if (!IsPropertyKey(P2)) {
        throw new $TypeError("Assertion failed: IsPropertyKey(P) is not true, got " + inspect(P2));
      }
      return O2[P2];
    };
  }
});

// node_modules/es-abstract/2024/HasProperty.js
var require_HasProperty = __commonJS({
  "node_modules/es-abstract/2024/HasProperty.js"(exports2, module2) {
    "use strict";
    var $TypeError = require_type();
    var IsPropertyKey = require_IsPropertyKey();
    var Type = require_Type2();
    module2.exports = function HasProperty(O2, P2) {
      if (Type(O2) !== "Object") {
        throw new $TypeError("Assertion failed: `O` must be an Object");
      }
      if (!IsPropertyKey(P2)) {
        throw new $TypeError("Assertion failed: `P` must be a Property Key");
      }
      return P2 in O2;
    };
  }
});

// node_modules/es-abstract/2024/LengthOfArrayLike.js
var require_LengthOfArrayLike = __commonJS({
  "node_modules/es-abstract/2024/LengthOfArrayLike.js"(exports2, module2) {
    "use strict";
    var $TypeError = require_type();
    var Get = require_Get();
    var ToLength = require_ToLength();
    var Type = require_Type2();
    module2.exports = function LengthOfArrayLike(obj) {
      if (Type(obj) !== "Object") {
        throw new $TypeError("Assertion failed: `obj` must be an Object");
      }
      return ToLength(Get(obj, "length"));
    };
  }
});

// node_modules/array.prototype.reduce/implementation.js
var require_implementation5 = __commonJS({
  "node_modules/array.prototype.reduce/implementation.js"(exports2, module2) {
    "use strict";
    var Call = require_Call();
    var Get = require_Get();
    var HasProperty = require_HasProperty();
    var IsCallable = require_IsCallable();
    var LengthOfArrayLike = require_LengthOfArrayLike();
    var ToObject = require_ToObject();
    var ToString = require_ToString();
    var callBound = require_callBound();
    var isString = require_is_string();
    var $Object = require_es_object_atoms();
    var $TypeError = require_type();
    var boxedString = $Object("a");
    var splitString = boxedString[0] !== "a" || !(0 in boxedString);
    var strSplit = callBound("%String.prototype.split%");
    module2.exports = function reduce(callbackfn) {
      var O2 = ToObject(this);
      var self2 = splitString && isString(O2) ? strSplit(O2, "") : O2;
      var len = LengthOfArrayLike(self2);
      if (!IsCallable(callbackfn)) {
        throw new $TypeError("Array.prototype.reduce callback must be a function");
      }
      if (len === 0 && arguments.length < 2) {
        throw new $TypeError("reduce of empty array with no initial value");
      }
      var k = 0;
      var accumulator;
      var Pk, kPresent;
      if (arguments.length > 1) {
        accumulator = arguments[1];
      } else {
        kPresent = false;
        while (!kPresent && k < len) {
          Pk = ToString(k);
          kPresent = HasProperty(O2, Pk);
          if (kPresent) {
            accumulator = Get(O2, Pk);
          }
          k += 1;
        }
        if (!kPresent) {
          throw new $TypeError("reduce of empty array with no initial value");
        }
      }
      while (k < len) {
        Pk = ToString(k);
        kPresent = HasProperty(O2, Pk);
        if (kPresent) {
          var kValue = Get(O2, Pk);
          accumulator = Call(callbackfn, void 0, [accumulator, kValue, k, O2]);
        }
        k += 1;
      }
      return accumulator;
    };
  }
});

// node_modules/es-array-method-boxes-properly/index.js
var require_es_array_method_boxes_properly = __commonJS({
  "node_modules/es-array-method-boxes-properly/index.js"(exports2, module2) {
    module2.exports = function properlyBoxed(method) {
      var properlyBoxesNonStrict = true;
      var properlyBoxesStrict = true;
      var threwException = false;
      if (typeof method === "function") {
        try {
          method.call("f", function(_2, __, O2) {
            if (typeof O2 !== "object") {
              properlyBoxesNonStrict = false;
            }
          });
          method.call(
            [null],
            function() {
              "use strict";
              properlyBoxesStrict = typeof this === "string";
            },
            "x"
          );
        } catch (e) {
          threwException = true;
        }
        return !threwException && properlyBoxesNonStrict && properlyBoxesStrict;
      }
      return false;
    };
  }
});

// node_modules/array.prototype.reduce/polyfill.js
var require_polyfill3 = __commonJS({
  "node_modules/array.prototype.reduce/polyfill.js"(exports2, module2) {
    "use strict";
    var arrayMethodBoxesProperly = require_es_array_method_boxes_properly();
    var implementation = require_implementation5();
    module2.exports = function getPolyfill() {
      var method = Array.prototype.reduce;
      return arrayMethodBoxesProperly(method) ? method : implementation;
    };
  }
});

// node_modules/array.prototype.reduce/shim.js
var require_shim3 = __commonJS({
  "node_modules/array.prototype.reduce/shim.js"(exports2, module2) {
    "use strict";
    var define2 = require_define_properties();
    var getPolyfill = require_polyfill3();
    module2.exports = function shimArrayPrototypeReduce() {
      var polyfill = getPolyfill();
      define2(
        Array.prototype,
        { reduce: polyfill },
        { reduce: function() {
          return Array.prototype.reduce !== polyfill;
        } }
      );
      return polyfill;
    };
  }
});

// node_modules/array.prototype.reduce/index.js
var require_array_prototype = __commonJS({
  "node_modules/array.prototype.reduce/index.js"(exports2, module2) {
    "use strict";
    var define2 = require_define_properties();
    var RequireObjectCoercible = require_RequireObjectCoercible2();
    var callBind = require_call_bind();
    var callBound = require_callBound();
    var implementation = require_implementation5();
    var getPolyfill = require_polyfill3();
    var polyfill = callBind.apply(getPolyfill());
    var shim = require_shim3();
    var $slice = callBound("%Array.prototype.slice%");
    var boundShim = function reduce(array, callbackfn) {
      RequireObjectCoercible(array);
      return polyfill(array, $slice(arguments, 1));
    };
    define2(boundShim, {
      getPolyfill,
      implementation,
      shim
    });
    module2.exports = boundShim;
  }
});

// node_modules/object.getownpropertydescriptors/implementation.js
var require_implementation6 = __commonJS({
  "node_modules/object.getownpropertydescriptors/implementation.js"(exports2, module2) {
    "use strict";
    var CreateDataProperty = require_CreateDataProperty();
    var RequireObjectCoercible = require_RequireObjectCoercible();
    var ToObject = require_ToObject();
    var safeConcat = require_safe_array_concat();
    var reduce = require_array_prototype();
    var gOPD = require_gopd();
    var $Object = require_es_object_atoms();
    var $getOwnNames = $Object.getOwnPropertyNames;
    var $getSymbols = $Object.getOwnPropertySymbols;
    var getAll = $getSymbols ? function(obj) {
      return safeConcat($getOwnNames(obj), $getSymbols(obj));
    } : $getOwnNames;
    var isES5 = gOPD && typeof $getOwnNames === "function";
    module2.exports = function getOwnPropertyDescriptors(value) {
      RequireObjectCoercible(value);
      if (!isES5) {
        throw new TypeError("getOwnPropertyDescriptors requires Object.getOwnPropertyDescriptor");
      }
      var O2 = ToObject(value);
      return reduce(
        getAll(O2),
        function(acc, key2) {
          var descriptor = gOPD(O2, key2);
          if (typeof descriptor !== "undefined") {
            CreateDataProperty(acc, key2, descriptor);
          }
          return acc;
        },
        {}
      );
    };
  }
});

// node_modules/object.getownpropertydescriptors/polyfill.js
var require_polyfill4 = __commonJS({
  "node_modules/object.getownpropertydescriptors/polyfill.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation6();
    module2.exports = function getPolyfill() {
      return typeof Object.getOwnPropertyDescriptors === "function" ? Object.getOwnPropertyDescriptors : implementation;
    };
  }
});

// node_modules/object.getownpropertydescriptors/shim.js
var require_shim4 = __commonJS({
  "node_modules/object.getownpropertydescriptors/shim.js"(exports2, module2) {
    "use strict";
    var getPolyfill = require_polyfill4();
    var define2 = require_define_properties();
    module2.exports = function shimGetOwnPropertyDescriptors() {
      var polyfill = getPolyfill();
      define2(
        Object,
        { getOwnPropertyDescriptors: polyfill },
        { getOwnPropertyDescriptors: function() {
          return Object.getOwnPropertyDescriptors !== polyfill;
        } }
      );
      return polyfill;
    };
  }
});

// node_modules/object.getownpropertydescriptors/index.js
var require_object = __commonJS({
  "node_modules/object.getownpropertydescriptors/index.js"(exports2, module2) {
    "use strict";
    var define2 = require_define_properties();
    var callBind = require_call_bind();
    var implementation = require_implementation6();
    var getPolyfill = require_polyfill4();
    var shim = require_shim4();
    var bound = callBind(getPolyfill(), Object);
    define2(bound, {
      getPolyfill,
      implementation,
      shim
    });
    module2.exports = bound;
  }
});

// node_modules/object.entries/implementation.js
var require_implementation7 = __commonJS({
  "node_modules/object.entries/implementation.js"(exports2, module2) {
    "use strict";
    var RequireObjectCoercible = require_RequireObjectCoercible();
    var callBound = require_callBound();
    var $isEnumerable = callBound("Object.prototype.propertyIsEnumerable");
    var $push = callBound("Array.prototype.push");
    module2.exports = function entries(O2) {
      var obj = RequireObjectCoercible(O2);
      var entrys = [];
      for (var key2 in obj) {
        if ($isEnumerable(obj, key2)) {
          $push(entrys, [key2, obj[key2]]);
        }
      }
      return entrys;
    };
  }
});

// node_modules/object.entries/polyfill.js
var require_polyfill5 = __commonJS({
  "node_modules/object.entries/polyfill.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation7();
    module2.exports = function getPolyfill() {
      return typeof Object.entries === "function" ? Object.entries : implementation;
    };
  }
});

// node_modules/object.entries/shim.js
var require_shim5 = __commonJS({
  "node_modules/object.entries/shim.js"(exports2, module2) {
    "use strict";
    var getPolyfill = require_polyfill5();
    var define2 = require_define_properties();
    module2.exports = function shimEntries() {
      var polyfill = getPolyfill();
      define2(Object, { entries: polyfill }, {
        entries: function testEntries() {
          return Object.entries !== polyfill;
        }
      });
      return polyfill;
    };
  }
});

// node_modules/object.entries/index.js
var require_object2 = __commonJS({
  "node_modules/object.entries/index.js"(exports2, module2) {
    "use strict";
    var define2 = require_define_properties();
    var callBind = require_call_bind();
    var implementation = require_implementation7();
    var getPolyfill = require_polyfill5();
    var shim = require_shim5();
    var polyfill = callBind(getPolyfill(), Object);
    define2(polyfill, {
      getPolyfill,
      implementation,
      shim
    });
    module2.exports = polyfill;
  }
});

// node_modules/object.values/implementation.js
var require_implementation8 = __commonJS({
  "node_modules/object.values/implementation.js"(exports2, module2) {
    "use strict";
    var RequireObjectCoercible = require_RequireObjectCoercible();
    var callBound = require_callBound();
    var $isEnumerable = callBound("Object.prototype.propertyIsEnumerable");
    var $push = callBound("Array.prototype.push");
    module2.exports = function values(O2) {
      var obj = RequireObjectCoercible(O2);
      var vals = [];
      for (var key2 in obj) {
        if ($isEnumerable(obj, key2)) {
          $push(vals, obj[key2]);
        }
      }
      return vals;
    };
  }
});

// node_modules/object.values/polyfill.js
var require_polyfill6 = __commonJS({
  "node_modules/object.values/polyfill.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation8();
    module2.exports = function getPolyfill() {
      return typeof Object.values === "function" ? Object.values : implementation;
    };
  }
});

// node_modules/object.values/shim.js
var require_shim6 = __commonJS({
  "node_modules/object.values/shim.js"(exports2, module2) {
    "use strict";
    var getPolyfill = require_polyfill6();
    var define2 = require_define_properties();
    module2.exports = function shimValues() {
      var polyfill = getPolyfill();
      define2(Object, { values: polyfill }, {
        values: function testValues() {
          return Object.values !== polyfill;
        }
      });
      return polyfill;
    };
  }
});

// node_modules/object.values/index.js
var require_object3 = __commonJS({
  "node_modules/object.values/index.js"(exports2, module2) {
    "use strict";
    var define2 = require_define_properties();
    var callBind = require_call_bind();
    var implementation = require_implementation8();
    var getPolyfill = require_polyfill6();
    var shim = require_shim6();
    var polyfill = callBind(getPolyfill(), Object);
    define2(polyfill, {
      getPolyfill,
      implementation,
      shim
    });
    module2.exports = polyfill;
  }
});

// node_modules/es7-shim/Object.js
var require_Object = __commonJS({
  "node_modules/es7-shim/Object.js"(exports2, module2) {
    "use strict";
    var getDescriptors = require_object();
    var entries = require_object2();
    var values = require_object3();
    module2.exports = {
      entries,
      getOwnPropertyDescriptors: getDescriptors,
      shim: function shimObject() {
        getDescriptors.shim();
        entries.shim();
        values.shim();
      },
      values
    };
  }
});

// node_modules/es-abstract/5/abs.js
var require_abs = __commonJS({
  "node_modules/es-abstract/5/abs.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $abs = GetIntrinsic("%Math.abs%");
    module2.exports = function abs(x2) {
      return $abs(x2);
    };
  }
});

// node_modules/es-abstract/5/floor.js
var require_floor2 = __commonJS({
  "node_modules/es-abstract/5/floor.js"(exports2, module2) {
    "use strict";
    var $floor = Math.floor;
    module2.exports = function floor(x2) {
      return $floor(x2);
    };
  }
});

// node_modules/es-to-primitive/es5.js
var require_es5 = __commonJS({
  "node_modules/es-to-primitive/es5.js"(exports2, module2) {
    "use strict";
    var toStr = Object.prototype.toString;
    var isPrimitive = require_isPrimitive2();
    var isCallable = require_is_callable();
    var ES5internalSlots = {
      "[[DefaultValue]]": function(O2) {
        var actualHint;
        if (arguments.length > 1) {
          actualHint = arguments[1];
        } else {
          actualHint = toStr.call(O2) === "[object Date]" ? String : Number;
        }
        if (actualHint === String || actualHint === Number) {
          var methods = actualHint === String ? ["toString", "valueOf"] : ["valueOf", "toString"];
          var value, i;
          for (i = 0; i < methods.length; ++i) {
            if (isCallable(O2[methods[i]])) {
              value = O2[methods[i]]();
              if (isPrimitive(value)) {
                return value;
              }
            }
          }
          throw new TypeError("No default value");
        }
        throw new TypeError("invalid [[DefaultValue]] hint supplied");
      }
    };
    module2.exports = function ToPrimitive(input) {
      if (isPrimitive(input)) {
        return input;
      }
      if (arguments.length > 1) {
        return ES5internalSlots["[[DefaultValue]]"](input, arguments[1]);
      }
      return ES5internalSlots["[[DefaultValue]]"](input);
    };
  }
});

// node_modules/es-abstract/5/ToPrimitive.js
var require_ToPrimitive2 = __commonJS({
  "node_modules/es-abstract/5/ToPrimitive.js"(exports2, module2) {
    "use strict";
    module2.exports = require_es5();
  }
});

// node_modules/es-abstract/5/ToNumber.js
var require_ToNumber2 = __commonJS({
  "node_modules/es-abstract/5/ToNumber.js"(exports2, module2) {
    "use strict";
    var ToPrimitive = require_ToPrimitive2();
    var callBound = require_callBound();
    var $replace = callBound("String.prototype.replace");
    var safeRegexTester = require_safe_regex_test();
    var isNonDecimal = safeRegexTester(/^0[ob]|^[+-]0x/);
    module2.exports = function ToNumber(value) {
      var prim = ToPrimitive(value, Number);
      if (typeof prim !== "string") {
        return +prim;
      }
      var trimmed = $replace(
        prim,
        // eslint-disable-next-line no-control-regex
        /^[ \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u0085]+|[ \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u0085]+$/g,
        ""
      );
      if (isNonDecimal(trimmed)) {
        return NaN;
      }
      return +trimmed;
    };
  }
});

// node_modules/es-abstract/helpers/sign.js
var require_sign = __commonJS({
  "node_modules/es-abstract/helpers/sign.js"(exports2, module2) {
    "use strict";
    module2.exports = function sign2(number) {
      return number >= 0 ? 1 : -1;
    };
  }
});

// node_modules/es-abstract/5/ToInteger.js
var require_ToInteger = __commonJS({
  "node_modules/es-abstract/5/ToInteger.js"(exports2, module2) {
    "use strict";
    var abs = require_abs();
    var floor = require_floor2();
    var ToNumber = require_ToNumber2();
    var $isNaN = require_isNaN();
    var $isFinite = require_isFinite();
    var $sign = require_sign();
    module2.exports = function ToInteger(value) {
      var number = ToNumber(value);
      if ($isNaN(number)) {
        return 0;
      }
      if (number === 0 || !$isFinite(number)) {
        return number;
      }
      return $sign(number) * floor(abs(number));
    };
  }
});

// node_modules/es-abstract/2019/ToPrimitive.js
var require_ToPrimitive3 = __commonJS({
  "node_modules/es-abstract/2019/ToPrimitive.js"(exports2, module2) {
    "use strict";
    var toPrimitive = require_es2015();
    module2.exports = function ToPrimitive(input) {
      if (arguments.length > 1) {
        return toPrimitive(input, arguments[1]);
      }
      return toPrimitive(input);
    };
  }
});

// node_modules/es-abstract/2019/ToNumber.js
var require_ToNumber3 = __commonJS({
  "node_modules/es-abstract/2019/ToNumber.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $TypeError = require_type();
    var $Number = GetIntrinsic("%Number%");
    var $RegExp = GetIntrinsic("%RegExp%");
    var $parseInteger = GetIntrinsic("%parseInt%");
    var callBound = require_callBound();
    var regexTester = require_safe_regex_test();
    var isPrimitive = require_isPrimitive();
    var $strSlice = callBound("String.prototype.slice");
    var isBinary = regexTester(/^0b[01]+$/i);
    var isOctal = regexTester(/^0o[0-7]+$/i);
    var isInvalidHexLiteral = regexTester(/^[-+]0x[0-9a-f]+$/i);
    var nonWS = ["", "​", "￾"].join("");
    var nonWSregex = new $RegExp("[" + nonWS + "]", "g");
    var hasNonWS = regexTester(nonWSregex);
    var $trim = require_string_prototype();
    var ToPrimitive = require_ToPrimitive3();
    module2.exports = function ToNumber(argument) {
      var value = isPrimitive(argument) ? argument : ToPrimitive(argument, $Number);
      if (typeof value === "symbol") {
        throw new $TypeError("Cannot convert a Symbol value to a number");
      }
      if (typeof value === "string") {
        if (isBinary(value)) {
          return ToNumber($parseInteger($strSlice(value, 2), 2));
        } else if (isOctal(value)) {
          return ToNumber($parseInteger($strSlice(value, 2), 8));
        } else if (hasNonWS(value) || isInvalidHexLiteral(value)) {
          return NaN;
        }
        var trimmed = $trim(value);
        if (trimmed !== value) {
          return ToNumber(trimmed);
        }
      }
      return $Number(value);
    };
  }
});

// node_modules/es-abstract/2019/ToInteger.js
var require_ToInteger2 = __commonJS({
  "node_modules/es-abstract/2019/ToInteger.js"(exports2, module2) {
    "use strict";
    var ES5ToInteger = require_ToInteger();
    var ToNumber = require_ToNumber3();
    module2.exports = function ToInteger(value) {
      var number = ToNumber(value);
      return ES5ToInteger(number);
    };
  }
});

// node_modules/es-abstract/2019/ToObject.js
var require_ToObject2 = __commonJS({
  "node_modules/es-abstract/2019/ToObject.js"(exports2, module2) {
    "use strict";
    module2.exports = require_ToObject();
  }
});

// node_modules/es-abstract/2019/ToString.js
var require_ToString2 = __commonJS({
  "node_modules/es-abstract/2019/ToString.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $String = GetIntrinsic("%String%");
    var $TypeError = require_type();
    module2.exports = function ToString(argument) {
      if (typeof argument === "symbol") {
        throw new $TypeError("Cannot convert a Symbol value to a string");
      }
      return $String(argument);
    };
  }
});

// node_modules/es-abstract/helpers/callBind.js
var require_callBind = __commonJS({
  "node_modules/es-abstract/helpers/callBind.js"(exports2, module2) {
    "use strict";
    module2.exports = require_call_bind();
  }
});

// node_modules/string-at/index.js
var require_string_at = __commonJS({
  "node_modules/string-at/index.js"(exports2, module2) {
    "use strict";
    var define2 = require_define_properties();
    var ToInteger = require_ToInteger2();
    var ToObject = require_ToObject2();
    var ToString = require_ToString2();
    var callBind = require_callBind();
    var atShim = function at2(pos2) {
      var O2 = ToObject(this);
      var S2 = ToString(O2);
      var position = ToInteger(pos2);
      var size = S2.length;
      if (position < 0 || position >= size) {
        return "";
      }
      var cuFirst = S2.charCodeAt(position);
      var cuSecond;
      var nextIndex = position + 1;
      var len = 1;
      var isHighSurrogate = cuFirst >= 55296 && cuFirst <= 56319;
      if (isHighSurrogate && size > nextIndex) {
        cuSecond = S2.charCodeAt(nextIndex);
        if (cuSecond >= 56320 && cuSecond <= 57343) {
          len = 2;
        }
      }
      return S2.slice(position, position + len);
    };
    var boundAt = callBind(atShim);
    define2(boundAt, {
      method: atShim,
      shim: function shimStringPrototypeAt() {
        define2(String.prototype, { at: atShim });
        return String.prototype.at;
      }
    });
    module2.exports = boundAt;
  }
});

// node_modules/es7-shim/String.prototype.at.js
var require_String_prototype_at = __commonJS({
  "node_modules/es7-shim/String.prototype.at.js"(exports2, module2) {
    "use strict";
    module2.exports = require_string_at();
  }
});

// node_modules/string.prototype.padstart/implementation.js
var require_implementation9 = __commonJS({
  "node_modules/string.prototype.padstart/implementation.js"(exports2, module2) {
    "use strict";
    var ToLength = require_ToLength();
    var ToString = require_ToString();
    var RequireObjectCoercible = require_RequireObjectCoercible();
    var callBound = require_callBound();
    var $slice = callBound("String.prototype.slice");
    module2.exports = function padStart(maxLength) {
      var O2 = RequireObjectCoercible(this);
      var S2 = ToString(O2);
      var stringLength = ToLength(S2.length);
      var fillString;
      if (arguments.length > 1) {
        fillString = arguments[1];
      }
      var filler = typeof fillString === "undefined" ? "" : ToString(fillString);
      if (filler === "") {
        filler = " ";
      }
      var intMaxLength = ToLength(maxLength);
      if (intMaxLength <= stringLength) {
        return S2;
      }
      var fillLen = intMaxLength - stringLength;
      while (filler.length < fillLen) {
        var fLen = filler.length;
        var remainingCodeUnits = fillLen - fLen;
        filler += fLen > remainingCodeUnits ? $slice(filler, 0, remainingCodeUnits) : filler;
      }
      var truncatedStringFiller = filler.length > fillLen ? $slice(filler, 0, fillLen) : filler;
      return truncatedStringFiller + S2;
    };
  }
});

// node_modules/string.prototype.padstart/polyfill.js
var require_polyfill7 = __commonJS({
  "node_modules/string.prototype.padstart/polyfill.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation9();
    module2.exports = function getPolyfill() {
      return typeof String.prototype.padStart === "function" ? String.prototype.padStart : implementation;
    };
  }
});

// node_modules/string.prototype.padstart/shim.js
var require_shim7 = __commonJS({
  "node_modules/string.prototype.padstart/shim.js"(exports2, module2) {
    "use strict";
    var getPolyfill = require_polyfill7();
    var define2 = require_define_properties();
    module2.exports = function shimPadStart() {
      var polyfill = getPolyfill();
      define2(String.prototype, { padStart: polyfill }, {
        padStart: function testPadStart() {
          return String.prototype.padStart !== polyfill;
        }
      });
      return polyfill;
    };
  }
});

// node_modules/string.prototype.padstart/index.js
var require_string_prototype2 = __commonJS({
  "node_modules/string.prototype.padstart/index.js"(exports2, module2) {
    "use strict";
    var define2 = require_define_properties();
    var RequireObjectCoercible = require_RequireObjectCoercible();
    var callBind = require_call_bind();
    var implementation = require_implementation9();
    var getPolyfill = require_polyfill7();
    var shim = require_shim7();
    var bound = callBind.apply(getPolyfill());
    var boundPadStart = function padStart(str, maxLength) {
      RequireObjectCoercible(str);
      var args = arguments.length > 2 ? [maxLength, arguments[2]] : [maxLength];
      return bound(str, args);
    };
    define2(boundPadStart, {
      getPolyfill,
      implementation,
      shim
    });
    module2.exports = boundPadStart;
  }
});

// node_modules/es7-shim/String.prototype.padStart.js
var require_String_prototype_padStart = __commonJS({
  "node_modules/es7-shim/String.prototype.padStart.js"(exports2, module2) {
    "use strict";
    module2.exports = require_string_prototype2();
  }
});

// node_modules/string.prototype.padend/implementation.js
var require_implementation10 = __commonJS({
  "node_modules/string.prototype.padend/implementation.js"(exports2, module2) {
    "use strict";
    var ToLength = require_ToLength();
    var ToString = require_ToString();
    var RequireObjectCoercible = require_RequireObjectCoercible();
    var callBound = require_callBound();
    var $slice = callBound("String.prototype.slice");
    module2.exports = function padEnd(maxLength) {
      var O2 = RequireObjectCoercible(this);
      var S2 = ToString(O2);
      var stringLength = ToLength(S2.length);
      var fillString;
      if (arguments.length > 1) {
        fillString = arguments[1];
      }
      var filler = typeof fillString === "undefined" ? "" : ToString(fillString);
      if (filler === "") {
        filler = " ";
      }
      var intMaxLength = ToLength(maxLength);
      if (intMaxLength <= stringLength) {
        return S2;
      }
      var fillLen = intMaxLength - stringLength;
      while (filler.length < fillLen) {
        var fLen = filler.length;
        var remainingCodeUnits = fillLen - fLen;
        filler += fLen > remainingCodeUnits ? $slice(filler, 0, remainingCodeUnits) : filler;
      }
      var truncatedStringFiller = filler.length > fillLen ? $slice(filler, 0, fillLen) : filler;
      return S2 + truncatedStringFiller;
    };
  }
});

// node_modules/string.prototype.padend/polyfill.js
var require_polyfill8 = __commonJS({
  "node_modules/string.prototype.padend/polyfill.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation10();
    module2.exports = function getPolyfill() {
      return typeof String.prototype.padEnd === "function" ? String.prototype.padEnd : implementation;
    };
  }
});

// node_modules/string.prototype.padend/shim.js
var require_shim8 = __commonJS({
  "node_modules/string.prototype.padend/shim.js"(exports2, module2) {
    "use strict";
    var getPolyfill = require_polyfill8();
    var define2 = require_define_properties();
    module2.exports = function shimPadEnd() {
      var polyfill = getPolyfill();
      define2(String.prototype, { padEnd: polyfill }, {
        padEnd: function testPadEnd() {
          return String.prototype.padEnd !== polyfill;
        }
      });
      return polyfill;
    };
  }
});

// node_modules/string.prototype.padend/index.js
var require_string_prototype3 = __commonJS({
  "node_modules/string.prototype.padend/index.js"(exports2, module2) {
    "use strict";
    var define2 = require_define_properties();
    var RequireObjectCoercible = require_RequireObjectCoercible();
    var callBind = require_call_bind();
    var implementation = require_implementation10();
    var getPolyfill = require_polyfill8();
    var shim = require_shim8();
    var bound = callBind.apply(getPolyfill());
    var boundPadEnd = function padEnd(str, maxLength) {
      RequireObjectCoercible(str);
      var args = arguments.length > 2 ? [maxLength, arguments[2]] : [maxLength];
      return bound(str, args);
    };
    define2(boundPadEnd, {
      getPolyfill,
      implementation,
      shim
    });
    module2.exports = boundPadEnd;
  }
});

// node_modules/es7-shim/String.prototype.padEnd.js
var require_String_prototype_padEnd = __commonJS({
  "node_modules/es7-shim/String.prototype.padEnd.js"(exports2, module2) {
    "use strict";
    module2.exports = require_string_prototype3();
  }
});

// node_modules/string.prototype.trimstart/implementation.js
var require_implementation11 = __commonJS({
  "node_modules/string.prototype.trimstart/implementation.js"(exports2, module2) {
    "use strict";
    var callBound = require_callBound();
    var $replace = callBound("String.prototype.replace");
    var mvsIsWS = /^\s$/.test("᠎");
    var startWhitespace = mvsIsWS ? /^[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+/ : /^[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+/;
    module2.exports = function trimStart() {
      return $replace(this, startWhitespace, "");
    };
  }
});

// node_modules/string.prototype.trimleft/implementation.js
var require_implementation12 = __commonJS({
  "node_modules/string.prototype.trimleft/implementation.js"(exports2, module2) {
    "use strict";
    module2.exports = require_implementation11();
  }
});

// node_modules/string.prototype.trimleft/polyfill.js
var require_polyfill9 = __commonJS({
  "node_modules/string.prototype.trimleft/polyfill.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation12();
    module2.exports = function getPolyfill() {
      if (!String.prototype.trimLeft) {
        return implementation;
      }
      var zeroWidthSpace = "​";
      if (zeroWidthSpace.trimLeft() !== zeroWidthSpace) {
        return implementation;
      }
      return String.prototype.trimLeft;
    };
  }
});

// node_modules/string.prototype.trimleft/shim.js
var require_shim9 = __commonJS({
  "node_modules/string.prototype.trimleft/shim.js"(exports2, module2) {
    "use strict";
    var define2 = require_define_properties();
    var getPolyfill = require_polyfill9();
    module2.exports = function shimTrimLeft() {
      var polyfill = getPolyfill();
      define2(
        String.prototype,
        { trimLeft: polyfill },
        { trimLeft: function() {
          return String.prototype.trimLeft !== polyfill;
        } }
      );
      return polyfill;
    };
  }
});

// node_modules/string.prototype.trimleft/index.js
var require_string_prototype4 = __commonJS({
  "node_modules/string.prototype.trimleft/index.js"(exports2, module2) {
    "use strict";
    var callBind = require_call_bind();
    var define2 = require_define_properties();
    var implementation = require_implementation12();
    var getPolyfill = require_polyfill9();
    var shim = require_shim9();
    var bound = callBind(getPolyfill());
    define2(bound, {
      getPolyfill,
      implementation,
      shim
    });
    module2.exports = bound;
  }
});

// node_modules/es7-shim/String.prototype.trimLeft.js
var require_String_prototype_trimLeft = __commonJS({
  "node_modules/es7-shim/String.prototype.trimLeft.js"(exports2, module2) {
    "use strict";
    module2.exports = require_string_prototype4();
  }
});

// node_modules/string.prototype.trimend/implementation.js
var require_implementation13 = __commonJS({
  "node_modules/string.prototype.trimend/implementation.js"(exports2, module2) {
    "use strict";
    var callBound = require_callBound();
    var $replace = callBound("String.prototype.replace");
    var mvsIsWS = /^\s$/.test("᠎");
    var endWhitespace = mvsIsWS ? /[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+$/ : /[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]+$/;
    module2.exports = function trimEnd() {
      return $replace(this, endWhitespace, "");
    };
  }
});

// node_modules/string.prototype.trimright/implementation.js
var require_implementation14 = __commonJS({
  "node_modules/string.prototype.trimright/implementation.js"(exports2, module2) {
    "use strict";
    module2.exports = require_implementation13();
  }
});

// node_modules/string.prototype.trimright/polyfill.js
var require_polyfill10 = __commonJS({
  "node_modules/string.prototype.trimright/polyfill.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation14();
    module2.exports = function getPolyfill() {
      if (!String.prototype.trimRight) {
        return implementation;
      }
      var zeroWidthSpace = "​";
      if (zeroWidthSpace.trimRight() !== zeroWidthSpace) {
        return implementation;
      }
      return String.prototype.trimRight;
    };
  }
});

// node_modules/string.prototype.trimright/shim.js
var require_shim10 = __commonJS({
  "node_modules/string.prototype.trimright/shim.js"(exports2, module2) {
    "use strict";
    var define2 = require_define_properties();
    var getPolyfill = require_polyfill10();
    module2.exports = function shimTrimRight() {
      var polyfill = getPolyfill();
      define2(
        String.prototype,
        { trimRight: polyfill },
        { trimRight: function() {
          return String.prototype.trimRight !== polyfill;
        } }
      );
      return polyfill;
    };
  }
});

// node_modules/string.prototype.trimright/index.js
var require_string_prototype5 = __commonJS({
  "node_modules/string.prototype.trimright/index.js"(exports2, module2) {
    "use strict";
    var callBind = require_call_bind();
    var define2 = require_define_properties();
    var implementation = require_implementation14();
    var getPolyfill = require_polyfill10();
    var shim = require_shim10();
    var bound = callBind(getPolyfill());
    define2(bound, {
      getPolyfill,
      implementation,
      shim
    });
    module2.exports = bound;
  }
});

// node_modules/es7-shim/String.prototype.trimRight.js
var require_String_prototype_trimRight = __commonJS({
  "node_modules/es7-shim/String.prototype.trimRight.js"(exports2, module2) {
    "use strict";
    module2.exports = require_string_prototype5();
  }
});

// node_modules/es7-shim/String.prototype.js
var require_String_prototype = __commonJS({
  "node_modules/es7-shim/String.prototype.js"(exports2, module2) {
    "use strict";
    var at2 = require_String_prototype_at();
    var padStart = require_String_prototype_padStart();
    var padEnd = require_String_prototype_padEnd();
    var trimLeft = require_String_prototype_trimLeft();
    var trimRight = require_String_prototype_trimRight();
    module2.exports = {
      at: at2,
      padStart,
      padEnd,
      trimLeft,
      trimRight,
      shim: function shimStringPrototype() {
        at2.shim();
        padStart.shim();
        padEnd.shim();
        trimLeft.shim();
        trimRight.shim();
      }
    };
  }
});

// node_modules/es7-shim/String.js
var require_String = __commonJS({
  "node_modules/es7-shim/String.js"(exports2, module2) {
    "use strict";
    var stringPrototype = require_String_prototype();
    module2.exports = {
      prototype: stringPrototype,
      shim: function shimString() {
        stringPrototype.shim();
      }
    };
  }
});

// node_modules/es7-shim/es7-shim.js
var require_es7_shim = __commonJS({
  "node_modules/es7-shim/es7-shim.js"(exports2, module2) {
    "use strict";
    var $Array = require_Array();
    var $Object = require_Object();
    var $String = require_String();
    module2.exports = {
      Array: $Array,
      Object: $Object,
      String: $String,
      shim: function shimES7() {
        $Array.shim();
        $Object.shim();
        $String.shim();
      }
    };
  }
});

// node_modules/json-to-ts/build/src/get-interfaces.js
var require_get_interfaces = __commonJS({
  "node_modules/json-to-ts/build/src/get-interfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util();
    function isKeyNameValid(keyName) {
      var regex = /^[a-zA-Z_][a-zA-Z\d_]*$/;
      return regex.test(keyName);
    }
    function parseKeyMetaData(key2) {
      var isOptional = key2.endsWith("--?");
      if (isOptional) {
        return {
          isOptional,
          keyValue: key2.slice(0, -3)
        };
      } else {
        return {
          isOptional,
          keyValue: key2
        };
      }
    }
    function findNameById(id, names) {
      return names.find(function(_2) {
        return _2.id === id;
      }).name;
    }
    function removeUndefinedFromUnion(unionTypeName) {
      var typeNames = unionTypeName.split(" | ");
      var undefinedIndex = typeNames.indexOf("undefined");
      typeNames.splice(undefinedIndex, 1);
      return typeNames.join(" | ");
    }
    function replaceTypeObjIdsWithNames(typeObj, names) {
      return Object.entries(typeObj).map(function(_a) {
        var key2 = _a[0], type = _a[1];
        var _b = parseKeyMetaData(key2), isOptional = _b.isOptional, keyValue = _b.keyValue;
        var isValid = isKeyNameValid(keyValue);
        var validName = isValid ? keyValue : "'" + keyValue + "'";
        return isOptional ? [validName + "?", type, isOptional] : [validName, type, isOptional];
      }).map(function(_a) {
        var key2 = _a[0], type = _a[1], isOptional = _a[2];
        if (!util_1.isHash(type)) {
          return [key2, type, isOptional];
        }
        var newType = findNameById(type, names);
        return [key2, newType, isOptional];
      }).map(function(_a) {
        var key2 = _a[0], type = _a[1], isOptional = _a[2];
        if (!(util_1.isNonArrayUnion(type) && type.includes("undefined"))) {
          return [key2, type, isOptional];
        }
        var newType = removeUndefinedFromUnion(type);
        var newKey = isOptional ? key2 : key2 + "?";
        return [newKey, newType, isOptional];
      }).map(function(_a) {
        var key2 = _a[0], type = _a[1], isOptional = _a[2];
        if (type !== "undefined") {
          return [key2, type, isOptional];
        }
        var newType = "any";
        var newKey = isOptional ? key2 : key2 + "?";
        return [newKey, newType, isOptional];
      }).reduce(function(agg, _a) {
        var key2 = _a[0], value = _a[1];
        agg[key2] = value;
        return agg;
      }, {});
    }
    function getInterfaceStringFromDescription(_a) {
      var name = _a.name, typeMap = _a.typeMap, useTypeAlias = _a.useTypeAlias;
      var stringTypeMap = Object.entries(typeMap).map(function(_a2) {
        var key2 = _a2[0], name2 = _a2[1];
        return "  " + key2 + ": " + name2 + ";\n";
      }).reduce(function(a, b2) {
        return a += b2;
      }, "");
      var declarationKeyWord = useTypeAlias ? "type" : "interface";
      var interfaceString = declarationKeyWord + " " + name + (useTypeAlias ? " =" : "") + " {\n";
      interfaceString += stringTypeMap;
      interfaceString += "}";
      return interfaceString;
    }
    exports2.getInterfaceStringFromDescription = getInterfaceStringFromDescription;
    function getInterfaceDescriptions(typeStructure, names) {
      return names.map(function(_a) {
        var id = _a.id, name = _a.name;
        var typeDescription = util_1.findTypeById(id, typeStructure.types);
        if (typeDescription.typeObj) {
          var typeMap = replaceTypeObjIdsWithNames(typeDescription.typeObj, names);
          return { name, typeMap };
        } else {
          return null;
        }
      }).filter(function(_2) {
        return _2 !== null;
      });
    }
    exports2.getInterfaceDescriptions = getInterfaceDescriptions;
  }
});

// node_modules/pluralize/pluralize.js
var require_pluralize = __commonJS({
  "node_modules/pluralize/pluralize.js"(exports2, module2) {
    (function(root2, pluralize) {
      if (typeof __require === "function" && typeof exports2 === "object" && typeof module2 === "object") {
        module2.exports = pluralize();
      } else if (typeof define === "function" && define.amd) {
        define(function() {
          return pluralize();
        });
      } else {
        root2.pluralize = pluralize();
      }
    })(exports2, function() {
      var pluralRules = [];
      var singularRules = [];
      var uncountables = {};
      var irregularPlurals = {};
      var irregularSingles = {};
      function toTitleCase(str) {
        return str.charAt(0).toUpperCase() + str.substr(1).toLowerCase();
      }
      function sanitizeRule(rule) {
        if (typeof rule === "string") {
          return new RegExp("^" + rule + "$", "i");
        }
        return rule;
      }
      function restoreCase(word, token2) {
        if (word === token2) {
          return token2;
        }
        if (word === word.toUpperCase()) {
          return token2.toUpperCase();
        }
        if (word[0] === word[0].toUpperCase()) {
          return toTitleCase(token2);
        }
        return token2.toLowerCase();
      }
      function interpolate(str, args) {
        return str.replace(/\$(\d{1,2})/g, function(match, index) {
          return args[index] || "";
        });
      }
      function sanitizeWord(token2, word, collection) {
        if (!token2.length || uncountables.hasOwnProperty(token2)) {
          return word;
        }
        var len = collection.length;
        while (len--) {
          var rule = collection[len];
          if (rule[0].test(word)) {
            return word.replace(rule[0], function(match, index, word2) {
              var result = interpolate(rule[1], arguments);
              if (match === "") {
                return restoreCase(word2[index - 1], result);
              }
              return restoreCase(match, result);
            });
          }
        }
        return word;
      }
      function replaceWord(replaceMap, keepMap, rules) {
        return function(word) {
          var token2 = word.toLowerCase();
          if (keepMap.hasOwnProperty(token2)) {
            return restoreCase(word, token2);
          }
          if (replaceMap.hasOwnProperty(token2)) {
            return restoreCase(word, replaceMap[token2]);
          }
          return sanitizeWord(token2, word, rules);
        };
      }
      function pluralize(word, count, inclusive) {
        var pluralized = count === 1 ? pluralize.singular(word) : pluralize.plural(word);
        return (inclusive ? count + " " : "") + pluralized;
      }
      pluralize.plural = replaceWord(
        irregularSingles,
        irregularPlurals,
        pluralRules
      );
      pluralize.singular = replaceWord(
        irregularPlurals,
        irregularSingles,
        singularRules
      );
      pluralize.addPluralRule = function(rule, replacement) {
        pluralRules.push([sanitizeRule(rule), replacement]);
      };
      pluralize.addSingularRule = function(rule, replacement) {
        singularRules.push([sanitizeRule(rule), replacement]);
      };
      pluralize.addUncountableRule = function(word) {
        if (typeof word === "string") {
          uncountables[word.toLowerCase()] = true;
          return;
        }
        pluralize.addPluralRule(word, "$0");
        pluralize.addSingularRule(word, "$0");
      };
      pluralize.addIrregularRule = function(single, plural) {
        plural = plural.toLowerCase();
        single = single.toLowerCase();
        irregularSingles[single] = plural;
        irregularPlurals[plural] = single;
      };
      [
        // Pronouns.
        ["I", "we"],
        ["me", "us"],
        ["he", "they"],
        ["she", "they"],
        ["them", "them"],
        ["myself", "ourselves"],
        ["yourself", "yourselves"],
        ["itself", "themselves"],
        ["herself", "themselves"],
        ["himself", "themselves"],
        ["themself", "themselves"],
        ["is", "are"],
        ["was", "were"],
        ["has", "have"],
        ["this", "these"],
        ["that", "those"],
        // Words ending in with a consonant and `o`.
        ["echo", "echoes"],
        ["dingo", "dingoes"],
        ["volcano", "volcanoes"],
        ["tornado", "tornadoes"],
        ["torpedo", "torpedoes"],
        // Ends with `us`.
        ["genus", "genera"],
        ["viscus", "viscera"],
        // Ends with `ma`.
        ["stigma", "stigmata"],
        ["stoma", "stomata"],
        ["dogma", "dogmata"],
        ["lemma", "lemmata"],
        ["schema", "schemata"],
        ["anathema", "anathemata"],
        // Other irregular rules.
        ["ox", "oxen"],
        ["axe", "axes"],
        ["die", "dice"],
        ["yes", "yeses"],
        ["foot", "feet"],
        ["eave", "eaves"],
        ["goose", "geese"],
        ["tooth", "teeth"],
        ["quiz", "quizzes"],
        ["human", "humans"],
        ["proof", "proofs"],
        ["carve", "carves"],
        ["valve", "valves"],
        ["looey", "looies"],
        ["thief", "thieves"],
        ["groove", "grooves"],
        ["pickaxe", "pickaxes"],
        ["whiskey", "whiskies"]
      ].forEach(function(rule) {
        return pluralize.addIrregularRule(rule[0], rule[1]);
      });
      [
        [/s?$/i, "s"],
        [/([^aeiou]ese)$/i, "$1"],
        [/(ax|test)is$/i, "$1es"],
        [/(alias|[^aou]us|tlas|gas|ris)$/i, "$1es"],
        [/(e[mn]u)s?$/i, "$1s"],
        [/([^l]ias|[aeiou]las|[emjzr]as|[iu]am)$/i, "$1"],
        [/(alumn|syllab|octop|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1i"],
        [/(alumn|alg|vertebr)(?:a|ae)$/i, "$1ae"],
        [/(seraph|cherub)(?:im)?$/i, "$1im"],
        [/(her|at|gr)o$/i, "$1oes"],
        [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|automat|quor)(?:a|um)$/i, "$1a"],
        [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)(?:a|on)$/i, "$1a"],
        [/sis$/i, "ses"],
        [/(?:(kni|wi|li)fe|(ar|l|ea|eo|oa|hoo)f)$/i, "$1$2ves"],
        [/([^aeiouy]|qu)y$/i, "$1ies"],
        [/([^ch][ieo][ln])ey$/i, "$1ies"],
        [/(x|ch|ss|sh|zz)$/i, "$1es"],
        [/(matr|cod|mur|sil|vert|ind|append)(?:ix|ex)$/i, "$1ices"],
        [/(m|l)(?:ice|ouse)$/i, "$1ice"],
        [/(pe)(?:rson|ople)$/i, "$1ople"],
        [/(child)(?:ren)?$/i, "$1ren"],
        [/eaux$/i, "$0"],
        [/m[ae]n$/i, "men"],
        ["thou", "you"]
      ].forEach(function(rule) {
        return pluralize.addPluralRule(rule[0], rule[1]);
      });
      [
        [/s$/i, ""],
        [/(ss)$/i, "$1"],
        [/((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)(?:sis|ses)$/i, "$1sis"],
        [/(^analy)(?:sis|ses)$/i, "$1sis"],
        [/(wi|kni|(?:after|half|high|low|mid|non|night|[^\w]|^)li)ves$/i, "$1fe"],
        [/(ar|(?:wo|[ae])l|[eo][ao])ves$/i, "$1f"],
        [/ies$/i, "y"],
        [/\b([pl]|zomb|(?:neck|cross)?t|coll|faer|food|gen|goon|group|lass|talk|goal|cut)ies$/i, "$1ie"],
        [/\b(mon|smil)ies$/i, "$1ey"],
        [/(m|l)ice$/i, "$1ouse"],
        [/(seraph|cherub)im$/i, "$1"],
        [/(x|ch|ss|sh|zz|tto|go|cho|alias|[^aou]us|tlas|gas|(?:her|at|gr)o|ris)(?:es)?$/i, "$1"],
        [/(e[mn]u)s?$/i, "$1"],
        [/(movie|twelve)s$/i, "$1"],
        [/(cris|test|diagnos)(?:is|es)$/i, "$1is"],
        [/(alumn|syllab|octop|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1us"],
        [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|quor)a$/i, "$1um"],
        [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)a$/i, "$1on"],
        [/(alumn|alg|vertebr)ae$/i, "$1a"],
        [/(cod|mur|sil|vert|ind)ices$/i, "$1ex"],
        [/(matr|append)ices$/i, "$1ix"],
        [/(pe)(rson|ople)$/i, "$1rson"],
        [/(child)ren$/i, "$1"],
        [/(eau)x?$/i, "$1"],
        [/men$/i, "man"]
      ].forEach(function(rule) {
        return pluralize.addSingularRule(rule[0], rule[1]);
      });
      [
        // Singular words with no plurals.
        "advice",
        "adulthood",
        "agenda",
        "aid",
        "alcohol",
        "ammo",
        "athletics",
        "bison",
        "blood",
        "bream",
        "buffalo",
        "butter",
        "carp",
        "cash",
        "chassis",
        "chess",
        "clothing",
        "commerce",
        "cod",
        "cooperation",
        "corps",
        "digestion",
        "debris",
        "diabetes",
        "energy",
        "equipment",
        "elk",
        "excretion",
        "expertise",
        "flounder",
        "fun",
        "gallows",
        "garbage",
        "graffiti",
        "headquarters",
        "health",
        "herpes",
        "highjinks",
        "homework",
        "housework",
        "information",
        "jeans",
        "justice",
        "kudos",
        "labour",
        "literature",
        "machinery",
        "mackerel",
        "mail",
        "media",
        "mews",
        "moose",
        "music",
        "news",
        "pike",
        "plankton",
        "pliers",
        "pollution",
        "premises",
        "rain",
        "research",
        "rice",
        "salmon",
        "scissors",
        "series",
        "sewage",
        "shambles",
        "shrimp",
        "species",
        "staff",
        "swine",
        "trout",
        "traffic",
        "transporation",
        "tuna",
        "wealth",
        "welfare",
        "whiting",
        "wildebeest",
        "wildlife",
        "you",
        // Regexes.
        /pox$/i,
        // "chickpox", "smallpox"
        /ois$/i,
        /deer$/i,
        // "deer", "reindeer"
        /fish$/i,
        // "fish", "blowfish", "angelfish"
        /sheep$/i,
        /measles$/i,
        /[^aeiou]ese$/i
        // "chinese", "japanese"
      ].forEach(pluralize.addUncountableRule);
      return pluralize;
    });
  }
});

// node_modules/json-to-ts/build/src/get-names.js
var require_get_names = __commonJS({
  "node_modules/json-to-ts/build/src/get-names.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var pluralize = require_pluralize();
    var model_1 = require_model();
    var util_1 = require_util();
    function getName(_a, keyName, names, isInsideArray) {
      var rootTypeId = _a.rootTypeId, types = _a.types;
      var typeDesc = types.find(function(_2) {
        return _2.id === rootTypeId;
      });
      switch (util_1.getTypeDescriptionGroup(typeDesc)) {
        case model_1.TypeGroup.Array:
          typeDesc.arrayOfTypes.forEach(function(typeIdOrPrimitive, i) {
            getName(
              { rootTypeId: typeIdOrPrimitive, types },
              // to differenttiate array types
              i === 0 ? keyName : "" + keyName + (i + 1),
              names,
              true
            );
          });
          return {
            rootName: getNameById(typeDesc.id, keyName, isInsideArray, types, names),
            names
          };
        case model_1.TypeGroup.Object:
          Object.entries(typeDesc.typeObj).forEach(function(_a2) {
            var key2 = _a2[0], value = _a2[1];
            getName({ rootTypeId: value, types }, key2, names, false);
          });
          return {
            rootName: getNameById(typeDesc.id, keyName, isInsideArray, types, names),
            names
          };
        case model_1.TypeGroup.Primitive:
          return {
            rootName: rootTypeId,
            names
          };
      }
    }
    function getNames(typeStructure, rootName) {
      if (rootName === void 0) {
        rootName = "RootObject";
      }
      return getName(typeStructure, rootName, [], false).names.reverse();
    }
    exports2.getNames = getNames;
    function getNameById(id, keyName, isInsideArray, types, nameMap) {
      var nameEntry = nameMap.find(function(_2) {
        return _2.id === id;
      });
      if (nameEntry) {
        return nameEntry.name;
      }
      var typeDesc = util_1.findTypeById(id, types);
      var group = util_1.getTypeDescriptionGroup(typeDesc);
      var name;
      switch (group) {
        case model_1.TypeGroup.Array:
          name = typeDesc.isUnion ? getArrayName(typeDesc, types, nameMap) : formatArrayName(typeDesc, types, nameMap);
          break;
        case model_1.TypeGroup.Object:
          name = [keyName].map(function(key2) {
            return util_1.parseKeyMetaData(key2).keyValue;
          }).map(function(name2) {
            return isInsideArray ? pluralize.singular(name2) : name2;
          }).map(pascalCase).map(normalizeInvalidTypeName).map(pascalCase).map(function(name2) {
            return uniqueByIncrement(name2, nameMap.map(function(_a) {
              var name3 = _a.name;
              return name3;
            }));
          }).pop();
          break;
      }
      nameMap.push({ id, name });
      return name;
    }
    function pascalCase(name) {
      return name.split(/\s+/g).filter(function(_2) {
        return _2 !== "";
      }).map(capitalize).reduce(function(a, b2) {
        return a + b2;
      }, "");
    }
    function capitalize(name) {
      return name.charAt(0).toUpperCase() + name.slice(1);
    }
    function normalizeInvalidTypeName(name) {
      if (/^[a-zA-Z][a-zA-Z0-9]*$/.test(name)) {
        return name;
      } else {
        var noSymbolsName = name.replace(/[^a-zA-Z0-9]/g, "");
        var startsWithWordCharacter = /^[a-zA-Z]/.test(noSymbolsName);
        return startsWithWordCharacter ? noSymbolsName : "_" + noSymbolsName;
      }
    }
    function uniqueByIncrement(name, names) {
      for (var i = 0; i < 1e3; i++) {
        var nameProposal = i === 0 ? name : "" + name + (i + 1);
        if (!names.includes(nameProposal)) {
          return nameProposal;
        }
      }
    }
    function getArrayName(typeDesc, types, nameMap) {
      if (typeDesc.arrayOfTypes.length === 0) {
        return "any";
      } else if (typeDesc.arrayOfTypes.length === 1) {
        var idOrPrimitive = typeDesc.arrayOfTypes[0];
        return convertToReadableType(idOrPrimitive, types, nameMap);
      } else {
        return unionToString(typeDesc, types, nameMap);
      }
    }
    function convertToReadableType(idOrPrimitive, types, nameMap) {
      return util_1.isHash(idOrPrimitive) ? (
        // array keyName makes no difference in picking name for type
        getNameById(idOrPrimitive, null, true, types, nameMap)
      ) : idOrPrimitive;
    }
    function unionToString(typeDesc, types, nameMap) {
      return typeDesc.arrayOfTypes.reduce(function(acc, type, i) {
        var readableTypeName = convertToReadableType(type, types, nameMap);
        return i === 0 ? readableTypeName : acc + " | " + readableTypeName;
      }, "");
    }
    function formatArrayName(typeDesc, types, nameMap) {
      var innerTypeId = typeDesc.arrayOfTypes[0];
      var isMultipleTypeArray = util_1.isHash(innerTypeId) && util_1.findTypeById(innerTypeId, types).isUnion && util_1.findTypeById(innerTypeId, types).arrayOfTypes.length > 1;
      var readableInnerType = getArrayName(typeDesc, types, nameMap);
      return isMultipleTypeArray ? "(" + readableInnerType + ")[]" : readableInnerType + "[]";
    }
  }
});

// node_modules/json-to-ts/build/src/index.js
var require_src = __commonJS({
  "node_modules/json-to-ts/build/src/index.js"(exports2, module2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var get_type_structure_1 = require_get_type_structure();
    var es7_shim_1 = require_es7_shim();
    var get_interfaces_1 = require_get_interfaces();
    var get_names_1 = require_get_names();
    var util_1 = require_util();
    es7_shim_1.shim();
    function JsonToTS(json, userOptions) {
      var defaultOptions = {
        rootName: "RootObject"
      };
      var options2 = __assign(__assign({}, defaultOptions), userOptions);
      var isArrayOfObjects = util_1.isArray(json) && json.length > 0 && json.reduce(function(a, b2) {
        return a && util_1.isObject(b2);
      }, true);
      if (!(util_1.isObject(json) || isArrayOfObjects)) {
        throw new Error("Only (Object) and (Array of Object) are supported");
      }
      var typeStructure = get_type_structure_1.getTypeStructure(json);
      get_type_structure_1.optimizeTypeStructure(typeStructure);
      var names = get_names_1.getNames(typeStructure, options2.rootName);
      return get_interfaces_1.getInterfaceDescriptions(typeStructure, names).map(function(description) {
        return get_interfaces_1.getInterfaceStringFromDescription(__assign(__assign({}, description), { useTypeAlias: options2.useTypeAlias }));
      });
    }
    exports2.default = JsonToTS;
    JsonToTS.default = JsonToTS;
    module2.exports = JsonToTS;
  }
});

// node_modules/vm-browserify/index.js
var require_vm_browserify = __commonJS({
  "node_modules/vm-browserify/index.js"(exports, module) {
    var indexOf = function(xs, item) {
      if (xs.indexOf) return xs.indexOf(item);
      else for (var i = 0; i < xs.length; i++) {
        if (xs[i] === item) return i;
      }
      return -1;
    };
    var Object_keys = function(obj) {
      if (Object.keys) return Object.keys(obj);
      else {
        var res = [];
        for (var key2 in obj) res.push(key2);
        return res;
      }
    };
    var forEach = function(xs, fn2) {
      if (xs.forEach) return xs.forEach(fn2);
      else for (var i = 0; i < xs.length; i++) {
        fn2(xs[i], i, xs);
      }
    };
    var defineProp = function() {
      try {
        Object.defineProperty({}, "_", {});
        return function(obj, name, value) {
          Object.defineProperty(obj, name, {
            writable: true,
            enumerable: false,
            configurable: true,
            value
          });
        };
      } catch (e) {
        return function(obj, name, value) {
          obj[name] = value;
        };
      }
    }();
    var globals = [
      "Array",
      "Boolean",
      "Date",
      "Error",
      "EvalError",
      "Function",
      "Infinity",
      "JSON",
      "Math",
      "NaN",
      "Number",
      "Object",
      "RangeError",
      "ReferenceError",
      "RegExp",
      "String",
      "SyntaxError",
      "TypeError",
      "URIError",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "undefined",
      "unescape"
    ];
    function Context() {
    }
    Context.prototype = {};
    var Script = exports.Script = function NodeScript(code) {
      if (!(this instanceof Script)) return new Script(code);
      this.code = code;
    };
    Script.prototype.runInContext = function(context) {
      if (!(context instanceof Context)) {
        throw new TypeError("needs a 'context' argument.");
      }
      var iframe = document.createElement("iframe");
      if (!iframe.style) iframe.style = {};
      iframe.style.display = "none";
      document.body.appendChild(iframe);
      var win = iframe.contentWindow;
      var wEval = win.eval, wExecScript = win.execScript;
      if (!wEval && wExecScript) {
        wExecScript.call(win, "null");
        wEval = win.eval;
      }
      forEach(Object_keys(context), function(key2) {
        win[key2] = context[key2];
      });
      forEach(globals, function(key2) {
        if (context[key2]) {
          win[key2] = context[key2];
        }
      });
      var winKeys = Object_keys(win);
      var res = wEval.call(win, this.code);
      forEach(Object_keys(win), function(key2) {
        if (key2 in context || indexOf(winKeys, key2) === -1) {
          context[key2] = win[key2];
        }
      });
      forEach(globals, function(key2) {
        if (!(key2 in context)) {
          defineProp(context, key2, win[key2]);
        }
      });
      document.body.removeChild(iframe);
      return res;
    };
    Script.prototype.runInThisContext = function() {
      return eval(this.code);
    };
    Script.prototype.runInNewContext = function(context) {
      var ctx = Script.createContext(context);
      var res = this.runInContext(ctx);
      if (context) {
        forEach(Object_keys(ctx), function(key2) {
          context[key2] = ctx[key2];
        });
      }
      return res;
    };
    forEach(Object_keys(Script.prototype), function(name) {
      exports[name] = Script[name] = function(code) {
        var s = Script(code);
        return s[name].apply(s, [].slice.call(arguments, 1));
      };
    });
    exports.isContext = function(context) {
      return context instanceof Context;
    };
    exports.createScript = function(code) {
      return exports.Script(code);
    };
    exports.createContext = Script.createContext = function(context) {
      var copy = new Context();
      if (typeof context === "object") {
        forEach(Object_keys(context), function(key2) {
          copy[key2] = context[key2];
        });
      }
      return copy;
    };
  }
});

// node_modules/prettier/standalone.mjs
var yu = Object.create;
var He = Object.defineProperty;
var Au = Object.getOwnPropertyDescriptor;
var Bu = Object.getOwnPropertyNames;
var wu = Object.getPrototypeOf;
var xu = Object.prototype.hasOwnProperty;
var sr = (e) => {
  throw TypeError(e);
};
var _u = (e, t) => () => (e && (t = e(e = 0)), t);
var At = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports);
var We = (e, t) => {
  for (var r in t) He(e, r, { get: t[r], enumerable: true });
};
var ar = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function") for (let o of Bu(t)) !xu.call(e, o) && o !== r && He(e, o, { get: () => t[o], enumerable: !(n = Au(t, o)) || n.enumerable });
  return e;
};
var Me = (e, t, r) => (r = e != null ? yu(wu(e)) : {}, ar(t || !e || !e.__esModule ? He(r, "default", { value: e, enumerable: true }) : r, e));
var vu = (e) => ar(He({}, "__esModule", { value: true }), e);
var bu = (e, t, r) => t.has(e) || sr("Cannot " + r);
var Dr = (e, t, r) => t.has(e) ? sr("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, r);
var pe = (e, t, r) => (bu(e, t, "access private method"), r);
var it = At((ia, sn) => {
  "use strict";
  var on = new Proxy(String, { get: () => on });
  sn.exports = on;
});
var Tn = {};
We(Tn, { default: () => _o, shouldHighlight: () => xo });
var xo;
var _o;
var kn = _u(() => {
  xo = () => false, _o = String;
});
var Pn = At((bD, Xt) => {
  var g = String, Ln = function() {
    return { isColorSupported: false, reset: g, bold: g, dim: g, italic: g, underline: g, inverse: g, hidden: g, strikethrough: g, black: g, red: g, green: g, yellow: g, blue: g, magenta: g, cyan: g, white: g, gray: g, bgBlack: g, bgRed: g, bgGreen: g, bgYellow: g, bgBlue: g, bgMagenta: g, bgCyan: g, bgWhite: g };
  };
  Xt.exports = Ln();
  Xt.exports.createColors = Ln;
});
var $n = At((Ct) => {
  "use strict";
  Object.defineProperty(Ct, "__esModule", { value: true });
  Ct.codeFrameColumns = Mn;
  Ct.default = To;
  var In = (kn(), vu(Tn)), Hn = vo(Pn(), true);
  function Wn(e) {
    if (typeof WeakMap != "function") return null;
    var t = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
    return (Wn = function(n) {
      return n ? r : t;
    })(e);
  }
  function vo(e, t) {
    if (!t && e && e.__esModule) return e;
    if (e === null || typeof e != "object" && typeof e != "function") return { default: e };
    var r = Wn(t);
    if (r && r.has(e)) return r.get(e);
    var n = { __proto__: null }, o = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var u in e) if (u !== "default" && {}.hasOwnProperty.call(e, u)) {
      var i = o ? Object.getOwnPropertyDescriptor(e, u) : null;
      i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, r && r.set(e, n), n;
  }
  var bo = Hn.default, Rn = (e, t) => (r) => e(t(r)), Zt;
  function Oo(e) {
    if (e) {
      var t;
      return (t = Zt) != null || (Zt = (0, Hn.createColors)(true)), Zt;
    }
    return bo;
  }
  var Yn = false;
  function So(e) {
    return { gutter: e.gray, marker: Rn(e.red, e.bold), message: Rn(e.red, e.bold) };
  }
  var jn = /\r\n|[\n\r\u2028\u2029]/;
  function No(e, t, r) {
    let n = Object.assign({ column: 0, line: -1 }, e.start), o = Object.assign({}, n, e.end), { linesAbove: u = 2, linesBelow: i = 3 } = r || {}, s = n.line, a = n.column, D = o.line, l = o.column, d = Math.max(s - (u + 1), 0), f = Math.min(t.length, D + i);
    s === -1 && (d = 0), D === -1 && (f = t.length);
    let p = D - s, c2 = {};
    if (p) for (let F = 0; F <= p; F++) {
      let m = F + s;
      if (!a) c2[m] = true;
      else if (F === 0) {
        let E = t[m - 1].length;
        c2[m] = [a, E - a + 1];
      } else if (F === p) c2[m] = [0, l];
      else {
        let E = t[m - F].length;
        c2[m] = [0, E];
      }
    }
    else a === l ? a ? c2[s] = [a, 0] : c2[s] = true : c2[s] = [a, l - a];
    return { start: d, end: f, markerLines: c2 };
  }
  function Mn(e, t, r = {}) {
    let n = (r.highlightCode || r.forceColor) && (0, In.shouldHighlight)(r), o = Oo(r.forceColor), u = So(o), i = (F, m) => n ? F(m) : m, s = e.split(jn), { start: a, end: D, markerLines: l } = No(t, s, r), d = t.start && typeof t.start.column == "number", f = String(D).length, c2 = (n ? (0, In.default)(e, r) : e).split(jn, D).slice(a, D).map((F, m) => {
      let E = a + 1 + m, w = ` ${` ${E}`.slice(-f)} |`, h = l[E], C = !l[E + 1];
      if (h) {
        let k = "";
        if (Array.isArray(h)) {
          let v = F.slice(0, Math.max(h[0] - 1, 0)).replace(/[^\t]/g, " "), $ = h[1] || 1;
          k = [`
 `, i(u.gutter, w.replace(/\d/g, " ")), " ", v, i(u.marker, "^").repeat($)].join(""), C && r.message && (k += " " + i(u.message, r.message));
        }
        return [i(u.marker, ">"), i(u.gutter, w), F.length > 0 ? ` ${F}` : "", k].join("");
      } else return ` ${i(u.gutter, w)}${F.length > 0 ? ` ${F}` : ""}`;
    }).join(`
`);
    return r.message && !d && (c2 = `${" ".repeat(f + 1)}${r.message}
${c2}`), n ? o.reset(c2) : c2;
  }
  function To(e, t, r, n = {}) {
    if (!Yn) {
      Yn = true;
      let u = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
      {
        let i = new Error(u);
        i.name = "DeprecationWarning", console.warn(new Error(u));
      }
    }
    return r = Math.max(r, 0), Mn(e, { start: { column: r, line: t } }, n);
  }
});
var ir = {};
We(ir, { __debug: () => di, check: () => fi, doc: () => nr, format: () => gu, formatWithCursor: () => Cu, getSupportInfo: () => pi, util: () => or, version: () => fu });
var Ou = (e, t, r, n) => {
  if (!(e && t == null)) return t.replaceAll ? t.replaceAll(r, n) : r.global ? t.replace(r, n) : t.split(r).join(n);
};
var ne = Ou;
function Z() {
}
Z.prototype = { diff: function(t, r) {
  var n, o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, u = o.callback;
  typeof o == "function" && (u = o, o = {}), this.options = o;
  var i = this;
  function s(h) {
    return u ? (setTimeout(function() {
      u(void 0, h);
    }, 0), true) : h;
  }
  t = this.castInput(t), r = this.castInput(r), t = this.removeEmpty(this.tokenize(t)), r = this.removeEmpty(this.tokenize(r));
  var a = r.length, D = t.length, l = 1, d = a + D;
  o.maxEditLength && (d = Math.min(d, o.maxEditLength));
  var f = (n = o.timeout) !== null && n !== void 0 ? n : 1 / 0, p = Date.now() + f, c2 = [{ oldPos: -1, lastComponent: void 0 }], F = this.extractCommon(c2[0], r, t, 0);
  if (c2[0].oldPos + 1 >= D && F + 1 >= a) return s([{ value: this.join(r), count: r.length }]);
  var m = -1 / 0, E = 1 / 0;
  function A() {
    for (var h = Math.max(m, -l); h <= Math.min(E, l); h += 2) {
      var C = void 0, k = c2[h - 1], v = c2[h + 1];
      k && (c2[h - 1] = void 0);
      var $ = false;
      if (v) {
        var ye = v.oldPos - h;
        $ = v && 0 <= ye && ye < a;
      }
      var yt = k && k.oldPos + 1 < D;
      if (!$ && !yt) {
        c2[h] = void 0;
        continue;
      }
      if (!yt || $ && k.oldPos + 1 < v.oldPos ? C = i.addToPath(v, true, void 0, 0) : C = i.addToPath(k, void 0, true, 1), F = i.extractCommon(C, r, t, h), C.oldPos + 1 >= D && F + 1 >= a) return s(Su(i, C.lastComponent, r, t, i.useLongestToken));
      c2[h] = C, C.oldPos + 1 >= D && (E = Math.min(E, h - 1)), F + 1 >= a && (m = Math.max(m, h + 1));
    }
    l++;
  }
  if (u) (function h() {
    setTimeout(function() {
      if (l > d || Date.now() > p) return u();
      A() || h();
    }, 0);
  })();
  else for (; l <= d && Date.now() <= p; ) {
    var w = A();
    if (w) return w;
  }
}, addToPath: function(t, r, n, o) {
  var u = t.lastComponent;
  return u && u.added === r && u.removed === n ? { oldPos: t.oldPos + o, lastComponent: { count: u.count + 1, added: r, removed: n, previousComponent: u.previousComponent } } : { oldPos: t.oldPos + o, lastComponent: { count: 1, added: r, removed: n, previousComponent: u } };
}, extractCommon: function(t, r, n, o) {
  for (var u = r.length, i = n.length, s = t.oldPos, a = s - o, D = 0; a + 1 < u && s + 1 < i && this.equals(r[a + 1], n[s + 1]); ) a++, s++, D++;
  return D && (t.lastComponent = { count: D, previousComponent: t.lastComponent }), t.oldPos = s, a;
}, equals: function(t, r) {
  return this.options.comparator ? this.options.comparator(t, r) : t === r || this.options.ignoreCase && t.toLowerCase() === r.toLowerCase();
}, removeEmpty: function(t) {
  for (var r = [], n = 0; n < t.length; n++) t[n] && r.push(t[n]);
  return r;
}, castInput: function(t) {
  return t;
}, tokenize: function(t) {
  return t.split("");
}, join: function(t) {
  return t.join("");
} };
function Su(e, t, r, n, o) {
  for (var u = [], i; t; ) u.push(t), i = t.previousComponent, delete t.previousComponent, t = i;
  u.reverse();
  for (var s = 0, a = u.length, D = 0, l = 0; s < a; s++) {
    var d = u[s];
    if (d.removed) {
      if (d.value = e.join(n.slice(l, l + d.count)), l += d.count, s && u[s - 1].added) {
        var p = u[s - 1];
        u[s - 1] = u[s], u[s] = p;
      }
    } else {
      if (!d.added && o) {
        var f = r.slice(D, D + d.count);
        f = f.map(function(F, m) {
          var E = n[l + m];
          return E.length > F.length ? E : F;
        }), d.value = e.join(f);
      } else d.value = e.join(r.slice(D, D + d.count));
      D += d.count, d.added || (l += d.count);
    }
  }
  var c2 = u[a - 1];
  return a > 1 && typeof c2.value == "string" && (c2.added || c2.removed) && e.equals("", c2.value) && (u[a - 2].value += c2.value, u.pop()), u;
}
var hi = new Z();
var lr = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;
var cr = /\S/;
var fr = new Z();
fr.equals = function(e, t) {
  return this.options.ignoreCase && (e = e.toLowerCase(), t = t.toLowerCase()), e === t || this.options.ignoreWhitespace && !cr.test(e) && !cr.test(t);
};
fr.tokenize = function(e) {
  for (var t = e.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/), r = 0; r < t.length - 1; r++) !t[r + 1] && t[r + 2] && lr.test(t[r]) && lr.test(t[r + 2]) && (t[r] += t[r + 2], t.splice(r + 1, 2), r--);
  return t;
};
var pr = new Z();
pr.tokenize = function(e) {
  this.options.stripTrailingCr && (e = e.replace(/\r\n/g, `
`));
  var t = [], r = e.split(/(\n|\r\n)/);
  r[r.length - 1] || r.pop();
  for (var n = 0; n < r.length; n++) {
    var o = r[n];
    n % 2 && !this.options.newlineIsToken ? t[t.length - 1] += o : (this.options.ignoreWhitespace && (o = o.trim()), t.push(o));
  }
  return t;
};
var Nu = new Z();
Nu.tokenize = function(e) {
  return e.split(/(\S.+?[.!?])(?=\s+|$)/);
};
var Tu = new Z();
Tu.tokenize = function(e) {
  return e.split(/([{}:;,]|\s+)/);
};
function $e(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? $e = function(t) {
    return typeof t;
  } : $e = function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, $e(e);
}
var ku = Object.prototype.toString;
var Ae = new Z();
Ae.useLongestToken = true;
Ae.tokenize = pr.tokenize;
Ae.castInput = function(e) {
  var t = this.options, r = t.undefinedReplacement, n = t.stringifyReplacer, o = n === void 0 ? function(u, i) {
    return typeof i > "u" ? r : i;
  } : n;
  return typeof e == "string" ? e : JSON.stringify(Bt(e, null, null, o), o, "  ");
};
Ae.equals = function(e, t) {
  return Z.prototype.equals.call(Ae, e.replace(/,([\r\n])/g, "$1"), t.replace(/,([\r\n])/g, "$1"));
};
function Bt(e, t, r, n, o) {
  t = t || [], r = r || [], n && (e = n(o, e));
  var u;
  for (u = 0; u < t.length; u += 1) if (t[u] === e) return r[u];
  var i;
  if (ku.call(e) === "[object Array]") {
    for (t.push(e), i = new Array(e.length), r.push(i), u = 0; u < e.length; u += 1) i[u] = Bt(e[u], t, r, n, o);
    return t.pop(), r.pop(), i;
  }
  if (e && e.toJSON && (e = e.toJSON()), $e(e) === "object" && e !== null) {
    t.push(e), i = {}, r.push(i);
    var s = [], a;
    for (a in e) e.hasOwnProperty(a) && s.push(a);
    for (s.sort(), u = 0; u < s.length; u += 1) a = s[u], i[a] = Bt(e[a], t, r, n, a);
    t.pop(), r.pop();
  } else i = e;
  return i;
}
var Ve = new Z();
Ve.tokenize = function(e) {
  return e.slice();
};
Ve.join = Ve.removeEmpty = function(e) {
  return e;
};
function dr(e, t, r) {
  return Ve.diff(e, t, r);
}
function Fr(e) {
  let t = e.indexOf("\r");
  return t >= 0 ? e.charAt(t + 1) === `
` ? "crlf" : "cr" : "lf";
}
function Be(e) {
  switch (e) {
    case "cr":
      return "\r";
    case "crlf":
      return `\r
`;
    default:
      return `
`;
  }
}
function wt(e, t) {
  let r;
  switch (t) {
    case `
`:
      r = /\n/gu;
      break;
    case "\r":
      r = /\r/gu;
      break;
    case `\r
`:
      r = /\r\n/gu;
      break;
    default:
      throw new Error(`Unexpected "eol" ${JSON.stringify(t)}.`);
  }
  let n = e.match(r);
  return n ? n.length : 0;
}
function mr(e) {
  return ne(false, e, /\r\n?/gu, `
`);
}
var U = "string";
var W = "array";
var z = "cursor";
var L = "indent";
var P = "align";
var I = "trim";
var x = "group";
var S = "fill";
var _ = "if-break";
var R = "indent-if-break";
var Y = "line-suffix";
var j = "line-suffix-boundary";
var B = "line";
var N = "label";
var b = "break-parent";
var Ue = /* @__PURE__ */ new Set([z, L, P, I, x, S, _, R, Y, j, B, N, b]);
function Lu(e) {
  if (typeof e == "string") return U;
  if (Array.isArray(e)) return W;
  if (!e) return;
  let { type: t } = e;
  if (Ue.has(t)) return t;
}
var G = Lu;
var Pu = (e) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(e);
function Iu(e) {
  let t = e === null ? "null" : typeof e;
  if (t !== "string" && t !== "object") return `Unexpected doc '${t}', 
Expected it to be 'string' or 'object'.`;
  if (G(e)) throw new Error("doc is valid.");
  let r = Object.prototype.toString.call(e);
  if (r !== "[object Object]") return `Unexpected doc '${r}'.`;
  let n = Pu([...Ue].map((o) => `'${o}'`));
  return `Unexpected doc.type '${e.type}'.
Expected it to be ${n}.`;
}
var xt = class extends Error {
  constructor(t) {
    super(Iu(t));
    __publicField(this, "name", "InvalidDocError");
    this.doc = t;
  }
};
var Q = xt;
var Er = {};
function Ru(e, t, r, n) {
  let o = [e];
  for (; o.length > 0; ) {
    let u = o.pop();
    if (u === Er) {
      r(o.pop());
      continue;
    }
    r && o.push(u, Er);
    let i = G(u);
    if (!i) throw new Q(u);
    if ((t == null ? void 0 : t(u)) !== false) switch (i) {
      case W:
      case S: {
        let s = i === W ? u : u.parts;
        for (let a = s.length, D = a - 1; D >= 0; --D) o.push(s[D]);
        break;
      }
      case _:
        o.push(u.flatContents, u.breakContents);
        break;
      case x:
        if (n && u.expandedStates) for (let s = u.expandedStates.length, a = s - 1; a >= 0; --a) o.push(u.expandedStates[a]);
        else o.push(u.contents);
        break;
      case P:
      case L:
      case R:
      case N:
      case Y:
        o.push(u.contents);
        break;
      case U:
      case z:
      case I:
      case j:
      case B:
      case b:
        break;
      default:
        throw new Q(u);
    }
  }
}
var we = Ru;
var hr = () => {
};
var K = hr;
var ze = hr;
function De(e) {
  return K(e), { type: L, contents: e };
}
function ae(e, t) {
  return K(t), { type: P, contents: t, n: e };
}
function _t(e, t = {}) {
  return K(e), ze(t.expandedStates, true), { type: x, id: t.id, contents: e, break: !!t.shouldBreak, expandedStates: t.expandedStates };
}
function Cr(e) {
  return ae(Number.NEGATIVE_INFINITY, e);
}
function gr(e) {
  return ae({ type: "root" }, e);
}
function yr(e) {
  return ae(-1, e);
}
function Ar(e, t) {
  return _t(e[0], { ...t, expandedStates: e });
}
function Ge(e) {
  return ze(e), { type: S, parts: e };
}
function Br(e, t = "", r = {}) {
  return K(e), t !== "" && K(t), { type: _, breakContents: e, flatContents: t, groupId: r.groupId };
}
function wr(e, t) {
  return K(e), { type: R, contents: e, groupId: t.groupId, negate: t.negate };
}
function xe(e) {
  return K(e), { type: Y, contents: e };
}
var xr = { type: j };
var de = { type: b };
var _r = { type: I };
var _e = { type: B, hard: true };
var vt = { type: B, hard: true, literal: true };
var Ke = { type: B };
var vr = { type: B, soft: true };
var q = [_e, de];
var qe = [vt, de];
var ve = { type: z };
function be(e, t) {
  K(e), ze(t);
  let r = [];
  for (let n = 0; n < t.length; n++) n !== 0 && r.push(e), r.push(t[n]);
  return r;
}
function Je(e, t, r) {
  K(e);
  let n = e;
  if (t > 0) {
    for (let o = 0; o < Math.floor(t / r); ++o) n = De(n);
    n = ae(t % r, n), n = ae(Number.NEGATIVE_INFINITY, n);
  }
  return n;
}
function br(e, t) {
  return K(t), e ? { type: N, label: e, contents: t } : t;
}
function ee(e) {
  var t;
  if (!e) return "";
  if (Array.isArray(e)) {
    let r = [];
    for (let n of e) if (Array.isArray(n)) r.push(...ee(n));
    else {
      let o = ee(n);
      o !== "" && r.push(o);
    }
    return r;
  }
  return e.type === _ ? { ...e, breakContents: ee(e.breakContents), flatContents: ee(e.flatContents) } : e.type === x ? { ...e, contents: ee(e.contents), expandedStates: (t = e.expandedStates) == null ? void 0 : t.map(ee) } : e.type === S ? { type: "fill", parts: e.parts.map(ee) } : e.contents ? { ...e, contents: ee(e.contents) } : e;
}
function Or(e) {
  let t = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ new Set();
  return n(ee(e));
  function n(u, i, s) {
    var a, D;
    if (typeof u == "string") return JSON.stringify(u);
    if (Array.isArray(u)) {
      let l = u.map(n).filter(Boolean);
      return l.length === 1 ? l[0] : `[${l.join(", ")}]`;
    }
    if (u.type === B) {
      let l = ((a = s == null ? void 0 : s[i + 1]) == null ? void 0 : a.type) === b;
      return u.literal ? l ? "literalline" : "literallineWithoutBreakParent" : u.hard ? l ? "hardline" : "hardlineWithoutBreakParent" : u.soft ? "softline" : "line";
    }
    if (u.type === b) return ((D = s == null ? void 0 : s[i - 1]) == null ? void 0 : D.type) === B && s[i - 1].hard ? void 0 : "breakParent";
    if (u.type === I) return "trim";
    if (u.type === L) return "indent(" + n(u.contents) + ")";
    if (u.type === P) return u.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + n(u.contents) + ")" : u.n < 0 ? "dedent(" + n(u.contents) + ")" : u.n.type === "root" ? "markAsRoot(" + n(u.contents) + ")" : "align(" + JSON.stringify(u.n) + ", " + n(u.contents) + ")";
    if (u.type === _) return "ifBreak(" + n(u.breakContents) + (u.flatContents ? ", " + n(u.flatContents) : "") + (u.groupId ? (u.flatContents ? "" : ', ""') + `, { groupId: ${o(u.groupId)} }` : "") + ")";
    if (u.type === R) {
      let l = [];
      u.negate && l.push("negate: true"), u.groupId && l.push(`groupId: ${o(u.groupId)}`);
      let d = l.length > 0 ? `, { ${l.join(", ")} }` : "";
      return `indentIfBreak(${n(u.contents)}${d})`;
    }
    if (u.type === x) {
      let l = [];
      u.break && u.break !== "propagated" && l.push("shouldBreak: true"), u.id && l.push(`id: ${o(u.id)}`);
      let d = l.length > 0 ? `, { ${l.join(", ")} }` : "";
      return u.expandedStates ? `conditionalGroup([${u.expandedStates.map((f) => n(f)).join(",")}]${d})` : `group(${n(u.contents)}${d})`;
    }
    if (u.type === S) return `fill([${u.parts.map((l) => n(l)).join(", ")}])`;
    if (u.type === Y) return "lineSuffix(" + n(u.contents) + ")";
    if (u.type === j) return "lineSuffixBoundary";
    if (u.type === N) return `label(${JSON.stringify(u.label)}, ${n(u.contents)})`;
    throw new Error("Unknown doc type " + u.type);
  }
  function o(u) {
    if (typeof u != "symbol") return JSON.stringify(String(u));
    if (u in t) return t[u];
    let i = u.description || "symbol";
    for (let s = 0; ; s++) {
      let a = i + (s > 0 ? ` #${s}` : "");
      if (!r.has(a)) return r.add(a), t[u] = `Symbol.for(${JSON.stringify(a)})`;
    }
  }
}
var Yu = (e, t, r) => {
  if (!(e && t == null)) return Array.isArray(t) || typeof t == "string" ? t[r < 0 ? t.length + r : r] : t.at(r);
};
var y = Yu;
var Sr = () => /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
function Nr(e) {
  return e === 12288 || e >= 65281 && e <= 65376 || e >= 65504 && e <= 65510;
}
function Tr(e) {
  return e >= 4352 && e <= 4447 || e === 8986 || e === 8987 || e === 9001 || e === 9002 || e >= 9193 && e <= 9196 || e === 9200 || e === 9203 || e === 9725 || e === 9726 || e === 9748 || e === 9749 || e >= 9800 && e <= 9811 || e === 9855 || e === 9875 || e === 9889 || e === 9898 || e === 9899 || e === 9917 || e === 9918 || e === 9924 || e === 9925 || e === 9934 || e === 9940 || e === 9962 || e === 9970 || e === 9971 || e === 9973 || e === 9978 || e === 9981 || e === 9989 || e === 9994 || e === 9995 || e === 10024 || e === 10060 || e === 10062 || e >= 10067 && e <= 10069 || e === 10071 || e >= 10133 && e <= 10135 || e === 10160 || e === 10175 || e === 11035 || e === 11036 || e === 11088 || e === 11093 || e >= 11904 && e <= 11929 || e >= 11931 && e <= 12019 || e >= 12032 && e <= 12245 || e >= 12272 && e <= 12287 || e >= 12289 && e <= 12350 || e >= 12353 && e <= 12438 || e >= 12441 && e <= 12543 || e >= 12549 && e <= 12591 || e >= 12593 && e <= 12686 || e >= 12688 && e <= 12771 || e >= 12783 && e <= 12830 || e >= 12832 && e <= 12871 || e >= 12880 && e <= 19903 || e >= 19968 && e <= 42124 || e >= 42128 && e <= 42182 || e >= 43360 && e <= 43388 || e >= 44032 && e <= 55203 || e >= 63744 && e <= 64255 || e >= 65040 && e <= 65049 || e >= 65072 && e <= 65106 || e >= 65108 && e <= 65126 || e >= 65128 && e <= 65131 || e >= 94176 && e <= 94180 || e === 94192 || e === 94193 || e >= 94208 && e <= 100343 || e >= 100352 && e <= 101589 || e >= 101632 && e <= 101640 || e >= 110576 && e <= 110579 || e >= 110581 && e <= 110587 || e === 110589 || e === 110590 || e >= 110592 && e <= 110882 || e === 110898 || e >= 110928 && e <= 110930 || e === 110933 || e >= 110948 && e <= 110951 || e >= 110960 && e <= 111355 || e === 126980 || e === 127183 || e === 127374 || e >= 127377 && e <= 127386 || e >= 127488 && e <= 127490 || e >= 127504 && e <= 127547 || e >= 127552 && e <= 127560 || e === 127568 || e === 127569 || e >= 127584 && e <= 127589 || e >= 127744 && e <= 127776 || e >= 127789 && e <= 127797 || e >= 127799 && e <= 127868 || e >= 127870 && e <= 127891 || e >= 127904 && e <= 127946 || e >= 127951 && e <= 127955 || e >= 127968 && e <= 127984 || e === 127988 || e >= 127992 && e <= 128062 || e === 128064 || e >= 128066 && e <= 128252 || e >= 128255 && e <= 128317 || e >= 128331 && e <= 128334 || e >= 128336 && e <= 128359 || e === 128378 || e === 128405 || e === 128406 || e === 128420 || e >= 128507 && e <= 128591 || e >= 128640 && e <= 128709 || e === 128716 || e >= 128720 && e <= 128722 || e >= 128725 && e <= 128727 || e >= 128732 && e <= 128735 || e === 128747 || e === 128748 || e >= 128756 && e <= 128764 || e >= 128992 && e <= 129003 || e === 129008 || e >= 129292 && e <= 129338 || e >= 129340 && e <= 129349 || e >= 129351 && e <= 129535 || e >= 129648 && e <= 129660 || e >= 129664 && e <= 129672 || e >= 129680 && e <= 129725 || e >= 129727 && e <= 129733 || e >= 129742 && e <= 129755 || e >= 129760 && e <= 129768 || e >= 129776 && e <= 129784 || e >= 131072 && e <= 196605 || e >= 196608 && e <= 262141;
}
var kr = (e) => !(Nr(e) || Tr(e));
var ju = /[^\x20-\x7F]/u;
function Hu(e) {
  if (!e) return 0;
  if (!ju.test(e)) return e.length;
  e = e.replace(Sr(), "  ");
  let t = 0;
  for (let r of e) {
    let n = r.codePointAt(0);
    n <= 31 || n >= 127 && n <= 159 || n >= 768 && n <= 879 || (t += kr(n) ? 1 : 2);
  }
  return t;
}
var Oe = Hu;
function Ne(e, t) {
  if (typeof e == "string") return t(e);
  let r = /* @__PURE__ */ new Map();
  return n(e);
  function n(u) {
    if (r.has(u)) return r.get(u);
    let i = o(u);
    return r.set(u, i), i;
  }
  function o(u) {
    switch (G(u)) {
      case W:
        return t(u.map(n));
      case S:
        return t({ ...u, parts: u.parts.map(n) });
      case _:
        return t({ ...u, breakContents: n(u.breakContents), flatContents: n(u.flatContents) });
      case x: {
        let { expandedStates: i, contents: s } = u;
        return i ? (i = i.map(n), s = i[0]) : s = n(s), t({ ...u, contents: s, expandedStates: i });
      }
      case P:
      case L:
      case R:
      case N:
      case Y:
        return t({ ...u, contents: n(u.contents) });
      case U:
      case z:
      case I:
      case j:
      case B:
      case b:
        return t(u);
      default:
        throw new Q(u);
    }
  }
}
function Xe(e, t, r) {
  let n = r, o = false;
  function u(i) {
    if (o) return false;
    let s = t(i);
    s !== void 0 && (o = true, n = s);
  }
  return we(e, u), n;
}
function Wu(e) {
  if (e.type === x && e.break || e.type === B && e.hard || e.type === b) return true;
}
function Ir(e) {
  return Xe(e, Wu, false);
}
function Lr(e) {
  if (e.length > 0) {
    let t = y(false, e, -1);
    !t.expandedStates && !t.break && (t.break = "propagated");
  }
  return null;
}
function Rr(e) {
  let t = /* @__PURE__ */ new Set(), r = [];
  function n(u) {
    if (u.type === b && Lr(r), u.type === x) {
      if (r.push(u), t.has(u)) return false;
      t.add(u);
    }
  }
  function o(u) {
    u.type === x && r.pop().break && Lr(r);
  }
  we(e, n, o, true);
}
function Mu(e) {
  return e.type === B && !e.hard ? e.soft ? "" : " " : e.type === _ ? e.flatContents : e;
}
function Yr(e) {
  return Ne(e, Mu);
}
function Pr(e) {
  for (e = [...e]; e.length >= 2 && y(false, e, -2).type === B && y(false, e, -1).type === b; ) e.length -= 2;
  if (e.length > 0) {
    let t = Se(y(false, e, -1));
    e[e.length - 1] = t;
  }
  return e;
}
function Se(e) {
  switch (G(e)) {
    case L:
    case R:
    case x:
    case Y:
    case N: {
      let t = Se(e.contents);
      return { ...e, contents: t };
    }
    case _:
      return { ...e, breakContents: Se(e.breakContents), flatContents: Se(e.flatContents) };
    case S:
      return { ...e, parts: Pr(e.parts) };
    case W:
      return Pr(e);
    case U:
      return e.replace(/[\n\r]*$/u, "");
    case P:
    case z:
    case I:
    case j:
    case B:
    case b:
      break;
    default:
      throw new Q(e);
  }
  return e;
}
function Ze(e) {
  return Se(Vu(e));
}
function $u(e) {
  switch (G(e)) {
    case S:
      if (e.parts.every((t) => t === "")) return "";
      break;
    case x:
      if (!e.contents && !e.id && !e.break && !e.expandedStates) return "";
      if (e.contents.type === x && e.contents.id === e.id && e.contents.break === e.break && e.contents.expandedStates === e.expandedStates) return e.contents;
      break;
    case P:
    case L:
    case R:
    case Y:
      if (!e.contents) return "";
      break;
    case _:
      if (!e.flatContents && !e.breakContents) return "";
      break;
    case W: {
      let t = [];
      for (let r of e) {
        if (!r) continue;
        let [n, ...o] = Array.isArray(r) ? r : [r];
        typeof n == "string" && typeof y(false, t, -1) == "string" ? t[t.length - 1] += n : t.push(n), t.push(...o);
      }
      return t.length === 0 ? "" : t.length === 1 ? t[0] : t;
    }
    case U:
    case z:
    case I:
    case j:
    case B:
    case N:
    case b:
      break;
    default:
      throw new Q(e);
  }
  return e;
}
function Vu(e) {
  return Ne(e, (t) => $u(t));
}
function jr(e, t = qe) {
  return Ne(e, (r) => typeof r == "string" ? be(t, r.split(`
`)) : r);
}
function Uu(e) {
  if (e.type === B) return true;
}
function Hr(e) {
  return Xe(e, Uu, false);
}
function Qe(e, t) {
  return e.type === N ? { ...e, contents: t(e.contents) } : t(e);
}
var H = Symbol("MODE_BREAK");
var J = Symbol("MODE_FLAT");
var Te = Symbol("cursor");
function Wr() {
  return { value: "", length: 0, queue: [] };
}
function zu(e, t) {
  return bt(e, { type: "indent" }, t);
}
function Gu(e, t, r) {
  return t === Number.NEGATIVE_INFINITY ? e.root || Wr() : t < 0 ? bt(e, { type: "dedent" }, r) : t ? t.type === "root" ? { ...e, root: e } : bt(e, { type: typeof t == "string" ? "stringAlign" : "numberAlign", n: t }, r) : e;
}
function bt(e, t, r) {
  let n = t.type === "dedent" ? e.queue.slice(0, -1) : [...e.queue, t], o = "", u = 0, i = 0, s = 0;
  for (let c2 of n) switch (c2.type) {
    case "indent":
      l(), r.useTabs ? a(1) : D(r.tabWidth);
      break;
    case "stringAlign":
      l(), o += c2.n, u += c2.n.length;
      break;
    case "numberAlign":
      i += 1, s += c2.n;
      break;
    default:
      throw new Error(`Unexpected type '${c2.type}'`);
  }
  return f(), { ...e, value: o, length: u, queue: n };
  function a(c2) {
    o += "	".repeat(c2), u += r.tabWidth * c2;
  }
  function D(c2) {
    o += " ".repeat(c2), u += c2;
  }
  function l() {
    r.useTabs ? d() : f();
  }
  function d() {
    i > 0 && a(i), p();
  }
  function f() {
    s > 0 && D(s), p();
  }
  function p() {
    i = 0, s = 0;
  }
}
function Ot(e) {
  let t = 0, r = 0, n = e.length;
  e: for (; n--; ) {
    let o = e[n];
    if (o === Te) {
      r++;
      continue;
    }
    for (let u = o.length - 1; u >= 0; u--) {
      let i = o[u];
      if (i === " " || i === "	") t++;
      else {
        e[n] = o.slice(0, u + 1);
        break e;
      }
    }
  }
  if (t > 0 || r > 0) for (e.length = n + 1; r-- > 0; ) e.push(Te);
  return t;
}
function et(e, t, r, n, o, u) {
  if (r === Number.POSITIVE_INFINITY) return true;
  let i = t.length, s = [e], a = [];
  for (; r >= 0; ) {
    if (s.length === 0) {
      if (i === 0) return true;
      s.push(t[--i]);
      continue;
    }
    let { mode: D, doc: l } = s.pop(), d = G(l);
    switch (d) {
      case U:
        a.push(l), r -= Oe(l);
        break;
      case W:
      case S: {
        let f = d === W ? l : l.parts;
        for (let p = f.length - 1; p >= 0; p--) s.push({ mode: D, doc: f[p] });
        break;
      }
      case L:
      case P:
      case R:
      case N:
        s.push({ mode: D, doc: l.contents });
        break;
      case I:
        r += Ot(a);
        break;
      case x: {
        if (u && l.break) return false;
        let f = l.break ? H : D, p = l.expandedStates && f === H ? y(false, l.expandedStates, -1) : l.contents;
        s.push({ mode: f, doc: p });
        break;
      }
      case _: {
        let p = (l.groupId ? o[l.groupId] || J : D) === H ? l.breakContents : l.flatContents;
        p && s.push({ mode: D, doc: p });
        break;
      }
      case B:
        if (D === H || l.hard) return true;
        l.soft || (a.push(" "), r--);
        break;
      case Y:
        n = true;
        break;
      case j:
        if (n) return false;
        break;
    }
  }
  return false;
}
function Fe(e, t) {
  let r = {}, n = t.printWidth, o = Be(t.endOfLine), u = 0, i = [{ ind: Wr(), mode: H, doc: e }], s = [], a = false, D = [], l = 0;
  for (Rr(e); i.length > 0; ) {
    let { ind: f, mode: p, doc: c2 } = i.pop();
    switch (G(c2)) {
      case U: {
        let F = o !== `
` ? ne(false, c2, `
`, o) : c2;
        s.push(F), i.length > 0 && (u += Oe(F));
        break;
      }
      case W:
        for (let F = c2.length - 1; F >= 0; F--) i.push({ ind: f, mode: p, doc: c2[F] });
        break;
      case z:
        if (l >= 2) throw new Error("There are too many 'cursor' in doc.");
        s.push(Te), l++;
        break;
      case L:
        i.push({ ind: zu(f, t), mode: p, doc: c2.contents });
        break;
      case P:
        i.push({ ind: Gu(f, c2.n, t), mode: p, doc: c2.contents });
        break;
      case I:
        u -= Ot(s);
        break;
      case x:
        switch (p) {
          case J:
            if (!a) {
              i.push({ ind: f, mode: c2.break ? H : J, doc: c2.contents });
              break;
            }
          case H: {
            a = false;
            let F = { ind: f, mode: J, doc: c2.contents }, m = n - u, E = D.length > 0;
            if (!c2.break && et(F, i, m, E, r)) i.push(F);
            else if (c2.expandedStates) {
              let A = y(false, c2.expandedStates, -1);
              if (c2.break) {
                i.push({ ind: f, mode: H, doc: A });
                break;
              } else for (let w = 1; w < c2.expandedStates.length + 1; w++) if (w >= c2.expandedStates.length) {
                i.push({ ind: f, mode: H, doc: A });
                break;
              } else {
                let h = c2.expandedStates[w], C = { ind: f, mode: J, doc: h };
                if (et(C, i, m, E, r)) {
                  i.push(C);
                  break;
                }
              }
            } else i.push({ ind: f, mode: H, doc: c2.contents });
            break;
          }
        }
        c2.id && (r[c2.id] = y(false, i, -1).mode);
        break;
      case S: {
        let F = n - u, { parts: m } = c2;
        if (m.length === 0) break;
        let [E, A] = m, w = { ind: f, mode: J, doc: E }, h = { ind: f, mode: H, doc: E }, C = et(w, [], F, D.length > 0, r, true);
        if (m.length === 1) {
          C ? i.push(w) : i.push(h);
          break;
        }
        let k = { ind: f, mode: J, doc: A }, v = { ind: f, mode: H, doc: A };
        if (m.length === 2) {
          C ? i.push(k, w) : i.push(v, h);
          break;
        }
        m.splice(0, 2);
        let $ = { ind: f, mode: p, doc: Ge(m) }, ye = m[0];
        et({ ind: f, mode: J, doc: [E, A, ye] }, [], F, D.length > 0, r, true) ? i.push($, k, w) : C ? i.push($, v, w) : i.push($, v, h);
        break;
      }
      case _:
      case R: {
        let F = c2.groupId ? r[c2.groupId] : p;
        if (F === H) {
          let m = c2.type === _ ? c2.breakContents : c2.negate ? c2.contents : De(c2.contents);
          m && i.push({ ind: f, mode: p, doc: m });
        }
        if (F === J) {
          let m = c2.type === _ ? c2.flatContents : c2.negate ? De(c2.contents) : c2.contents;
          m && i.push({ ind: f, mode: p, doc: m });
        }
        break;
      }
      case Y:
        D.push({ ind: f, mode: p, doc: c2.contents });
        break;
      case j:
        D.length > 0 && i.push({ ind: f, mode: p, doc: _e });
        break;
      case B:
        switch (p) {
          case J:
            if (c2.hard) a = true;
            else {
              c2.soft || (s.push(" "), u += 1);
              break;
            }
          case H:
            if (D.length > 0) {
              i.push({ ind: f, mode: p, doc: c2 }, ...D.reverse()), D.length = 0;
              break;
            }
            c2.literal ? f.root ? (s.push(o, f.root.value), u = f.root.length) : (s.push(o), u = 0) : (u -= Ot(s), s.push(o + f.value), u = f.length);
            break;
        }
        break;
      case N:
        i.push({ ind: f, mode: p, doc: c2.contents });
        break;
      case b:
        break;
      default:
        throw new Q(c2);
    }
    i.length === 0 && D.length > 0 && (i.push(...D.reverse()), D.length = 0);
  }
  let d = s.indexOf(Te);
  if (d !== -1) {
    let f = s.indexOf(Te, d + 1), p = s.slice(0, d).join(""), c2 = s.slice(d + 1, f).join(""), F = s.slice(f + 1).join("");
    return { formatted: p + c2 + F, cursorNodeStart: p.length, cursorNodeText: c2 };
  }
  return { formatted: s.join("") };
}
function Ku(e, t, r = 0) {
  let n = 0;
  for (let o = r; o < e.length; ++o) e[o] === "	" ? n = n + t - n % t : n++;
  return n;
}
var me = Ku;
var te;
var Nt;
var tt;
var St = class {
  constructor(t) {
    Dr(this, te);
    this.stack = [t];
  }
  get key() {
    let { stack: t, siblings: r } = this;
    return y(false, t, r === null ? -2 : -4) ?? null;
  }
  get index() {
    return this.siblings === null ? null : y(false, this.stack, -2);
  }
  get node() {
    return y(false, this.stack, -1);
  }
  get parent() {
    return this.getNode(1);
  }
  get grandparent() {
    return this.getNode(2);
  }
  get isInArray() {
    return this.siblings !== null;
  }
  get siblings() {
    let { stack: t } = this, r = y(false, t, -3);
    return Array.isArray(r) ? r : null;
  }
  get next() {
    let { siblings: t } = this;
    return t === null ? null : t[this.index + 1];
  }
  get previous() {
    let { siblings: t } = this;
    return t === null ? null : t[this.index - 1];
  }
  get isFirst() {
    return this.index === 0;
  }
  get isLast() {
    let { siblings: t, index: r } = this;
    return t !== null && r === t.length - 1;
  }
  get isRoot() {
    return this.stack.length === 1;
  }
  get root() {
    return this.stack[0];
  }
  get ancestors() {
    return [...pe(this, te, tt).call(this)];
  }
  getName() {
    let { stack: t } = this, { length: r } = t;
    return r > 1 ? y(false, t, -2) : null;
  }
  getValue() {
    return y(false, this.stack, -1);
  }
  getNode(t = 0) {
    let r = pe(this, te, Nt).call(this, t);
    return r === -1 ? null : this.stack[r];
  }
  getParentNode(t = 0) {
    return this.getNode(t + 1);
  }
  call(t, ...r) {
    let { stack: n } = this, { length: o } = n, u = y(false, n, -1);
    for (let i of r) u = u[i], n.push(i, u);
    try {
      return t(this);
    } finally {
      n.length = o;
    }
  }
  callParent(t, r = 0) {
    let n = pe(this, te, Nt).call(this, r + 1), o = this.stack.splice(n + 1);
    try {
      return t(this);
    } finally {
      this.stack.push(...o);
    }
  }
  each(t, ...r) {
    let { stack: n } = this, { length: o } = n, u = y(false, n, -1);
    for (let i of r) u = u[i], n.push(i, u);
    try {
      for (let i = 0; i < u.length; ++i) n.push(i, u[i]), t(this, i, u), n.length -= 2;
    } finally {
      n.length = o;
    }
  }
  map(t, ...r) {
    let n = [];
    return this.each((o, u, i) => {
      n[u] = t(o, u, i);
    }, ...r), n;
  }
  match(...t) {
    let r = this.stack.length - 1, n = null, o = this.stack[r--];
    for (let u of t) {
      if (o === void 0) return false;
      let i = null;
      if (typeof n == "number" && (i = n, n = this.stack[r--], o = this.stack[r--]), u && !u(o, n, i)) return false;
      n = this.stack[r--], o = this.stack[r--];
    }
    return true;
  }
  findAncestor(t) {
    for (let r of pe(this, te, tt).call(this)) if (t(r)) return r;
  }
  hasAncestor(t) {
    for (let r of pe(this, te, tt).call(this)) if (t(r)) return true;
    return false;
  }
};
te = /* @__PURE__ */ new WeakSet(), Nt = function(t) {
  let { stack: r } = this;
  for (let n = r.length - 1; n >= 0; n -= 2) if (!Array.isArray(r[n]) && --t < 0) return n;
  return -1;
}, tt = function* () {
  let { stack: t } = this;
  for (let r = t.length - 3; r >= 0; r -= 2) {
    let n = t[r];
    Array.isArray(n) || (yield n);
  }
};
var Mr = St;
var $r = new Proxy(() => {
}, { get: () => $r });
var ke = $r;
function qu(e) {
  return e !== null && typeof e == "object";
}
var Vr = qu;
function* Tt(e, t) {
  let { getVisitorKeys: r, filter: n = () => true } = t, o = (u) => Vr(u) && n(u);
  for (let u of r(e)) {
    let i = e[u];
    if (Array.isArray(i)) for (let s of i) o(s) && (yield s);
    else o(i) && (yield i);
  }
}
function* Ur(e, t) {
  let r = [e];
  for (let n = 0; n < r.length; n++) {
    let o = r[n];
    for (let u of Tt(o, t)) yield u, r.push(u);
  }
}
function Ee(e) {
  return (t, r, n) => {
    let o = !!(n != null && n.backwards);
    if (r === false) return false;
    let { length: u } = t, i = r;
    for (; i >= 0 && i < u; ) {
      let s = t.charAt(i);
      if (e instanceof RegExp) {
        if (!e.test(s)) return i;
      } else if (!e.includes(s)) return i;
      o ? i-- : i++;
    }
    return i === -1 || i === u ? i : false;
  };
}
var zr = Ee(/\s/u);
var T = Ee(" 	");
var rt = Ee(",; 	");
var nt = Ee(/[^\n\r]/u);
function Ju(e, t, r) {
  let n = !!(r != null && r.backwards);
  if (t === false) return false;
  let o = e.charAt(t);
  if (n) {
    if (e.charAt(t - 1) === "\r" && o === `
`) return t - 2;
    if (o === `
` || o === "\r" || o === "\u2028" || o === "\u2029") return t - 1;
  } else {
    if (o === "\r" && e.charAt(t + 1) === `
`) return t + 2;
    if (o === `
` || o === "\r" || o === "\u2028" || o === "\u2029") return t + 1;
  }
  return t;
}
var M = Ju;
function Xu(e, t, r = {}) {
  let n = T(e, r.backwards ? t - 1 : t, r), o = M(e, n, r);
  return n !== o;
}
var V = Xu;
function Zu(e) {
  return Array.isArray(e) && e.length > 0;
}
var kt = Zu;
var Gr = /* @__PURE__ */ new Set(["tokens", "comments", "parent", "enclosingNode", "precedingNode", "followingNode"]);
var Qu = (e) => Object.keys(e).filter((t) => !Gr.has(t));
function eo(e) {
  return e ? (t) => e(t, Gr) : Qu;
}
var X = eo;
function to(e) {
  let t = e.type || e.kind || "(unknown type)", r = String(e.name || e.id && (typeof e.id == "object" ? e.id.name : e.id) || e.key && (typeof e.key == "object" ? e.key.name : e.key) || e.value && (typeof e.value == "object" ? "" : String(e.value)) || e.operator || "");
  return r.length > 20 && (r = r.slice(0, 19) + "…"), t + (r ? " " + r : "");
}
function Lt(e, t) {
  (e.comments ?? (e.comments = [])).push(t), t.printed = false, t.nodeDescription = to(e);
}
function ue(e, t) {
  t.leading = true, t.trailing = false, Lt(e, t);
}
function re(e, t, r) {
  t.leading = false, t.trailing = false, r && (t.marker = r), Lt(e, t);
}
function oe(e, t) {
  t.leading = false, t.trailing = true, Lt(e, t);
}
var Pt = /* @__PURE__ */ new WeakMap();
function ut(e, t) {
  if (Pt.has(e)) return Pt.get(e);
  let { printer: { getCommentChildNodes: r, canAttachComment: n, getVisitorKeys: o }, locStart: u, locEnd: i } = t;
  if (!n) return [];
  let s = ((r == null ? void 0 : r(e, t)) ?? [...Tt(e, { getVisitorKeys: X(o) })]).flatMap((a) => n(a) ? [a] : ut(a, t));
  return s.sort((a, D) => u(a) - u(D) || i(a) - i(D)), Pt.set(e, s), s;
}
function qr(e, t, r, n) {
  let { locStart: o, locEnd: u } = r, i = o(t), s = u(t), a = ut(e, r), D, l, d = 0, f = a.length;
  for (; d < f; ) {
    let p = d + f >> 1, c2 = a[p], F = o(c2), m = u(c2);
    if (F <= i && s <= m) return qr(c2, t, r, c2);
    if (m <= i) {
      D = c2, d = p + 1;
      continue;
    }
    if (s <= F) {
      l = c2, f = p;
      continue;
    }
    throw new Error("Comment location overlaps with node location");
  }
  if ((n == null ? void 0 : n.type) === "TemplateLiteral") {
    let { quasis: p } = n, c2 = Rt(p, t, r);
    D && Rt(p, D, r) !== c2 && (D = null), l && Rt(p, l, r) !== c2 && (l = null);
  }
  return { enclosingNode: n, precedingNode: D, followingNode: l };
}
var It = () => false;
function Jr(e, t) {
  let { comments: r } = e;
  if (delete e.comments, !kt(r) || !t.printer.canAttachComment) return;
  let n = [], { locStart: o, locEnd: u, printer: { experimentalFeatures: { avoidAstMutation: i = false } = {}, handleComments: s = {} }, originalText: a } = t, { ownLine: D = It, endOfLine: l = It, remaining: d = It } = s, f = r.map((p, c2) => ({ ...qr(e, p, t), comment: p, text: a, options: t, ast: e, isLastComment: r.length - 1 === c2 }));
  for (let [p, c2] of f.entries()) {
    let { comment: F, precedingNode: m, enclosingNode: E, followingNode: A, text: w, options: h, ast: C, isLastComment: k } = c2;
    if (h.parser === "json" || h.parser === "json5" || h.parser === "jsonc" || h.parser === "__js_expression" || h.parser === "__ts_expression" || h.parser === "__vue_expression" || h.parser === "__vue_ts_expression") {
      if (o(F) - o(C) <= 0) {
        ue(C, F);
        continue;
      }
      if (u(F) - u(C) >= 0) {
        oe(C, F);
        continue;
      }
    }
    let v;
    if (i ? v = [c2] : (F.enclosingNode = E, F.precedingNode = m, F.followingNode = A, v = [F, w, h, C, k]), ro(w, h, f, p)) F.placement = "ownLine", D(...v) || (A ? ue(A, F) : m ? oe(m, F) : E ? re(E, F) : re(C, F));
    else if (no(w, h, f, p)) F.placement = "endOfLine", l(...v) || (m ? oe(m, F) : A ? ue(A, F) : E ? re(E, F) : re(C, F));
    else if (F.placement = "remaining", !d(...v)) if (m && A) {
      let $ = n.length;
      $ > 0 && n[$ - 1].followingNode !== A && Kr(n, h), n.push(c2);
    } else m ? oe(m, F) : A ? ue(A, F) : E ? re(E, F) : re(C, F);
  }
  if (Kr(n, t), !i) for (let p of r) delete p.precedingNode, delete p.enclosingNode, delete p.followingNode;
}
var Xr = (e) => !/[\S\n\u2028\u2029]/u.test(e);
function ro(e, t, r, n) {
  let { comment: o, precedingNode: u } = r[n], { locStart: i, locEnd: s } = t, a = i(o);
  if (u) for (let D = n - 1; D >= 0; D--) {
    let { comment: l, precedingNode: d } = r[D];
    if (d !== u || !Xr(e.slice(s(l), a))) break;
    a = i(l);
  }
  return V(e, a, { backwards: true });
}
function no(e, t, r, n) {
  let { comment: o, followingNode: u } = r[n], { locStart: i, locEnd: s } = t, a = s(o);
  if (u) for (let D = n + 1; D < r.length; D++) {
    let { comment: l, followingNode: d } = r[D];
    if (d !== u || !Xr(e.slice(a, i(l)))) break;
    a = s(l);
  }
  return V(e, a);
}
function Kr(e, t) {
  var s, a;
  let r = e.length;
  if (r === 0) return;
  let { precedingNode: n, followingNode: o } = e[0], u = t.locStart(o), i;
  for (i = r; i > 0; --i) {
    let { comment: D, precedingNode: l, followingNode: d } = e[i - 1];
    ke.strictEqual(l, n), ke.strictEqual(d, o);
    let f = t.originalText.slice(t.locEnd(D), u);
    if (((a = (s = t.printer).isGap) == null ? void 0 : a.call(s, f, t)) ?? /^[\s(]*$/u.test(f)) u = t.locStart(D);
    else break;
  }
  for (let [D, { comment: l }] of e.entries()) D < i ? oe(n, l) : ue(o, l);
  for (let D of [n, o]) D.comments && D.comments.length > 1 && D.comments.sort((l, d) => t.locStart(l) - t.locStart(d));
  e.length = 0;
}
function Rt(e, t, r) {
  let n = r.locStart(t) - 1;
  for (let o = 1; o < e.length; ++o) if (n < r.locStart(e[o])) return o - 1;
  return 0;
}
function uo(e, t) {
  let r = t - 1;
  r = T(e, r, { backwards: true }), r = M(e, r, { backwards: true }), r = T(e, r, { backwards: true });
  let n = M(e, r, { backwards: true });
  return r !== n;
}
var Le = uo;
function Zr(e, t) {
  let r = e.node;
  return r.printed = true, t.printer.printComment(e, t);
}
function oo(e, t) {
  var l;
  let r = e.node, n = [Zr(e, t)], { printer: o, originalText: u, locStart: i, locEnd: s } = t;
  if ((l = o.isBlockComment) == null ? void 0 : l.call(o, r)) {
    let d = V(u, s(r)) ? V(u, i(r), { backwards: true }) ? q : Ke : " ";
    n.push(d);
  } else n.push(q);
  let D = M(u, T(u, s(r)));
  return D !== false && V(u, D) && n.push(q), n;
}
function io(e, t, r) {
  var D;
  let n = e.node, o = Zr(e, t), { printer: u, originalText: i, locStart: s } = t, a = (D = u.isBlockComment) == null ? void 0 : D.call(u, n);
  if (r != null && r.hasLineSuffix && !(r != null && r.isBlock) || V(i, s(n), { backwards: true })) {
    let l = Le(i, s(n));
    return { doc: xe([q, l ? q : "", o]), isBlock: a, hasLineSuffix: true };
  }
  return !a || r != null && r.hasLineSuffix ? { doc: [xe([" ", o]), de], isBlock: a, hasLineSuffix: true } : { doc: [" ", o], isBlock: a, hasLineSuffix: false };
}
function so(e, t) {
  let r = e.node;
  if (!r) return {};
  let n = t[Symbol.for("printedComments")];
  if ((r.comments || []).filter((a) => !n.has(a)).length === 0) return { leading: "", trailing: "" };
  let u = [], i = [], s;
  return e.each(() => {
    let a = e.node;
    if (n != null && n.has(a)) return;
    let { leading: D, trailing: l } = a;
    D ? u.push(oo(e, t)) : l && (s = io(e, t, s), i.push(s.doc));
  }, "comments"), { leading: u, trailing: i };
}
function Qr(e, t, r) {
  let { leading: n, trailing: o } = so(e, r);
  return !n && !o ? t : Qe(t, (u) => [n, u, o]);
}
function en(e) {
  let { [Symbol.for("comments")]: t, [Symbol.for("printedComments")]: r } = e;
  for (let n of t) {
    if (!n.printed && !r.has(n)) throw new Error('Comment "' + n.value.trim() + '" was not printed. Please report this error!');
    delete n.printed;
  }
}
function ao(e) {
  return () => {
  };
}
var tn = ao;
var Pe = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "ConfigError");
  }
};
var Ie = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "UndefinedParserError");
  }
};
var rn = { cursorOffset: { category: "Special", type: "int", default: -1, range: { start: -1, end: 1 / 0, step: 1 }, description: "Print (to stderr) where a cursor at the given position would move to after formatting.", cliCategory: "Editor" }, endOfLine: { category: "Global", type: "choice", default: "lf", description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: `Maintain existing
(mixed values within one file are normalised by looking at what's used after the first line)` }] }, filepath: { category: "Special", type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: "Other", cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { category: "Special", type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: "Other" }, parser: { category: "Global", type: "choice", default: void 0, description: "Which parser to use.", exception: (e) => typeof e == "string" || typeof e == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", description: "JavaScript" }, { value: "babel-flow", description: "Flow" }, { value: "babel-ts", description: "TypeScript" }, { value: "typescript", description: "TypeScript" }, { value: "acorn", description: "JavaScript" }, { value: "espree", description: "JavaScript" }, { value: "meriyah", description: "JavaScript" }, { value: "css", description: "CSS" }, { value: "less", description: "Less" }, { value: "scss", description: "SCSS" }, { value: "json", description: "JSON" }, { value: "json5", description: "JSON5" }, { value: "jsonc", description: "JSON with Comments" }, { value: "json-stringify", description: "JSON.stringify" }, { value: "graphql", description: "GraphQL" }, { value: "markdown", description: "Markdown" }, { value: "mdx", description: "MDX" }, { value: "vue", description: "Vue" }, { value: "yaml", description: "YAML" }, { value: "glimmer", description: "Ember / Handlebars" }, { value: "html", description: "HTML" }, { value: "angular", description: "Angular" }, { value: "lwc", description: "Lightning Web Components" }] }, plugins: { type: "path", array: true, default: [{ value: [] }], category: "Global", description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (e) => typeof e == "string" || typeof e == "object", cliName: "plugin", cliCategory: "Config" }, printWidth: { category: "Global", type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: 1 / 0, step: 1 } }, rangeEnd: { category: "Special", type: "int", default: 1 / 0, range: { start: 0, end: 1 / 0, step: 1 }, description: `Format code ending at a given character offset (exclusive).
The range will extend forwards to the end of the selected statement.`, cliCategory: "Editor" }, rangeStart: { category: "Special", type: "int", default: 0, range: { start: 0, end: 1 / 0, step: 1 }, description: `Format code starting at a given character offset.
The range will extend backwards to the start of the first line containing the selected statement.`, cliCategory: "Editor" }, requirePragma: { category: "Special", type: "boolean", default: false, description: `Require either '@prettier' or '@format' to be present in the file's first docblock comment
in order for it to be formatted.`, cliCategory: "Other" }, tabWidth: { type: "int", category: "Global", default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: 1 / 0, step: 1 } }, useTabs: { category: "Global", type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { category: "Global", type: "choice", default: "auto", description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
function ot({ plugins: e = [], showDeprecated: t = false } = {}) {
  let r = e.flatMap((o) => o.languages ?? []), n = [];
  for (let o of lo(Object.assign({}, ...e.map(({ options: u }) => u), rn))) !t && o.deprecated || (Array.isArray(o.choices) && (t || (o.choices = o.choices.filter((u) => !u.deprecated)), o.name === "parser" && (o.choices = [...o.choices, ...Do(o.choices, r, e)])), o.pluginDefaults = Object.fromEntries(e.filter((u) => {
    var i;
    return ((i = u.defaultOptions) == null ? void 0 : i[o.name]) !== void 0;
  }).map((u) => [u.name, u.defaultOptions[o.name]])), n.push(o));
  return { languages: r, options: n };
}
function* Do(e, t, r) {
  let n = new Set(e.map((o) => o.value));
  for (let o of t) if (o.parsers) {
    for (let u of o.parsers) if (!n.has(u)) {
      n.add(u);
      let i = r.find((a) => a.parsers && Object.prototype.hasOwnProperty.call(a.parsers, u)), s = o.name;
      i != null && i.name && (s += ` (plugin: ${i.name})`), yield { value: u, description: s };
    }
  }
}
function lo(e) {
  let t = [];
  for (let [r, n] of Object.entries(e)) {
    let o = { name: r, ...n };
    Array.isArray(o.default) && (o.default = y(false, o.default, -1).value), t.push(o);
  }
  return t;
}
var co = (e) => String(e).split(/[/\\]/u).pop();
function nn(e, t) {
  if (!t) return;
  let r = co(t).toLowerCase();
  return e.find(({ filenames: n }) => n == null ? void 0 : n.some((o) => o.toLowerCase() === r)) ?? e.find(({ extensions: n }) => n == null ? void 0 : n.some((o) => r.endsWith(o)));
}
function fo(e, t) {
  if (t) return e.find(({ name: r }) => r.toLowerCase() === t) ?? e.find(({ aliases: r }) => r == null ? void 0 : r.includes(t)) ?? e.find(({ extensions: r }) => r == null ? void 0 : r.includes(`.${t}`));
}
function po(e, t) {
  let r = e.plugins.flatMap((o) => o.languages ?? []), n = fo(r, t.language) ?? nn(r, t.physicalFile) ?? nn(r, t.file) ?? (t.physicalFile, void 0);
  return n == null ? void 0 : n.parsers[0];
}
var un = po;
var ie = { key: (e) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(e) ? e : JSON.stringify(e), value(e) {
  if (e === null || typeof e != "object") return JSON.stringify(e);
  if (Array.isArray(e)) return `[${e.map((r) => ie.value(r)).join(", ")}]`;
  let t = Object.keys(e);
  return t.length === 0 ? "{}" : `{ ${t.map((r) => `${ie.key(r)}: ${ie.value(e[r])}`).join(", ")} }`;
}, pair: ({ key: e, value: t }) => ie.value({ [e]: t }) };
var Yt = Me(it(), 1);
var an = (e, t, { descriptor: r }) => {
  let n = [`${Yt.default.yellow(typeof e == "string" ? r.key(e) : r.pair(e))} is deprecated`];
  return t && n.push(`we now treat it as ${Yt.default.blue(typeof t == "string" ? r.key(t) : r.pair(t))}`), n.join("; ") + ".";
};
var le = Me(it(), 1);
var st = Symbol.for("vnopts.VALUE_NOT_EXIST");
var he = Symbol.for("vnopts.VALUE_UNCHANGED");
var Dn = " ".repeat(2);
var cn = (e, t, r) => {
  let { text: n, list: o } = r.normalizeExpectedResult(r.schemas[e].expected(r)), u = [];
  return n && u.push(ln(e, t, n, r.descriptor)), o && u.push([ln(e, t, o.title, r.descriptor)].concat(o.values.map((i) => fn(i, r.loggerPrintWidth))).join(`
`)), pn(u, r.loggerPrintWidth);
};
function ln(e, t, r, n) {
  return [`Invalid ${le.default.red(n.key(e))} value.`, `Expected ${le.default.blue(r)},`, `but received ${t === st ? le.default.gray("nothing") : le.default.red(n.value(t))}.`].join(" ");
}
function fn({ text: e, list: t }, r) {
  let n = [];
  return e && n.push(`- ${le.default.blue(e)}`), t && n.push([`- ${le.default.blue(t.title)}:`].concat(t.values.map((o) => fn(o, r - Dn.length).replace(/^|\n/g, `$&${Dn}`))).join(`
`)), pn(n, r);
}
function pn(e, t) {
  if (e.length === 1) return e[0];
  let [r, n] = e, [o, u] = e.map((i) => i.split(`
`, 1)[0].length);
  return o > t && o > u ? n : r;
}
var Wt = Me(it(), 1);
var jt = [];
var dn = [];
function Ht(e, t) {
  if (e === t) return 0;
  let r = e;
  e.length > t.length && (e = t, t = r);
  let n = e.length, o = t.length;
  for (; n > 0 && e.charCodeAt(~-n) === t.charCodeAt(~-o); ) n--, o--;
  let u = 0;
  for (; u < n && e.charCodeAt(u) === t.charCodeAt(u); ) u++;
  if (n -= u, o -= u, n === 0) return o;
  let i, s, a, D, l = 0, d = 0;
  for (; l < n; ) dn[l] = e.charCodeAt(u + l), jt[l] = ++l;
  for (; d < o; ) for (i = t.charCodeAt(u + d), a = d++, s = d, l = 0; l < n; l++) D = i === dn[l] ? a : a + 1, a = jt[l], s = jt[l] = a > s ? D > s ? s + 1 : D : D > a ? a + 1 : D;
  return s;
}
var at = (e, t, { descriptor: r, logger: n, schemas: o }) => {
  let u = [`Ignored unknown option ${Wt.default.yellow(r.pair({ key: e, value: t }))}.`], i = Object.keys(o).sort().find((s) => Ht(e, s) < 3);
  i && u.push(`Did you mean ${Wt.default.blue(r.key(i))}?`), n.warn(u.join(" "));
};
var Fo = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
function mo(e, t) {
  let r = new e(t), n = Object.create(r);
  for (let o of Fo) o in t && (n[o] = Eo(t[o], r, O.prototype[o].length));
  return n;
}
var O = class {
  static create(t) {
    return mo(this, t);
  }
  constructor(t) {
    this.name = t.name;
  }
  default(t) {
  }
  expected(t) {
    return "nothing";
  }
  validate(t, r) {
    return false;
  }
  deprecated(t, r) {
    return false;
  }
  forward(t, r) {
  }
  redirect(t, r) {
  }
  overlap(t, r, n) {
    return t;
  }
  preprocess(t, r) {
    return t;
  }
  postprocess(t, r) {
    return he;
  }
};
function Eo(e, t, r) {
  return typeof e == "function" ? (...n) => e(...n.slice(0, r - 1), t, ...n.slice(r - 1)) : () => e;
}
var Dt = class extends O {
  constructor(t) {
    super(t), this._sourceName = t.sourceName;
  }
  expected(t) {
    return t.schemas[this._sourceName].expected(t);
  }
  validate(t, r) {
    return r.schemas[this._sourceName].validate(t, r);
  }
  redirect(t, r) {
    return this._sourceName;
  }
};
var lt = class extends O {
  expected() {
    return "anything";
  }
  validate() {
    return true;
  }
};
var ct = class extends O {
  constructor({ valueSchema: t, name: r = t.name, ...n }) {
    super({ ...n, name: r }), this._valueSchema = t;
  }
  expected(t) {
    let { text: r, list: n } = t.normalizeExpectedResult(this._valueSchema.expected(t));
    return { text: r && `an array of ${r}`, list: n && { title: "an array of the following values", values: [{ list: n }] } };
  }
  validate(t, r) {
    if (!Array.isArray(t)) return false;
    let n = [];
    for (let o of t) {
      let u = r.normalizeValidateResult(this._valueSchema.validate(o, r), o);
      u !== true && n.push(u.value);
    }
    return n.length === 0 ? true : { value: n };
  }
  deprecated(t, r) {
    let n = [];
    for (let o of t) {
      let u = r.normalizeDeprecatedResult(this._valueSchema.deprecated(o, r), o);
      u !== false && n.push(...u.map(({ value: i }) => ({ value: [i] })));
    }
    return n;
  }
  forward(t, r) {
    let n = [];
    for (let o of t) {
      let u = r.normalizeForwardResult(this._valueSchema.forward(o, r), o);
      n.push(...u.map(Fn));
    }
    return n;
  }
  redirect(t, r) {
    let n = [], o = [];
    for (let u of t) {
      let i = r.normalizeRedirectResult(this._valueSchema.redirect(u, r), u);
      "remain" in i && n.push(i.remain), o.push(...i.redirect.map(Fn));
    }
    return n.length === 0 ? { redirect: o } : { redirect: o, remain: n };
  }
  overlap(t, r) {
    return t.concat(r);
  }
};
function Fn({ from: e, to: t }) {
  return { from: [e], to: t };
}
var ft = class extends O {
  expected() {
    return "true or false";
  }
  validate(t) {
    return typeof t == "boolean";
  }
};
function En(e, t) {
  let r = /* @__PURE__ */ Object.create(null);
  for (let n of e) {
    let o = n[t];
    if (r[o]) throw new Error(`Duplicate ${t} ${JSON.stringify(o)}`);
    r[o] = n;
  }
  return r;
}
function hn(e, t) {
  let r = /* @__PURE__ */ new Map();
  for (let n of e) {
    let o = n[t];
    if (r.has(o)) throw new Error(`Duplicate ${t} ${JSON.stringify(o)}`);
    r.set(o, n);
  }
  return r;
}
function Cn() {
  let e = /* @__PURE__ */ Object.create(null);
  return (t) => {
    let r = JSON.stringify(t);
    return e[r] ? true : (e[r] = true, false);
  };
}
function gn(e, t) {
  let r = [], n = [];
  for (let o of e) t(o) ? r.push(o) : n.push(o);
  return [r, n];
}
function yn(e) {
  return e === Math.floor(e);
}
function An(e, t) {
  if (e === t) return 0;
  let r = typeof e, n = typeof t, o = ["undefined", "object", "boolean", "number", "string"];
  return r !== n ? o.indexOf(r) - o.indexOf(n) : r !== "string" ? Number(e) - Number(t) : e.localeCompare(t);
}
function Bn(e) {
  return (...t) => {
    let r = e(...t);
    return typeof r == "string" ? new Error(r) : r;
  };
}
function Mt(e) {
  return e === void 0 ? {} : e;
}
function $t(e) {
  if (typeof e == "string") return { text: e };
  let { text: t, list: r } = e;
  return ho((t || r) !== void 0, "Unexpected `expected` result, there should be at least one field."), r ? { text: t, list: { title: r.title, values: r.values.map($t) } } : { text: t };
}
function Vt(e, t) {
  return e === true ? true : e === false ? { value: t } : e;
}
function Ut(e, t, r = false) {
  return e === false ? false : e === true ? r ? true : [{ value: t }] : "value" in e ? [e] : e.length === 0 ? false : e;
}
function mn(e, t) {
  return typeof e == "string" || "key" in e ? { from: t, to: e } : "from" in e ? { from: e.from, to: e.to } : { from: t, to: e.to };
}
function pt(e, t) {
  return e === void 0 ? [] : Array.isArray(e) ? e.map((r) => mn(r, t)) : [mn(e, t)];
}
function zt(e, t) {
  let r = pt(typeof e == "object" && "redirect" in e ? e.redirect : e, t);
  return r.length === 0 ? { remain: t, redirect: r } : typeof e == "object" && "remain" in e ? { remain: e.remain, redirect: r } : { redirect: r };
}
function ho(e, t) {
  if (!e) throw new Error(t);
}
var dt = class extends O {
  constructor(t) {
    super(t), this._choices = hn(t.choices.map((r) => r && typeof r == "object" ? r : { value: r }), "value");
  }
  expected({ descriptor: t }) {
    let r = Array.from(this._choices.keys()).map((i) => this._choices.get(i)).filter(({ hidden: i }) => !i).map((i) => i.value).sort(An).map(t.value), n = r.slice(0, -2), o = r.slice(-2);
    return { text: n.concat(o.join(" or ")).join(", "), list: { title: "one of the following values", values: r } };
  }
  validate(t) {
    return this._choices.has(t);
  }
  deprecated(t) {
    let r = this._choices.get(t);
    return r && r.deprecated ? { value: t } : false;
  }
  forward(t) {
    let r = this._choices.get(t);
    return r ? r.forward : void 0;
  }
  redirect(t) {
    let r = this._choices.get(t);
    return r ? r.redirect : void 0;
  }
};
var Ft = class extends O {
  expected() {
    return "a number";
  }
  validate(t, r) {
    return typeof t == "number";
  }
};
var mt = class extends Ft {
  expected() {
    return "an integer";
  }
  validate(t, r) {
    return r.normalizeValidateResult(super.validate(t, r), t) === true && yn(t);
  }
};
var Re = class extends O {
  expected() {
    return "a string";
  }
  validate(t) {
    return typeof t == "string";
  }
};
var wn = ie;
var xn = at;
var _n = cn;
var vn = an;
var Et = class {
  constructor(t, r) {
    let { logger: n = console, loggerPrintWidth: o = 80, descriptor: u = wn, unknown: i = xn, invalid: s = _n, deprecated: a = vn, missing: D = () => false, required: l = () => false, preprocess: d = (p) => p, postprocess: f = () => he } = r || {};
    this._utils = { descriptor: u, logger: n || { warn: () => {
    } }, loggerPrintWidth: o, schemas: En(t, "name"), normalizeDefaultResult: Mt, normalizeExpectedResult: $t, normalizeDeprecatedResult: Ut, normalizeForwardResult: pt, normalizeRedirectResult: zt, normalizeValidateResult: Vt }, this._unknownHandler = i, this._invalidHandler = Bn(s), this._deprecatedHandler = a, this._identifyMissing = (p, c2) => !(p in c2) || D(p, c2), this._identifyRequired = l, this._preprocess = d, this._postprocess = f, this.cleanHistory();
  }
  cleanHistory() {
    this._hasDeprecationWarned = Cn();
  }
  normalize(t) {
    let r = {}, o = [this._preprocess(t, this._utils)], u = () => {
      for (; o.length !== 0; ) {
        let i = o.shift(), s = this._applyNormalization(i, r);
        o.push(...s);
      }
    };
    u();
    for (let i of Object.keys(this._utils.schemas)) {
      let s = this._utils.schemas[i];
      if (!(i in r)) {
        let a = Mt(s.default(this._utils));
        "value" in a && o.push({ [i]: a.value });
      }
    }
    u();
    for (let i of Object.keys(this._utils.schemas)) {
      if (!(i in r)) continue;
      let s = this._utils.schemas[i], a = r[i], D = s.postprocess(a, this._utils);
      D !== he && (this._applyValidation(D, i, s), r[i] = D);
    }
    return this._applyPostprocess(r), this._applyRequiredCheck(r), r;
  }
  _applyNormalization(t, r) {
    let n = [], { knownKeys: o, unknownKeys: u } = this._partitionOptionKeys(t);
    for (let i of o) {
      let s = this._utils.schemas[i], a = s.preprocess(t[i], this._utils);
      this._applyValidation(a, i, s);
      let D = ({ from: p, to: c2 }) => {
        n.push(typeof c2 == "string" ? { [c2]: p } : { [c2.key]: c2.value });
      }, l = ({ value: p, redirectTo: c2 }) => {
        let F = Ut(s.deprecated(p, this._utils), a, true);
        if (F !== false) if (F === true) this._hasDeprecationWarned(i) || this._utils.logger.warn(this._deprecatedHandler(i, c2, this._utils));
        else for (let { value: m } of F) {
          let E = { key: i, value: m };
          if (!this._hasDeprecationWarned(E)) {
            let A = typeof c2 == "string" ? { key: c2, value: m } : c2;
            this._utils.logger.warn(this._deprecatedHandler(E, A, this._utils));
          }
        }
      };
      pt(s.forward(a, this._utils), a).forEach(D);
      let f = zt(s.redirect(a, this._utils), a);
      if (f.redirect.forEach(D), "remain" in f) {
        let p = f.remain;
        r[i] = i in r ? s.overlap(r[i], p, this._utils) : p, l({ value: p });
      }
      for (let { from: p, to: c2 } of f.redirect) l({ value: p, redirectTo: c2 });
    }
    for (let i of u) {
      let s = t[i];
      this._applyUnknownHandler(i, s, r, (a, D) => {
        n.push({ [a]: D });
      });
    }
    return n;
  }
  _applyRequiredCheck(t) {
    for (let r of Object.keys(this._utils.schemas)) if (this._identifyMissing(r, t) && this._identifyRequired(r)) throw this._invalidHandler(r, st, this._utils);
  }
  _partitionOptionKeys(t) {
    let [r, n] = gn(Object.keys(t).filter((o) => !this._identifyMissing(o, t)), (o) => o in this._utils.schemas);
    return { knownKeys: r, unknownKeys: n };
  }
  _applyValidation(t, r, n) {
    let o = Vt(n.validate(t, this._utils), t);
    if (o !== true) throw this._invalidHandler(r, o.value, this._utils);
  }
  _applyUnknownHandler(t, r, n, o) {
    let u = this._unknownHandler(t, r, this._utils);
    if (u) for (let i of Object.keys(u)) {
      if (this._identifyMissing(i, u)) continue;
      let s = u[i];
      i in this._utils.schemas ? o(i, s) : n[i] = s;
    }
  }
  _applyPostprocess(t) {
    let r = this._postprocess(t, this._utils);
    if (r !== he) {
      if (r.delete) for (let n of r.delete) delete t[n];
      if (r.override) {
        let { knownKeys: n, unknownKeys: o } = this._partitionOptionKeys(r.override);
        for (let u of n) {
          let i = r.override[u];
          this._applyValidation(i, u, this._utils.schemas[u]), t[u] = i;
        }
        for (let u of o) {
          let i = r.override[u];
          this._applyUnknownHandler(u, i, t, (s, a) => {
            let D = this._utils.schemas[s];
            this._applyValidation(a, s, D), t[s] = a;
          });
        }
      }
    }
  }
};
var Gt;
function go(e, t, { logger: r = false, isCLI: n = false, passThrough: o = false, FlagSchema: u, descriptor: i } = {}) {
  if (n) {
    if (!u) throw new Error("'FlagSchema' option is required.");
    if (!i) throw new Error("'descriptor' option is required.");
  } else i = ie;
  let s = o ? Array.isArray(o) ? (f, p) => o.includes(f) ? { [f]: p } : void 0 : (f, p) => ({ [f]: p }) : (f, p, c2) => {
    let { _: F, ...m } = c2.schemas;
    return at(f, p, { ...c2, schemas: m });
  }, a = yo(t, { isCLI: n, FlagSchema: u }), D = new Et(a, { logger: r, unknown: s, descriptor: i }), l = r !== false;
  l && Gt && (D._hasDeprecationWarned = Gt);
  let d = D.normalize(e);
  return l && (Gt = D._hasDeprecationWarned), d;
}
function yo(e, { isCLI: t, FlagSchema: r }) {
  let n = [];
  t && n.push(lt.create({ name: "_" }));
  for (let o of e) n.push(Ao(o, { isCLI: t, optionInfos: e, FlagSchema: r })), o.alias && t && n.push(Dt.create({ name: o.alias, sourceName: o.name }));
  return n;
}
function Ao(e, { isCLI: t, optionInfos: r, FlagSchema: n }) {
  let { name: o } = e, u = { name: o }, i, s = {};
  switch (e.type) {
    case "int":
      i = mt, t && (u.preprocess = Number);
      break;
    case "string":
      i = Re;
      break;
    case "choice":
      i = dt, u.choices = e.choices.map((a) => a != null && a.redirect ? { ...a, redirect: { to: { key: e.name, value: a.redirect } } } : a);
      break;
    case "boolean":
      i = ft;
      break;
    case "flag":
      i = n, u.flags = r.flatMap((a) => [a.alias, a.description && a.name, a.oppositeDescription && `no-${a.name}`].filter(Boolean));
      break;
    case "path":
      i = Re;
      break;
    default:
      throw new Error(`Unexpected type ${e.type}`);
  }
  if (e.exception ? u.validate = (a, D, l) => e.exception(a) || D.validate(a, l) : u.validate = (a, D, l) => a === void 0 || D.validate(a, l), e.redirect && (s.redirect = (a) => a ? { to: typeof e.redirect == "string" ? e.redirect : { key: e.redirect.option, value: e.redirect.value } } : void 0), e.deprecated && (s.deprecated = true), t && !e.array) {
    let a = u.preprocess || ((D) => D);
    u.preprocess = (D, l, d) => l.preprocess(a(Array.isArray(D) ? y(false, D, -1) : D), d);
  }
  return e.array ? ct.create({ ...t ? { preprocess: (a) => Array.isArray(a) ? a : [a] } : {}, ...s, valueSchema: i.create(u) }) : i.create({ ...u, ...s });
}
var bn = go;
var Bo = (e, t, r) => {
  if (!(e && t == null)) {
    if (t.findLast) return t.findLast(r);
    for (let n = t.length - 1; n >= 0; n--) {
      let o = t[n];
      if (r(o, n, t)) return o;
    }
  }
};
var Kt = Bo;
function qt(e, t) {
  if (!t) throw new Error("parserName is required.");
  let r = Kt(false, e, (o) => o.parsers && Object.prototype.hasOwnProperty.call(o.parsers, t));
  if (r) return r;
  let n = `Couldn't resolve parser "${t}".`;
  throw n += " Plugins must be explicitly added to the standalone bundle.", new Pe(n);
}
function On(e, t) {
  if (!t) throw new Error("astFormat is required.");
  let r = Kt(false, e, (o) => o.printers && Object.prototype.hasOwnProperty.call(o.printers, t));
  if (r) return r;
  let n = `Couldn't find plugin for AST format "${t}".`;
  throw n += " Plugins must be explicitly added to the standalone bundle.", new Pe(n);
}
function ht({ plugins: e, parser: t }) {
  let r = qt(e, t);
  return Jt(r, t);
}
function Jt(e, t) {
  let r = e.parsers[t];
  return typeof r == "function" ? r() : r;
}
function Sn(e, t) {
  let r = e.printers[t];
  return typeof r == "function" ? r() : r;
}
var Nn = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null };
async function wo(e, t = {}) {
  var d;
  let r = { ...e };
  if (!r.parser) if (r.filepath) {
    if (r.parser = un(r, { physicalFile: r.filepath }), !r.parser) throw new Ie(`No parser could be inferred for file "${r.filepath}".`);
  } else throw new Ie("No parser and no file path given, couldn't infer a parser.");
  let n = ot({ plugins: e.plugins, showDeprecated: true }).options, o = { ...Nn, ...Object.fromEntries(n.filter((f) => f.default !== void 0).map((f) => [f.name, f.default])) }, u = qt(r.plugins, r.parser), i = await Jt(u, r.parser);
  r.astFormat = i.astFormat, r.locEnd = i.locEnd, r.locStart = i.locStart;
  let s = (d = u.printers) != null && d[i.astFormat] ? u : On(r.plugins, i.astFormat), a = await Sn(s, i.astFormat);
  r.printer = a;
  let D = s.defaultOptions ? Object.fromEntries(Object.entries(s.defaultOptions).filter(([, f]) => f !== void 0)) : {}, l = { ...o, ...D };
  for (let [f, p] of Object.entries(l)) (r[f] === null || r[f] === void 0) && (r[f] = p);
  return r.parser === "json" && (r.trailingComma = "none"), bn(r, n, { passThrough: Object.keys(Nn), ...t });
}
var se = wo;
var Vn = Me($n(), 1);
async function ko(e, t) {
  let r = await ht(t), n = r.preprocess ? r.preprocess(e, t) : e;
  t.originalText = n;
  let o;
  try {
    o = await r.parse(n, t, t);
  } catch (u) {
    Lo(u, e);
  }
  return { text: n, ast: o };
}
function Lo(e, t) {
  let { loc: r } = e;
  if (r) {
    let n = (0, Vn.codeFrameColumns)(t, r, { highlightCode: true });
    throw e.message += `
` + n, e.codeFrame = n, e;
  }
  throw e;
}
var ce = ko;
async function Un(e, t, r, n, o) {
  let { embeddedLanguageFormatting: u, printer: { embed: i, hasPrettierIgnore: s = () => false, getVisitorKeys: a } } = r;
  if (!i || u !== "auto") return;
  if (i.length > 2) throw new Error("printer.embed has too many parameters. The API changed in Prettier v3. Please update your plugin. See https://prettier.io/docs/en/plugins.html#optional-embed");
  let D = X(i.getVisitorKeys ?? a), l = [];
  p();
  let d = e.stack;
  for (let { print: c2, node: F, pathStack: m } of l) try {
    e.stack = m;
    let E = await c2(f, t, e, r);
    E && o.set(F, E);
  } catch (E) {
    if (globalThis.PRETTIER_DEBUG) throw E;
  }
  e.stack = d;
  function f(c2, F) {
    return Po(c2, F, r, n);
  }
  function p() {
    let { node: c2 } = e;
    if (c2 === null || typeof c2 != "object" || s(e)) return;
    for (let m of D(c2)) Array.isArray(c2[m]) ? e.each(p, m) : e.call(p, m);
    let F = i(e, r);
    if (F) {
      if (typeof F == "function") {
        l.push({ print: F, node: c2, pathStack: [...e.stack] });
        return;
      }
      o.set(c2, F);
    }
  }
}
async function Po(e, t, r, n) {
  let o = await se({ ...r, ...t, parentParser: r.parser, originalText: e }, { passThrough: true }), { ast: u } = await ce(e, o), i = await n(u, o);
  return Ze(i);
}
function Io(e, t) {
  let { originalText: r, [Symbol.for("comments")]: n, locStart: o, locEnd: u, [Symbol.for("printedComments")]: i } = t, { node: s } = e, a = o(s), D = u(s);
  for (let l of n) o(l) >= a && u(l) <= D && i.add(l);
  return r.slice(a, D);
}
var zn = Io;
async function Ye(e, t) {
  ({ ast: e } = await Qt(e, t));
  let r = /* @__PURE__ */ new Map(), n = new Mr(e), o = tn(t), u = /* @__PURE__ */ new Map();
  await Un(n, s, t, Ye, u);
  let i = await Gn(n, t, s, void 0, u);
  return en(t), i;
  function s(D, l) {
    return D === void 0 || D === n ? a(l) : Array.isArray(D) ? n.call(() => a(l), ...D) : n.call(() => a(l), D);
  }
  function a(D) {
    o(n);
    let l = n.node;
    if (l == null) return "";
    let d = l && typeof l == "object" && D === void 0;
    if (d && r.has(l)) return r.get(l);
    let f = Gn(n, t, s, D, u);
    return d && r.set(l, f), f;
  }
}
function Gn(e, t, r, n, o) {
  var a;
  let { node: u } = e, { printer: i } = t, s;
  return (a = i.hasPrettierIgnore) != null && a.call(i, e) ? s = zn(e, t) : o.has(u) ? s = o.get(u) : s = i.print(e, t, r, n), u === t.cursorNode && (s = Qe(s, (D) => [ve, D, ve])), i.printComment && (!i.willPrintOwnComments || !i.willPrintOwnComments(e, t)) && (s = Qr(e, s, t)), s;
}
async function Qt(e, t) {
  let r = e.comments ?? [];
  t[Symbol.for("comments")] = r, t[Symbol.for("tokens")] = e.tokens ?? [], t[Symbol.for("printedComments")] = /* @__PURE__ */ new Set(), Jr(e, t);
  let { printer: { preprocess: n } } = t;
  return e = n ? await n(e, t) : e, { ast: e, comments: r };
}
function Ro(e, t) {
  let { cursorOffset: r, locStart: n, locEnd: o } = t, u = X(t.printer.getVisitorKeys), i = (a) => n(a) <= r && o(a) >= r, s = e;
  for (let a of Ur(e, { getVisitorKeys: u, filter: i })) s = a;
  return s;
}
var Kn = Ro;
function Yo(e, t) {
  let { printer: { massageAstNode: r, getVisitorKeys: n } } = t;
  if (!r) return e;
  let o = X(n), u = r.ignoredProperties ?? /* @__PURE__ */ new Set();
  return i(e);
  function i(s, a) {
    if (!(s !== null && typeof s == "object")) return s;
    if (Array.isArray(s)) return s.map((f) => i(f, a)).filter(Boolean);
    let D = {}, l = new Set(o(s));
    for (let f in s) !Object.prototype.hasOwnProperty.call(s, f) || u.has(f) || (l.has(f) ? D[f] = i(s[f], s) : D[f] = s[f]);
    let d = r(s, D, a);
    if (d !== null) return d ?? D;
  }
}
var qn = Yo;
var jo = (e, t, r) => {
  if (!(e && t == null)) {
    if (t.findLastIndex) return t.findLastIndex(r);
    for (let n = t.length - 1; n >= 0; n--) {
      let o = t[n];
      if (r(o, n, t)) return n;
    }
    return -1;
  }
};
var Jn = jo;
var Ho = ({ parser: e }) => e === "json" || e === "json5" || e === "jsonc" || e === "json-stringify";
function Wo(e, t) {
  let r = [e.node, ...e.parentNodes], n = /* @__PURE__ */ new Set([t.node, ...t.parentNodes]);
  return r.find((o) => Qn.has(o.type) && n.has(o));
}
function Xn(e) {
  let t = Jn(false, e, (r) => r.type !== "Program" && r.type !== "File");
  return t === -1 ? e : e.slice(0, t + 1);
}
function Mo(e, t, { locStart: r, locEnd: n }) {
  let o = e.node, u = t.node;
  if (o === u) return { startNode: o, endNode: u };
  let i = r(e.node);
  for (let a of Xn(t.parentNodes)) if (r(a) >= i) u = a;
  else break;
  let s = n(t.node);
  for (let a of Xn(e.parentNodes)) {
    if (n(a) <= s) o = a;
    else break;
    if (o === u) break;
  }
  return { startNode: o, endNode: u };
}
function er(e, t, r, n, o = [], u) {
  let { locStart: i, locEnd: s } = r, a = i(e), D = s(e);
  if (!(t > D || t < a || u === "rangeEnd" && t === a || u === "rangeStart" && t === D)) {
    for (let l of ut(e, r)) {
      let d = er(l, t, r, n, [e, ...o], u);
      if (d) return d;
    }
    if (!n || n(e, o[0])) return { node: e, parentNodes: o };
  }
}
function $o(e, t) {
  return t !== "DeclareExportDeclaration" && e !== "TypeParameterDeclaration" && (e === "Directive" || e === "TypeAlias" || e === "TSExportAssignment" || e.startsWith("Declare") || e.startsWith("TSDeclare") || e.endsWith("Statement") || e.endsWith("Declaration"));
}
var Qn = /* @__PURE__ */ new Set(["JsonRoot", "ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]);
var Vo = /* @__PURE__ */ new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
function Zn(e, t, r) {
  if (!t) return false;
  switch (e.parser) {
    case "flow":
    case "babel":
    case "babel-flow":
    case "babel-ts":
    case "typescript":
    case "acorn":
    case "espree":
    case "meriyah":
    case "__babel_estree":
      return $o(t.type, r == null ? void 0 : r.type);
    case "json":
    case "json5":
    case "jsonc":
    case "json-stringify":
      return Qn.has(t.type);
    case "graphql":
      return Vo.has(t.kind);
    case "vue":
      return t.tag !== "root";
  }
  return false;
}
function eu(e, t, r) {
  let { rangeStart: n, rangeEnd: o, locStart: u, locEnd: i } = t;
  ke.ok(o > n);
  let s = e.slice(n, o).search(/\S/u), a = s === -1;
  if (!a) for (n += s; o > n && !/\S/u.test(e[o - 1]); --o) ;
  let D = er(r, n, t, (p, c2) => Zn(t, p, c2), [], "rangeStart"), l = a ? D : er(r, o, t, (p) => Zn(t, p), [], "rangeEnd");
  if (!D || !l) return { rangeStart: 0, rangeEnd: 0 };
  let d, f;
  if (Ho(t)) {
    let p = Wo(D, l);
    d = p, f = p;
  } else ({ startNode: d, endNode: f } = Mo(D, l, t));
  return { rangeStart: Math.min(u(d), u(f)), rangeEnd: Math.max(i(d), i(f)) };
}
var uu = "\uFEFF";
var tu = Symbol("cursor");
async function ou(e, t, r = 0) {
  if (!e || e.trim().length === 0) return { formatted: "", cursorOffset: -1, comments: [] };
  let { ast: n, text: o } = await ce(e, t);
  t.cursorOffset >= 0 && (t.cursorNode = Kn(n, t));
  let u = await Ye(n, t, r);
  r > 0 && (u = Je([q, u], r, t.tabWidth));
  let i = Fe(u, t);
  if (r > 0) {
    let a = i.formatted.trim();
    i.cursorNodeStart !== void 0 && (i.cursorNodeStart -= i.formatted.indexOf(a)), i.formatted = a + Be(t.endOfLine);
  }
  let s = t[Symbol.for("comments")];
  if (t.cursorOffset >= 0) {
    let a, D, l, d, f;
    if (t.cursorNode && i.cursorNodeText ? (a = t.locStart(t.cursorNode), D = o.slice(a, t.locEnd(t.cursorNode)), l = t.cursorOffset - a, d = i.cursorNodeStart, f = i.cursorNodeText) : (a = 0, D = o, l = t.cursorOffset, d = 0, f = i.formatted), D === f) return { formatted: i.formatted, cursorOffset: d + l, comments: s };
    let p = D.split("");
    p.splice(l, 0, tu);
    let c2 = f.split(""), F = dr(p, c2), m = d;
    for (let E of F) if (E.removed) {
      if (E.value.includes(tu)) break;
    } else m += E.count;
    return { formatted: i.formatted, cursorOffset: m, comments: s };
  }
  return { formatted: i.formatted, cursorOffset: -1, comments: s };
}
async function Uo(e, t) {
  let { ast: r, text: n } = await ce(e, t), { rangeStart: o, rangeEnd: u } = eu(n, t, r), i = n.slice(o, u), s = Math.min(o, n.lastIndexOf(`
`, o) + 1), a = n.slice(s, o).match(/^\s*/u)[0], D = me(a, t.tabWidth), l = await ou(i, { ...t, rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: t.cursorOffset > o && t.cursorOffset <= u ? t.cursorOffset - o : -1, endOfLine: "lf" }, D), d = l.formatted.trimEnd(), { cursorOffset: f } = t;
  f > u ? f += d.length - i.length : l.cursorOffset >= 0 && (f = l.cursorOffset + o);
  let p = n.slice(0, o) + d + n.slice(u);
  if (t.endOfLine !== "lf") {
    let c2 = Be(t.endOfLine);
    f >= 0 && c2 === `\r
` && (f += wt(p.slice(0, f), `
`)), p = ne(false, p, `
`, c2);
  }
  return { formatted: p, cursorOffset: f, comments: l.comments };
}
function tr(e, t, r) {
  return typeof t != "number" || Number.isNaN(t) || t < 0 || t > e.length ? r : t;
}
function ru(e, t) {
  let { cursorOffset: r, rangeStart: n, rangeEnd: o } = t;
  return r = tr(e, r, -1), n = tr(e, n, 0), o = tr(e, o, e.length), { ...t, cursorOffset: r, rangeStart: n, rangeEnd: o };
}
function iu(e, t) {
  let { cursorOffset: r, rangeStart: n, rangeEnd: o, endOfLine: u } = ru(e, t), i = e.charAt(0) === uu;
  if (i && (e = e.slice(1), r--, n--, o--), u === "auto" && (u = Fr(e)), e.includes("\r")) {
    let s = (a) => wt(e.slice(0, Math.max(a, 0)), `\r
`);
    r -= s(r), n -= s(n), o -= s(o), e = mr(e);
  }
  return { hasBOM: i, text: e, options: ru(e, { ...t, cursorOffset: r, rangeStart: n, rangeEnd: o, endOfLine: u }) };
}
async function nu(e, t) {
  let r = await ht(t);
  return !r.hasPragma || r.hasPragma(e);
}
async function rr(e, t) {
  let { hasBOM: r, text: n, options: o } = iu(e, await se(t));
  if (o.rangeStart >= o.rangeEnd && n !== "" || o.requirePragma && !await nu(n, o)) return { formatted: e, cursorOffset: t.cursorOffset, comments: [] };
  let u;
  return o.rangeStart > 0 || o.rangeEnd < n.length ? u = await Uo(n, o) : (!o.requirePragma && o.insertPragma && o.printer.insertPragma && !await nu(n, o) && (n = o.printer.insertPragma(n)), u = await ou(n, o)), r && (u.formatted = uu + u.formatted, u.cursorOffset >= 0 && u.cursorOffset++), u;
}
async function su(e, t, r) {
  let { text: n, options: o } = iu(e, await se(t)), u = await ce(n, o);
  return r && (r.preprocessForPrint && (u.ast = await Qt(u.ast, o)), r.massage && (u.ast = qn(u.ast, o))), u;
}
async function au(e, t) {
  t = await se(t);
  let r = await Ye(e, t);
  return Fe(r, t);
}
async function Du(e, t) {
  let r = Or(e), { formatted: n } = await rr(r, { ...t, parser: "__js_expression" });
  return n;
}
async function lu(e, t) {
  t = await se(t);
  let { ast: r } = await ce(e, t);
  return Ye(r, t);
}
async function cu(e, t) {
  return Fe(e, await se(t));
}
var nr = {};
We(nr, { builders: () => Go, printer: () => Ko, utils: () => qo });
var Go = { join: be, line: Ke, softline: vr, hardline: q, literalline: qe, group: _t, conditionalGroup: Ar, fill: Ge, lineSuffix: xe, lineSuffixBoundary: xr, cursor: ve, breakParent: de, ifBreak: Br, trim: _r, indent: De, indentIfBreak: wr, align: ae, addAlignmentToDoc: Je, markAsRoot: gr, dedentToRoot: Cr, dedent: yr, hardlineWithoutBreakParent: _e, literallineWithoutBreakParent: vt, label: br, concat: (e) => e };
var Ko = { printDocToString: Fe };
var qo = { willBreak: Ir, traverseDoc: we, findInDoc: Xe, mapDoc: Ne, removeLines: Yr, stripTrailingHardline: Ze, replaceEndOfLine: jr, canBreak: Hr };
var fu = "3.3.3";
var or = {};
We(or, { addDanglingComment: () => re, addLeadingComment: () => ue, addTrailingComment: () => oe, getAlignmentSize: () => me, getIndentSize: () => pu, getMaxContinuousCount: () => du, getNextNonSpaceNonCommentCharacter: () => Fu, getNextNonSpaceNonCommentCharacterIndex: () => si, getStringWidth: () => Oe, hasNewline: () => V, hasNewlineInRange: () => mu, hasSpaces: () => Eu, isNextLineEmpty: () => ci, isNextLineEmptyAfterIndex: () => gt, isPreviousLineEmpty: () => Di, makeString: () => hu, skip: () => Ee, skipEverythingButNewLine: () => nt, skipInlineComment: () => Ce, skipNewline: () => M, skipSpaces: () => T, skipToLineEnd: () => rt, skipTrailingComment: () => ge, skipWhitespace: () => zr });
function Jo(e, t) {
  if (t === false) return false;
  if (e.charAt(t) === "/" && e.charAt(t + 1) === "*") {
    for (let r = t + 2; r < e.length; ++r) if (e.charAt(r) === "*" && e.charAt(r + 1) === "/") return r + 2;
  }
  return t;
}
var Ce = Jo;
function Xo(e, t) {
  return t === false ? false : e.charAt(t) === "/" && e.charAt(t + 1) === "/" ? nt(e, t) : t;
}
var ge = Xo;
function Zo(e, t) {
  let r = null, n = t;
  for (; n !== r; ) r = n, n = T(e, n), n = Ce(e, n), n = ge(e, n), n = M(e, n);
  return n;
}
var je = Zo;
function Qo(e, t) {
  let r = null, n = t;
  for (; n !== r; ) r = n, n = rt(e, n), n = Ce(e, n), n = T(e, n);
  return n = ge(e, n), n = M(e, n), n !== false && V(e, n);
}
var gt = Qo;
function ei(e, t) {
  let r = e.lastIndexOf(`
`);
  return r === -1 ? 0 : me(e.slice(r + 1).match(/^[\t ]*/u)[0], t);
}
var pu = ei;
function ur(e) {
  if (typeof e != "string") throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function ti(e, t) {
  let r = e.match(new RegExp(`(${ur(t)})+`, "gu"));
  return r === null ? 0 : r.reduce((n, o) => Math.max(n, o.length / t.length), 0);
}
var du = ti;
function ri(e, t) {
  let r = je(e, t);
  return r === false ? "" : e.charAt(r);
}
var Fu = ri;
function ni(e, t, r) {
  for (let n = t; n < r; ++n) if (e.charAt(n) === `
`) return true;
  return false;
}
var mu = ni;
function ui(e, t, r = {}) {
  return T(e, r.backwards ? t - 1 : t, r) !== t;
}
var Eu = ui;
function oi(e, t, r) {
  let n = t === '"' ? "'" : '"', u = ne(false, e, /\\(.)|(["'])/gsu, (i, s, a) => s === n ? s : a === t ? "\\" + a : a || (r && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/u.test(s) ? s : "\\" + s));
  return t + u + t;
}
var hu = oi;
function ii(e, t, r) {
  return je(e, r(t));
}
function si(e, t) {
  return arguments.length === 2 || typeof t == "number" ? je(e, t) : ii(...arguments);
}
function ai(e, t, r) {
  return Le(e, r(t));
}
function Di(e, t) {
  return arguments.length === 2 || typeof t == "number" ? Le(e, t) : ai(...arguments);
}
function li(e, t, r) {
  return gt(e, r(t));
}
function ci(e, t) {
  return arguments.length === 2 || typeof t == "number" ? gt(e, t) : li(...arguments);
}
function fe(e, t = 1) {
  return async (...r) => {
    let n = r[t] ?? {}, o = n.plugins ?? [];
    return r[t] = { ...n, plugins: Array.isArray(o) ? o : Object.values(o) }, e(...r);
  };
}
var Cu = fe(rr);
async function gu(e, t) {
  let { formatted: r } = await Cu(e, { ...t, cursorOffset: -1 });
  return r;
}
async function fi(e, t) {
  return await gu(e, t) === e;
}
var pi = fe(ot, 0);
var di = { parse: fe(su), formatAST: fe(au), formatDoc: fe(Du), printToDoc: fe(lu), printDocToString: fe(cu) };
var fc = ir;

// node_modules/@toolpad/studio/dist/exports/chunk-MNVDTQN5.mjs
var import_parser_babel = __toESM(require_babel(), 1);
var DOCUMENTATION_URL = "https://mui.com/toolpad/studio/getting-started/";
var UPGRADE_URL = "https://mui.com/toolpad/studio/getting-started/roadmap/#paid-plan";
var VERSION_CHECK_INTERVAL = 1e3 * 60 * 10;
var FEATURE_FLAG_GLOBAL_FUNCTIONS = false;
function insecureHash(str) {
  let h = 0;
  for (let i = 0; i < str.length; i += 1) {
    h = Math.imul(31, h) + str.charCodeAt(i) | 0;
  }
  return h;
}
function createRuntimeState({ dom }) {
  return {
    dom: createRenderTree(dom)
  };
}
var DEFAULT_OPTIONS = {
  parser: "babel-ts",
  plugins: [import_parser_babel.default]
};
async function formatExpression(code, config) {
  const formatted = await fc.format(code, {
    ...config,
    ...DEFAULT_OPTIONS,
    semi: false
  });
  return formatted.replace(/^;/, "");
}
async function tryFormatExpression(code, config) {
  try {
    return await formatExpression(code, config);
  } catch (err) {
    return code;
  }
}
function parseLegacyFunctionId(id) {
  if (!id) {
    return { file: "functions.ts" };
  }
  const [file, handler] = id.split("#");
  return handler ? { file, handler } : { file: "functions.ts", handler: file };
}
function parseFunctionId(id) {
  const [file, handler] = id.split("#");
  return handler ? { file, handler } : { file };
}
function serializeFunctionId({ file, handler }) {
  return handler ? `${file}#${handler}` : file;
}
function transformLegacyFunctionId(id) {
  if (!id) {
    return "";
  }
  const [file, handler] = id.split("#");
  return handler ? id : `functions.ts#${file}`;
}
var HTTP_NO_BODY = /* @__PURE__ */ new Set(["GET", "HEAD"]);
function getAuthenticationHeaders(auth) {
  if (!auth) {
    return [];
  }
  switch (auth.type) {
    case "basic":
      return [
        [
          "Authorization",
          `Basic ${Buffer.from(`${auth.user}:${auth.password}`, "utf-8").toString("base64")}`
        ]
      ];
    case "bearerToken":
      return [["Authorization", `Bearer ${auth.token}`]];
    case "apiKey":
      return [[auth.header, auth.key]];
    default:
      throw new Error(`Unsupported authentication type "${auth.type}"`);
  }
}
function parseBaseUrl(baseUrl) {
  const parsedBase = new URL(baseUrl);
  parsedBase.pathname = ensureSuffix(parsedBase.pathname, "/");
  parsedBase.search = "";
  parsedBase.hash = "";
  return parsedBase;
}

// node_modules/@toolpad/studio/dist/exports/editor.mjs
var React111 = __toESM(require_react(), 1);

// node_modules/@mui/icons-material/esm/OpenInNew.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var OpenInNew_default = createSvgIcon((0, import_jsx_runtime.jsx)("path", {
  d: "M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3z"
}), "OpenInNew");

// node_modules/@mui/icons-material/esm/CloudDone.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var CloudDone_default = createSvgIcon((0, import_jsx_runtime2.jsx)("path", {
  d: "M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96M10 17l-3.5-3.5 1.41-1.41L10 14.17 15.18 9l1.41 1.41z"
}), "CloudDone");

// node_modules/@mui/icons-material/esm/Sync.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
var Sync_default = createSvgIcon((0, import_jsx_runtime3.jsx)("path", {
  d: "M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8m0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4z"
}), "Sync");

// node_modules/@mui/icons-material/esm/SyncProblem.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
var SyncProblem_default = createSvgIcon((0, import_jsx_runtime4.jsx)("path", {
  d: "M3 12c0 2.21.91 4.2 2.36 5.64L3 20h6v-6l-2.24 2.24C5.68 15.15 5 13.66 5 12c0-2.61 1.67-4.83 4-5.65V4.26C5.55 5.15 3 8.27 3 12m8 5h2v-2h-2zM21 4h-6v6l2.24-2.24C18.32 8.85 19 10.34 19 12c0 2.61-1.67 4.83-4 5.65v2.09c3.45-.89 6-4.01 6-7.74 0-2.21-.91-4.2-2.36-5.64zm-10 9h2V7h-2z"
}), "SyncProblem");

// node_modules/@toolpad/studio/dist/exports/editor.mjs
var React101 = __toESM(require_react(), 1);
var React73 = __toESM(require_react(), 1);

// node_modules/react-resizable-panels/dist/react-resizable-panels.browser.development.esm.js
var react_resizable_panels_browser_development_esm_exports = {};
__export(react_resizable_panels_browser_development_esm_exports, {
  Panel: () => Panel,
  PanelGroup: () => PanelGroup,
  PanelResizeHandle: () => PanelResizeHandle,
  assert: () => assert,
  disableGlobalCursorStyles: () => disableGlobalCursorStyles,
  enableGlobalCursorStyles: () => enableGlobalCursorStyles,
  getIntersectingRectangle: () => getIntersectingRectangle,
  getPanelElement: () => getPanelElement,
  getPanelElementsForGroup: () => getPanelElementsForGroup,
  getPanelGroupElement: () => getPanelGroupElement,
  getResizeHandleElement: () => getResizeHandleElement,
  getResizeHandleElementIndex: () => getResizeHandleElementIndex,
  getResizeHandleElementsForGroup: () => getResizeHandleElementsForGroup,
  getResizeHandlePanelIds: () => getResizeHandlePanelIds,
  intersects: () => intersects,
  setNonce: () => setNonce
});
var React = __toESM(require_react());
var {
  createElement: createElement2,
  createContext,
  createRef,
  forwardRef,
  useCallback,
  useContext,
  useEffect,
  useImperativeHandle,
  useLayoutEffect,
  useMemo,
  useRef,
  useState
} = React;
var useId = React[`useId${Math.random()}`.slice(0, 5)];
var useLayoutEffect_do_not_use_directly = useLayoutEffect;
var PanelGroupContext = createContext(null);
PanelGroupContext.displayName = "PanelGroupContext";
var useIsomorphicLayoutEffect = useLayoutEffect_do_not_use_directly;
var wrappedUseId = typeof useId === "function" ? useId : () => null;
var counter = 0;
function useUniqueId(idFromParams = null) {
  const idFromUseId = wrappedUseId();
  const idRef = useRef(idFromParams || idFromUseId || null);
  if (idRef.current === null) {
    idRef.current = "" + counter++;
  }
  return idFromParams !== null && idFromParams !== void 0 ? idFromParams : idRef.current;
}
function PanelWithForwardedRef({
  children,
  className: classNameFromProps = "",
  collapsedSize,
  collapsible,
  defaultSize,
  forwardedRef,
  id: idFromProps,
  maxSize,
  minSize,
  onCollapse,
  onExpand,
  onResize,
  order,
  style: styleFromProps,
  tagName: Type = "div",
  ...rest
}) {
  const context = useContext(PanelGroupContext);
  if (context === null) {
    throw Error(`Panel components must be rendered within a PanelGroup container`);
  }
  const {
    collapsePanel,
    expandPanel,
    getPanelSize,
    getPanelStyle,
    groupId,
    isPanelCollapsed,
    reevaluatePanelConstraints,
    registerPanel,
    resizePanel: resizePanel2,
    unregisterPanel
  } = context;
  const panelId = useUniqueId(idFromProps);
  const panelDataRef = useRef({
    callbacks: {
      onCollapse,
      onExpand,
      onResize
    },
    constraints: {
      collapsedSize,
      collapsible,
      defaultSize,
      maxSize,
      minSize
    },
    id: panelId,
    idIsFromProps: idFromProps !== void 0,
    order
  });
  const devWarningsRef = useRef({
    didLogMissingDefaultSizeWarning: false
  });
  {
    if (!devWarningsRef.current.didLogMissingDefaultSizeWarning) ;
  }
  useIsomorphicLayoutEffect(() => {
    const {
      callbacks,
      constraints
    } = panelDataRef.current;
    const prevConstraints = {
      ...constraints
    };
    panelDataRef.current.id = panelId;
    panelDataRef.current.idIsFromProps = idFromProps !== void 0;
    panelDataRef.current.order = order;
    callbacks.onCollapse = onCollapse;
    callbacks.onExpand = onExpand;
    callbacks.onResize = onResize;
    constraints.collapsedSize = collapsedSize;
    constraints.collapsible = collapsible;
    constraints.defaultSize = defaultSize;
    constraints.maxSize = maxSize;
    constraints.minSize = minSize;
    if (prevConstraints.collapsedSize !== constraints.collapsedSize || prevConstraints.collapsible !== constraints.collapsible || prevConstraints.maxSize !== constraints.maxSize || prevConstraints.minSize !== constraints.minSize) {
      reevaluatePanelConstraints(panelDataRef.current, prevConstraints);
    }
  });
  useIsomorphicLayoutEffect(() => {
    const panelData = panelDataRef.current;
    registerPanel(panelData);
    return () => {
      unregisterPanel(panelData);
    };
  }, [order, panelId, registerPanel, unregisterPanel]);
  useImperativeHandle(forwardedRef, () => ({
    collapse: () => {
      collapsePanel(panelDataRef.current);
    },
    expand: (minSize2) => {
      expandPanel(panelDataRef.current, minSize2);
    },
    getId() {
      return panelId;
    },
    getSize() {
      return getPanelSize(panelDataRef.current);
    },
    isCollapsed() {
      return isPanelCollapsed(panelDataRef.current);
    },
    isExpanded() {
      return !isPanelCollapsed(panelDataRef.current);
    },
    resize: (size) => {
      resizePanel2(panelDataRef.current, size);
    }
  }), [collapsePanel, expandPanel, getPanelSize, isPanelCollapsed, panelId, resizePanel2]);
  const style = getPanelStyle(panelDataRef.current, defaultSize);
  return createElement2(Type, {
    ...rest,
    children,
    className: classNameFromProps,
    id: idFromProps,
    style: {
      ...style,
      ...styleFromProps
    },
    // CSS selectors
    "data-panel": "",
    "data-panel-collapsible": collapsible || void 0,
    "data-panel-group-id": groupId,
    "data-panel-id": panelId,
    "data-panel-size": parseFloat("" + style.flexGrow).toFixed(1)
  });
}
var Panel = forwardRef((props2, ref) => createElement2(PanelWithForwardedRef, {
  ...props2,
  forwardedRef: ref
}));
PanelWithForwardedRef.displayName = "Panel";
Panel.displayName = "forwardRef(Panel)";
var nonce;
function getNonce() {
  return nonce;
}
function setNonce(value) {
  nonce = value;
}
var currentCursorStyle = null;
var enabled = true;
var styleElement = null;
function disableGlobalCursorStyles() {
  enabled = false;
}
function enableGlobalCursorStyles() {
  enabled = true;
}
function getCursorStyle(state, constraintFlags) {
  if (constraintFlags) {
    const horizontalMin = (constraintFlags & EXCEEDED_HORIZONTAL_MIN) !== 0;
    const horizontalMax = (constraintFlags & EXCEEDED_HORIZONTAL_MAX) !== 0;
    const verticalMin = (constraintFlags & EXCEEDED_VERTICAL_MIN) !== 0;
    const verticalMax = (constraintFlags & EXCEEDED_VERTICAL_MAX) !== 0;
    if (horizontalMin) {
      if (verticalMin) {
        return "se-resize";
      } else if (verticalMax) {
        return "ne-resize";
      } else {
        return "e-resize";
      }
    } else if (horizontalMax) {
      if (verticalMin) {
        return "sw-resize";
      } else if (verticalMax) {
        return "nw-resize";
      } else {
        return "w-resize";
      }
    } else if (verticalMin) {
      return "s-resize";
    } else if (verticalMax) {
      return "n-resize";
    }
  }
  switch (state) {
    case "horizontal":
      return "ew-resize";
    case "intersection":
      return "move";
    case "vertical":
      return "ns-resize";
  }
}
function resetGlobalCursorStyle() {
  if (styleElement !== null) {
    document.head.removeChild(styleElement);
    currentCursorStyle = null;
    styleElement = null;
  }
}
function setGlobalCursorStyle(state, constraintFlags) {
  if (!enabled) {
    return;
  }
  const style = getCursorStyle(state, constraintFlags);
  if (currentCursorStyle === style) {
    return;
  }
  currentCursorStyle = style;
  if (styleElement === null) {
    styleElement = document.createElement("style");
    const nonce2 = getNonce();
    if (nonce2) {
      styleElement.setAttribute("nonce", nonce2);
    }
    document.head.appendChild(styleElement);
  }
  styleElement.innerHTML = `*{cursor: ${style}!important;}`;
}
function isKeyDown(event) {
  return event.type === "keydown";
}
function isPointerEvent(event) {
  return event.type.startsWith("pointer");
}
function isMouseEvent(event) {
  return event.type.startsWith("mouse");
}
function getResizeEventCoordinates(event) {
  if (isPointerEvent(event)) {
    if (event.isPrimary) {
      return {
        x: event.clientX,
        y: event.clientY
      };
    }
  } else if (isMouseEvent(event)) {
    return {
      x: event.clientX,
      y: event.clientY
    };
  }
  return {
    x: Infinity,
    y: Infinity
  };
}
function getInputType() {
  if (typeof matchMedia === "function") {
    return matchMedia("(pointer:coarse)").matches ? "coarse" : "fine";
  }
}
function intersects(rectOne, rectTwo, strict) {
  if (strict) {
    return rectOne.x < rectTwo.x + rectTwo.width && rectOne.x + rectOne.width > rectTwo.x && rectOne.y < rectTwo.y + rectTwo.height && rectOne.y + rectOne.height > rectTwo.y;
  } else {
    return rectOne.x <= rectTwo.x + rectTwo.width && rectOne.x + rectOne.width >= rectTwo.x && rectOne.y <= rectTwo.y + rectTwo.height && rectOne.y + rectOne.height >= rectTwo.y;
  }
}
function compare(a, b2) {
  if (a === b2) throw new Error("Cannot compare node with itself");
  const ancestors = {
    a: get_ancestors(a),
    b: get_ancestors(b2)
  };
  let common_ancestor;
  while (ancestors.a.at(-1) === ancestors.b.at(-1)) {
    a = ancestors.a.pop();
    b2 = ancestors.b.pop();
    common_ancestor = a;
  }
  assert(common_ancestor, "Stacking order can only be calculated for elements with a common ancestor");
  const z_indexes = {
    a: get_z_index(find_stacking_context(ancestors.a)),
    b: get_z_index(find_stacking_context(ancestors.b))
  };
  if (z_indexes.a === z_indexes.b) {
    const children = common_ancestor.childNodes;
    const furthest_ancestors = {
      a: ancestors.a.at(-1),
      b: ancestors.b.at(-1)
    };
    let i = children.length;
    while (i--) {
      const child = children[i];
      if (child === furthest_ancestors.a) return 1;
      if (child === furthest_ancestors.b) return -1;
    }
  }
  return Math.sign(z_indexes.a - z_indexes.b);
}
var props = /\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\b/;
function is_flex_item(node) {
  var _get_parent;
  const display = getComputedStyle((_get_parent = get_parent(node)) !== null && _get_parent !== void 0 ? _get_parent : node).display;
  return display === "flex" || display === "inline-flex";
}
function creates_stacking_context(node) {
  const style = getComputedStyle(node);
  if (style.position === "fixed") return true;
  if (style.zIndex !== "auto" && (style.position !== "static" || is_flex_item(node))) return true;
  if (+style.opacity < 1) return true;
  if ("transform" in style && style.transform !== "none") return true;
  if ("webkitTransform" in style && style.webkitTransform !== "none") return true;
  if ("mixBlendMode" in style && style.mixBlendMode !== "normal") return true;
  if ("filter" in style && style.filter !== "none") return true;
  if ("webkitFilter" in style && style.webkitFilter !== "none") return true;
  if ("isolation" in style && style.isolation === "isolate") return true;
  if (props.test(style.willChange)) return true;
  if (style.webkitOverflowScrolling === "touch") return true;
  return false;
}
function find_stacking_context(nodes) {
  let i = nodes.length;
  while (i--) {
    const node = nodes[i];
    assert(node, "Missing node");
    if (creates_stacking_context(node)) return node;
  }
  return null;
}
function get_z_index(node) {
  return node && Number(getComputedStyle(node).zIndex) || 0;
}
function get_ancestors(node) {
  const ancestors = [];
  while (node) {
    ancestors.push(node);
    node = get_parent(node);
  }
  return ancestors;
}
function get_parent(node) {
  const {
    parentNode
  } = node;
  if (parentNode && parentNode instanceof ShadowRoot) {
    return parentNode.host;
  }
  return parentNode;
}
var EXCEEDED_HORIZONTAL_MIN = 1;
var EXCEEDED_HORIZONTAL_MAX = 2;
var EXCEEDED_VERTICAL_MIN = 4;
var EXCEEDED_VERTICAL_MAX = 8;
var isCoarsePointer = getInputType() === "coarse";
var intersectingHandles = [];
var isPointerDown = false;
var ownerDocumentCounts = /* @__PURE__ */ new Map();
var panelConstraintFlags = /* @__PURE__ */ new Map();
var registeredResizeHandlers = /* @__PURE__ */ new Set();
function registerResizeHandle(resizeHandleId, element, direction, hitAreaMargins, setResizeHandlerState) {
  var _ownerDocumentCounts$;
  const {
    ownerDocument: ownerDocument2
  } = element;
  const data = {
    direction,
    element,
    hitAreaMargins,
    setResizeHandlerState
  };
  const count = (_ownerDocumentCounts$ = ownerDocumentCounts.get(ownerDocument2)) !== null && _ownerDocumentCounts$ !== void 0 ? _ownerDocumentCounts$ : 0;
  ownerDocumentCounts.set(ownerDocument2, count + 1);
  registeredResizeHandlers.add(data);
  updateListeners();
  return function unregisterResizeHandle() {
    var _ownerDocumentCounts$2;
    panelConstraintFlags.delete(resizeHandleId);
    registeredResizeHandlers.delete(data);
    const count2 = (_ownerDocumentCounts$2 = ownerDocumentCounts.get(ownerDocument2)) !== null && _ownerDocumentCounts$2 !== void 0 ? _ownerDocumentCounts$2 : 1;
    ownerDocumentCounts.set(ownerDocument2, count2 - 1);
    updateListeners();
    if (count2 === 1) {
      ownerDocumentCounts.delete(ownerDocument2);
    }
    if (intersectingHandles.includes(data)) {
      const index = intersectingHandles.indexOf(data);
      if (index >= 0) {
        intersectingHandles.splice(index, 1);
      }
      updateCursor();
      setResizeHandlerState("up", true, null);
    }
  };
}
function handlePointerDown(event) {
  const {
    target
  } = event;
  const {
    x: x2,
    y: y2
  } = getResizeEventCoordinates(event);
  isPointerDown = true;
  recalculateIntersectingHandles({
    target,
    x: x2,
    y: y2
  });
  updateListeners();
  if (intersectingHandles.length > 0) {
    updateResizeHandlerStates("down", event);
    event.preventDefault();
    event.stopPropagation();
  }
}
function handlePointerMove(event) {
  const {
    x: x2,
    y: y2
  } = getResizeEventCoordinates(event);
  if (isPointerDown && event.buttons === 0) {
    isPointerDown = false;
    updateResizeHandlerStates("up", event);
  }
  if (!isPointerDown) {
    const {
      target
    } = event;
    recalculateIntersectingHandles({
      target,
      x: x2,
      y: y2
    });
  }
  updateResizeHandlerStates("move", event);
  updateCursor();
  if (intersectingHandles.length > 0) {
    event.preventDefault();
  }
}
function handlePointerUp(event) {
  const {
    target
  } = event;
  const {
    x: x2,
    y: y2
  } = getResizeEventCoordinates(event);
  panelConstraintFlags.clear();
  isPointerDown = false;
  if (intersectingHandles.length > 0) {
    event.preventDefault();
  }
  updateResizeHandlerStates("up", event);
  recalculateIntersectingHandles({
    target,
    x: x2,
    y: y2
  });
  updateCursor();
  updateListeners();
}
function recalculateIntersectingHandles({
  target,
  x: x2,
  y: y2
}) {
  intersectingHandles.splice(0);
  let targetElement = null;
  if (target instanceof HTMLElement) {
    targetElement = target;
  }
  registeredResizeHandlers.forEach((data) => {
    const {
      element: dragHandleElement,
      hitAreaMargins
    } = data;
    const dragHandleRect = dragHandleElement.getBoundingClientRect();
    const {
      bottom,
      left,
      right,
      top
    } = dragHandleRect;
    const margin = isCoarsePointer ? hitAreaMargins.coarse : hitAreaMargins.fine;
    const eventIntersects = x2 >= left - margin && x2 <= right + margin && y2 >= top - margin && y2 <= bottom + margin;
    if (eventIntersects) {
      if (targetElement !== null && document.contains(targetElement) && dragHandleElement !== targetElement && !dragHandleElement.contains(targetElement) && !targetElement.contains(dragHandleElement) && // Calculating stacking order has a cost, so we should avoid it if possible
      // That is why we only check potentially intersecting handles,
      // and why we skip if the event target is within the handle's DOM
      compare(targetElement, dragHandleElement) > 0) {
        let currentElement = targetElement;
        let didIntersect = false;
        while (currentElement) {
          if (currentElement.contains(dragHandleElement)) {
            break;
          } else if (intersects(currentElement.getBoundingClientRect(), dragHandleRect, true)) {
            didIntersect = true;
            break;
          }
          currentElement = currentElement.parentElement;
        }
        if (didIntersect) {
          return;
        }
      }
      intersectingHandles.push(data);
    }
  });
}
function reportConstraintsViolation(resizeHandleId, flag) {
  panelConstraintFlags.set(resizeHandleId, flag);
}
function updateCursor() {
  let intersectsHorizontal = false;
  let intersectsVertical = false;
  intersectingHandles.forEach((data) => {
    const {
      direction
    } = data;
    if (direction === "horizontal") {
      intersectsHorizontal = true;
    } else {
      intersectsVertical = true;
    }
  });
  let constraintFlags = 0;
  panelConstraintFlags.forEach((flag) => {
    constraintFlags |= flag;
  });
  if (intersectsHorizontal && intersectsVertical) {
    setGlobalCursorStyle("intersection", constraintFlags);
  } else if (intersectsHorizontal) {
    setGlobalCursorStyle("horizontal", constraintFlags);
  } else if (intersectsVertical) {
    setGlobalCursorStyle("vertical", constraintFlags);
  } else {
    resetGlobalCursorStyle();
  }
}
function updateListeners() {
  ownerDocumentCounts.forEach((_2, ownerDocument2) => {
    const {
      body
    } = ownerDocument2;
    body.removeEventListener("contextmenu", handlePointerUp);
    body.removeEventListener("pointerdown", handlePointerDown);
    body.removeEventListener("pointerleave", handlePointerMove);
    body.removeEventListener("pointermove", handlePointerMove);
  });
  window.removeEventListener("pointerup", handlePointerUp);
  window.removeEventListener("pointercancel", handlePointerUp);
  if (registeredResizeHandlers.size > 0) {
    if (isPointerDown) {
      if (intersectingHandles.length > 0) {
        ownerDocumentCounts.forEach((count, ownerDocument2) => {
          const {
            body
          } = ownerDocument2;
          if (count > 0) {
            body.addEventListener("contextmenu", handlePointerUp);
            body.addEventListener("pointerleave", handlePointerMove);
            body.addEventListener("pointermove", handlePointerMove);
          }
        });
      }
      window.addEventListener("pointerup", handlePointerUp);
      window.addEventListener("pointercancel", handlePointerUp);
    } else {
      ownerDocumentCounts.forEach((count, ownerDocument2) => {
        const {
          body
        } = ownerDocument2;
        if (count > 0) {
          body.addEventListener("pointerdown", handlePointerDown, {
            capture: true
          });
          body.addEventListener("pointermove", handlePointerMove);
        }
      });
    }
  }
}
function updateResizeHandlerStates(action, event) {
  registeredResizeHandlers.forEach((data) => {
    const {
      setResizeHandlerState
    } = data;
    const isActive = intersectingHandles.includes(data);
    setResizeHandlerState(action, isActive, event);
  });
}
function useForceUpdate() {
  const [_2, setCount] = useState(0);
  return useCallback(() => setCount((prevCount) => prevCount + 1), []);
}
function assert(expectedCondition, message) {
  if (!expectedCondition) {
    console.error(message);
    throw Error(message);
  }
}
var PRECISION = 10;
function fuzzyCompareNumbers(actual, expected, fractionDigits = PRECISION) {
  if (actual.toFixed(fractionDigits) === expected.toFixed(fractionDigits)) {
    return 0;
  } else {
    return actual > expected ? 1 : -1;
  }
}
function fuzzyNumbersEqual$1(actual, expected, fractionDigits = PRECISION) {
  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;
}
function fuzzyNumbersEqual(actual, expected, fractionDigits) {
  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;
}
function fuzzyLayoutsEqual(actual, expected, fractionDigits) {
  if (actual.length !== expected.length) {
    return false;
  }
  for (let index = 0; index < actual.length; index++) {
    const actualSize = actual[index];
    const expectedSize = expected[index];
    if (!fuzzyNumbersEqual(actualSize, expectedSize, fractionDigits)) {
      return false;
    }
  }
  return true;
}
function resizePanel({
  panelConstraints: panelConstraintsArray,
  panelIndex,
  size
}) {
  const panelConstraints = panelConstraintsArray[panelIndex];
  assert(panelConstraints != null, `Panel constraints not found for index ${panelIndex}`);
  let {
    collapsedSize = 0,
    collapsible,
    maxSize = 100,
    minSize = 0
  } = panelConstraints;
  if (fuzzyCompareNumbers(size, minSize) < 0) {
    if (collapsible) {
      const halfwayPoint = (collapsedSize + minSize) / 2;
      if (fuzzyCompareNumbers(size, halfwayPoint) < 0) {
        size = collapsedSize;
      } else {
        size = minSize;
      }
    } else {
      size = minSize;
    }
  }
  size = Math.min(maxSize, size);
  size = parseFloat(size.toFixed(PRECISION));
  return size;
}
function adjustLayoutByDelta({
  delta,
  initialLayout,
  panelConstraints: panelConstraintsArray,
  pivotIndices,
  prevLayout,
  trigger
}) {
  if (fuzzyNumbersEqual(delta, 0)) {
    return initialLayout;
  }
  const nextLayout = [...initialLayout];
  const [firstPivotIndex, secondPivotIndex] = pivotIndices;
  assert(firstPivotIndex != null, "Invalid first pivot index");
  assert(secondPivotIndex != null, "Invalid second pivot index");
  let deltaApplied = 0;
  {
    if (trigger === "keyboard") {
      {
        const index = delta < 0 ? secondPivotIndex : firstPivotIndex;
        const panelConstraints = panelConstraintsArray[index];
        assert(panelConstraints, `Panel constraints not found for index ${index}`);
        const {
          collapsedSize = 0,
          collapsible,
          minSize = 0
        } = panelConstraints;
        if (collapsible) {
          const prevSize = initialLayout[index];
          assert(prevSize != null, `Previous layout not found for panel index ${index}`);
          if (fuzzyNumbersEqual(prevSize, collapsedSize)) {
            const localDelta = minSize - prevSize;
            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {
              delta = delta < 0 ? 0 - localDelta : localDelta;
            }
          }
        }
      }
      {
        const index = delta < 0 ? firstPivotIndex : secondPivotIndex;
        const panelConstraints = panelConstraintsArray[index];
        assert(panelConstraints, `No panel constraints found for index ${index}`);
        const {
          collapsedSize = 0,
          collapsible,
          minSize = 0
        } = panelConstraints;
        if (collapsible) {
          const prevSize = initialLayout[index];
          assert(prevSize != null, `Previous layout not found for panel index ${index}`);
          if (fuzzyNumbersEqual(prevSize, minSize)) {
            const localDelta = prevSize - collapsedSize;
            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {
              delta = delta < 0 ? 0 - localDelta : localDelta;
            }
          }
        }
      }
    }
  }
  {
    const increment = delta < 0 ? 1 : -1;
    let index = delta < 0 ? secondPivotIndex : firstPivotIndex;
    let maxAvailableDelta = 0;
    while (true) {
      const prevSize = initialLayout[index];
      assert(prevSize != null, `Previous layout not found for panel index ${index}`);
      const maxSafeSize = resizePanel({
        panelConstraints: panelConstraintsArray,
        panelIndex: index,
        size: 100
      });
      const delta2 = maxSafeSize - prevSize;
      maxAvailableDelta += delta2;
      index += increment;
      if (index < 0 || index >= panelConstraintsArray.length) {
        break;
      }
    }
    const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));
    delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;
  }
  {
    const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex;
    let index = pivotIndex;
    while (index >= 0 && index < panelConstraintsArray.length) {
      const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);
      const prevSize = initialLayout[index];
      assert(prevSize != null, `Previous layout not found for panel index ${index}`);
      const unsafeSize = prevSize - deltaRemaining;
      const safeSize = resizePanel({
        panelConstraints: panelConstraintsArray,
        panelIndex: index,
        size: unsafeSize
      });
      if (!fuzzyNumbersEqual(prevSize, safeSize)) {
        deltaApplied += prevSize - safeSize;
        nextLayout[index] = safeSize;
        if (deltaApplied.toPrecision(3).localeCompare(Math.abs(delta).toPrecision(3), void 0, {
          numeric: true
        }) >= 0) {
          break;
        }
      }
      if (delta < 0) {
        index--;
      } else {
        index++;
      }
    }
  }
  if (fuzzyLayoutsEqual(prevLayout, nextLayout)) {
    return prevLayout;
  }
  {
    const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;
    const prevSize = initialLayout[pivotIndex];
    assert(prevSize != null, `Previous layout not found for panel index ${pivotIndex}`);
    const unsafeSize = prevSize + deltaApplied;
    const safeSize = resizePanel({
      panelConstraints: panelConstraintsArray,
      panelIndex: pivotIndex,
      size: unsafeSize
    });
    nextLayout[pivotIndex] = safeSize;
    if (!fuzzyNumbersEqual(safeSize, unsafeSize)) {
      let deltaRemaining = unsafeSize - safeSize;
      const pivotIndex2 = delta < 0 ? secondPivotIndex : firstPivotIndex;
      let index = pivotIndex2;
      while (index >= 0 && index < panelConstraintsArray.length) {
        const prevSize2 = nextLayout[index];
        assert(prevSize2 != null, `Previous layout not found for panel index ${index}`);
        const unsafeSize2 = prevSize2 + deltaRemaining;
        const safeSize2 = resizePanel({
          panelConstraints: panelConstraintsArray,
          panelIndex: index,
          size: unsafeSize2
        });
        if (!fuzzyNumbersEqual(prevSize2, safeSize2)) {
          deltaRemaining -= safeSize2 - prevSize2;
          nextLayout[index] = safeSize2;
        }
        if (fuzzyNumbersEqual(deltaRemaining, 0)) {
          break;
        }
        if (delta > 0) {
          index--;
        } else {
          index++;
        }
      }
    }
  }
  const totalSize = nextLayout.reduce((total, size) => size + total, 0);
  if (!fuzzyNumbersEqual(totalSize, 100)) {
    return prevLayout;
  }
  return nextLayout;
}
function calculateAriaValues({
  layout,
  panelsArray,
  pivotIndices
}) {
  let currentMinSize = 0;
  let currentMaxSize = 100;
  let totalMinSize = 0;
  let totalMaxSize = 0;
  const firstIndex = pivotIndices[0];
  assert(firstIndex != null, "No pivot index found");
  panelsArray.forEach((panelData, index) => {
    const {
      constraints
    } = panelData;
    const {
      maxSize = 100,
      minSize = 0
    } = constraints;
    if (index === firstIndex) {
      currentMinSize = minSize;
      currentMaxSize = maxSize;
    } else {
      totalMinSize += minSize;
      totalMaxSize += maxSize;
    }
  });
  const valueMax = Math.min(currentMaxSize, 100 - totalMinSize);
  const valueMin = Math.max(currentMinSize, 100 - totalMaxSize);
  const valueNow = layout[firstIndex];
  return {
    valueMax,
    valueMin,
    valueNow
  };
}
function getResizeHandleElementsForGroup(groupId, scope = document) {
  return Array.from(scope.querySelectorAll(`[data-panel-resize-handle-id][data-panel-group-id="${groupId}"]`));
}
function getResizeHandleElementIndex(groupId, id, scope = document) {
  const handles = getResizeHandleElementsForGroup(groupId, scope);
  const index = handles.findIndex((handle) => handle.getAttribute("data-panel-resize-handle-id") === id);
  return index !== null && index !== void 0 ? index : null;
}
function determinePivotIndices(groupId, dragHandleId, panelGroupElement) {
  const index = getResizeHandleElementIndex(groupId, dragHandleId, panelGroupElement);
  return index != null ? [index, index + 1] : [-1, -1];
}
function getPanelGroupElement(id, rootElement = document) {
  var _dataset;
  if (rootElement instanceof HTMLElement && (rootElement === null || rootElement === void 0 ? void 0 : (_dataset = rootElement.dataset) === null || _dataset === void 0 ? void 0 : _dataset.panelGroupId) == id) {
    return rootElement;
  }
  const element = rootElement.querySelector(`[data-panel-group][data-panel-group-id="${id}"]`);
  if (element) {
    return element;
  }
  return null;
}
function getResizeHandleElement(id, scope = document) {
  const element = scope.querySelector(`[data-panel-resize-handle-id="${id}"]`);
  if (element) {
    return element;
  }
  return null;
}
function getResizeHandlePanelIds(groupId, handleId, panelsArray, scope = document) {
  var _panelsArray$index$id, _panelsArray$index, _panelsArray$id, _panelsArray;
  const handle = getResizeHandleElement(handleId, scope);
  const handles = getResizeHandleElementsForGroup(groupId, scope);
  const index = handle ? handles.indexOf(handle) : -1;
  const idBefore = (_panelsArray$index$id = (_panelsArray$index = panelsArray[index]) === null || _panelsArray$index === void 0 ? void 0 : _panelsArray$index.id) !== null && _panelsArray$index$id !== void 0 ? _panelsArray$index$id : null;
  const idAfter = (_panelsArray$id = (_panelsArray = panelsArray[index + 1]) === null || _panelsArray === void 0 ? void 0 : _panelsArray.id) !== null && _panelsArray$id !== void 0 ? _panelsArray$id : null;
  return [idBefore, idAfter];
}
function useWindowSplitterPanelGroupBehavior({
  committedValuesRef,
  eagerValuesRef,
  groupId,
  layout,
  panelDataArray,
  panelGroupElement,
  setLayout
}) {
  const devWarningsRef = useRef({
    didWarnAboutMissingResizeHandle: false
  });
  useIsomorphicLayoutEffect(() => {
    if (!panelGroupElement) {
      return;
    }
    const resizeHandleElements = getResizeHandleElementsForGroup(groupId, panelGroupElement);
    for (let index = 0; index < panelDataArray.length - 1; index++) {
      const {
        valueMax,
        valueMin,
        valueNow
      } = calculateAriaValues({
        layout,
        panelsArray: panelDataArray,
        pivotIndices: [index, index + 1]
      });
      const resizeHandleElement = resizeHandleElements[index];
      if (resizeHandleElement == null) {
        {
          const {
            didWarnAboutMissingResizeHandle
          } = devWarningsRef.current;
          if (!didWarnAboutMissingResizeHandle) {
            devWarningsRef.current.didWarnAboutMissingResizeHandle = true;
            console.warn(`WARNING: Missing resize handle for PanelGroup "${groupId}"`);
          }
        }
      } else {
        const panelData = panelDataArray[index];
        assert(panelData, `No panel data found for index "${index}"`);
        resizeHandleElement.setAttribute("aria-controls", panelData.id);
        resizeHandleElement.setAttribute("aria-valuemax", "" + Math.round(valueMax));
        resizeHandleElement.setAttribute("aria-valuemin", "" + Math.round(valueMin));
        resizeHandleElement.setAttribute("aria-valuenow", valueNow != null ? "" + Math.round(valueNow) : "");
      }
    }
    return () => {
      resizeHandleElements.forEach((resizeHandleElement, index) => {
        resizeHandleElement.removeAttribute("aria-controls");
        resizeHandleElement.removeAttribute("aria-valuemax");
        resizeHandleElement.removeAttribute("aria-valuemin");
        resizeHandleElement.removeAttribute("aria-valuenow");
      });
    };
  }, [groupId, layout, panelDataArray, panelGroupElement]);
  useEffect(() => {
    if (!panelGroupElement) {
      return;
    }
    const eagerValues = eagerValuesRef.current;
    assert(eagerValues, `Eager values not found`);
    const {
      panelDataArray: panelDataArray2
    } = eagerValues;
    const groupElement = getPanelGroupElement(groupId, panelGroupElement);
    assert(groupElement != null, `No group found for id "${groupId}"`);
    const handles = getResizeHandleElementsForGroup(groupId, panelGroupElement);
    assert(handles, `No resize handles found for group id "${groupId}"`);
    const cleanupFunctions = handles.map((handle) => {
      const handleId = handle.getAttribute("data-panel-resize-handle-id");
      assert(handleId, `Resize handle element has no handle id attribute`);
      const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelDataArray2, panelGroupElement);
      if (idBefore == null || idAfter == null) {
        return () => {
        };
      }
      const onKeyDown = (event) => {
        if (event.defaultPrevented) {
          return;
        }
        switch (event.key) {
          case "Enter": {
            event.preventDefault();
            const index = panelDataArray2.findIndex((panelData) => panelData.id === idBefore);
            if (index >= 0) {
              const panelData = panelDataArray2[index];
              assert(panelData, `No panel data found for index ${index}`);
              const size = layout[index];
              const {
                collapsedSize = 0,
                collapsible,
                minSize = 0
              } = panelData.constraints;
              if (size != null && collapsible) {
                const nextLayout = adjustLayoutByDelta({
                  delta: fuzzyNumbersEqual(size, collapsedSize) ? minSize - collapsedSize : collapsedSize - size,
                  initialLayout: layout,
                  panelConstraints: panelDataArray2.map((panelData2) => panelData2.constraints),
                  pivotIndices: determinePivotIndices(groupId, handleId, panelGroupElement),
                  prevLayout: layout,
                  trigger: "keyboard"
                });
                if (layout !== nextLayout) {
                  setLayout(nextLayout);
                }
              }
            }
            break;
          }
        }
      };
      handle.addEventListener("keydown", onKeyDown);
      return () => {
        handle.removeEventListener("keydown", onKeyDown);
      };
    });
    return () => {
      cleanupFunctions.forEach((cleanupFunction) => cleanupFunction());
    };
  }, [panelGroupElement, committedValuesRef, eagerValuesRef, groupId, layout, panelDataArray, setLayout]);
}
function areEqual(arrayA, arrayB) {
  if (arrayA.length !== arrayB.length) {
    return false;
  }
  for (let index = 0; index < arrayA.length; index++) {
    if (arrayA[index] !== arrayB[index]) {
      return false;
    }
  }
  return true;
}
function getResizeEventCursorPosition(direction, event) {
  const isHorizontal = direction === "horizontal";
  const {
    x: x2,
    y: y2
  } = getResizeEventCoordinates(event);
  return isHorizontal ? x2 : y2;
}
function calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement) {
  const isHorizontal = direction === "horizontal";
  const handleElement = getResizeHandleElement(dragHandleId, panelGroupElement);
  assert(handleElement, `No resize handle element found for id "${dragHandleId}"`);
  const groupId = handleElement.getAttribute("data-panel-group-id");
  assert(groupId, `Resize handle element has no group id attribute`);
  let {
    initialCursorPosition
  } = initialDragState;
  const cursorPosition = getResizeEventCursorPosition(direction, event);
  const groupElement = getPanelGroupElement(groupId, panelGroupElement);
  assert(groupElement, `No group element found for id "${groupId}"`);
  const groupRect = groupElement.getBoundingClientRect();
  const groupSizeInPixels = isHorizontal ? groupRect.width : groupRect.height;
  const offsetPixels = cursorPosition - initialCursorPosition;
  const offsetPercentage = offsetPixels / groupSizeInPixels * 100;
  return offsetPercentage;
}
function calculateDeltaPercentage(event, dragHandleId, direction, initialDragState, keyboardResizeBy, panelGroupElement) {
  if (isKeyDown(event)) {
    const isHorizontal = direction === "horizontal";
    let delta = 0;
    if (event.shiftKey) {
      delta = 100;
    } else if (keyboardResizeBy != null) {
      delta = keyboardResizeBy;
    } else {
      delta = 10;
    }
    let movement = 0;
    switch (event.key) {
      case "ArrowDown":
        movement = isHorizontal ? 0 : delta;
        break;
      case "ArrowLeft":
        movement = isHorizontal ? -delta : 0;
        break;
      case "ArrowRight":
        movement = isHorizontal ? delta : 0;
        break;
      case "ArrowUp":
        movement = isHorizontal ? 0 : -delta;
        break;
      case "End":
        movement = 100;
        break;
      case "Home":
        movement = -100;
        break;
    }
    return movement;
  } else {
    if (initialDragState == null) {
      return 0;
    }
    return calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement);
  }
}
function calculateUnsafeDefaultLayout({
  panelDataArray
}) {
  const layout = Array(panelDataArray.length);
  const panelConstraintsArray = panelDataArray.map((panelData) => panelData.constraints);
  let numPanelsWithSizes = 0;
  let remainingSize = 100;
  for (let index = 0; index < panelDataArray.length; index++) {
    const panelConstraints = panelConstraintsArray[index];
    assert(panelConstraints, `Panel constraints not found for index ${index}`);
    const {
      defaultSize
    } = panelConstraints;
    if (defaultSize != null) {
      numPanelsWithSizes++;
      layout[index] = defaultSize;
      remainingSize -= defaultSize;
    }
  }
  for (let index = 0; index < panelDataArray.length; index++) {
    const panelConstraints = panelConstraintsArray[index];
    assert(panelConstraints, `Panel constraints not found for index ${index}`);
    const {
      defaultSize
    } = panelConstraints;
    if (defaultSize != null) {
      continue;
    }
    const numRemainingPanels = panelDataArray.length - numPanelsWithSizes;
    const size = remainingSize / numRemainingPanels;
    numPanelsWithSizes++;
    layout[index] = size;
    remainingSize -= size;
  }
  return layout;
}
function callPanelCallbacks(panelsArray, layout, panelIdToLastNotifiedSizeMap) {
  layout.forEach((size, index) => {
    const panelData = panelsArray[index];
    assert(panelData, `Panel data not found for index ${index}`);
    const {
      callbacks,
      constraints,
      id: panelId
    } = panelData;
    const {
      collapsedSize = 0,
      collapsible
    } = constraints;
    const lastNotifiedSize = panelIdToLastNotifiedSizeMap[panelId];
    if (lastNotifiedSize == null || size !== lastNotifiedSize) {
      panelIdToLastNotifiedSizeMap[panelId] = size;
      const {
        onCollapse,
        onExpand,
        onResize
      } = callbacks;
      if (onResize) {
        onResize(size, lastNotifiedSize);
      }
      if (collapsible && (onCollapse || onExpand)) {
        if (onExpand && (lastNotifiedSize == null || fuzzyNumbersEqual$1(lastNotifiedSize, collapsedSize)) && !fuzzyNumbersEqual$1(size, collapsedSize)) {
          onExpand();
        }
        if (onCollapse && (lastNotifiedSize == null || !fuzzyNumbersEqual$1(lastNotifiedSize, collapsedSize)) && fuzzyNumbersEqual$1(size, collapsedSize)) {
          onCollapse();
        }
      }
    }
  });
}
function compareLayouts(a, b2) {
  if (a.length !== b2.length) {
    return false;
  } else {
    for (let index = 0; index < a.length; index++) {
      if (a[index] != b2[index]) {
        return false;
      }
    }
  }
  return true;
}
function computePanelFlexBoxStyle({
  defaultSize,
  dragState,
  layout,
  panelData,
  panelIndex,
  precision = 3
}) {
  const size = layout[panelIndex];
  let flexGrow;
  if (size == null) {
    flexGrow = defaultSize != void 0 ? defaultSize.toPrecision(precision) : "1";
  } else if (panelData.length === 1) {
    flexGrow = "1";
  } else {
    flexGrow = size.toPrecision(precision);
  }
  return {
    flexBasis: 0,
    flexGrow,
    flexShrink: 1,
    // Without this, Panel sizes may be unintentionally overridden by their content
    overflow: "hidden",
    // Disable pointer events inside of a panel during resize
    // This avoid edge cases like nested iframes
    pointerEvents: dragState !== null ? "none" : void 0
  };
}
function debounce(callback, durationMs = 10) {
  let timeoutId = null;
  let callable = (...args) => {
    if (timeoutId !== null) {
      clearTimeout(timeoutId);
    }
    timeoutId = setTimeout(() => {
      callback(...args);
    }, durationMs);
  };
  return callable;
}
function initializeDefaultStorage(storageObject) {
  try {
    if (typeof localStorage !== "undefined") {
      storageObject.getItem = (name) => {
        return localStorage.getItem(name);
      };
      storageObject.setItem = (name, value) => {
        localStorage.setItem(name, value);
      };
    } else {
      throw new Error("localStorage not supported in this environment");
    }
  } catch (error) {
    console.error(error);
    storageObject.getItem = () => null;
    storageObject.setItem = () => {
    };
  }
}
function getPanelGroupKey(autoSaveId) {
  return `react-resizable-panels:${autoSaveId}`;
}
function getPanelKey(panels) {
  return panels.map((panel) => {
    const {
      constraints,
      id,
      idIsFromProps,
      order
    } = panel;
    if (idIsFromProps) {
      return id;
    } else {
      return order ? `${order}:${JSON.stringify(constraints)}` : JSON.stringify(constraints);
    }
  }).sort((a, b2) => a.localeCompare(b2)).join(",");
}
function loadSerializedPanelGroupState(autoSaveId, storage) {
  try {
    const panelGroupKey = getPanelGroupKey(autoSaveId);
    const serialized = storage.getItem(panelGroupKey);
    if (serialized) {
      const parsed = JSON.parse(serialized);
      if (typeof parsed === "object" && parsed != null) {
        return parsed;
      }
    }
  } catch (error) {
  }
  return null;
}
function loadPanelGroupState(autoSaveId, panels, storage) {
  var _loadSerializedPanelG, _state$panelKey;
  const state = (_loadSerializedPanelG = loadSerializedPanelGroupState(autoSaveId, storage)) !== null && _loadSerializedPanelG !== void 0 ? _loadSerializedPanelG : {};
  const panelKey = getPanelKey(panels);
  return (_state$panelKey = state[panelKey]) !== null && _state$panelKey !== void 0 ? _state$panelKey : null;
}
function savePanelGroupState(autoSaveId, panels, panelSizesBeforeCollapse, sizes, storage) {
  var _loadSerializedPanelG2;
  const panelGroupKey = getPanelGroupKey(autoSaveId);
  const panelKey = getPanelKey(panels);
  const state = (_loadSerializedPanelG2 = loadSerializedPanelGroupState(autoSaveId, storage)) !== null && _loadSerializedPanelG2 !== void 0 ? _loadSerializedPanelG2 : {};
  state[panelKey] = {
    expandToSizes: Object.fromEntries(panelSizesBeforeCollapse.entries()),
    layout: sizes
  };
  try {
    storage.setItem(panelGroupKey, JSON.stringify(state));
  } catch (error) {
    console.error(error);
  }
}
function validatePanelConstraints({
  panelConstraints: panelConstraintsArray,
  panelId,
  panelIndex
}) {
  {
    const warnings = [];
    const panelConstraints = panelConstraintsArray[panelIndex];
    assert(panelConstraints, `No panel constraints found for index ${panelIndex}`);
    const {
      collapsedSize = 0,
      collapsible = false,
      defaultSize,
      maxSize = 100,
      minSize = 0
    } = panelConstraints;
    if (minSize > maxSize) {
      warnings.push(`min size (${minSize}%) should not be greater than max size (${maxSize}%)`);
    }
    if (defaultSize != null) {
      if (defaultSize < 0) {
        warnings.push("default size should not be less than 0");
      } else if (defaultSize < minSize && (!collapsible || defaultSize !== collapsedSize)) {
        warnings.push("default size should not be less than min size");
      }
      if (defaultSize > 100) {
        warnings.push("default size should not be greater than 100");
      } else if (defaultSize > maxSize) {
        warnings.push("default size should not be greater than max size");
      }
    }
    if (collapsedSize > minSize) {
      warnings.push("collapsed size should not be greater than min size");
    }
    if (warnings.length > 0) {
      const name = panelId != null ? `Panel "${panelId}"` : "Panel";
      console.warn(`${name} has an invalid configuration:

${warnings.join("\n")}`);
      return false;
    }
  }
  return true;
}
function validatePanelGroupLayout({
  layout: prevLayout,
  panelConstraints
}) {
  const nextLayout = [...prevLayout];
  const nextLayoutTotalSize = nextLayout.reduce((accumulated, current) => accumulated + current, 0);
  if (nextLayout.length !== panelConstraints.length) {
    throw Error(`Invalid ${panelConstraints.length} panel layout: ${nextLayout.map((size) => `${size}%`).join(", ")}`);
  } else if (!fuzzyNumbersEqual(nextLayoutTotalSize, 100) && nextLayout.length > 0) {
    {
      console.warn(`WARNING: Invalid layout total size: ${nextLayout.map((size) => `${size}%`).join(", ")}. Layout normalization will be applied.`);
    }
    for (let index = 0; index < panelConstraints.length; index++) {
      const unsafeSize = nextLayout[index];
      assert(unsafeSize != null, `No layout data found for index ${index}`);
      const safeSize = 100 / nextLayoutTotalSize * unsafeSize;
      nextLayout[index] = safeSize;
    }
  }
  let remainingSize = 0;
  for (let index = 0; index < panelConstraints.length; index++) {
    const unsafeSize = nextLayout[index];
    assert(unsafeSize != null, `No layout data found for index ${index}`);
    const safeSize = resizePanel({
      panelConstraints,
      panelIndex: index,
      size: unsafeSize
    });
    if (unsafeSize != safeSize) {
      remainingSize += unsafeSize - safeSize;
      nextLayout[index] = safeSize;
    }
  }
  if (!fuzzyNumbersEqual(remainingSize, 0)) {
    for (let index = 0; index < panelConstraints.length; index++) {
      const prevSize = nextLayout[index];
      assert(prevSize != null, `No layout data found for index ${index}`);
      const unsafeSize = prevSize + remainingSize;
      const safeSize = resizePanel({
        panelConstraints,
        panelIndex: index,
        size: unsafeSize
      });
      if (prevSize !== safeSize) {
        remainingSize -= safeSize - prevSize;
        nextLayout[index] = safeSize;
        if (fuzzyNumbersEqual(remainingSize, 0)) {
          break;
        }
      }
    }
  }
  return nextLayout;
}
var LOCAL_STORAGE_DEBOUNCE_INTERVAL = 100;
var defaultStorage = {
  getItem: (name) => {
    initializeDefaultStorage(defaultStorage);
    return defaultStorage.getItem(name);
  },
  setItem: (name, value) => {
    initializeDefaultStorage(defaultStorage);
    defaultStorage.setItem(name, value);
  }
};
var debounceMap = {};
function PanelGroupWithForwardedRef({
  autoSaveId = null,
  children,
  className: classNameFromProps = "",
  direction,
  forwardedRef,
  id: idFromProps = null,
  onLayout = null,
  keyboardResizeBy = null,
  storage = defaultStorage,
  style: styleFromProps,
  tagName: Type = "div",
  ...rest
}) {
  const groupId = useUniqueId(idFromProps);
  const panelGroupElementRef = useRef(null);
  const [dragState, setDragState] = useState(null);
  const [layout, setLayout] = useState([]);
  const forceUpdate = useForceUpdate();
  const panelIdToLastNotifiedSizeMapRef = useRef({});
  const panelSizeBeforeCollapseRef = useRef(/* @__PURE__ */ new Map());
  const prevDeltaRef = useRef(0);
  const committedValuesRef = useRef({
    autoSaveId,
    direction,
    dragState,
    id: groupId,
    keyboardResizeBy,
    onLayout,
    storage
  });
  const eagerValuesRef = useRef({
    layout,
    panelDataArray: [],
    panelDataArrayChanged: false
  });
  const devWarningsRef = useRef({
    didLogIdAndOrderWarning: false,
    didLogPanelConstraintsWarning: false,
    prevPanelIds: []
  });
  useImperativeHandle(forwardedRef, () => ({
    getId: () => committedValuesRef.current.id,
    getLayout: () => {
      const {
        layout: layout2
      } = eagerValuesRef.current;
      return layout2;
    },
    setLayout: (unsafeLayout) => {
      const {
        onLayout: onLayout2
      } = committedValuesRef.current;
      const {
        layout: prevLayout,
        panelDataArray
      } = eagerValuesRef.current;
      const safeLayout = validatePanelGroupLayout({
        layout: unsafeLayout,
        panelConstraints: panelDataArray.map((panelData) => panelData.constraints)
      });
      if (!areEqual(prevLayout, safeLayout)) {
        setLayout(safeLayout);
        eagerValuesRef.current.layout = safeLayout;
        if (onLayout2) {
          onLayout2(safeLayout);
        }
        callPanelCallbacks(panelDataArray, safeLayout, panelIdToLastNotifiedSizeMapRef.current);
      }
    }
  }), []);
  useIsomorphicLayoutEffect(() => {
    committedValuesRef.current.autoSaveId = autoSaveId;
    committedValuesRef.current.direction = direction;
    committedValuesRef.current.dragState = dragState;
    committedValuesRef.current.id = groupId;
    committedValuesRef.current.onLayout = onLayout;
    committedValuesRef.current.storage = storage;
  });
  useWindowSplitterPanelGroupBehavior({
    committedValuesRef,
    eagerValuesRef,
    groupId,
    layout,
    panelDataArray: eagerValuesRef.current.panelDataArray,
    setLayout,
    panelGroupElement: panelGroupElementRef.current
  });
  useEffect(() => {
    const {
      panelDataArray
    } = eagerValuesRef.current;
    if (autoSaveId) {
      if (layout.length === 0 || layout.length !== panelDataArray.length) {
        return;
      }
      let debouncedSave = debounceMap[autoSaveId];
      if (debouncedSave == null) {
        debouncedSave = debounce(savePanelGroupState, LOCAL_STORAGE_DEBOUNCE_INTERVAL);
        debounceMap[autoSaveId] = debouncedSave;
      }
      const clonedPanelDataArray = [...panelDataArray];
      const clonedPanelSizesBeforeCollapse = new Map(panelSizeBeforeCollapseRef.current);
      debouncedSave(autoSaveId, clonedPanelDataArray, clonedPanelSizesBeforeCollapse, layout, storage);
    }
  }, [autoSaveId, layout, storage]);
  useEffect(() => {
    {
      const {
        panelDataArray
      } = eagerValuesRef.current;
      const {
        didLogIdAndOrderWarning,
        didLogPanelConstraintsWarning,
        prevPanelIds
      } = devWarningsRef.current;
      if (!didLogIdAndOrderWarning) {
        const panelIds = panelDataArray.map(({
          id
        }) => id);
        devWarningsRef.current.prevPanelIds = panelIds;
        const panelsHaveChanged = prevPanelIds.length > 0 && !areEqual(prevPanelIds, panelIds);
        if (panelsHaveChanged) {
          if (panelDataArray.find(({
            idIsFromProps,
            order
          }) => !idIsFromProps || order == null)) {
            devWarningsRef.current.didLogIdAndOrderWarning = true;
            console.warn(`WARNING: Panel id and order props recommended when panels are dynamically rendered`);
          }
        }
      }
      if (!didLogPanelConstraintsWarning) {
        const panelConstraints = panelDataArray.map((panelData) => panelData.constraints);
        for (let panelIndex = 0; panelIndex < panelConstraints.length; panelIndex++) {
          const panelData = panelDataArray[panelIndex];
          assert(panelData, `Panel data not found for index ${panelIndex}`);
          const isValid = validatePanelConstraints({
            panelConstraints,
            panelId: panelData.id,
            panelIndex
          });
          if (!isValid) {
            devWarningsRef.current.didLogPanelConstraintsWarning = true;
            break;
          }
        }
      }
    }
  });
  const collapsePanel = useCallback((panelData) => {
    const {
      onLayout: onLayout2
    } = committedValuesRef.current;
    const {
      layout: prevLayout,
      panelDataArray
    } = eagerValuesRef.current;
    if (panelData.constraints.collapsible) {
      const panelConstraintsArray = panelDataArray.map((panelData2) => panelData2.constraints);
      const {
        collapsedSize = 0,
        panelSize,
        pivotIndices
      } = panelDataHelper(panelDataArray, panelData, prevLayout);
      assert(panelSize != null, `Panel size not found for panel "${panelData.id}"`);
      if (!fuzzyNumbersEqual$1(panelSize, collapsedSize)) {
        panelSizeBeforeCollapseRef.current.set(panelData.id, panelSize);
        const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;
        const delta = isLastPanel ? panelSize - collapsedSize : collapsedSize - panelSize;
        const nextLayout = adjustLayoutByDelta({
          delta,
          initialLayout: prevLayout,
          panelConstraints: panelConstraintsArray,
          pivotIndices,
          prevLayout,
          trigger: "imperative-api"
        });
        if (!compareLayouts(prevLayout, nextLayout)) {
          setLayout(nextLayout);
          eagerValuesRef.current.layout = nextLayout;
          if (onLayout2) {
            onLayout2(nextLayout);
          }
          callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);
        }
      }
    }
  }, []);
  const expandPanel = useCallback((panelData, minSizeOverride) => {
    const {
      onLayout: onLayout2
    } = committedValuesRef.current;
    const {
      layout: prevLayout,
      panelDataArray
    } = eagerValuesRef.current;
    if (panelData.constraints.collapsible) {
      const panelConstraintsArray = panelDataArray.map((panelData2) => panelData2.constraints);
      const {
        collapsedSize = 0,
        panelSize = 0,
        minSize: minSizeFromProps = 0,
        pivotIndices
      } = panelDataHelper(panelDataArray, panelData, prevLayout);
      const minSize = minSizeOverride !== null && minSizeOverride !== void 0 ? minSizeOverride : minSizeFromProps;
      if (fuzzyNumbersEqual$1(panelSize, collapsedSize)) {
        const prevPanelSize = panelSizeBeforeCollapseRef.current.get(panelData.id);
        const baseSize = prevPanelSize != null && prevPanelSize >= minSize ? prevPanelSize : minSize;
        const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;
        const delta = isLastPanel ? panelSize - baseSize : baseSize - panelSize;
        const nextLayout = adjustLayoutByDelta({
          delta,
          initialLayout: prevLayout,
          panelConstraints: panelConstraintsArray,
          pivotIndices,
          prevLayout,
          trigger: "imperative-api"
        });
        if (!compareLayouts(prevLayout, nextLayout)) {
          setLayout(nextLayout);
          eagerValuesRef.current.layout = nextLayout;
          if (onLayout2) {
            onLayout2(nextLayout);
          }
          callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);
        }
      }
    }
  }, []);
  const getPanelSize = useCallback((panelData) => {
    const {
      layout: layout2,
      panelDataArray
    } = eagerValuesRef.current;
    const {
      panelSize
    } = panelDataHelper(panelDataArray, panelData, layout2);
    assert(panelSize != null, `Panel size not found for panel "${panelData.id}"`);
    return panelSize;
  }, []);
  const getPanelStyle = useCallback((panelData, defaultSize) => {
    const {
      panelDataArray
    } = eagerValuesRef.current;
    const panelIndex = findPanelDataIndex(panelDataArray, panelData);
    return computePanelFlexBoxStyle({
      defaultSize,
      dragState,
      layout,
      panelData: panelDataArray,
      panelIndex
    });
  }, [dragState, layout]);
  const isPanelCollapsed = useCallback((panelData) => {
    const {
      layout: layout2,
      panelDataArray
    } = eagerValuesRef.current;
    const {
      collapsedSize = 0,
      collapsible,
      panelSize
    } = panelDataHelper(panelDataArray, panelData, layout2);
    assert(panelSize != null, `Panel size not found for panel "${panelData.id}"`);
    return collapsible === true && fuzzyNumbersEqual$1(panelSize, collapsedSize);
  }, []);
  const isPanelExpanded = useCallback((panelData) => {
    const {
      layout: layout2,
      panelDataArray
    } = eagerValuesRef.current;
    const {
      collapsedSize = 0,
      collapsible,
      panelSize
    } = panelDataHelper(panelDataArray, panelData, layout2);
    assert(panelSize != null, `Panel size not found for panel "${panelData.id}"`);
    return !collapsible || fuzzyCompareNumbers(panelSize, collapsedSize) > 0;
  }, []);
  const registerPanel = useCallback((panelData) => {
    const {
      panelDataArray
    } = eagerValuesRef.current;
    panelDataArray.push(panelData);
    panelDataArray.sort((panelA, panelB) => {
      const orderA = panelA.order;
      const orderB = panelB.order;
      if (orderA == null && orderB == null) {
        return 0;
      } else if (orderA == null) {
        return -1;
      } else if (orderB == null) {
        return 1;
      } else {
        return orderA - orderB;
      }
    });
    eagerValuesRef.current.panelDataArrayChanged = true;
    forceUpdate();
  }, [forceUpdate]);
  useIsomorphicLayoutEffect(() => {
    if (eagerValuesRef.current.panelDataArrayChanged) {
      eagerValuesRef.current.panelDataArrayChanged = false;
      const {
        autoSaveId: autoSaveId2,
        onLayout: onLayout2,
        storage: storage2
      } = committedValuesRef.current;
      const {
        layout: prevLayout,
        panelDataArray
      } = eagerValuesRef.current;
      let unsafeLayout = null;
      if (autoSaveId2) {
        const state = loadPanelGroupState(autoSaveId2, panelDataArray, storage2);
        if (state) {
          panelSizeBeforeCollapseRef.current = new Map(Object.entries(state.expandToSizes));
          unsafeLayout = state.layout;
        }
      }
      if (unsafeLayout == null) {
        unsafeLayout = calculateUnsafeDefaultLayout({
          panelDataArray
        });
      }
      const nextLayout = validatePanelGroupLayout({
        layout: unsafeLayout,
        panelConstraints: panelDataArray.map((panelData) => panelData.constraints)
      });
      if (!areEqual(prevLayout, nextLayout)) {
        setLayout(nextLayout);
        eagerValuesRef.current.layout = nextLayout;
        if (onLayout2) {
          onLayout2(nextLayout);
        }
        callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);
      }
    }
  });
  useIsomorphicLayoutEffect(() => {
    const eagerValues = eagerValuesRef.current;
    return () => {
      eagerValues.layout = [];
    };
  }, []);
  const registerResizeHandle2 = useCallback((dragHandleId) => {
    return function resizeHandler(event) {
      event.preventDefault();
      const panelGroupElement = panelGroupElementRef.current;
      if (!panelGroupElement) {
        return () => null;
      }
      const {
        direction: direction2,
        dragState: dragState2,
        id: groupId2,
        keyboardResizeBy: keyboardResizeBy2,
        onLayout: onLayout2
      } = committedValuesRef.current;
      const {
        layout: prevLayout,
        panelDataArray
      } = eagerValuesRef.current;
      const {
        initialLayout
      } = dragState2 !== null && dragState2 !== void 0 ? dragState2 : {};
      const pivotIndices = determinePivotIndices(groupId2, dragHandleId, panelGroupElement);
      let delta = calculateDeltaPercentage(event, dragHandleId, direction2, dragState2, keyboardResizeBy2, panelGroupElement);
      const isHorizontal = direction2 === "horizontal";
      if (document.dir === "rtl" && isHorizontal) {
        delta = -delta;
      }
      const panelConstraints = panelDataArray.map((panelData) => panelData.constraints);
      const nextLayout = adjustLayoutByDelta({
        delta,
        initialLayout: initialLayout !== null && initialLayout !== void 0 ? initialLayout : prevLayout,
        panelConstraints,
        pivotIndices,
        prevLayout,
        trigger: isKeyDown(event) ? "keyboard" : "mouse-or-touch"
      });
      const layoutChanged = !compareLayouts(prevLayout, nextLayout);
      if (isPointerEvent(event) || isMouseEvent(event)) {
        if (prevDeltaRef.current != delta) {
          prevDeltaRef.current = delta;
          if (!layoutChanged && delta !== 0) {
            if (isHorizontal) {
              reportConstraintsViolation(dragHandleId, delta < 0 ? EXCEEDED_HORIZONTAL_MIN : EXCEEDED_HORIZONTAL_MAX);
            } else {
              reportConstraintsViolation(dragHandleId, delta < 0 ? EXCEEDED_VERTICAL_MIN : EXCEEDED_VERTICAL_MAX);
            }
          } else {
            reportConstraintsViolation(dragHandleId, 0);
          }
        }
      }
      if (layoutChanged) {
        setLayout(nextLayout);
        eagerValuesRef.current.layout = nextLayout;
        if (onLayout2) {
          onLayout2(nextLayout);
        }
        callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);
      }
    };
  }, []);
  const resizePanel2 = useCallback((panelData, unsafePanelSize) => {
    const {
      onLayout: onLayout2
    } = committedValuesRef.current;
    const {
      layout: prevLayout,
      panelDataArray
    } = eagerValuesRef.current;
    const panelConstraintsArray = panelDataArray.map((panelData2) => panelData2.constraints);
    const {
      panelSize,
      pivotIndices
    } = panelDataHelper(panelDataArray, panelData, prevLayout);
    assert(panelSize != null, `Panel size not found for panel "${panelData.id}"`);
    const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;
    const delta = isLastPanel ? panelSize - unsafePanelSize : unsafePanelSize - panelSize;
    const nextLayout = adjustLayoutByDelta({
      delta,
      initialLayout: prevLayout,
      panelConstraints: panelConstraintsArray,
      pivotIndices,
      prevLayout,
      trigger: "imperative-api"
    });
    if (!compareLayouts(prevLayout, nextLayout)) {
      setLayout(nextLayout);
      eagerValuesRef.current.layout = nextLayout;
      if (onLayout2) {
        onLayout2(nextLayout);
      }
      callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);
    }
  }, []);
  const reevaluatePanelConstraints = useCallback((panelData, prevConstraints) => {
    const {
      layout: layout2,
      panelDataArray
    } = eagerValuesRef.current;
    const {
      collapsedSize: prevCollapsedSize = 0,
      collapsible: prevCollapsible
    } = prevConstraints;
    const {
      collapsedSize: nextCollapsedSize = 0,
      collapsible: nextCollapsible,
      maxSize: nextMaxSize = 100,
      minSize: nextMinSize = 0
    } = panelData.constraints;
    const {
      panelSize: prevPanelSize
    } = panelDataHelper(panelDataArray, panelData, layout2);
    if (prevPanelSize == null) {
      return;
    }
    if (prevCollapsible && nextCollapsible && fuzzyNumbersEqual$1(prevPanelSize, prevCollapsedSize)) {
      if (!fuzzyNumbersEqual$1(prevCollapsedSize, nextCollapsedSize)) {
        resizePanel2(panelData, nextCollapsedSize);
      }
    } else if (prevPanelSize < nextMinSize) {
      resizePanel2(panelData, nextMinSize);
    } else if (prevPanelSize > nextMaxSize) {
      resizePanel2(panelData, nextMaxSize);
    }
  }, [resizePanel2]);
  const startDragging = useCallback((dragHandleId, event) => {
    const {
      direction: direction2
    } = committedValuesRef.current;
    const {
      layout: layout2
    } = eagerValuesRef.current;
    if (!panelGroupElementRef.current) {
      return;
    }
    const handleElement = getResizeHandleElement(dragHandleId, panelGroupElementRef.current);
    assert(handleElement, `Drag handle element not found for id "${dragHandleId}"`);
    const initialCursorPosition = getResizeEventCursorPosition(direction2, event);
    setDragState({
      dragHandleId,
      dragHandleRect: handleElement.getBoundingClientRect(),
      initialCursorPosition,
      initialLayout: layout2
    });
  }, []);
  const stopDragging = useCallback(() => {
    setDragState(null);
  }, []);
  const unregisterPanel = useCallback((panelData) => {
    const {
      panelDataArray
    } = eagerValuesRef.current;
    const index = findPanelDataIndex(panelDataArray, panelData);
    if (index >= 0) {
      panelDataArray.splice(index, 1);
      delete panelIdToLastNotifiedSizeMapRef.current[panelData.id];
      eagerValuesRef.current.panelDataArrayChanged = true;
      forceUpdate();
    }
  }, [forceUpdate]);
  const context = useMemo(() => ({
    collapsePanel,
    direction,
    dragState,
    expandPanel,
    getPanelSize,
    getPanelStyle,
    groupId,
    isPanelCollapsed,
    isPanelExpanded,
    reevaluatePanelConstraints,
    registerPanel,
    registerResizeHandle: registerResizeHandle2,
    resizePanel: resizePanel2,
    startDragging,
    stopDragging,
    unregisterPanel,
    panelGroupElement: panelGroupElementRef.current
  }), [collapsePanel, dragState, direction, expandPanel, getPanelSize, getPanelStyle, groupId, isPanelCollapsed, isPanelExpanded, reevaluatePanelConstraints, registerPanel, registerResizeHandle2, resizePanel2, startDragging, stopDragging, unregisterPanel]);
  const style = {
    display: "flex",
    flexDirection: direction === "horizontal" ? "row" : "column",
    height: "100%",
    overflow: "hidden",
    width: "100%"
  };
  return createElement2(PanelGroupContext.Provider, {
    value: context
  }, createElement2(Type, {
    ...rest,
    children,
    className: classNameFromProps,
    id: idFromProps,
    ref: panelGroupElementRef,
    style: {
      ...style,
      ...styleFromProps
    },
    // CSS selectors
    "data-panel-group": "",
    "data-panel-group-direction": direction,
    "data-panel-group-id": groupId
  }));
}
var PanelGroup = forwardRef((props2, ref) => createElement2(PanelGroupWithForwardedRef, {
  ...props2,
  forwardedRef: ref
}));
PanelGroupWithForwardedRef.displayName = "PanelGroup";
PanelGroup.displayName = "forwardRef(PanelGroup)";
function findPanelDataIndex(panelDataArray, panelData) {
  return panelDataArray.findIndex((prevPanelData) => prevPanelData === panelData || prevPanelData.id === panelData.id);
}
function panelDataHelper(panelDataArray, panelData, layout) {
  const panelIndex = findPanelDataIndex(panelDataArray, panelData);
  const isLastPanel = panelIndex === panelDataArray.length - 1;
  const pivotIndices = isLastPanel ? [panelIndex - 1, panelIndex] : [panelIndex, panelIndex + 1];
  const panelSize = layout[panelIndex];
  return {
    ...panelData.constraints,
    panelSize,
    pivotIndices
  };
}
function useWindowSplitterResizeHandlerBehavior({
  disabled,
  handleId,
  resizeHandler,
  panelGroupElement
}) {
  useEffect(() => {
    if (disabled || resizeHandler == null || panelGroupElement == null) {
      return;
    }
    const handleElement = getResizeHandleElement(handleId, panelGroupElement);
    if (handleElement == null) {
      return;
    }
    const onKeyDown = (event) => {
      if (event.defaultPrevented) {
        return;
      }
      switch (event.key) {
        case "ArrowDown":
        case "ArrowLeft":
        case "ArrowRight":
        case "ArrowUp":
        case "End":
        case "Home": {
          event.preventDefault();
          resizeHandler(event);
          break;
        }
        case "F6": {
          event.preventDefault();
          const groupId = handleElement.getAttribute("data-panel-group-id");
          assert(groupId, `No group element found for id "${groupId}"`);
          const handles = getResizeHandleElementsForGroup(groupId, panelGroupElement);
          const index = getResizeHandleElementIndex(groupId, handleId, panelGroupElement);
          assert(index !== null, `No resize element found for id "${handleId}"`);
          const nextIndex = event.shiftKey ? index > 0 ? index - 1 : handles.length - 1 : index + 1 < handles.length ? index + 1 : 0;
          const nextHandle = handles[nextIndex];
          nextHandle.focus();
          break;
        }
      }
    };
    handleElement.addEventListener("keydown", onKeyDown);
    return () => {
      handleElement.removeEventListener("keydown", onKeyDown);
    };
  }, [panelGroupElement, disabled, handleId, resizeHandler]);
}
function PanelResizeHandle({
  children = null,
  className: classNameFromProps = "",
  disabled = false,
  hitAreaMargins,
  id: idFromProps,
  onBlur,
  onDragging,
  onFocus,
  style: styleFromProps = {},
  tabIndex = 0,
  tagName: Type = "div",
  ...rest
}) {
  var _hitAreaMargins$coars, _hitAreaMargins$fine;
  const elementRef = useRef(null);
  const callbacksRef = useRef({
    onDragging
  });
  useEffect(() => {
    callbacksRef.current.onDragging = onDragging;
  });
  const panelGroupContext = useContext(PanelGroupContext);
  if (panelGroupContext === null) {
    throw Error(`PanelResizeHandle components must be rendered within a PanelGroup container`);
  }
  const {
    direction,
    groupId,
    registerResizeHandle: registerResizeHandleWithParentGroup,
    startDragging,
    stopDragging,
    panelGroupElement
  } = panelGroupContext;
  const resizeHandleId = useUniqueId(idFromProps);
  const [state, setState] = useState("inactive");
  const [isFocused, setIsFocused] = useState(false);
  const [resizeHandler, setResizeHandler] = useState(null);
  const committedValuesRef = useRef({
    state
  });
  useIsomorphicLayoutEffect(() => {
    committedValuesRef.current.state = state;
  });
  useEffect(() => {
    if (disabled) {
      setResizeHandler(null);
    } else {
      const resizeHandler2 = registerResizeHandleWithParentGroup(resizeHandleId);
      setResizeHandler(() => resizeHandler2);
    }
  }, [disabled, resizeHandleId, registerResizeHandleWithParentGroup]);
  const coarseHitAreaMargins = (_hitAreaMargins$coars = hitAreaMargins === null || hitAreaMargins === void 0 ? void 0 : hitAreaMargins.coarse) !== null && _hitAreaMargins$coars !== void 0 ? _hitAreaMargins$coars : 15;
  const fineHitAreaMargins = (_hitAreaMargins$fine = hitAreaMargins === null || hitAreaMargins === void 0 ? void 0 : hitAreaMargins.fine) !== null && _hitAreaMargins$fine !== void 0 ? _hitAreaMargins$fine : 5;
  useEffect(() => {
    if (disabled || resizeHandler == null) {
      return;
    }
    const element = elementRef.current;
    assert(element, "Element ref not attached");
    const setResizeHandlerState = (action, isActive, event) => {
      if (isActive) {
        switch (action) {
          case "down": {
            setState("drag");
            assert(event, 'Expected event to be defined for "down" action');
            startDragging(resizeHandleId, event);
            const {
              onDragging: onDragging2
            } = callbacksRef.current;
            if (onDragging2) {
              onDragging2(true);
            }
            break;
          }
          case "move": {
            const {
              state: state2
            } = committedValuesRef.current;
            if (state2 !== "drag") {
              setState("hover");
            }
            assert(event, 'Expected event to be defined for "move" action');
            resizeHandler(event);
            break;
          }
          case "up": {
            setState("hover");
            stopDragging();
            const {
              onDragging: onDragging2
            } = callbacksRef.current;
            if (onDragging2) {
              onDragging2(false);
            }
            break;
          }
        }
      } else {
        setState("inactive");
      }
    };
    return registerResizeHandle(resizeHandleId, element, direction, {
      coarse: coarseHitAreaMargins,
      fine: fineHitAreaMargins
    }, setResizeHandlerState);
  }, [coarseHitAreaMargins, direction, disabled, fineHitAreaMargins, registerResizeHandleWithParentGroup, resizeHandleId, resizeHandler, startDragging, stopDragging]);
  useWindowSplitterResizeHandlerBehavior({
    disabled,
    handleId: resizeHandleId,
    resizeHandler,
    panelGroupElement
  });
  const style = {
    touchAction: "none",
    userSelect: "none"
  };
  return createElement2(Type, {
    ...rest,
    children,
    className: classNameFromProps,
    id: idFromProps,
    onBlur: () => {
      setIsFocused(false);
      onBlur === null || onBlur === void 0 ? void 0 : onBlur();
    },
    onFocus: () => {
      setIsFocused(true);
      onFocus === null || onFocus === void 0 ? void 0 : onFocus();
    },
    ref: elementRef,
    role: "separator",
    style: {
      ...style,
      ...styleFromProps
    },
    tabIndex,
    // CSS selectors
    "data-panel-group-direction": direction,
    "data-panel-group-id": groupId,
    "data-resize-handle": "",
    "data-resize-handle-active": state === "drag" ? "pointer" : isFocused ? "keyboard" : void 0,
    "data-resize-handle-state": state,
    "data-panel-resize-handle-enabled": !disabled,
    "data-panel-resize-handle-id": resizeHandleId
  });
}
PanelResizeHandle.displayName = "PanelResizeHandle";
function getPanelElement(id, scope = document) {
  const element = scope.querySelector(`[data-panel-id="${id}"]`);
  if (element) {
    return element;
  }
  return null;
}
function getPanelElementsForGroup(groupId, scope = document) {
  return Array.from(scope.querySelectorAll(`[data-panel][data-panel-group-id="${groupId}"]`));
}
function getIntersectingRectangle(rectOne, rectTwo, strict) {
  if (!intersects(rectOne, rectTwo, strict)) {
    return {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
  }
  return {
    x: Math.max(rectOne.x, rectTwo.x),
    y: Math.max(rectOne.y, rectTwo.y),
    width: Math.min(rectOne.x + rectOne.width, rectTwo.x + rectTwo.width) - Math.max(rectOne.x, rectTwo.x),
    height: Math.min(rectOne.y + rectOne.height, rectTwo.y + rectTwo.height) - Math.max(rectOne.y, rectTwo.y)
  };
}

// node_modules/@toolpad/studio/dist/exports/editor.mjs
var React112 = __toESM(require_react(), 1);
var React410 = __toESM(require_react(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);

// node_modules/@toolpad/utils/dist/chunk-WJUTEAU5.js
var Emitter = class {
  constructor() {
    this.handlers = /* @__PURE__ */ new Map();
  }
  on(name, handler) {
    let eventHandlers = this.handlers.get(name);
    if (!eventHandlers) {
      eventHandlers = /* @__PURE__ */ new Set();
      this.handlers.set(name, eventHandlers);
    }
    eventHandlers.add(handler);
  }
  /**
   * Remove a listener from an event
   */
  off(name, handler) {
    const eventHandlers = this.handlers.get(name);
    if (eventHandlers) {
      eventHandlers.delete(handler);
      if (eventHandlers.size <= 0) {
        this.handlers.delete(name);
      }
    }
  }
  /**
   * Subscribe to an event and return an unsubscribe function.
   */
  subscribe(name, handler) {
    this.on(name, handler);
    return () => {
      this.off(name, handler);
    };
  }
  /**
   * Emit an event.
   */
  emit(name, event) {
    const eventHandlers = this.handlers.get(name);
    if (eventHandlers) {
      for (const eventHandler of eventHandlers) {
        eventHandler(event);
      }
    }
    const allHandlers = this.handlers.get("*");
    if (allHandlers) {
      for (const eventHandler of allHandlers) {
        eventHandler(name, event);
      }
    }
  }
};

// node_modules/@toolpad/studio/dist/exports/editor.mjs
var import_invariant = __toESM(require_browser(), 1);
var React53 = __toESM(require_react(), 1);
var import_invariant2 = __toESM(require_browser(), 1);
var React310 = __toESM(require_react(), 1);
var import_invariant3 = __toESM(require_browser(), 1);

// node_modules/@toolpad/utils/dist/hooks/useDebouncedHandler.js
var React2 = __toESM(require_react());
function defer(fn2, params, delay) {
  const timeout = setTimeout(() => {
    fn2.current(...params);
  }, delay);
  return { startTime: Date.now(), timeout, params };
}
function useDebouncedHandler(fn2, delay) {
  const fnRef = React2.useRef(fn2);
  React2.useEffect(() => {
    fnRef.current = fn2;
  }, [fn2]);
  const delayedInvocation = React2.useRef(null);
  const clearCurrent = React2.useCallback(() => {
    if (delayedInvocation.current) {
      clearTimeout(delayedInvocation.current.timeout);
      delayedInvocation.current = null;
    }
  }, []);
  React2.useEffect(() => {
    if (!delayedInvocation.current) {
      return;
    }
    const { startTime, params } = delayedInvocation.current;
    const elapsed = Date.now() - startTime;
    const newDelay = Math.max(delay - elapsed, 0);
    clearCurrent();
    delayedInvocation.current = defer(fnRef, params, newDelay);
  }, [delay, clearCurrent]);
  return React2.useCallback(
    (...params) => {
      clearCurrent();
      delayedInvocation.current = defer(fnRef, params, delay);
    },
    [delay, clearCurrent]
  );
}

// node_modules/@toolpad/studio/dist/exports/editor.mjs
var React210 = __toESM(require_react(), 1);
var React54 = __toESM(require_react(), 1);
var React102 = __toESM(require_react(), 1);
var import_invariant4 = __toESM(require_browser(), 1);
var React62 = __toESM(require_react(), 1);

// node_modules/@mui/icons-material/esm/DragIndicator.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
var DragIndicator_default = createSvgIcon((0, import_jsx_runtime5.jsx)("path", {
  d: "M11 18c0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2 2 .9 2 2m-2-8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2m0-6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2m6 4c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2m0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2m0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2"
}), "DragIndicator");

// node_modules/@mui/icons-material/esm/Delete.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime());
var Delete_default = createSvgIcon((0, import_jsx_runtime6.jsx)("path", {
  d: "M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6zM19 4h-3.5l-1-1h-5l-1 1H5v2h14z"
}), "Delete");

// node_modules/@mui/icons-material/esm/ContentCopy.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime());
var ContentCopy_default = createSvgIcon((0, import_jsx_runtime7.jsx)("path", {
  d: "M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"
}), "ContentCopy");

// node_modules/@toolpad/studio/dist/exports/editor.mjs
var React72 = __toESM(require_react(), 1);
var import_invariant5 = __toESM(require_browser(), 1);
var React82 = __toESM(require_react(), 1);
var React92 = __toESM(require_react(), 1);
var React452 = __toESM(require_react(), 1);
var React202 = __toESM(require_react(), 1);
var React142 = __toESM(require_react(), 1);
var React122 = __toESM(require_react(), 1);
var React132 = __toESM(require_react(), 1);
var React162 = __toESM(require_react(), 1);
var React152 = __toESM(require_react(), 1);
var React172 = __toESM(require_react(), 1);
var React182 = __toESM(require_react(), 1);

// node_modules/@mui/icons-material/esm/RestartAlt.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime());
var RestartAlt_default = createSvgIcon((0, import_jsx_runtime8.jsx)("path", {
  d: "M12 5V2L8 6l4 4V7c3.31 0 6 2.69 6 6 0 2.97-2.17 5.43-5 5.91v2.02c3.95-.49 7-3.85 7-7.93 0-4.42-3.58-8-8-8m-6 8c0-1.65.67-3.15 1.76-4.24L6.34 7.34C4.9 8.79 4 10.79 4 13c0 4.08 3.05 7.44 7 7.93v-2.02c-2.83-.48-5-2.94-5-5.91"
}), "RestartAlt");

// node_modules/@toolpad/studio/dist/exports/editor.mjs
var React192 = __toESM(require_react(), 1);
var React412 = __toESM(require_react(), 1);
var React392 = __toESM(require_react(), 1);
var React382 = __toESM(require_react(), 1);
var React232 = __toESM(require_react(), 1);
var React222 = __toESM(require_react(), 1);
var React212 = __toESM(require_react(), 1);
var React242 = __toESM(require_react(), 1);
var React252 = __toESM(require_react(), 1);
var React262 = __toESM(require_react(), 1);
var React292 = __toESM(require_react(), 1);

// node_modules/json5/dist/index.mjs
var Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
var ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
var ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;
var unicode = {
  Space_Separator,
  ID_Start,
  ID_Continue
};
var util = {
  isSpaceSeparator(c2) {
    return typeof c2 === "string" && unicode.Space_Separator.test(c2);
  },
  isIdStartChar(c2) {
    return typeof c2 === "string" && (c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 === "$" || c2 === "_" || unicode.ID_Start.test(c2));
  },
  isIdContinueChar(c2) {
    return typeof c2 === "string" && (c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 >= "0" && c2 <= "9" || c2 === "$" || c2 === "_" || c2 === "‌" || c2 === "‍" || unicode.ID_Continue.test(c2));
  },
  isDigit(c2) {
    return typeof c2 === "string" && /[0-9]/.test(c2);
  },
  isHexDigit(c2) {
    return typeof c2 === "string" && /[0-9A-Fa-f]/.test(c2);
  }
};
var source;
var parseState;
var stack;
var pos;
var line;
var column;
var token;
var key;
var root;
var parse = function parse2(text, reviver) {
  source = String(text);
  parseState = "start";
  stack = [];
  pos = 0;
  line = 1;
  column = 0;
  token = void 0;
  key = void 0;
  root = void 0;
  do {
    token = lex();
    parseStates[parseState]();
  } while (token.type !== "eof");
  if (typeof reviver === "function") {
    return internalize({ "": root }, "", reviver);
  }
  return root;
};
function internalize(holder, name, reviver) {
  const value = holder[name];
  if (value != null && typeof value === "object") {
    if (Array.isArray(value)) {
      for (let i = 0; i < value.length; i++) {
        const key2 = String(i);
        const replacement = internalize(value, key2, reviver);
        if (replacement === void 0) {
          delete value[key2];
        } else {
          Object.defineProperty(value, key2, {
            value: replacement,
            writable: true,
            enumerable: true,
            configurable: true
          });
        }
      }
    } else {
      for (const key2 in value) {
        const replacement = internalize(value, key2, reviver);
        if (replacement === void 0) {
          delete value[key2];
        } else {
          Object.defineProperty(value, key2, {
            value: replacement,
            writable: true,
            enumerable: true,
            configurable: true
          });
        }
      }
    }
  }
  return reviver.call(holder, name, value);
}
var lexState;
var buffer;
var doubleQuote;
var sign;
var c;
function lex() {
  lexState = "default";
  buffer = "";
  doubleQuote = false;
  sign = 1;
  for (; ; ) {
    c = peek();
    const token2 = lexStates[lexState]();
    if (token2) {
      return token2;
    }
  }
}
function peek() {
  if (source[pos]) {
    return String.fromCodePoint(source.codePointAt(pos));
  }
}
function read() {
  const c2 = peek();
  if (c2 === "\n") {
    line++;
    column = 0;
  } else if (c2) {
    column += c2.length;
  } else {
    column++;
  }
  if (c2) {
    pos += c2.length;
  }
  return c2;
}
var lexStates = {
  default() {
    switch (c) {
      case "	":
      case "\v":
      case "\f":
      case " ":
      case " ":
      case "\uFEFF":
      case "\n":
      case "\r":
      case "\u2028":
      case "\u2029":
        read();
        return;
      case "/":
        read();
        lexState = "comment";
        return;
      case void 0:
        read();
        return newToken("eof");
    }
    if (util.isSpaceSeparator(c)) {
      read();
      return;
    }
    return lexStates[parseState]();
  },
  comment() {
    switch (c) {
      case "*":
        read();
        lexState = "multiLineComment";
        return;
      case "/":
        read();
        lexState = "singleLineComment";
        return;
    }
    throw invalidChar(read());
  },
  multiLineComment() {
    switch (c) {
      case "*":
        read();
        lexState = "multiLineCommentAsterisk";
        return;
      case void 0:
        throw invalidChar(read());
    }
    read();
  },
  multiLineCommentAsterisk() {
    switch (c) {
      case "*":
        read();
        return;
      case "/":
        read();
        lexState = "default";
        return;
      case void 0:
        throw invalidChar(read());
    }
    read();
    lexState = "multiLineComment";
  },
  singleLineComment() {
    switch (c) {
      case "\n":
      case "\r":
      case "\u2028":
      case "\u2029":
        read();
        lexState = "default";
        return;
      case void 0:
        read();
        return newToken("eof");
    }
    read();
  },
  value() {
    switch (c) {
      case "{":
      case "[":
        return newToken("punctuator", read());
      case "n":
        read();
        literal("ull");
        return newToken("null", null);
      case "t":
        read();
        literal("rue");
        return newToken("boolean", true);
      case "f":
        read();
        literal("alse");
        return newToken("boolean", false);
      case "-":
      case "+":
        if (read() === "-") {
          sign = -1;
        }
        lexState = "sign";
        return;
      case ".":
        buffer = read();
        lexState = "decimalPointLeading";
        return;
      case "0":
        buffer = read();
        lexState = "zero";
        return;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        buffer = read();
        lexState = "decimalInteger";
        return;
      case "I":
        read();
        literal("nfinity");
        return newToken("numeric", Infinity);
      case "N":
        read();
        literal("aN");
        return newToken("numeric", NaN);
      case '"':
      case "'":
        doubleQuote = read() === '"';
        buffer = "";
        lexState = "string";
        return;
    }
    throw invalidChar(read());
  },
  identifierNameStartEscape() {
    if (c !== "u") {
      throw invalidChar(read());
    }
    read();
    const u = unicodeEscape();
    switch (u) {
      case "$":
      case "_":
        break;
      default:
        if (!util.isIdStartChar(u)) {
          throw invalidIdentifier();
        }
        break;
    }
    buffer += u;
    lexState = "identifierName";
  },
  identifierName() {
    switch (c) {
      case "$":
      case "_":
      case "‌":
      case "‍":
        buffer += read();
        return;
      case "\\":
        read();
        lexState = "identifierNameEscape";
        return;
    }
    if (util.isIdContinueChar(c)) {
      buffer += read();
      return;
    }
    return newToken("identifier", buffer);
  },
  identifierNameEscape() {
    if (c !== "u") {
      throw invalidChar(read());
    }
    read();
    const u = unicodeEscape();
    switch (u) {
      case "$":
      case "_":
      case "‌":
      case "‍":
        break;
      default:
        if (!util.isIdContinueChar(u)) {
          throw invalidIdentifier();
        }
        break;
    }
    buffer += u;
    lexState = "identifierName";
  },
  sign() {
    switch (c) {
      case ".":
        buffer = read();
        lexState = "decimalPointLeading";
        return;
      case "0":
        buffer = read();
        lexState = "zero";
        return;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        buffer = read();
        lexState = "decimalInteger";
        return;
      case "I":
        read();
        literal("nfinity");
        return newToken("numeric", sign * Infinity);
      case "N":
        read();
        literal("aN");
        return newToken("numeric", NaN);
    }
    throw invalidChar(read());
  },
  zero() {
    switch (c) {
      case ".":
        buffer += read();
        lexState = "decimalPoint";
        return;
      case "e":
      case "E":
        buffer += read();
        lexState = "decimalExponent";
        return;
      case "x":
      case "X":
        buffer += read();
        lexState = "hexadecimal";
        return;
    }
    return newToken("numeric", sign * 0);
  },
  decimalInteger() {
    switch (c) {
      case ".":
        buffer += read();
        lexState = "decimalPoint";
        return;
      case "e":
      case "E":
        buffer += read();
        lexState = "decimalExponent";
        return;
    }
    if (util.isDigit(c)) {
      buffer += read();
      return;
    }
    return newToken("numeric", sign * Number(buffer));
  },
  decimalPointLeading() {
    if (util.isDigit(c)) {
      buffer += read();
      lexState = "decimalFraction";
      return;
    }
    throw invalidChar(read());
  },
  decimalPoint() {
    switch (c) {
      case "e":
      case "E":
        buffer += read();
        lexState = "decimalExponent";
        return;
    }
    if (util.isDigit(c)) {
      buffer += read();
      lexState = "decimalFraction";
      return;
    }
    return newToken("numeric", sign * Number(buffer));
  },
  decimalFraction() {
    switch (c) {
      case "e":
      case "E":
        buffer += read();
        lexState = "decimalExponent";
        return;
    }
    if (util.isDigit(c)) {
      buffer += read();
      return;
    }
    return newToken("numeric", sign * Number(buffer));
  },
  decimalExponent() {
    switch (c) {
      case "+":
      case "-":
        buffer += read();
        lexState = "decimalExponentSign";
        return;
    }
    if (util.isDigit(c)) {
      buffer += read();
      lexState = "decimalExponentInteger";
      return;
    }
    throw invalidChar(read());
  },
  decimalExponentSign() {
    if (util.isDigit(c)) {
      buffer += read();
      lexState = "decimalExponentInteger";
      return;
    }
    throw invalidChar(read());
  },
  decimalExponentInteger() {
    if (util.isDigit(c)) {
      buffer += read();
      return;
    }
    return newToken("numeric", sign * Number(buffer));
  },
  hexadecimal() {
    if (util.isHexDigit(c)) {
      buffer += read();
      lexState = "hexadecimalInteger";
      return;
    }
    throw invalidChar(read());
  },
  hexadecimalInteger() {
    if (util.isHexDigit(c)) {
      buffer += read();
      return;
    }
    return newToken("numeric", sign * Number(buffer));
  },
  string() {
    switch (c) {
      case "\\":
        read();
        buffer += escape();
        return;
      case '"':
        if (doubleQuote) {
          read();
          return newToken("string", buffer);
        }
        buffer += read();
        return;
      case "'":
        if (!doubleQuote) {
          read();
          return newToken("string", buffer);
        }
        buffer += read();
        return;
      case "\n":
      case "\r":
        throw invalidChar(read());
      case "\u2028":
      case "\u2029":
        separatorChar(c);
        break;
      case void 0:
        throw invalidChar(read());
    }
    buffer += read();
  },
  start() {
    switch (c) {
      case "{":
      case "[":
        return newToken("punctuator", read());
    }
    lexState = "value";
  },
  beforePropertyName() {
    switch (c) {
      case "$":
      case "_":
        buffer = read();
        lexState = "identifierName";
        return;
      case "\\":
        read();
        lexState = "identifierNameStartEscape";
        return;
      case "}":
        return newToken("punctuator", read());
      case '"':
      case "'":
        doubleQuote = read() === '"';
        lexState = "string";
        return;
    }
    if (util.isIdStartChar(c)) {
      buffer += read();
      lexState = "identifierName";
      return;
    }
    throw invalidChar(read());
  },
  afterPropertyName() {
    if (c === ":") {
      return newToken("punctuator", read());
    }
    throw invalidChar(read());
  },
  beforePropertyValue() {
    lexState = "value";
  },
  afterPropertyValue() {
    switch (c) {
      case ",":
      case "}":
        return newToken("punctuator", read());
    }
    throw invalidChar(read());
  },
  beforeArrayValue() {
    if (c === "]") {
      return newToken("punctuator", read());
    }
    lexState = "value";
  },
  afterArrayValue() {
    switch (c) {
      case ",":
      case "]":
        return newToken("punctuator", read());
    }
    throw invalidChar(read());
  },
  end() {
    throw invalidChar(read());
  }
};
function newToken(type, value) {
  return {
    type,
    value,
    line,
    column
  };
}
function literal(s) {
  for (const c2 of s) {
    const p = peek();
    if (p !== c2) {
      throw invalidChar(read());
    }
    read();
  }
}
function escape() {
  const c2 = peek();
  switch (c2) {
    case "b":
      read();
      return "\b";
    case "f":
      read();
      return "\f";
    case "n":
      read();
      return "\n";
    case "r":
      read();
      return "\r";
    case "t":
      read();
      return "	";
    case "v":
      read();
      return "\v";
    case "0":
      read();
      if (util.isDigit(peek())) {
        throw invalidChar(read());
      }
      return "\0";
    case "x":
      read();
      return hexEscape();
    case "u":
      read();
      return unicodeEscape();
    case "\n":
    case "\u2028":
    case "\u2029":
      read();
      return "";
    case "\r":
      read();
      if (peek() === "\n") {
        read();
      }
      return "";
    case "1":
    case "2":
    case "3":
    case "4":
    case "5":
    case "6":
    case "7":
    case "8":
    case "9":
      throw invalidChar(read());
    case void 0:
      throw invalidChar(read());
  }
  return read();
}
function hexEscape() {
  let buffer2 = "";
  let c2 = peek();
  if (!util.isHexDigit(c2)) {
    throw invalidChar(read());
  }
  buffer2 += read();
  c2 = peek();
  if (!util.isHexDigit(c2)) {
    throw invalidChar(read());
  }
  buffer2 += read();
  return String.fromCodePoint(parseInt(buffer2, 16));
}
function unicodeEscape() {
  let buffer2 = "";
  let count = 4;
  while (count-- > 0) {
    const c2 = peek();
    if (!util.isHexDigit(c2)) {
      throw invalidChar(read());
    }
    buffer2 += read();
  }
  return String.fromCodePoint(parseInt(buffer2, 16));
}
var parseStates = {
  start() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    push();
  },
  beforePropertyName() {
    switch (token.type) {
      case "identifier":
      case "string":
        key = token.value;
        parseState = "afterPropertyName";
        return;
      case "punctuator":
        pop();
        return;
      case "eof":
        throw invalidEOF();
    }
  },
  afterPropertyName() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    parseState = "beforePropertyValue";
  },
  beforePropertyValue() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    push();
  },
  beforeArrayValue() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    if (token.type === "punctuator" && token.value === "]") {
      pop();
      return;
    }
    push();
  },
  afterPropertyValue() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    switch (token.value) {
      case ",":
        parseState = "beforePropertyName";
        return;
      case "}":
        pop();
    }
  },
  afterArrayValue() {
    if (token.type === "eof") {
      throw invalidEOF();
    }
    switch (token.value) {
      case ",":
        parseState = "beforeArrayValue";
        return;
      case "]":
        pop();
    }
  },
  end() {
  }
};
function push() {
  let value;
  switch (token.type) {
    case "punctuator":
      switch (token.value) {
        case "{":
          value = {};
          break;
        case "[":
          value = [];
          break;
      }
      break;
    case "null":
    case "boolean":
    case "numeric":
    case "string":
      value = token.value;
      break;
  }
  if (root === void 0) {
    root = value;
  } else {
    const parent = stack[stack.length - 1];
    if (Array.isArray(parent)) {
      parent.push(value);
    } else {
      Object.defineProperty(parent, key, {
        value,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }
  if (value !== null && typeof value === "object") {
    stack.push(value);
    if (Array.isArray(value)) {
      parseState = "beforeArrayValue";
    } else {
      parseState = "beforePropertyName";
    }
  } else {
    const current = stack[stack.length - 1];
    if (current == null) {
      parseState = "end";
    } else if (Array.isArray(current)) {
      parseState = "afterArrayValue";
    } else {
      parseState = "afterPropertyValue";
    }
  }
}
function pop() {
  stack.pop();
  const current = stack[stack.length - 1];
  if (current == null) {
    parseState = "end";
  } else if (Array.isArray(current)) {
    parseState = "afterArrayValue";
  } else {
    parseState = "afterPropertyValue";
  }
}
function invalidChar(c2) {
  if (c2 === void 0) {
    return syntaxError(`JSON5: invalid end of input at ${line}:${column}`);
  }
  return syntaxError(`JSON5: invalid character '${formatChar(c2)}' at ${line}:${column}`);
}
function invalidEOF() {
  return syntaxError(`JSON5: invalid end of input at ${line}:${column}`);
}
function invalidIdentifier() {
  column -= 5;
  return syntaxError(`JSON5: invalid identifier character at ${line}:${column}`);
}
function separatorChar(c2) {
  console.warn(`JSON5: '${formatChar(c2)}' in strings is not valid ECMAScript; consider escaping`);
}
function formatChar(c2) {
  const replacements = {
    "'": "\\'",
    '"': '\\"',
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t",
    "\v": "\\v",
    "\0": "\\0",
    "\u2028": "\\u2028",
    "\u2029": "\\u2029"
  };
  if (replacements[c2]) {
    return replacements[c2];
  }
  if (c2 < " ") {
    const hexString = c2.charCodeAt(0).toString(16);
    return "\\x" + ("00" + hexString).substring(hexString.length);
  }
  return c2;
}
function syntaxError(message) {
  const err = new SyntaxError(message);
  err.lineNumber = line;
  err.columnNumber = column;
  return err;
}
var stringify = function stringify2(value, replacer, space) {
  const stack2 = [];
  let indent2 = "";
  let propertyList;
  let replacerFunc;
  let gap = "";
  let quote;
  if (replacer != null && typeof replacer === "object" && !Array.isArray(replacer)) {
    space = replacer.space;
    quote = replacer.quote;
    replacer = replacer.replacer;
  }
  if (typeof replacer === "function") {
    replacerFunc = replacer;
  } else if (Array.isArray(replacer)) {
    propertyList = [];
    for (const v of replacer) {
      let item;
      if (typeof v === "string") {
        item = v;
      } else if (typeof v === "number" || v instanceof String || v instanceof Number) {
        item = String(v);
      }
      if (item !== void 0 && propertyList.indexOf(item) < 0) {
        propertyList.push(item);
      }
    }
  }
  if (space instanceof Number) {
    space = Number(space);
  } else if (space instanceof String) {
    space = String(space);
  }
  if (typeof space === "number") {
    if (space > 0) {
      space = Math.min(10, Math.floor(space));
      gap = "          ".substr(0, space);
    }
  } else if (typeof space === "string") {
    gap = space.substr(0, 10);
  }
  return serializeProperty("", { "": value });
  function serializeProperty(key2, holder) {
    let value2 = holder[key2];
    if (value2 != null) {
      if (typeof value2.toJSON5 === "function") {
        value2 = value2.toJSON5(key2);
      } else if (typeof value2.toJSON === "function") {
        value2 = value2.toJSON(key2);
      }
    }
    if (replacerFunc) {
      value2 = replacerFunc.call(holder, key2, value2);
    }
    if (value2 instanceof Number) {
      value2 = Number(value2);
    } else if (value2 instanceof String) {
      value2 = String(value2);
    } else if (value2 instanceof Boolean) {
      value2 = value2.valueOf();
    }
    switch (value2) {
      case null:
        return "null";
      case true:
        return "true";
      case false:
        return "false";
    }
    if (typeof value2 === "string") {
      return quoteString(value2, false);
    }
    if (typeof value2 === "number") {
      return String(value2);
    }
    if (typeof value2 === "object") {
      return Array.isArray(value2) ? serializeArray(value2) : serializeObject(value2);
    }
    return void 0;
  }
  function quoteString(value2) {
    const quotes = {
      "'": 0.1,
      '"': 0.2
    };
    const replacements = {
      "'": "\\'",
      '"': '\\"',
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t",
      "\v": "\\v",
      "\0": "\\0",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    let product = "";
    for (let i = 0; i < value2.length; i++) {
      const c2 = value2[i];
      switch (c2) {
        case "'":
        case '"':
          quotes[c2]++;
          product += c2;
          continue;
        case "\0":
          if (util.isDigit(value2[i + 1])) {
            product += "\\x00";
            continue;
          }
      }
      if (replacements[c2]) {
        product += replacements[c2];
        continue;
      }
      if (c2 < " ") {
        let hexString = c2.charCodeAt(0).toString(16);
        product += "\\x" + ("00" + hexString).substring(hexString.length);
        continue;
      }
      product += c2;
    }
    const quoteChar = quote || Object.keys(quotes).reduce((a, b2) => quotes[a] < quotes[b2] ? a : b2);
    product = product.replace(new RegExp(quoteChar, "g"), replacements[quoteChar]);
    return quoteChar + product + quoteChar;
  }
  function serializeObject(value2) {
    if (stack2.indexOf(value2) >= 0) {
      throw TypeError("Converting circular structure to JSON5");
    }
    stack2.push(value2);
    let stepback = indent2;
    indent2 = indent2 + gap;
    let keys = propertyList || Object.keys(value2);
    let partial = [];
    for (const key2 of keys) {
      const propertyString = serializeProperty(key2, value2);
      if (propertyString !== void 0) {
        let member = serializeKey(key2) + ":";
        if (gap !== "") {
          member += " ";
        }
        member += propertyString;
        partial.push(member);
      }
    }
    let final;
    if (partial.length === 0) {
      final = "{}";
    } else {
      let properties;
      if (gap === "") {
        properties = partial.join(",");
        final = "{" + properties + "}";
      } else {
        let separator = ",\n" + indent2;
        properties = partial.join(separator);
        final = "{\n" + indent2 + properties + ",\n" + stepback + "}";
      }
    }
    stack2.pop();
    indent2 = stepback;
    return final;
  }
  function serializeKey(key2) {
    if (key2.length === 0) {
      return quoteString(key2, true);
    }
    const firstChar = String.fromCodePoint(key2.codePointAt(0));
    if (!util.isIdStartChar(firstChar)) {
      return quoteString(key2, true);
    }
    for (let i = firstChar.length; i < key2.length; i++) {
      if (!util.isIdContinueChar(String.fromCodePoint(key2.codePointAt(i)))) {
        return quoteString(key2, true);
      }
    }
    return key2;
  }
  function serializeArray(value2) {
    if (stack2.indexOf(value2) >= 0) {
      throw TypeError("Converting circular structure to JSON5");
    }
    stack2.push(value2);
    let stepback = indent2;
    indent2 = indent2 + gap;
    let partial = [];
    for (let i = 0; i < value2.length; i++) {
      const propertyString = serializeProperty(String(i), value2);
      partial.push(propertyString !== void 0 ? propertyString : "null");
    }
    let final;
    if (partial.length === 0) {
      final = "[]";
    } else {
      if (gap === "") {
        let properties = partial.join(",");
        final = "[" + properties + "]";
      } else {
        let separator = ",\n" + indent2;
        let properties = partial.join(separator);
        final = "[\n" + indent2 + properties + ",\n" + stepback + "]";
      }
    }
    stack2.pop();
    indent2 = stepback;
    return final;
  }
};
var JSON5 = {
  parse,
  stringify
};
var lib = JSON5;
var dist_default = lib;

// node_modules/@toolpad/studio/dist/exports/editor.mjs
var React282 = __toESM(require_react(), 1);
var React272 = __toESM(require_react(), 1);
var React302 = __toESM(require_react(), 1);
var React372 = __toESM(require_react(), 1);

// node_modules/@mui/icons-material/esm/Link.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime());
var Link_default2 = createSvgIcon((0, import_jsx_runtime9.jsx)("path", {
  d: "M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1M8 13h8v-2H8zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5"
}), "Link");

// node_modules/@mui/icons-material/esm/AddLink.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime());
var AddLink_default = createSvgIcon((0, import_jsx_runtime10.jsx)("path", {
  d: "M8 11h8v2H8zm12.1 1H22c0-2.76-2.24-5-5-5h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1M19 12h-2v3h-3v2h3v3h2v-3h3v-2h-3z"
}), "AddLink");

// node_modules/@toolpad/utils/dist/hooks/useDebounced.js
var React3 = __toESM(require_react());
function useDebounced(value, delay) {
  const [debouncedValue, setDebouncedValue] = React3.useState(() => value);
  const timeoutIdRef = React3.useRef(null);
  React3.useEffect(
    () => () => {
      if (timeoutIdRef.current) {
        clearTimeout(timeoutIdRef.current);
        timeoutIdRef.current = null;
      }
    },
    []
  );
  React3.useEffect(() => {
    timeoutIdRef.current = setTimeout(() => setDebouncedValue(() => value), delay);
    return () => {
      if (timeoutIdRef.current) {
        clearTimeout(timeoutIdRef.current);
        timeoutIdRef.current = null;
      }
    };
  }, [value, delay]);
  return debouncedValue;
}

// node_modules/@toolpad/studio/dist/exports/editor.mjs
var React322 = __toESM(require_react(), 1);
var import_json_to_ts = __toESM(require_src(), 1);

// node_modules/@toolpad/utils/dist/json.js
function getCircularReplacer() {
  const ancestors = [];
  return function replacer(key2, value) {
    if (typeof value !== "object" || value === null) {
      return value;
    }
    while (ancestors.length > 0 && ancestors.at(-1) !== this) {
      ancestors.pop();
    }
    if (ancestors.includes(value)) {
      return "[Circular]";
    }
    ancestors.push(value);
    return value;
  };
}
function replaceRecursiveImpl(obj, replacer) {
  if (Array.isArray(obj)) {
    return obj.map((item, i) => {
      const newItem = replacer.call(obj, i, item);
      return replaceRecursiveImpl(newItem, replacer);
    });
  }
  if (obj && typeof obj === "object") {
    return Object.fromEntries(
      Object.entries(obj).map(([key2, value]) => {
        const newValue = replacer.call(obj, key2, value);
        return [key2, replaceRecursiveImpl(newValue, replacer)];
      })
    );
  }
  return obj;
}
function replaceRecursive(obj, replacer) {
  return replaceRecursiveImpl({ "": obj }, replacer)[""];
}

// node_modules/@toolpad/studio/dist/exports/editor.mjs
var React312 = __toESM(require_react(), 1);
var React342 = __toESM(require_react(), 1);
var React332 = __toESM(require_react(), 1);

// node_modules/react-inspector/dist/index.mjs
var import_react = __toESM(require_react(), 1);
var import_react2 = __toESM(require_react(), 1);
var import_react3 = __toESM(require_react(), 1);
var import_react4 = __toESM(require_react(), 1);
var import_react5 = __toESM(require_react(), 1);
var import_react6 = __toESM(require_react(), 1);
var import_react7 = __toESM(require_react(), 1);
var import_react8 = __toESM(require_react(), 1);
var import_react9 = __toESM(require_react(), 1);
var import_react10 = __toESM(require_react(), 1);
var import_react11 = __toESM(require_react(), 1);
var import_react12 = __toESM(require_react(), 1);
var import_react13 = __toESM(require_react(), 1);
var import_react14 = __toESM(require_react(), 1);
var import_react15 = __toESM(require_react(), 1);
var import_react16 = __toESM(require_react(), 1);
var import_react17 = __toESM(require_react(), 1);
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS2 = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export3 = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to2, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key2 of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to2, key2) && key2 !== except)
        __defProp(to2, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
  }
  return to2;
};
var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var require_is_object = __commonJS2({
  "node_modules/is-object/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function isObject(x2) {
      return typeof x2 === "object" && x2 !== null;
    };
  }
});
var require_is_window = __commonJS2({
  "node_modules/is-window/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(obj) {
      if (obj == null) {
        return false;
      }
      var o = Object(obj);
      return o === o.window;
    };
  }
});
var require_is_dom = __commonJS2({
  "node_modules/is-dom/index.js"(exports2, module2) {
    var isObject = require_is_object();
    var isWindow = require_is_window();
    function isNode(val) {
      if (!isObject(val) || !isWindow(window) || typeof window.Node !== "function") {
        return false;
      }
      return typeof val.nodeType === "number" && typeof val.nodeName === "string";
    }
    module2.exports = isNode;
  }
});
var themes_exports = {};
__export3(themes_exports, {
  chromeDark: () => theme,
  chromeLight: () => theme2
});
var theme = {
  BASE_FONT_FAMILY: "Menlo, monospace",
  BASE_FONT_SIZE: "11px",
  BASE_LINE_HEIGHT: 1.2,
  BASE_BACKGROUND_COLOR: "rgb(36, 36, 36)",
  BASE_COLOR: "rgb(213, 213, 213)",
  OBJECT_PREVIEW_ARRAY_MAX_PROPERTIES: 10,
  OBJECT_PREVIEW_OBJECT_MAX_PROPERTIES: 5,
  OBJECT_NAME_COLOR: "rgb(227, 110, 236)",
  OBJECT_VALUE_NULL_COLOR: "rgb(127, 127, 127)",
  OBJECT_VALUE_UNDEFINED_COLOR: "rgb(127, 127, 127)",
  OBJECT_VALUE_REGEXP_COLOR: "rgb(233, 63, 59)",
  OBJECT_VALUE_STRING_COLOR: "rgb(233, 63, 59)",
  OBJECT_VALUE_SYMBOL_COLOR: "rgb(233, 63, 59)",
  OBJECT_VALUE_NUMBER_COLOR: "hsl(252, 100%, 75%)",
  OBJECT_VALUE_BOOLEAN_COLOR: "hsl(252, 100%, 75%)",
  OBJECT_VALUE_FUNCTION_PREFIX_COLOR: "rgb(85, 106, 242)",
  HTML_TAG_COLOR: "rgb(93, 176, 215)",
  HTML_TAGNAME_COLOR: "rgb(93, 176, 215)",
  HTML_TAGNAME_TEXT_TRANSFORM: "lowercase",
  HTML_ATTRIBUTE_NAME_COLOR: "rgb(155, 187, 220)",
  HTML_ATTRIBUTE_VALUE_COLOR: "rgb(242, 151, 102)",
  HTML_COMMENT_COLOR: "rgb(137, 137, 137)",
  HTML_DOCTYPE_COLOR: "rgb(192, 192, 192)",
  ARROW_COLOR: "rgb(145, 145, 145)",
  ARROW_MARGIN_RIGHT: 3,
  ARROW_FONT_SIZE: 12,
  ARROW_ANIMATION_DURATION: "0",
  TREENODE_FONT_FAMILY: "Menlo, monospace",
  TREENODE_FONT_SIZE: "11px",
  TREENODE_LINE_HEIGHT: 1.2,
  TREENODE_PADDING_LEFT: 12,
  TABLE_BORDER_COLOR: "rgb(85, 85, 85)",
  TABLE_TH_BACKGROUND_COLOR: "rgb(44, 44, 44)",
  TABLE_TH_HOVER_COLOR: "rgb(48, 48, 48)",
  TABLE_SORT_ICON_COLOR: "black",
  TABLE_DATA_BACKGROUND_IMAGE: "linear-gradient(rgba(255, 255, 255, 0), rgba(255, 255, 255, 0) 50%, rgba(51, 139, 255, 0.0980392) 50%, rgba(51, 139, 255, 0.0980392))",
  TABLE_DATA_BACKGROUND_SIZE: "128px 32px"
};
var theme2 = {
  BASE_FONT_FAMILY: "Menlo, monospace",
  BASE_FONT_SIZE: "11px",
  BASE_LINE_HEIGHT: 1.2,
  BASE_BACKGROUND_COLOR: "white",
  BASE_COLOR: "black",
  OBJECT_PREVIEW_ARRAY_MAX_PROPERTIES: 10,
  OBJECT_PREVIEW_OBJECT_MAX_PROPERTIES: 5,
  OBJECT_NAME_COLOR: "rgb(136, 19, 145)",
  OBJECT_VALUE_NULL_COLOR: "rgb(128, 128, 128)",
  OBJECT_VALUE_UNDEFINED_COLOR: "rgb(128, 128, 128)",
  OBJECT_VALUE_REGEXP_COLOR: "rgb(196, 26, 22)",
  OBJECT_VALUE_STRING_COLOR: "rgb(196, 26, 22)",
  OBJECT_VALUE_SYMBOL_COLOR: "rgb(196, 26, 22)",
  OBJECT_VALUE_NUMBER_COLOR: "rgb(28, 0, 207)",
  OBJECT_VALUE_BOOLEAN_COLOR: "rgb(28, 0, 207)",
  OBJECT_VALUE_FUNCTION_PREFIX_COLOR: "rgb(13, 34, 170)",
  HTML_TAG_COLOR: "rgb(168, 148, 166)",
  HTML_TAGNAME_COLOR: "rgb(136, 18, 128)",
  HTML_TAGNAME_TEXT_TRANSFORM: "lowercase",
  HTML_ATTRIBUTE_NAME_COLOR: "rgb(153, 69, 0)",
  HTML_ATTRIBUTE_VALUE_COLOR: "rgb(26, 26, 166)",
  HTML_COMMENT_COLOR: "rgb(35, 110, 37)",
  HTML_DOCTYPE_COLOR: "rgb(192, 192, 192)",
  ARROW_COLOR: "#6e6e6e",
  ARROW_MARGIN_RIGHT: 3,
  ARROW_FONT_SIZE: 12,
  ARROW_ANIMATION_DURATION: "0",
  TREENODE_FONT_FAMILY: "Menlo, monospace",
  TREENODE_FONT_SIZE: "11px",
  TREENODE_LINE_HEIGHT: 1.2,
  TREENODE_PADDING_LEFT: 12,
  TABLE_BORDER_COLOR: "#aaa",
  TABLE_TH_BACKGROUND_COLOR: "#eee",
  TABLE_TH_HOVER_COLOR: "hsla(0, 0%, 90%, 1)",
  TABLE_SORT_ICON_COLOR: "#6e6e6e",
  TABLE_DATA_BACKGROUND_IMAGE: "linear-gradient(to bottom, white, white 50%, rgb(234, 243, 255) 50%, rgb(234, 243, 255))",
  TABLE_DATA_BACKGROUND_SIZE: "128px 32px"
};
var ExpandedPathsContext = (0, import_react3.createContext)([{}, () => {
}]);
var unselectable = {
  WebkitTouchCallout: "none",
  WebkitUserSelect: "none",
  KhtmlUserSelect: "none",
  MozUserSelect: "none",
  msUserSelect: "none",
  OUserSelect: "none",
  userSelect: "none"
};
var createTheme2 = (theme3) => ({
  DOMNodePreview: {
    htmlOpenTag: {
      base: {
        color: theme3.HTML_TAG_COLOR
      },
      tagName: {
        color: theme3.HTML_TAGNAME_COLOR,
        textTransform: theme3.HTML_TAGNAME_TEXT_TRANSFORM
      },
      htmlAttributeName: {
        color: theme3.HTML_ATTRIBUTE_NAME_COLOR
      },
      htmlAttributeValue: {
        color: theme3.HTML_ATTRIBUTE_VALUE_COLOR
      }
    },
    htmlCloseTag: {
      base: {
        color: theme3.HTML_TAG_COLOR
      },
      offsetLeft: {
        marginLeft: -theme3.TREENODE_PADDING_LEFT
      },
      tagName: {
        color: theme3.HTML_TAGNAME_COLOR,
        textTransform: theme3.HTML_TAGNAME_TEXT_TRANSFORM
      }
    },
    htmlComment: {
      color: theme3.HTML_COMMENT_COLOR
    },
    htmlDoctype: {
      color: theme3.HTML_DOCTYPE_COLOR
    }
  },
  ObjectPreview: {
    objectDescription: {
      fontStyle: "italic"
    },
    preview: {
      fontStyle: "italic"
    },
    arrayMaxProperties: theme3.OBJECT_PREVIEW_ARRAY_MAX_PROPERTIES,
    objectMaxProperties: theme3.OBJECT_PREVIEW_OBJECT_MAX_PROPERTIES
  },
  ObjectName: {
    base: {
      color: theme3.OBJECT_NAME_COLOR
    },
    dimmed: {
      opacity: 0.6
    }
  },
  ObjectValue: {
    objectValueNull: {
      color: theme3.OBJECT_VALUE_NULL_COLOR
    },
    objectValueUndefined: {
      color: theme3.OBJECT_VALUE_UNDEFINED_COLOR
    },
    objectValueRegExp: {
      color: theme3.OBJECT_VALUE_REGEXP_COLOR
    },
    objectValueString: {
      color: theme3.OBJECT_VALUE_STRING_COLOR
    },
    objectValueSymbol: {
      color: theme3.OBJECT_VALUE_SYMBOL_COLOR
    },
    objectValueNumber: {
      color: theme3.OBJECT_VALUE_NUMBER_COLOR
    },
    objectValueBoolean: {
      color: theme3.OBJECT_VALUE_BOOLEAN_COLOR
    },
    objectValueFunctionPrefix: {
      color: theme3.OBJECT_VALUE_FUNCTION_PREFIX_COLOR,
      fontStyle: "italic"
    },
    objectValueFunctionName: {
      fontStyle: "italic"
    }
  },
  TreeView: {
    treeViewOutline: {
      padding: 0,
      margin: 0,
      listStyleType: "none"
    }
  },
  TreeNode: {
    treeNodeBase: {
      color: theme3.BASE_COLOR,
      backgroundColor: theme3.BASE_BACKGROUND_COLOR,
      lineHeight: theme3.TREENODE_LINE_HEIGHT,
      cursor: "default",
      boxSizing: "border-box",
      listStyle: "none",
      fontFamily: theme3.TREENODE_FONT_FAMILY,
      fontSize: theme3.TREENODE_FONT_SIZE
    },
    treeNodePreviewContainer: {},
    treeNodePlaceholder: {
      whiteSpace: "pre",
      fontSize: theme3.ARROW_FONT_SIZE,
      marginRight: theme3.ARROW_MARGIN_RIGHT,
      ...unselectable
    },
    treeNodeArrow: {
      base: {
        color: theme3.ARROW_COLOR,
        display: "inline-block",
        fontSize: theme3.ARROW_FONT_SIZE,
        marginRight: theme3.ARROW_MARGIN_RIGHT,
        ...parseFloat(theme3.ARROW_ANIMATION_DURATION) > 0 ? {
          transition: `transform ${theme3.ARROW_ANIMATION_DURATION} ease 0s`
        } : {},
        ...unselectable
      },
      expanded: {
        WebkitTransform: "rotateZ(90deg)",
        MozTransform: "rotateZ(90deg)",
        transform: "rotateZ(90deg)"
      },
      collapsed: {
        WebkitTransform: "rotateZ(0deg)",
        MozTransform: "rotateZ(0deg)",
        transform: "rotateZ(0deg)"
      }
    },
    treeNodeChildNodesContainer: {
      margin: 0,
      paddingLeft: theme3.TREENODE_PADDING_LEFT
    }
  },
  TableInspector: {
    base: {
      color: theme3.BASE_COLOR,
      position: "relative",
      border: `1px solid ${theme3.TABLE_BORDER_COLOR}`,
      fontFamily: theme3.BASE_FONT_FAMILY,
      fontSize: theme3.BASE_FONT_SIZE,
      lineHeight: "120%",
      boxSizing: "border-box",
      cursor: "default"
    }
  },
  TableInspectorHeaderContainer: {
    base: {
      top: 0,
      height: "17px",
      left: 0,
      right: 0,
      overflowX: "hidden"
    },
    table: {
      tableLayout: "fixed",
      borderSpacing: 0,
      borderCollapse: "separate",
      height: "100%",
      width: "100%",
      margin: 0
    }
  },
  TableInspectorDataContainer: {
    tr: {
      display: "table-row"
    },
    td: {
      boxSizing: "border-box",
      border: "none",
      height: "16px",
      verticalAlign: "top",
      padding: "1px 4px",
      WebkitUserSelect: "text",
      whiteSpace: "nowrap",
      textOverflow: "ellipsis",
      overflow: "hidden",
      lineHeight: "14px"
    },
    div: {
      position: "static",
      top: "17px",
      bottom: 0,
      overflowY: "overlay",
      transform: "translateZ(0)",
      left: 0,
      right: 0,
      overflowX: "hidden"
    },
    table: {
      positon: "static",
      left: 0,
      top: 0,
      right: 0,
      bottom: 0,
      borderTop: "0 none transparent",
      margin: 0,
      backgroundImage: theme3.TABLE_DATA_BACKGROUND_IMAGE,
      backgroundSize: theme3.TABLE_DATA_BACKGROUND_SIZE,
      tableLayout: "fixed",
      borderSpacing: 0,
      borderCollapse: "separate",
      width: "100%",
      fontSize: theme3.BASE_FONT_SIZE,
      lineHeight: "120%"
    }
  },
  TableInspectorTH: {
    base: {
      position: "relative",
      height: "auto",
      textAlign: "left",
      backgroundColor: theme3.TABLE_TH_BACKGROUND_COLOR,
      borderBottom: `1px solid ${theme3.TABLE_BORDER_COLOR}`,
      fontWeight: "normal",
      verticalAlign: "middle",
      padding: "0 4px",
      whiteSpace: "nowrap",
      textOverflow: "ellipsis",
      overflow: "hidden",
      lineHeight: "14px",
      ":hover": {
        backgroundColor: theme3.TABLE_TH_HOVER_COLOR
      }
    },
    div: {
      whiteSpace: "nowrap",
      textOverflow: "ellipsis",
      overflow: "hidden",
      fontSize: theme3.BASE_FONT_SIZE,
      lineHeight: "120%"
    }
  },
  TableInspectorLeftBorder: {
    none: {
      borderLeft: "none"
    },
    solid: {
      borderLeft: `1px solid ${theme3.TABLE_BORDER_COLOR}`
    }
  },
  TableInspectorSortIcon: {
    display: "block",
    marginRight: 3,
    width: 8,
    height: 7,
    marginTop: -7,
    color: theme3.TABLE_SORT_ICON_COLOR,
    fontSize: 12,
    ...unselectable
  }
});
var DEFAULT_THEME_NAME = "chromeLight";
var ThemeContext = (0, import_react5.createContext)(createTheme2(themes_exports[DEFAULT_THEME_NAME]));
var useStyles = (baseStylesKey) => {
  const themeStyles = (0, import_react5.useContext)(ThemeContext);
  return themeStyles[baseStylesKey];
};
var themeAcceptor = (WrappedComponent) => {
  const ThemeAcceptor = ({ theme: theme3 = DEFAULT_THEME_NAME, ...restProps }) => {
    const themeStyles = (0, import_react5.useMemo)(() => {
      switch (Object.prototype.toString.call(theme3)) {
        case "[object String]":
          return createTheme2(themes_exports[theme3]);
        case "[object Object]":
          return createTheme2(theme3);
        default:
          return createTheme2(themes_exports[DEFAULT_THEME_NAME]);
      }
    }, [theme3]);
    return import_react5.default.createElement(ThemeContext.Provider, {
      value: themeStyles
    }, import_react5.default.createElement(WrappedComponent, {
      ...restProps
    }));
  };
  return ThemeAcceptor;
};
var Arrow = ({ expanded, styles }) => import_react4.default.createElement("span", {
  style: {
    ...styles.base,
    ...expanded ? styles.expanded : styles.collapsed
  }
}, "▶");
var TreeNode = (0, import_react4.memo)((props2) => {
  props2 = {
    expanded: true,
    nodeRenderer: ({ name }) => import_react4.default.createElement("span", null, name),
    onClick: () => {
    },
    shouldShowArrow: false,
    shouldShowPlaceholder: true,
    ...props2
  };
  const { expanded, onClick, children, nodeRenderer, title, shouldShowArrow, shouldShowPlaceholder } = props2;
  const styles = useStyles("TreeNode");
  const NodeRenderer = nodeRenderer;
  return import_react4.default.createElement("li", {
    "aria-expanded": expanded,
    role: "treeitem",
    style: styles.treeNodeBase,
    title
  }, import_react4.default.createElement("div", {
    style: styles.treeNodePreviewContainer,
    onClick
  }, shouldShowArrow || import_react4.Children.count(children) > 0 ? import_react4.default.createElement(Arrow, {
    expanded,
    styles: styles.treeNodeArrow
  }) : shouldShowPlaceholder && import_react4.default.createElement("span", {
    style: styles.treeNodePlaceholder
  }, " "), import_react4.default.createElement(NodeRenderer, {
    ...props2
  })), import_react4.default.createElement("ol", {
    role: "group",
    style: styles.treeNodeChildNodesContainer
  }, expanded ? children : void 0));
});
var DEFAULT_ROOT_PATH = "$";
var WILDCARD = "*";
function hasChildNodes(data, dataIterator) {
  return !dataIterator(data).next().done;
}
var wildcardPathsFromLevel = (level) => {
  return Array.from({ length: level }, (_2, i) => [DEFAULT_ROOT_PATH].concat(Array.from({ length: i }, () => "*")).join("."));
};
var getExpandedPaths = (data, dataIterator, expandPaths, expandLevel, prevExpandedPaths) => {
  const wildcardPaths = [].concat(wildcardPathsFromLevel(expandLevel)).concat(expandPaths).filter((path) => typeof path === "string");
  const expandedPaths = [];
  wildcardPaths.forEach((wildcardPath) => {
    const keyPaths = wildcardPath.split(".");
    const populatePaths = (curData, curPath, depth) => {
      if (depth === keyPaths.length) {
        expandedPaths.push(curPath);
        return;
      }
      const key2 = keyPaths[depth];
      if (depth === 0) {
        if (hasChildNodes(curData, dataIterator) && (key2 === DEFAULT_ROOT_PATH || key2 === WILDCARD)) {
          populatePaths(curData, DEFAULT_ROOT_PATH, depth + 1);
        }
      } else {
        if (key2 === WILDCARD) {
          for (const { name, data: data2 } of dataIterator(curData)) {
            if (hasChildNodes(data2, dataIterator)) {
              populatePaths(data2, `${curPath}.${name}`, depth + 1);
            }
          }
        } else {
          const value = curData[key2];
          if (hasChildNodes(value, dataIterator)) {
            populatePaths(value, `${curPath}.${key2}`, depth + 1);
          }
        }
      }
    };
    populatePaths(data, "", 0);
  });
  return expandedPaths.reduce((obj, path) => {
    obj[path] = true;
    return obj;
  }, { ...prevExpandedPaths });
};
var ConnectedTreeNode = (0, import_react2.memo)((props2) => {
  const { data, dataIterator, path, depth, nodeRenderer } = props2;
  const [expandedPaths, setExpandedPaths] = (0, import_react2.useContext)(ExpandedPathsContext);
  const nodeHasChildNodes = hasChildNodes(data, dataIterator);
  const expanded = !!expandedPaths[path];
  const handleClick = (0, import_react2.useCallback)(() => nodeHasChildNodes && setExpandedPaths((prevExpandedPaths) => ({
    ...prevExpandedPaths,
    [path]: !expanded
  })), [nodeHasChildNodes, setExpandedPaths, path, expanded]);
  return import_react2.default.createElement(TreeNode, {
    expanded,
    onClick: handleClick,
    shouldShowArrow: nodeHasChildNodes,
    shouldShowPlaceholder: depth > 0,
    nodeRenderer,
    ...props2
  }, expanded ? [...dataIterator(data)].map(({ name, data: data2, ...renderNodeProps }) => {
    return import_react2.default.createElement(ConnectedTreeNode, {
      name,
      data: data2,
      depth: depth + 1,
      path: `${path}.${name}`,
      key: name,
      dataIterator,
      nodeRenderer,
      ...renderNodeProps
    });
  }) : null);
});
var TreeView = (0, import_react2.memo)(({ name, data, dataIterator, nodeRenderer, expandPaths, expandLevel }) => {
  const styles = useStyles("TreeView");
  const stateAndSetter = (0, import_react2.useState)({});
  const [, setExpandedPaths] = stateAndSetter;
  (0, import_react2.useLayoutEffect)(() => setExpandedPaths((prevExpandedPaths) => getExpandedPaths(data, dataIterator, expandPaths, expandLevel, prevExpandedPaths)), [data, dataIterator, expandPaths, expandLevel]);
  return import_react2.default.createElement(ExpandedPathsContext.Provider, {
    value: stateAndSetter
  }, import_react2.default.createElement("ol", {
    role: "tree",
    style: styles.treeViewOutline
  }, import_react2.default.createElement(ConnectedTreeNode, {
    name,
    data,
    dataIterator,
    depth: 0,
    path: DEFAULT_ROOT_PATH,
    nodeRenderer
  })));
});
var ObjectName = ({ name, dimmed = false, styles = {} }) => {
  const themeStyles = useStyles("ObjectName");
  const appliedStyles = {
    ...themeStyles.base,
    ...dimmed ? themeStyles["dimmed"] : {},
    ...styles
  };
  return import_react7.default.createElement("span", {
    style: appliedStyles
  }, name);
};
var ObjectValue = ({ object, styles }) => {
  const themeStyles = useStyles("ObjectValue");
  const mkStyle = (key2) => ({ ...themeStyles[key2], ...styles });
  switch (typeof object) {
    case "bigint":
      return import_react9.default.createElement("span", {
        style: mkStyle("objectValueNumber")
      }, String(object), "n");
    case "number":
      return import_react9.default.createElement("span", {
        style: mkStyle("objectValueNumber")
      }, String(object));
    case "string":
      return import_react9.default.createElement("span", {
        style: mkStyle("objectValueString")
      }, '"', object, '"');
    case "boolean":
      return import_react9.default.createElement("span", {
        style: mkStyle("objectValueBoolean")
      }, String(object));
    case "undefined":
      return import_react9.default.createElement("span", {
        style: mkStyle("objectValueUndefined")
      }, "undefined");
    case "object":
      if (object === null) {
        return import_react9.default.createElement("span", {
          style: mkStyle("objectValueNull")
        }, "null");
      }
      if (object instanceof Date) {
        return import_react9.default.createElement("span", null, object.toString());
      }
      if (object instanceof RegExp) {
        return import_react9.default.createElement("span", {
          style: mkStyle("objectValueRegExp")
        }, object.toString());
      }
      if (Array.isArray(object)) {
        return import_react9.default.createElement("span", null, `Array(${object.length})`);
      }
      if (!object.constructor) {
        return import_react9.default.createElement("span", null, "Object");
      }
      if (typeof object.constructor.isBuffer === "function" && object.constructor.isBuffer(object)) {
        return import_react9.default.createElement("span", null, `Buffer[${object.length}]`);
      }
      return import_react9.default.createElement("span", null, object.constructor.name);
    case "function":
      return import_react9.default.createElement("span", null, import_react9.default.createElement("span", {
        style: mkStyle("objectValueFunctionPrefix")
      }, "ƒ "), import_react9.default.createElement("span", {
        style: mkStyle("objectValueFunctionName")
      }, object.name, "()"));
    case "symbol":
      return import_react9.default.createElement("span", {
        style: mkStyle("objectValueSymbol")
      }, object.toString());
    default:
      return import_react9.default.createElement("span", null);
  }
};
var hasOwnProperty2 = Object.prototype.hasOwnProperty;
var propertyIsEnumerable = Object.prototype.propertyIsEnumerable;
function getPropertyValue(object, propertyName) {
  const propertyDescriptor = Object.getOwnPropertyDescriptor(object, propertyName);
  if (propertyDescriptor.get) {
    try {
      return propertyDescriptor.get();
    } catch {
      return propertyDescriptor.get;
    }
  }
  return object[propertyName];
}
function intersperse(arr, sep) {
  if (arr.length === 0) {
    return [];
  }
  return arr.slice(1).reduce((xs, x2) => xs.concat([sep, x2]), [arr[0]]);
}
var ObjectPreview = ({ data }) => {
  const styles = useStyles("ObjectPreview");
  const object = data;
  if (typeof object !== "object" || object === null || object instanceof Date || object instanceof RegExp) {
    return import_react8.default.createElement(ObjectValue, {
      object
    });
  }
  if (Array.isArray(object)) {
    const maxProperties = styles.arrayMaxProperties;
    const previewArray = object.slice(0, maxProperties).map((element, index) => import_react8.default.createElement(ObjectValue, {
      key: index,
      object: element
    }));
    if (object.length > maxProperties) {
      previewArray.push(import_react8.default.createElement("span", {
        key: "ellipsis"
      }, "…"));
    }
    const arrayLength = object.length;
    return import_react8.default.createElement(import_react8.default.Fragment, null, import_react8.default.createElement("span", {
      style: styles.objectDescription
    }, arrayLength === 0 ? `` : `(${arrayLength}) `), import_react8.default.createElement("span", {
      style: styles.preview
    }, "[", intersperse(previewArray, ", "), "]"));
  } else {
    const maxProperties = styles.objectMaxProperties;
    const propertyNodes = [];
    for (const propertyName in object) {
      if (hasOwnProperty2.call(object, propertyName)) {
        let ellipsis;
        if (propertyNodes.length === maxProperties - 1 && Object.keys(object).length > maxProperties) {
          ellipsis = import_react8.default.createElement("span", {
            key: "ellipsis"
          }, "…");
        }
        const propertyValue = getPropertyValue(object, propertyName);
        propertyNodes.push(import_react8.default.createElement("span", {
          key: propertyName
        }, import_react8.default.createElement(ObjectName, {
          name: propertyName || `""`
        }), ": ", import_react8.default.createElement(ObjectValue, {
          object: propertyValue
        }), ellipsis));
        if (ellipsis)
          break;
      }
    }
    const objectConstructorName = object.constructor ? object.constructor.name : "Object";
    return import_react8.default.createElement(import_react8.default.Fragment, null, import_react8.default.createElement("span", {
      style: styles.objectDescription
    }, objectConstructorName === "Object" ? "" : `${objectConstructorName} `), import_react8.default.createElement("span", {
      style: styles.preview
    }, "{", intersperse(propertyNodes, ", "), "}"));
  }
};
var ObjectRootLabel = ({ name, data }) => {
  if (typeof name === "string") {
    return import_react6.default.createElement("span", null, import_react6.default.createElement(ObjectName, {
      name
    }), import_react6.default.createElement("span", null, ": "), import_react6.default.createElement(ObjectPreview, {
      data
    }));
  } else {
    return import_react6.default.createElement(ObjectPreview, {
      data
    });
  }
};
var ObjectLabel = ({ name, data, isNonenumerable = false }) => {
  const object = data;
  return import_react10.default.createElement("span", null, typeof name === "string" ? import_react10.default.createElement(ObjectName, {
    name,
    dimmed: isNonenumerable
  }) : import_react10.default.createElement(ObjectPreview, {
    data: name
  }), import_react10.default.createElement("span", null, ": "), import_react10.default.createElement(ObjectValue, {
    object
  }));
};
var createIterator = (showNonenumerable, sortObjectKeys) => {
  const objectIterator = function* (data) {
    const shouldIterate = typeof data === "object" && data !== null || typeof data === "function";
    if (!shouldIterate)
      return;
    const dataIsArray = Array.isArray(data);
    if (!dataIsArray && data[Symbol.iterator]) {
      let i = 0;
      for (const entry of data) {
        if (Array.isArray(entry) && entry.length === 2) {
          const [k, v] = entry;
          yield {
            name: k,
            data: v
          };
        } else {
          yield {
            name: i.toString(),
            data: entry
          };
        }
        i++;
      }
    } else {
      const keys = Object.getOwnPropertyNames(data);
      if (sortObjectKeys === true && !dataIsArray) {
        keys.sort();
      } else if (typeof sortObjectKeys === "function") {
        keys.sort(sortObjectKeys);
      }
      for (const propertyName of keys) {
        if (propertyIsEnumerable.call(data, propertyName)) {
          const propertyValue = getPropertyValue(data, propertyName);
          yield {
            name: propertyName || `""`,
            data: propertyValue
          };
        } else if (showNonenumerable) {
          let propertyValue;
          try {
            propertyValue = getPropertyValue(data, propertyName);
          } catch (e) {
          }
          if (propertyValue !== void 0) {
            yield {
              name: propertyName,
              data: propertyValue,
              isNonenumerable: true
            };
          }
        }
      }
      if (showNonenumerable && data !== Object.prototype) {
        yield {
          name: "__proto__",
          data: Object.getPrototypeOf(data),
          isNonenumerable: true
        };
      }
    }
  };
  return objectIterator;
};
var defaultNodeRenderer = ({ depth, name, data, isNonenumerable }) => depth === 0 ? import_react.default.createElement(ObjectRootLabel, {
  name,
  data
}) : import_react.default.createElement(ObjectLabel, {
  name,
  data,
  isNonenumerable
});
var ObjectInspector = ({ showNonenumerable = false, sortObjectKeys, nodeRenderer, ...treeViewProps }) => {
  const dataIterator = createIterator(showNonenumerable, sortObjectKeys);
  const renderer = nodeRenderer ? nodeRenderer : defaultNodeRenderer;
  return import_react.default.createElement(TreeView, {
    nodeRenderer: renderer,
    dataIterator,
    ...treeViewProps
  });
};
var themedObjectInspector = themeAcceptor(ObjectInspector);
function getHeaders(data) {
  if (typeof data === "object") {
    let rowHeaders = [];
    if (Array.isArray(data)) {
      const nRows = data.length;
      rowHeaders = [...Array(nRows).keys()];
    } else if (data !== null) {
      rowHeaders = Object.keys(data);
    }
    const colHeaders = rowHeaders.reduce((colHeaders2, rowHeader) => {
      const row = data[rowHeader];
      if (typeof row === "object" && row !== null) {
        const cols = Object.keys(row);
        cols.reduce((xs, x2) => {
          if (!xs.includes(x2)) {
            xs.push(x2);
          }
          return xs;
        }, colHeaders2);
      }
      return colHeaders2;
    }, []);
    return {
      rowHeaders,
      colHeaders
    };
  }
  return void 0;
}
var DataContainer = ({ rows, columns, rowsData }) => {
  const styles = useStyles("TableInspectorDataContainer");
  const borderStyles = useStyles("TableInspectorLeftBorder");
  return import_react12.default.createElement("div", {
    style: styles.div
  }, import_react12.default.createElement("table", {
    style: styles.table
  }, import_react12.default.createElement("colgroup", null), import_react12.default.createElement("tbody", null, rows.map((row, i) => import_react12.default.createElement("tr", {
    key: row,
    style: styles.tr
  }, import_react12.default.createElement("td", {
    style: { ...styles.td, ...borderStyles.none }
  }, row), columns.map((column2) => {
    const rowData = rowsData[i];
    if (typeof rowData === "object" && rowData !== null && hasOwnProperty2.call(rowData, column2)) {
      return import_react12.default.createElement("td", {
        key: column2,
        style: { ...styles.td, ...borderStyles.solid }
      }, import_react12.default.createElement(ObjectValue, {
        object: rowData[column2]
      }));
    } else {
      return import_react12.default.createElement("td", {
        key: column2,
        style: { ...styles.td, ...borderStyles.solid }
      });
    }
  }))))));
};
var SortIconContainer = (props2) => import_react14.default.createElement("div", {
  style: {
    position: "absolute",
    top: 1,
    right: 0,
    bottom: 1,
    display: "flex",
    alignItems: "center"
  }
}, props2.children);
var SortIcon = ({ sortAscending }) => {
  const styles = useStyles("TableInspectorSortIcon");
  const glyph = sortAscending ? "▲" : "▼";
  return import_react14.default.createElement("div", {
    style: styles
  }, glyph);
};
var TH = ({
  sortAscending = false,
  sorted = false,
  onClick = void 0,
  borderStyle = {},
  children,
  ...thProps
}) => {
  const styles = useStyles("TableInspectorTH");
  const [hovered, setHovered] = (0, import_react14.useState)(false);
  const handleMouseEnter = (0, import_react14.useCallback)(() => setHovered(true), []);
  const handleMouseLeave = (0, import_react14.useCallback)(() => setHovered(false), []);
  return import_react14.default.createElement("th", {
    ...thProps,
    style: {
      ...styles.base,
      ...borderStyle,
      ...hovered ? styles.base[":hover"] : {}
    },
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave,
    onClick
  }, import_react14.default.createElement("div", {
    style: styles.div
  }, children), sorted && import_react14.default.createElement(SortIconContainer, null, import_react14.default.createElement(SortIcon, {
    sortAscending
  })));
};
var HeaderContainer = ({
  indexColumnText = "(index)",
  columns = [],
  sorted,
  sortIndexColumn,
  sortColumn,
  sortAscending,
  onTHClick,
  onIndexTHClick
}) => {
  const styles = useStyles("TableInspectorHeaderContainer");
  const borderStyles = useStyles("TableInspectorLeftBorder");
  return import_react13.default.createElement("div", {
    style: styles.base
  }, import_react13.default.createElement("table", {
    style: styles.table
  }, import_react13.default.createElement("tbody", null, import_react13.default.createElement("tr", null, import_react13.default.createElement(TH, {
    borderStyle: borderStyles.none,
    sorted: sorted && sortIndexColumn,
    sortAscending,
    onClick: onIndexTHClick
  }, indexColumnText), columns.map((column2) => import_react13.default.createElement(TH, {
    borderStyle: borderStyles.solid,
    key: column2,
    sorted: sorted && sortColumn === column2,
    sortAscending,
    onClick: onTHClick.bind(null, column2)
  }, column2))))));
};
var TableInspector = ({
  data,
  columns
}) => {
  const styles = useStyles("TableInspector");
  const [{ sorted, sortIndexColumn, sortColumn, sortAscending }, setState] = (0, import_react11.useState)({
    sorted: false,
    sortIndexColumn: false,
    sortColumn: void 0,
    sortAscending: false
  });
  const handleIndexTHClick = (0, import_react11.useCallback)(() => {
    setState(({ sortIndexColumn: sortIndexColumn2, sortAscending: sortAscending2 }) => ({
      sorted: true,
      sortIndexColumn: true,
      sortColumn: void 0,
      sortAscending: sortIndexColumn2 ? !sortAscending2 : true
    }));
  }, []);
  const handleTHClick = (0, import_react11.useCallback)((col) => {
    setState(({ sortColumn: sortColumn2, sortAscending: sortAscending2 }) => ({
      sorted: true,
      sortIndexColumn: false,
      sortColumn: col,
      sortAscending: col === sortColumn2 ? !sortAscending2 : true
    }));
  }, []);
  if (typeof data !== "object" || data === null) {
    return import_react11.default.createElement("div", null);
  }
  let { rowHeaders, colHeaders } = getHeaders(data);
  if (columns !== void 0) {
    colHeaders = columns;
  }
  let rowsData = rowHeaders.map((rowHeader) => data[rowHeader]);
  let columnDataWithRowIndexes;
  if (sortColumn !== void 0) {
    columnDataWithRowIndexes = rowsData.map((rowData, index) => {
      if (typeof rowData === "object" && rowData !== null) {
        const columnData = rowData[sortColumn];
        return [columnData, index];
      }
      return [void 0, index];
    });
  } else {
    if (sortIndexColumn) {
      columnDataWithRowIndexes = rowHeaders.map((rowData, index) => {
        const columnData = rowHeaders[index];
        return [columnData, index];
      });
    }
  }
  if (columnDataWithRowIndexes !== void 0) {
    const comparator = (mapper, ascending) => {
      return (a, b2) => {
        const v1 = mapper(a);
        const v2 = mapper(b2);
        const type1 = typeof v1;
        const type2 = typeof v2;
        const lt2 = (v12, v22) => {
          if (v12 < v22) {
            return -1;
          } else if (v12 > v22) {
            return 1;
          } else {
            return 0;
          }
        };
        let result;
        if (type1 === type2) {
          result = lt2(v1, v2);
        } else {
          const order = {
            string: 0,
            number: 1,
            object: 2,
            symbol: 3,
            boolean: 4,
            undefined: 5,
            function: 6
          };
          result = lt2(order[type1], order[type2]);
        }
        if (!ascending)
          result = -result;
        return result;
      };
    };
    const sortedRowIndexes = columnDataWithRowIndexes.sort(comparator((item) => item[0], sortAscending)).map((item) => item[1]);
    rowHeaders = sortedRowIndexes.map((i) => rowHeaders[i]);
    rowsData = sortedRowIndexes.map((i) => rowsData[i]);
  }
  return import_react11.default.createElement("div", {
    style: styles.base
  }, import_react11.default.createElement(HeaderContainer, {
    columns: colHeaders,
    sorted,
    sortIndexColumn,
    sortColumn,
    sortAscending,
    onTHClick: handleTHClick,
    onIndexTHClick: handleIndexTHClick
  }), import_react11.default.createElement(DataContainer, {
    rows: rowHeaders,
    columns: colHeaders,
    rowsData
  }));
};
var themedTableInspector = themeAcceptor(TableInspector);
var TEXT_NODE_MAX_INLINE_CHARS = 80;
var shouldInline = (data) => data.childNodes.length === 0 || data.childNodes.length === 1 && data.childNodes[0].nodeType === Node.TEXT_NODE && data.textContent.length < TEXT_NODE_MAX_INLINE_CHARS;
var OpenTag = ({ tagName, attributes, styles }) => {
  return import_react16.default.createElement("span", {
    style: styles.base
  }, "<", import_react16.default.createElement("span", {
    style: styles.tagName
  }, tagName), (() => {
    if (attributes) {
      const attributeNodes = [];
      for (let i = 0; i < attributes.length; i++) {
        const attribute = attributes[i];
        attributeNodes.push(import_react16.default.createElement("span", {
          key: i
        }, " ", import_react16.default.createElement("span", {
          style: styles.htmlAttributeName
        }, attribute.name), '="', import_react16.default.createElement("span", {
          style: styles.htmlAttributeValue
        }, attribute.value), '"'));
      }
      return attributeNodes;
    }
  })(), ">");
};
var CloseTag = ({ tagName, isChildNode = false, styles }) => import_react16.default.createElement("span", {
  style: Object.assign({}, styles.base, isChildNode && styles.offsetLeft)
}, "</", import_react16.default.createElement("span", {
  style: styles.tagName
}, tagName), ">");
var nameByNodeType = {
  1: "ELEMENT_NODE",
  3: "TEXT_NODE",
  7: "PROCESSING_INSTRUCTION_NODE",
  8: "COMMENT_NODE",
  9: "DOCUMENT_NODE",
  10: "DOCUMENT_TYPE_NODE",
  11: "DOCUMENT_FRAGMENT_NODE"
};
var DOMNodePreview = ({ isCloseTag, data, expanded }) => {
  const styles = useStyles("DOMNodePreview");
  if (isCloseTag) {
    return import_react16.default.createElement(CloseTag, {
      styles: styles.htmlCloseTag,
      isChildNode: true,
      tagName: data.tagName
    });
  }
  switch (data.nodeType) {
    case Node.ELEMENT_NODE:
      return import_react16.default.createElement("span", null, import_react16.default.createElement(OpenTag, {
        tagName: data.tagName,
        attributes: data.attributes,
        styles: styles.htmlOpenTag
      }), shouldInline(data) ? data.textContent : !expanded && "…", !expanded && import_react16.default.createElement(CloseTag, {
        tagName: data.tagName,
        styles: styles.htmlCloseTag
      }));
    case Node.TEXT_NODE:
      return import_react16.default.createElement("span", null, data.textContent);
    case Node.CDATA_SECTION_NODE:
      return import_react16.default.createElement("span", null, "<![CDATA[" + data.textContent + "]]>");
    case Node.COMMENT_NODE:
      return import_react16.default.createElement("span", {
        style: styles.htmlComment
      }, "<!--", data.textContent, "-->");
    case Node.PROCESSING_INSTRUCTION_NODE:
      return import_react16.default.createElement("span", null, data.nodeName);
    case Node.DOCUMENT_TYPE_NODE:
      return import_react16.default.createElement("span", {
        style: styles.htmlDoctype
      }, "<!DOCTYPE ", data.name, data.publicId ? ` PUBLIC "${data.publicId}"` : "", !data.publicId && data.systemId ? " SYSTEM" : "", data.systemId ? ` "${data.systemId}"` : "", ">");
    case Node.DOCUMENT_NODE:
      return import_react16.default.createElement("span", null, data.nodeName);
    case Node.DOCUMENT_FRAGMENT_NODE:
      return import_react16.default.createElement("span", null, data.nodeName);
    default:
      return import_react16.default.createElement("span", null, nameByNodeType[data.nodeType]);
  }
};
var domIterator = function* (data) {
  if (data && data.childNodes) {
    const textInlined = shouldInline(data);
    if (textInlined) {
      return;
    }
    for (let i = 0; i < data.childNodes.length; i++) {
      const node = data.childNodes[i];
      if (node.nodeType === Node.TEXT_NODE && node.textContent.trim().length === 0)
        continue;
      yield {
        name: `${node.tagName}[${i}]`,
        data: node
      };
    }
    if (data.tagName) {
      yield {
        name: "CLOSE_TAG",
        data: {
          tagName: data.tagName
        },
        isCloseTag: true
      };
    }
  }
};
var DOMInspector = (props2) => {
  return import_react15.default.createElement(TreeView, {
    nodeRenderer: DOMNodePreview,
    dataIterator: domIterator,
    ...props2
  });
};
var themedDOMInspector = themeAcceptor(DOMInspector);
var import_is_dom = __toESM2(require_is_dom());

// node_modules/@toolpad/studio/dist/exports/editor.mjs
var React352 = __toESM(require_react(), 1);
var React362 = __toESM(require_react(), 1);
var React402 = __toESM(require_react(), 1);
var React442 = __toESM(require_react(), 1);
var React432 = __toESM(require_react(), 1);
var React422 = __toESM(require_react(), 1);

// node_modules/@mui/icons-material/esm/Check.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime());
var Check_default = createSvgIcon((0, import_jsx_runtime11.jsx)("path", {
  d: "M9 16.17 4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"
}), "Check");

// node_modules/@toolpad/studio/dist/exports/editor.mjs
var import_invariant6 = __toESM(require_browser(), 1);
var React522 = __toESM(require_react(), 1);

// node_modules/@mui/icons-material/esm/ArrowLeft.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime());
var ArrowLeft_default = createSvgIcon((0, import_jsx_runtime12.jsx)("path", {
  d: "m14 7-5 5 5 5z"
}), "ArrowLeft");

// node_modules/@mui/icons-material/esm/ArrowRight.js
var import_jsx_runtime13 = __toESM(require_jsx_runtime());
var ArrowRight_default = createSvgIcon((0, import_jsx_runtime13.jsx)("path", {
  d: "m10 17 5-5-5-5z"
}), "ArrowRight");

// node_modules/@mui/icons-material/esm/ArrowDropDownSharp.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime());
var ArrowDropDownSharp_default = createSvgIcon((0, import_jsx_runtime14.jsx)("path", {
  d: "m7 10 5 5 5-5z"
}), "ArrowDropDownSharp");

// node_modules/@toolpad/studio/dist/exports/editor.mjs
var import_invariant7 = __toESM(require_browser(), 1);

// node_modules/@mui/icons-material/esm/Search.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime());
var Search_default = createSvgIcon((0, import_jsx_runtime15.jsx)("path", {
  d: "M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"
}), "Search");

// node_modules/@toolpad/studio/dist/exports/editor.mjs
var React462 = __toESM(require_react(), 1);

// node_modules/@mui/icons-material/esm/SmartButton.js
var import_jsx_runtime16 = __toESM(require_jsx_runtime());
var SmartButton_default = createSvgIcon((0, import_jsx_runtime16.jsx)("path", {
  d: "M22 9v6c0 1.1-.9 2-2 2h-1v-2h1V9H4v6h6v2H4c-1.1 0-2-.9-2-2V9c0-1.1.9-2 2-2h16c1.1 0 2 .9 2 2m-7.5 10 1.09-2.41L18 15.5l-2.41-1.09L14.5 12l-1.09 2.41L11 15.5l2.41 1.09zm2.5-5 .62-1.38L19 12l-1.38-.62L17 10l-.62 1.38L15 12l1.38.62zm-2.5 5 1.09-2.41L18 15.5l-2.41-1.09L14.5 12l-1.09 2.41L11 15.5l2.41 1.09zm2.5-5 .62-1.38L19 12l-1.38-.62L17 10l-.62 1.38L15 12l1.38.62z"
}), "SmartButton");

// node_modules/@mui/icons-material/esm/Image.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime());
var Image_default = createSvgIcon((0, import_jsx_runtime17.jsx)("path", {
  d: "M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2M8.5 13.5l2.5 3.01L14.5 12l4.5 6H5z"
}), "Image");

// node_modules/@mui/icons-material/esm/GridOn.js
var import_jsx_runtime18 = __toESM(require_jsx_runtime());
var GridOn_default = createSvgIcon((0, import_jsx_runtime18.jsx)("path", {
  d: "M20 2H4c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2M8 20H4v-4h4zm0-6H4v-4h4zm0-6H4V4h4zm6 12h-4v-4h4zm0-6h-4v-4h4zm0-6h-4V4h4zm6 12h-4v-4h4zm0-6h-4v-4h4zm0-6h-4V4h4z"
}), "GridOn");

// node_modules/@mui/icons-material/esm/Crop75.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime());
var Crop75_default = createSvgIcon((0, import_jsx_runtime19.jsx)("path", {
  d: "M19 5H5c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 12H5V7h14z"
}), "Crop75");

// node_modules/@mui/icons-material/esm/ArrowDropDownCircle.js
var import_jsx_runtime20 = __toESM(require_jsx_runtime());
var ArrowDropDownCircle_default = createSvgIcon((0, import_jsx_runtime20.jsx)("path", {
  d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m0 12-4-4h8z"
}), "ArrowDropDownCircle");

// node_modules/@mui/icons-material/esm/Layers.js
var import_jsx_runtime21 = __toESM(require_jsx_runtime());
var Layers_default = createSvgIcon((0, import_jsx_runtime21.jsx)("path", {
  d: "m11.99 18.54-7.37-5.73L3 14.07l9 7 9-7-1.63-1.27zM12 16l7.36-5.73L21 9l-9-7-9 7 1.63 1.27z"
}), "Layers");

// node_modules/@mui/icons-material/esm/Dns.js
var import_jsx_runtime22 = __toESM(require_jsx_runtime());
var Dns_default = createSvgIcon((0, import_jsx_runtime22.jsx)("path", {
  d: "M20 13H4c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h16c.55 0 1-.45 1-1v-6c0-.55-.45-1-1-1M7 19c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2M20 3H4c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h16c.55 0 1-.45 1-1V4c0-.55-.45-1-1-1M7 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2"
}), "Dns");

// node_modules/@mui/icons-material/esm/ContactPage.js
var import_jsx_runtime23 = __toESM(require_jsx_runtime());
var ContactPage_default = createSvgIcon((0, import_jsx_runtime23.jsx)("path", {
  d: "M14 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V8zm-2 8c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2m4 8H8v-.57c0-.81.48-1.53 1.22-1.85.85-.37 1.79-.58 2.78-.58s1.93.21 2.78.58c.74.32 1.22 1.04 1.22 1.85z"
}), "ContactPage");

// node_modules/@mui/icons-material/esm/Tab.js
var import_jsx_runtime24 = __toESM(require_jsx_runtime());
var Tab_default2 = createSvgIcon((0, import_jsx_runtime24.jsx)("path", {
  d: "M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2m0 16H3V5h10v4h8z"
}), "Tab");

// node_modules/@mui/icons-material/esm/Tune.js
var import_jsx_runtime25 = __toESM(require_jsx_runtime());
var Tune_default = createSvgIcon((0, import_jsx_runtime25.jsx)("path", {
  d: "M3 17v2h6v-2zM3 5v2h10V5zm10 16v-2h8v-2h-8v-2h-2v6zM7 9v2H3v2h4v2h2V9zm14 4v-2H11v2zm-6-4h2V7h4V5h-4V3h-2z"
}), "Tune");

// node_modules/@mui/icons-material/esm/ToggleOn.js
var import_jsx_runtime26 = __toESM(require_jsx_runtime());
var ToggleOn_default = createSvgIcon((0, import_jsx_runtime26.jsx)("path", {
  d: "M17 7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h10c2.76 0 5-2.24 5-5s-2.24-5-5-5m0 8c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3"
}), "ToggleOn");

// node_modules/@mui/icons-material/esm/List.js
var import_jsx_runtime27 = __toESM(require_jsx_runtime());
var List_default2 = createSvgIcon((0, import_jsx_runtime27.jsx)("path", {
  d: "M3 13h2v-2H3zm0 4h2v-2H3zm0-8h2V7H3zm4 4h14v-2H7zm0 4h14v-2H7zM7 7v2h14V7z"
}), "List");

// node_modules/@mui/icons-material/esm/RadioButtonChecked.js
var import_jsx_runtime28 = __toESM(require_jsx_runtime());
var RadioButtonChecked_default = createSvgIcon((0, import_jsx_runtime28.jsx)("path", {
  d: "M12 7c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5m0-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8"
}), "RadioButtonChecked");

// node_modules/@mui/icons-material/esm/DateRange.js
var import_jsx_runtime29 = __toESM(require_jsx_runtime());
var DateRange_default = createSvgIcon((0, import_jsx_runtime29.jsx)("path", {
  d: "M9 11H7v2h2zm4 0h-2v2h2zm4 0h-2v2h2zm2-7h-1V2h-2v2H8V2H6v2H5c-1.11 0-1.99.9-1.99 2L3 20c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2m0 16H5V9h14z"
}), "DateRange");

// node_modules/@mui/icons-material/esm/CheckBox.js
var import_jsx_runtime30 = __toESM(require_jsx_runtime());
var CheckBox_default = createSvgIcon((0, import_jsx_runtime30.jsx)("path", {
  d: "M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2m-9 14-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8z"
}), "CheckBox");

// node_modules/@mui/icons-material/esm/DashboardCustomizeSharp.js
var import_jsx_runtime31 = __toESM(require_jsx_runtime());
var DashboardCustomizeSharp_default = createSvgIcon((0, import_jsx_runtime31.jsx)("path", {
  d: "M3 3h8v8H3zm10 0h8v8h-8zM3 13h8v8H3zm15 0h-2v3h-3v2h3v3h2v-3h3v-2h-3z"
}), "DashboardCustomizeSharp");

// node_modules/@mui/icons-material/esm/ManageSearch.js
var import_jsx_runtime32 = __toESM(require_jsx_runtime());
var ManageSearch_default = createSvgIcon((0, import_jsx_runtime32.jsx)("path", {
  d: "M7 9H2V7h5zm0 3H2v2h5zm13.59 7-3.83-3.83c-.8.52-1.74.83-2.76.83-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5c0 1.02-.31 1.96-.83 2.75L22 17.59zM17 11c0-1.65-1.35-3-3-3s-3 1.35-3 3 1.35 3 3 3 3-1.35 3-3M2 19h10v-2H2z"
}), "ManageSearch");

// node_modules/@mui/icons-material/esm/UploadFile.js
var import_jsx_runtime33 = __toESM(require_jsx_runtime());
var UploadFile_default = createSvgIcon((0, import_jsx_runtime33.jsx)("path", {
  d: "M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8zm4 18H6V4h7v5h5zM8 15.01l1.41 1.41L11 14.84V19h2v-4.16l1.59 1.59L16 15.01 12.01 11z"
}), "UploadFile");

// node_modules/@mui/icons-material/esm/Notes.js
var import_jsx_runtime34 = __toESM(require_jsx_runtime());
var Notes_default = createSvgIcon((0, import_jsx_runtime34.jsx)("path", {
  d: "M3 18h12v-2H3zM3 6v2h18V6zm0 7h18v-2H3z"
}), "Notes");

// node_modules/@mui/icons-material/esm/AutoAwesomeMosaic.js
var import_jsx_runtime35 = __toESM(require_jsx_runtime());
var AutoAwesomeMosaic_default = createSvgIcon((0, import_jsx_runtime35.jsx)("path", {
  d: "M3 5v14c0 1.1.89 2 2 2h6V3H5c-1.11 0-2 .9-2 2m16-2h-6v8h8V5c0-1.1-.9-2-2-2m-6 18h6c1.1 0 2-.9 2-2v-6h-8z"
}), "AutoAwesomeMosaic");

// node_modules/@mui/icons-material/esm/Insights.js
var import_jsx_runtime36 = __toESM(require_jsx_runtime());
var Insights_default = createSvgIcon([(0, import_jsx_runtime36.jsx)("path", {
  d: "M21 8c-1.45 0-2.26 1.44-1.93 2.51l-3.55 3.56c-.3-.09-.74-.09-1.04 0l-2.55-2.55C12.27 10.45 11.46 9 10 9c-1.45 0-2.27 1.44-1.93 2.52l-4.56 4.55C2.44 15.74 1 16.55 1 18c0 1.1.9 2 2 2 1.45 0 2.26-1.44 1.93-2.51l4.55-4.56c.3.09.74.09 1.04 0l2.55 2.55C12.73 16.55 13.54 18 15 18c1.45 0 2.27-1.44 1.93-2.52l3.56-3.55c1.07.33 2.51-.48 2.51-1.93 0-1.1-.9-2-2-2"
}, "0"), (0, import_jsx_runtime36.jsx)("path", {
  d: "m15 9 .94-2.07L18 6l-2.06-.93L15 3l-.92 2.07L12 6l2.08.93zM3.5 11 4 9l2-.5L4 8l-.5-2L3 8l-2 .5L3 9z"
}, "1")], "Insights");

// node_modules/@mui/icons-material/esm/Place.js
var import_jsx_runtime37 = __toESM(require_jsx_runtime());
var Place_default = createSvgIcon((0, import_jsx_runtime37.jsx)("path", {
  d: "M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7m0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5"
}), "Place");

// node_modules/@mui/icons-material/esm/ViewSidebar.js
var import_jsx_runtime38 = __toESM(require_jsx_runtime());
var ViewSidebar_default = createSvgIcon((0, import_jsx_runtime38.jsx)("path", {
  d: "M16 20H2V4h14zm2-12h4V4h-4zm0 12h4v-4h-4zm0-6h4v-4h-4z"
}), "ViewSidebar");

// node_modules/@mui/icons-material/esm/Mood.js
var import_jsx_runtime39 = __toESM(require_jsx_runtime());
var Mood_default = createSvgIcon((0, import_jsx_runtime39.jsx)("path", {
  d: "M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2M12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8m3.5-9c.83 0 1.5-.67 1.5-1.5S16.33 8 15.5 8 14 8.67 14 9.5s.67 1.5 1.5 1.5m-7 0c.83 0 1.5-.67 1.5-1.5S9.33 8 8.5 8 7 8.67 7 9.5 7.67 11 8.5 11m3.5 6.5c2.33 0 4.31-1.46 5.11-3.5H6.89c.8 2.04 2.78 3.5 5.11 3.5"
}), "Mood");

// node_modules/@mui/icons-material/esm/Html.js
var import_jsx_runtime40 = __toESM(require_jsx_runtime());
var Html_default = createSvgIcon((0, import_jsx_runtime40.jsx)("path", {
  d: "M3.5 9H5v6H3.5v-2.5h-2V15H0V9h1.5v2h2zm14 0H13c-.55 0-1 .45-1 1v5h1.5v-4.5h1V14H16v-3.51h1V15h1.5v-5c0-.55-.45-1-1-1M11 9H6v1.5h1.75V15h1.5v-4.5H11zm13 6v-1.5h-2.5V9H20v6z"
}), "Html");

// node_modules/@mui/icons-material/esm/TableRows.js
var import_jsx_runtime41 = __toESM(require_jsx_runtime());
var TableRows_default = createSvgIcon((0, import_jsx_runtime41.jsx)("path", {
  d: "M21 8H3V4h18zm0 2H3v4h18zm0 6H3v4h18z"
}), "TableRows");

// node_modules/@mui/icons-material/esm/ViewColumn.js
var import_jsx_runtime42 = __toESM(require_jsx_runtime());
var ViewColumn_default = createSvgIcon((0, import_jsx_runtime42.jsx)("path", {
  d: "M14.67 5v14H9.33V5zm1 14H21V5h-5.33zm-7.34 0V5H3v14z"
}), "ViewColumn");

// node_modules/@mui/icons-material/esm/Tag.js
var import_jsx_runtime43 = __toESM(require_jsx_runtime());
var Tag_default = createSvgIcon((0, import_jsx_runtime43.jsx)("path", {
  d: "M20 10V8h-4V4h-2v4h-4V4H8v4H4v2h4v4H4v2h4v4h2v-4h4v4h2v-4h4v-2h-4v-4zm-6 4h-4v-4h4z"
}), "Tag");

// node_modules/@mui/icons-material/esm/TextFormat.js
var import_jsx_runtime44 = __toESM(require_jsx_runtime());
var TextFormat_default = createSvgIcon((0, import_jsx_runtime44.jsx)("path", {
  d: "M5 17v2h14v-2zm4.5-4.2h5l.9 2.2h2.1L12.75 4h-1.5L6.5 15h2.1zM12 5.98 13.87 11h-3.74z"
}), "TextFormat");

// node_modules/@mui/icons-material/esm/SpaceBar.js
var import_jsx_runtime45 = __toESM(require_jsx_runtime());
var SpaceBar_default = createSvgIcon((0, import_jsx_runtime45.jsx)("path", {
  d: "M18 9v4H6V9H4v6h16V9z"
}), "SpaceBar");

// node_modules/@mui/icons-material/esm/PieChart.js
var import_jsx_runtime46 = __toESM(require_jsx_runtime());
var PieChart_default = createSvgIcon((0, import_jsx_runtime46.jsx)("path", {
  d: "M11 2v20c-5.07-.5-9-4.79-9-10s3.93-9.5 9-10m2.03 0v8.99H22c-.47-4.74-4.24-8.52-8.97-8.99m0 11.01V22c4.74-.47 8.5-4.25 8.97-8.99z"
}), "PieChart");

// node_modules/@toolpad/studio/dist/exports/editor.mjs
var React492 = __toESM(require_react(), 1);
var import_invariant8 = __toESM(require_browser(), 1);
var React472 = __toESM(require_react(), 1);
var React482 = __toESM(require_react(), 1);

// node_modules/@mui/icons-material/esm/Code.js
var import_jsx_runtime47 = __toESM(require_jsx_runtime());
var Code_default = createSvgIcon((0, import_jsx_runtime47.jsx)("path", {
  d: "M9.4 16.6 4.8 12l4.6-4.6L8 6l-6 6 6 6zm5.2 0 4.6-4.6-4.6-4.6L16 6l6 6-6 6z"
}), "Code");

// node_modules/@toolpad/studio/dist/exports/editor.mjs
var React502 = __toESM(require_react(), 1);

// node_modules/@toolpad/utils/dist/hooks/useStorageState.js
var React17 = __toESM(require_react());
var emitter = new Emitter();
function subscribe(area, key2, cb) {
  const storageHandler = (event) => {
    if (event.storageArea === area && event.key === key2) {
      cb();
    }
  };
  window.addEventListener("storage", storageHandler);
  emitter.on(key2, cb);
  return () => {
    window.removeEventListener("storage", storageHandler);
    emitter.off(key2, cb);
  };
}
function getSnapshot(area, key2) {
  return area.getItem(key2);
}
function setValue(area, key2, value) {
  if (typeof window !== "undefined") {
    if (value === null) {
      area.removeItem(key2);
    } else {
      area.setItem(key2, String(value));
    }
    emitter.emit(key2, null);
  }
}
function useStorageStateServer(kind, key2, initializer = null) {
  const [initialValue] = React17.useState(initializer);
  return [initialValue, () => {
  }];
}
function useStorageStateBrowser(kind, key2, initializer = null) {
  const [initialValue] = React17.useState(initializer);
  const area = kind === "session" ? window.sessionStorage : window.localStorage;
  const subscribeKey = React17.useCallback((cb) => subscribe(area, key2, cb), [area, key2]);
  const getKeySnapshot = React17.useCallback(
    () => getSnapshot(area, key2) ?? initialValue,
    [area, initialValue, key2]
  );
  const getKeyServerSnapshot = React17.useCallback(() => initialValue, [initialValue]);
  const storedValue = React17.useSyncExternalStore(
    subscribeKey,
    getKeySnapshot,
    getKeyServerSnapshot
  );
  const setStoredValue = React17.useCallback(
    (value) => {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setValue(area, key2, valueToStore);
    },
    [area, key2, storedValue]
  );
  return [storedValue, setStoredValue];
}
var useStorageState_default = typeof window === "undefined" ? useStorageStateServer : useStorageStateBrowser;

// node_modules/@toolpad/studio/dist/exports/editor.mjs
var React512 = __toESM(require_react(), 1);

// node_modules/@mui/icons-material/esm/HelpOutline.js
var import_jsx_runtime48 = __toESM(require_jsx_runtime());
var HelpOutline_default = createSvgIcon((0, import_jsx_runtime48.jsx)("path", {
  d: "M11 18h2v-2h-2zm1-16C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8m0-14c-2.21 0-4 1.79-4 4h2c0-1.1.9-2 2-2s2 .9 2 2c0 2-3 1.75-3 5h2c0-2.25 3-2.5 3-5 0-2.21-1.79-4-4-4"
}), "HelpOutline");

// node_modules/@toolpad/studio/dist/exports/editor.mjs
var React532 = __toESM(require_react(), 1);
var React542 = __toESM(require_react(), 1);
var React722 = __toESM(require_react(), 1);

// node_modules/@mui/icons-material/esm/ClearOutlined.js
var import_jsx_runtime49 = __toESM(require_jsx_runtime());
var ClearOutlined_default = createSvgIcon((0, import_jsx_runtime49.jsx)("path", {
  d: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}), "ClearOutlined");

// node_modules/@mui/icons-material/esm/Circle.js
var import_jsx_runtime50 = __toESM(require_jsx_runtime());
var Circle_default = createSvgIcon((0, import_jsx_runtime50.jsx)("path", {
  d: "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2"
}), "Circle");

// node_modules/@mui/icons-material/esm/CancelPresentation.js
var import_jsx_runtime51 = __toESM(require_jsx_runtime());
var CancelPresentation_default = createSvgIcon([(0, import_jsx_runtime51.jsx)("path", {
  d: "M21 19.1H3V5h18zM21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2"
}, "0"), (0, import_jsx_runtime51.jsx)("path", {
  d: "M14.59 8 12 10.59 9.41 8 8 9.41 10.59 12 8 14.59 9.41 16 12 13.41 14.59 16 16 14.59 13.41 12 16 9.41z"
}, "1")], "CancelPresentation");

// node_modules/@toolpad/studio/dist/exports/editor.mjs
var React55 = __toESM(require_react(), 1);

// node_modules/@mui/icons-material/esm/Http.js
var import_jsx_runtime52 = __toESM(require_jsx_runtime());
var Http_default = createSvgIcon((0, import_jsx_runtime52.jsx)("path", {
  d: "M4.5 11h-2V9H1v6h1.5v-2.5h2V15H6V9H4.5zm2.5-.5h1.5V15H10v-4.5h1.5V9H7zm5.5 0H14V15h1.5v-4.5H17V9h-4.5zm9-1.5H18v6h1.5v-2h2c.8 0 1.5-.7 1.5-1.5v-1c0-.8-.7-1.5-1.5-1.5m0 2.5h-2v-1h2z"
}), "Http");

// node_modules/@mui/icons-material/esm/Javascript.js
var import_jsx_runtime53 = __toESM(require_jsx_runtime());
var Javascript_default = createSvgIcon((0, import_jsx_runtime53.jsx)("path", {
  d: "M12 14v-1h1.5v.5h2v-1H13c-.55 0-1-.45-1-1V10c0-.55.45-1 1-1h3c.55 0 1 .45 1 1v1h-1.5v-.5h-2v1H16c.55 0 1 .45 1 1V14c0 .55-.45 1-1 1h-3c-.55 0-1-.45-1-1M9 9v4.5H7.5v-1H6v1c0 .83.67 1.5 1.5 1.5H9c.83 0 1.5-.67 1.5-1.5V9z"
}), "Javascript");

// node_modules/@mui/icons-material/esm/AdsClick.js
var import_jsx_runtime54 = __toESM(require_jsx_runtime());
var AdsClick_default = createSvgIcon((0, import_jsx_runtime54.jsx)("path", {
  d: "M11.71 17.99C8.53 17.84 6 15.22 6 12c0-3.31 2.69-6 6-6 3.22 0 5.84 2.53 5.99 5.71l-2.1-.63C15.48 9.31 13.89 8 12 8c-2.21 0-4 1.79-4 4 0 1.89 1.31 3.48 3.08 3.89zM22 12c0 .3-.01.6-.04.9l-1.97-.59c.01-.1.01-.21.01-.31 0-4.42-3.58-8-8-8s-8 3.58-8 8 3.58 8 8 8c.1 0 .21 0 .31-.01l.59 1.97c-.3.03-.6.04-.9.04-5.52 0-10-4.48-10-10S6.48 2 12 2s10 4.48 10 10m-3.77 4.26L22 15l-10-3 3 10 1.26-3.77 4.27 4.27 1.98-1.98z"
}), "AdsClick");

// node_modules/@mui/icons-material/esm/AutoMode.js
var import_jsx_runtime55 = __toESM(require_jsx_runtime());
var AutoMode_default = createSvgIcon([(0, import_jsx_runtime55.jsx)("path", {
  d: "M19.03 3.56c-1.67-1.39-3.74-2.3-6.03-2.51v2.01c1.73.19 3.31.88 4.61 1.92zM11 3.06V1.05c-2.29.2-4.36 1.12-6.03 2.51l1.42 1.42C7.69 3.94 9.27 3.25 11 3.06M4.98 6.39 3.56 4.97C2.17 6.64 1.26 8.71 1.05 11h2.01c.19-1.73.88-3.31 1.92-4.61M20.94 11h2.01c-.21-2.29-1.12-4.36-2.51-6.03l-1.42 1.42c1.04 1.3 1.73 2.88 1.92 4.61M7 12l3.44 1.56L12 17l1.56-3.44L17 12l-3.44-1.56L12 7l-1.56 3.44z"
}, "0"), (0, import_jsx_runtime55.jsx)("path", {
  d: "M12 21c-3.11 0-5.85-1.59-7.46-4H7v-2H1v6h2v-2.7c1.99 2.84 5.27 4.7 9 4.7 4.87 0 9-3.17 10.44-7.56l-1.96-.45C19.25 18.48 15.92 21 12 21"
}, "1")], "AutoMode");

// node_modules/@toolpad/studio/dist/exports/editor.mjs
var React70 = __toESM(require_react(), 1);
var import_invariant9 = __toESM(require_browser(), 1);
var React67 = __toESM(require_react(), 1);

// node_modules/@mui/icons-material/esm/PlayArrow.js
var import_jsx_runtime56 = __toESM(require_jsx_runtime());
var PlayArrow_default = createSvgIcon((0, import_jsx_runtime56.jsx)("path", {
  d: "M8 5v14l11-7z"
}), "PlayArrow");

// node_modules/@toolpad/studio-runtime/dist/jsServerRuntime.js
var vm = __toESM(require_vm_browserify());
var React18 = __toESM(require_react());
function evalExpressionInContext(expression, globalScope = {}) {
  try {
    const value = vm.runInNewContext(expression, globalScope);
    return { value };
  } catch (rawError) {
    return { error: errorFrom(rawError) };
  }
}
function createServerJsRuntime(env) {
  return {
    getEnv() {
      if (env) {
        return env;
      }
      throw new Error(`Env variables are not supported in this context`);
    },
    evaluateExpression: (code, globalScope) => evalExpressionInContext(code, globalScope)
  };
}
function useServerJsRuntime() {
  return React18.useMemo(() => {
    const processEnv = {};
    return createServerJsRuntime(processEnv);
  }, []);
}

// node_modules/@toolpad/studio/dist/exports/editor.mjs
var React56 = __toESM(require_react(), 1);
var React57 = __toESM(require_react(), 1);
var React58 = __toESM(require_react(), 1);
var React59 = __toESM(require_react(), 1);
var React60 = __toESM(require_react(), 1);

// node_modules/@mui/icons-material/esm/Autorenew.js
var import_jsx_runtime57 = __toESM(require_jsx_runtime());
var Autorenew_default = createSvgIcon((0, import_jsx_runtime57.jsx)("path", {
  d: "M12 6v3l4-4-4-4v3c-4.42 0-8 3.58-8 8 0 1.57.46 3.03 1.24 4.26L6.7 14.8c-.45-.83-.7-1.79-.7-2.8 0-3.31 2.69-6 6-6m6.76 1.74L17.3 9.2c.44.84.7 1.79.7 2.8 0 3.31-2.69 6-6 6v-3l-4 4 4 4v-3c4.42 0 8-3.58 8-8 0-1.57-.46-3.03-1.24-4.26"
}), "Autorenew");

// node_modules/@toolpad/studio/dist/exports/editor.mjs
var React63 = __toESM(require_react(), 1);

// node_modules/@mui/icons-material/esm/DoDisturb.js
var import_jsx_runtime58 = __toESM(require_jsx_runtime());
var DoDisturb_default = createSvgIcon((0, import_jsx_runtime58.jsx)("path", {
  d: "M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2M4 12c0-4.4 3.6-8 8-8 1.8 0 3.5.6 4.9 1.7L5.7 16.9C4.6 15.5 4 13.8 4 12m8 8c-1.8 0-3.5-.6-4.9-1.7L18.3 7.1C19.4 8.5 20 10.2 20 12c0 4.4-3.6 8-8 8"
}), "DoDisturb");

// node_modules/@toolpad/studio/dist/exports/editor.mjs
var React61 = __toESM(require_react(), 1);
var React622 = __toESM(require_react(), 1);
var React64 = __toESM(require_react(), 1);
var React66 = __toESM(require_react(), 1);
var React65 = __toESM(require_react(), 1);
var React69 = __toESM(require_react(), 1);
var React68 = __toESM(require_react(), 1);

// node_modules/@mui/icons-material/esm/AddOutlined.js
var import_jsx_runtime59 = __toESM(require_jsx_runtime());
var AddOutlined_default = createSvgIcon((0, import_jsx_runtime59.jsx)("path", {
  d: "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6z"
}), "AddOutlined");

// node_modules/@mui/icons-material/esm/DataObjectOutlined.js
var import_jsx_runtime60 = __toESM(require_jsx_runtime());
var DataObjectOutlined_default = createSvgIcon((0, import_jsx_runtime60.jsx)("path", {
  d: "M4 7v2c0 .55-.45 1-1 1H2v4h1c.55 0 1 .45 1 1v2c0 1.65 1.35 3 3 3h3v-2H7c-.55 0-1-.45-1-1v-2c0-1.3-.84-2.42-2-2.83v-.34C5.16 11.42 6 10.3 6 9V7c0-.55.45-1 1-1h3V4H7C5.35 4 4 5.35 4 7m17 3c-.55 0-1-.45-1-1V7c0-1.65-1.35-3-3-3h-3v2h3c.55 0 1 .45 1 1v2c0 1.3.84 2.42 2 2.83v.34c-1.16.41-2 1.52-2 2.83v2c0 .55-.45 1-1 1h-3v2h3c1.65 0 3-1.35 3-3v-2c0-.55.45-1 1-1h1v-4z"
}), "DataObjectOutlined");

// node_modules/@mui/icons-material/esm/Done.js
var import_jsx_runtime61 = __toESM(require_jsx_runtime());
var Done_default = createSvgIcon((0, import_jsx_runtime61.jsx)("path", {
  d: "M9 16.2 4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4z"
}), "Done");

// node_modules/@toolpad/studio/dist/exports/editor.mjs
var React71 = __toESM(require_react(), 1);
var React98 = __toESM(require_react(), 1);
var React84 = __toESM(require_react(), 1);
var React79 = __toESM(require_react(), 1);

// node_modules/@mui/x-tree-view/TreeView/TreeView.js
var React40 = __toESM(require_react());
var import_prop_types3 = __toESM(require_prop_types());

// node_modules/@mui/x-tree-view/internals/zero-styled/index.js
function createUseThemeProps(name) {
  return useThemeProps;
}

// node_modules/@mui/x-tree-view/TreeView/treeViewClasses.js
function getTreeViewUtilityClass(slot) {
  return generateUtilityClass("MuiTreeView", slot);
}
var treeViewClasses = generateUtilityClasses("MuiTreeView", ["root"]);

// node_modules/@mui/x-tree-view/SimpleTreeView/SimpleTreeView.js
var React39 = __toESM(require_react());
var import_prop_types2 = __toESM(require_prop_types());

// node_modules/@mui/x-tree-view/SimpleTreeView/simpleTreeViewClasses.js
function getSimpleTreeViewUtilityClass(slot) {
  return generateUtilityClass("MuiSimpleTreeView", slot);
}
var simpleTreeViewClasses = generateUtilityClasses("MuiSimpleTreeView", ["root"]);

// node_modules/@mui/x-tree-view/internals/useTreeView/useTreeView.js
var React23 = __toESM(require_react());

// node_modules/@mui/x-tree-view/internals/useTreeView/useTreeViewModels.js
var React19 = __toESM(require_react());
var useTreeViewModels = (plugins, props2) => {
  const modelsRef = React19.useRef({});
  const [modelsState, setModelsState] = React19.useState(() => {
    const initialState = {};
    plugins.forEach((plugin) => {
      if (plugin.models) {
        Object.entries(plugin.models).forEach(([modelName, modelInitializer]) => {
          modelsRef.current[modelName] = {
            isControlled: props2[modelName] !== void 0,
            getDefaultValue: modelInitializer.getDefaultValue
          };
          initialState[modelName] = modelInitializer.getDefaultValue(props2);
        });
      }
    });
    return initialState;
  });
  const models = Object.fromEntries(Object.entries(modelsRef.current).map(([modelName, model]) => {
    const value = props2[modelName] ?? modelsState[modelName];
    return [modelName, {
      value,
      setControlledValue: (newValue) => {
        if (!model.isControlled) {
          setModelsState((prevState) => _extends({}, prevState, {
            [modelName]: newValue
          }));
        }
      }
    }];
  }));
  if (true) {
    Object.entries(modelsRef.current).forEach(([modelName, model]) => {
      const controlled = props2[modelName];
      const newDefaultValue = model.getDefaultValue(props2);
      React19.useEffect(() => {
        if (model.isControlled !== (controlled !== void 0)) {
          console.error([`MUI X: A component is changing the ${model.isControlled ? "" : "un"}controlled ${modelName} state of TreeView to be ${model.isControlled ? "un" : ""}controlled.`, "Elements should not switch from uncontrolled to controlled (or vice versa).", `Decide between using a controlled or uncontrolled ${modelName} element for the lifetime of the component.`, "The nature of the state is determined during the first render. It's considered controlled if the value is not `undefined`.", "More info: https://fb.me/react-controlled-components"].join("\n"));
        }
      }, [controlled]);
      const {
        current: defaultValue
      } = React19.useRef(newDefaultValue);
      React19.useEffect(() => {
        if (!model.isControlled && defaultValue !== newDefaultValue) {
          console.error([`MUI X: A component is changing the default ${modelName} state of an uncontrolled TreeView after being initialized. To suppress this warning opt to use a controlled TreeView.`].join("\n"));
        }
      }, [JSON.stringify(newDefaultValue)]);
    });
  }
  return models;
};

// node_modules/@mui/x-tree-view/internals/corePlugins/useTreeViewInstanceEvents/useTreeViewInstanceEvents.js
var React20 = __toESM(require_react());
var isSyntheticEvent = (event) => {
  return event.isPropagationStopped !== void 0;
};
var useTreeViewInstanceEvents = () => {
  const [eventManager] = React20.useState(() => new EventManager());
  const publishEvent = React20.useCallback((...args) => {
    const [name, params, event = {}] = args;
    event.defaultMuiPrevented = false;
    if (isSyntheticEvent(event) && event.isPropagationStopped()) {
      return;
    }
    eventManager.emit(name, params, event);
  }, [eventManager]);
  const subscribeEvent = React20.useCallback((event, handler) => {
    eventManager.on(event, handler);
    return () => {
      eventManager.removeListener(event, handler);
    };
  }, [eventManager]);
  return {
    instance: {
      $$publishEvent: publishEvent,
      $$subscribeEvent: subscribeEvent
    }
  };
};
useTreeViewInstanceEvents.params = {};

// node_modules/@mui/x-tree-view/internals/corePlugins/useTreeViewOptionalPlugins/useTreeViewOptionalPlugins.js
var useTreeViewOptionalPlugins = ({
  plugins
}) => {
  const pluginSet = new Set(plugins);
  const getAvailablePlugins = () => pluginSet;
  return {
    instance: {
      getAvailablePlugins
    }
  };
};
useTreeViewOptionalPlugins.params = {};

// node_modules/@mui/x-tree-view/internals/corePlugins/useTreeViewId/useTreeViewId.js
var React21 = __toESM(require_react());

// node_modules/@mui/x-tree-view/internals/corePlugins/useTreeViewId/useTreeViewId.utils.js
var globalTreeViewDefaultId = 0;
var createTreeViewDefaultId = () => {
  globalTreeViewDefaultId += 1;
  return `mui-tree-view-${globalTreeViewDefaultId}`;
};
var generateTreeItemIdAttribute = ({
  id,
  treeId = "",
  itemId
}) => {
  if (id != null) {
    return id;
  }
  return `${treeId}-${itemId}`;
};

// node_modules/@mui/x-tree-view/internals/corePlugins/useTreeViewId/useTreeViewId.js
var useTreeViewId = ({
  params,
  state,
  setState
}) => {
  React21.useEffect(() => {
    setState((prevState) => {
      if (prevState.id.treeId === params.id && prevState.id.treeId !== void 0) {
        return prevState;
      }
      return _extends({}, prevState, {
        id: _extends({}, prevState.id, {
          treeId: params.id ?? createTreeViewDefaultId()
        })
      });
    });
  }, [setState, params.id]);
  const treeId = params.id ?? state.id.treeId;
  return {
    getRootProps: () => ({
      id: treeId
    }),
    contextValue: {
      treeId
    }
  };
};
useTreeViewId.params = {
  id: true
};
useTreeViewId.getInitialState = ({
  id
}) => ({
  id: {
    treeId: id ?? void 0
  }
});

// node_modules/@mui/x-tree-view/internals/corePlugins/corePlugins.js
var TREE_VIEW_CORE_PLUGINS = [useTreeViewInstanceEvents, useTreeViewOptionalPlugins, useTreeViewId];

// node_modules/@mui/x-tree-view/internals/useTreeView/extractPluginParamsFromProps.js
var _excluded = ["slots", "slotProps", "apiRef", "experimentalFeatures"];
var extractPluginParamsFromProps = (_ref) => {
  let {
    props: {
      slots,
      slotProps,
      apiRef,
      experimentalFeatures: inExperimentalFeatures
    },
    plugins
  } = _ref, props2 = _objectWithoutPropertiesLoose(_ref.props, _excluded);
  const paramsLookup = {};
  plugins.forEach((plugin) => {
    Object.assign(paramsLookup, plugin.params);
  });
  const pluginParams = {};
  const forwardedProps = {};
  Object.keys(props2).forEach((propName) => {
    const prop = props2[propName];
    if (paramsLookup[propName]) {
      pluginParams[propName] = prop;
    } else {
      forwardedProps[propName] = prop;
    }
  });
  const experimentalFeatures = inExperimentalFeatures ?? {};
  const defaultizedPluginParams = plugins.reduce((acc, plugin) => {
    if (plugin.getDefaultizedParams) {
      return plugin.getDefaultizedParams({
        params: acc,
        experimentalFeatures
      });
    }
    return acc;
  }, pluginParams);
  return {
    apiRef,
    forwardedProps,
    pluginParams: defaultizedPluginParams,
    slots: slots ?? {},
    slotProps: slotProps ?? {},
    experimentalFeatures
  };
};

// node_modules/@mui/x-tree-view/internals/useTreeView/useTreeViewBuildContext.js
var useTreeViewBuildContext = ({
  plugins,
  instance,
  publicAPI,
  rootRef
}) => {
  const runItemPlugins = (itemPluginProps) => {
    let finalRootRef = null;
    let finalContentRef = null;
    const pluginPropEnhancers = [];
    const pluginPropEnhancersNames = {};
    plugins.forEach((plugin) => {
      if (!plugin.itemPlugin) {
        return;
      }
      const itemPluginResponse = plugin.itemPlugin({
        props: itemPluginProps,
        rootRef: finalRootRef,
        contentRef: finalContentRef
      });
      if (itemPluginResponse == null ? void 0 : itemPluginResponse.rootRef) {
        finalRootRef = itemPluginResponse.rootRef;
      }
      if (itemPluginResponse == null ? void 0 : itemPluginResponse.contentRef) {
        finalContentRef = itemPluginResponse.contentRef;
      }
      if (itemPluginResponse == null ? void 0 : itemPluginResponse.propsEnhancers) {
        pluginPropEnhancers.push(itemPluginResponse.propsEnhancers);
        Object.keys(itemPluginResponse.propsEnhancers).forEach((propsEnhancerName) => {
          pluginPropEnhancersNames[propsEnhancerName] = true;
        });
      }
    });
    const resolvePropsEnhancer = (currentSlotName) => (currentSlotParams) => {
      const enhancedProps = {};
      pluginPropEnhancers.forEach((propsEnhancersForCurrentPlugin) => {
        const propsEnhancerForCurrentPluginAndSlot = propsEnhancersForCurrentPlugin[currentSlotName];
        if (propsEnhancerForCurrentPluginAndSlot != null) {
          Object.assign(enhancedProps, propsEnhancerForCurrentPluginAndSlot(currentSlotParams));
        }
      });
      return enhancedProps;
    };
    const propsEnhancers = Object.fromEntries(Object.keys(pluginPropEnhancersNames).map((propEnhancerName) => [propEnhancerName, resolvePropsEnhancer(propEnhancerName)]));
    return {
      contentRef: finalContentRef,
      rootRef: finalRootRef,
      propsEnhancers
    };
  };
  const wrapItem = ({
    itemId,
    children
  }) => {
    let finalChildren = children;
    for (let i = plugins.length - 1; i >= 0; i -= 1) {
      const plugin = plugins[i];
      if (plugin.wrapItem) {
        finalChildren = plugin.wrapItem({
          itemId,
          children: finalChildren,
          instance
        });
      }
    }
    return finalChildren;
  };
  const wrapRoot = ({
    children
  }) => {
    let finalChildren = children;
    for (let i = plugins.length - 1; i >= 0; i -= 1) {
      const plugin = plugins[i];
      if (plugin.wrapRoot) {
        finalChildren = plugin.wrapRoot({
          children: finalChildren,
          instance
        });
      }
    }
    return finalChildren;
  };
  return {
    runItemPlugins,
    wrapItem,
    wrapRoot,
    instance,
    rootRef,
    publicAPI
  };
};

// node_modules/@mui/x-tree-view/internals/useTreeView/useTreeView.js
function useTreeViewApiInitialization(inputApiRef) {
  const fallbackPublicApiRef = React23.useRef({});
  if (inputApiRef) {
    if (inputApiRef.current == null) {
      inputApiRef.current = {};
    }
    return inputApiRef.current;
  }
  return fallbackPublicApiRef.current;
}
var useTreeView = ({
  plugins: inPlugins,
  rootRef,
  props: props2
}) => {
  const plugins = [...TREE_VIEW_CORE_PLUGINS, ...inPlugins];
  const {
    pluginParams,
    forwardedProps,
    apiRef,
    experimentalFeatures,
    slots,
    slotProps
  } = extractPluginParamsFromProps({
    plugins,
    props: props2
  });
  const models = useTreeViewModels(plugins, pluginParams);
  const instanceRef = React23.useRef({});
  const instance = instanceRef.current;
  const publicAPI = useTreeViewApiInitialization(apiRef);
  const innerRootRef = React23.useRef(null);
  const handleRootRef = useForkRef(innerRootRef, rootRef);
  const contextValue = useTreeViewBuildContext({
    plugins,
    instance,
    publicAPI,
    rootRef: innerRootRef
  });
  const [state, setState] = React23.useState(() => {
    const temp = {};
    plugins.forEach((plugin) => {
      if (plugin.getInitialState) {
        Object.assign(temp, plugin.getInitialState(pluginParams));
      }
    });
    return temp;
  });
  const rootPropsGetters = [];
  const runPlugin = (plugin) => {
    const pluginResponse = plugin({
      instance,
      params: pluginParams,
      slots,
      slotProps,
      experimentalFeatures,
      state,
      setState,
      rootRef: innerRootRef,
      models,
      plugins
    });
    if (pluginResponse.getRootProps) {
      rootPropsGetters.push(pluginResponse.getRootProps);
    }
    if (pluginResponse.publicAPI) {
      Object.assign(publicAPI, pluginResponse.publicAPI);
    }
    if (pluginResponse.instance) {
      Object.assign(instance, pluginResponse.instance);
    }
    if (pluginResponse.contextValue) {
      Object.assign(contextValue, pluginResponse.contextValue);
    }
  };
  plugins.forEach(runPlugin);
  const getRootProps = (otherHandlers = {}) => {
    const rootProps = _extends({
      role: "tree"
    }, forwardedProps, otherHandlers, {
      ref: handleRootRef
    });
    rootPropsGetters.forEach((rootPropsGetter) => {
      Object.assign(rootProps, rootPropsGetter(otherHandlers));
    });
    return rootProps;
  };
  return {
    getRootProps,
    rootRef: handleRootRef,
    contextValue,
    instance
  };
};

// node_modules/@mui/x-tree-view/internals/TreeViewProvider/TreeViewProvider.js
var React25 = __toESM(require_react());

// node_modules/@mui/x-tree-view/internals/TreeViewProvider/TreeViewContext.js
var React24 = __toESM(require_react());
var TreeViewContext = React24.createContext(null);
if (true) {
  TreeViewContext.displayName = "TreeViewContext";
}

// node_modules/@mui/x-tree-view/internals/TreeViewProvider/TreeViewProvider.js
var import_jsx_runtime62 = __toESM(require_jsx_runtime());
function TreeViewProvider(props2) {
  const {
    value,
    children
  } = props2;
  return (0, import_jsx_runtime62.jsx)(TreeViewContext.Provider, {
    value,
    children: value.wrapRoot({
      children,
      instance: value.instance
    })
  });
}

// node_modules/@mui/x-tree-view/internals/TreeViewProvider/useTreeViewContext.js
var React26 = __toESM(require_react());
var useTreeViewContext = () => {
  const context = React26.useContext(TreeViewContext);
  if (context == null) {
    throw new Error(["MUI X: Could not find the Tree View context.", "It looks like you rendered your component outside of a SimpleTreeView or RichTreeView parent component.", "This can also happen if you are bundling multiple versions of the Tree View."].join("\n"));
  }
  return context;
};

// node_modules/@mui/x-tree-view/internals/plugins/useTreeViewItems/useTreeViewItems.js
var React28 = __toESM(require_react());

// node_modules/@mui/x-tree-view/internals/utils/publishTreeViewEvent.js
var publishTreeViewEvent = (instance, eventName, params) => {
  instance.$$publishEvent(eventName, params);
};

// node_modules/@mui/x-tree-view/internals/plugins/useTreeViewItems/useTreeViewItems.utils.js
var TREE_VIEW_ROOT_PARENT_ID = "__TREE_VIEW_ROOT_PARENT_ID__";
var buildSiblingIndexes = (siblings) => {
  const siblingsIndexLookup = {};
  siblings.forEach((childId, index) => {
    siblingsIndexLookup[childId] = index;
  });
  return siblingsIndexLookup;
};

// node_modules/@mui/x-tree-view/internals/TreeViewItemDepthContext/TreeViewItemDepthContext.js
var React27 = __toESM(require_react());
var TreeViewItemDepthContext = React27.createContext(() => -1);
if (true) {
  TreeViewItemDepthContext.displayName = "TreeViewItemDepthContext";
}

// node_modules/@mui/x-tree-view/internals/plugins/useTreeViewItems/useTreeViewItems.js
var import_jsx_runtime63 = __toESM(require_jsx_runtime());
var _excluded2 = ["children"];
var updateItemsState = ({
  items,
  isItemDisabled,
  getItemLabel,
  getItemId
}) => {
  const itemMetaMap = {};
  const itemMap = {};
  const itemOrderedChildrenIds = {
    [TREE_VIEW_ROOT_PARENT_ID]: []
  };
  const processItem = (item, depth, parentId) => {
    var _a, _b;
    const id = getItemId ? getItemId(item) : item.id;
    if (id == null) {
      throw new Error(["MUI X: The Tree View component requires all items to have a unique `id` property.", "Alternatively, you can use the `getItemId` prop to specify a custom id for each item.", "An item was provided without id in the `items` prop:", JSON.stringify(item)].join("\n"));
    }
    if (itemMetaMap[id] != null) {
      throw new Error(["MUI X: The Tree View component requires all items to have a unique `id` property.", "Alternatively, you can use the `getItemId` prop to specify a custom id for each item.", `Two items were provided with the same id in the \`items\` prop: "${id}"`].join("\n"));
    }
    const label = getItemLabel ? getItemLabel(item) : item.label;
    if (label == null) {
      throw new Error(["MUI X: The Tree View component requires all items to have a `label` property.", "Alternatively, you can use the `getItemLabel` prop to specify a custom label for each item.", "An item was provided without label in the `items` prop:", JSON.stringify(item)].join("\n"));
    }
    itemMetaMap[id] = {
      id,
      label,
      parentId,
      idAttribute: void 0,
      expandable: !!((_a = item.children) == null ? void 0 : _a.length),
      disabled: isItemDisabled ? isItemDisabled(item) : false,
      depth
    };
    itemMap[id] = item;
    const parentIdWithDefault = parentId ?? TREE_VIEW_ROOT_PARENT_ID;
    if (!itemOrderedChildrenIds[parentIdWithDefault]) {
      itemOrderedChildrenIds[parentIdWithDefault] = [];
    }
    itemOrderedChildrenIds[parentIdWithDefault].push(id);
    (_b = item.children) == null ? void 0 : _b.forEach((child) => processItem(child, depth + 1, id));
  };
  items.forEach((item) => processItem(item, 0, null));
  const itemChildrenIndexes = {};
  Object.keys(itemOrderedChildrenIds).forEach((parentId) => {
    itemChildrenIndexes[parentId] = buildSiblingIndexes(itemOrderedChildrenIds[parentId]);
  });
  return {
    itemMetaMap,
    itemMap,
    itemOrderedChildrenIds,
    itemChildrenIndexes
  };
};
var useTreeViewItems = ({
  instance,
  params,
  state,
  setState,
  experimentalFeatures
}) => {
  const getItemMeta = React28.useCallback((itemId) => state.items.itemMetaMap[itemId], [state.items.itemMetaMap]);
  const getItem = React28.useCallback((itemId) => state.items.itemMap[itemId], [state.items.itemMap]);
  const getItemTree = React28.useCallback(() => {
    const getItemFromItemId = (id) => {
      const _state$items$itemMap$ = state.items.itemMap[id], item = _objectWithoutPropertiesLoose(_state$items$itemMap$, _excluded2);
      const newChildren = state.items.itemOrderedChildrenIds[id];
      if (newChildren) {
        item.children = newChildren.map(getItemFromItemId);
      }
      return item;
    };
    return state.items.itemOrderedChildrenIds[TREE_VIEW_ROOT_PARENT_ID].map(getItemFromItemId);
  }, [state.items.itemMap, state.items.itemOrderedChildrenIds]);
  const isItemDisabled = React28.useCallback((itemId) => {
    if (itemId == null) {
      return false;
    }
    let itemMeta = instance.getItemMeta(itemId);
    if (!itemMeta) {
      return false;
    }
    if (itemMeta.disabled) {
      return true;
    }
    while (itemMeta.parentId != null) {
      itemMeta = instance.getItemMeta(itemMeta.parentId);
      if (itemMeta.disabled) {
        return true;
      }
    }
    return false;
  }, [instance]);
  const getItemIndex = React28.useCallback((itemId) => {
    const parentId = instance.getItemMeta(itemId).parentId ?? TREE_VIEW_ROOT_PARENT_ID;
    return state.items.itemChildrenIndexes[parentId][itemId];
  }, [instance, state.items.itemChildrenIndexes]);
  const getItemOrderedChildrenIds = React28.useCallback((itemId) => state.items.itemOrderedChildrenIds[itemId ?? TREE_VIEW_ROOT_PARENT_ID] ?? [], [state.items.itemOrderedChildrenIds]);
  const getItemDOMElement = (itemId) => {
    const itemMeta = instance.getItemMeta(itemId);
    if (itemMeta == null) {
      return null;
    }
    return document.getElementById(generateTreeItemIdAttribute({
      treeId: state.id.treeId,
      itemId,
      id: itemMeta.idAttribute
    }));
  };
  const isItemNavigable = (itemId) => {
    if (params.disabledItemsFocusable) {
      return true;
    }
    return !instance.isItemDisabled(itemId);
  };
  const areItemUpdatesPreventedRef = React28.useRef(false);
  const preventItemUpdates = React28.useCallback(() => {
    areItemUpdatesPreventedRef.current = true;
  }, []);
  const areItemUpdatesPrevented = React28.useCallback(() => areItemUpdatesPreventedRef.current, []);
  React28.useEffect(() => {
    if (instance.areItemUpdatesPrevented()) {
      return;
    }
    setState((prevState) => {
      const newState = updateItemsState({
        items: params.items,
        isItemDisabled: params.isItemDisabled,
        getItemId: params.getItemId,
        getItemLabel: params.getItemLabel
      });
      Object.values(prevState.items.itemMetaMap).forEach((item) => {
        if (!newState.itemMetaMap[item.id]) {
          publishTreeViewEvent(instance, "removeItem", {
            id: item.id
          });
        }
      });
      return _extends({}, prevState, {
        items: newState
      });
    });
  }, [instance, setState, params.items, params.isItemDisabled, params.getItemId, params.getItemLabel]);
  const getItemsToRender = () => {
    const getPropsFromItemId = (id) => {
      var _a;
      const item = state.items.itemMetaMap[id];
      return {
        label: item.label,
        itemId: item.id,
        id: item.idAttribute,
        children: (_a = state.items.itemOrderedChildrenIds[id]) == null ? void 0 : _a.map(getPropsFromItemId)
      };
    };
    return state.items.itemOrderedChildrenIds[TREE_VIEW_ROOT_PARENT_ID].map(getPropsFromItemId);
  };
  return {
    getRootProps: () => ({
      style: {
        "--TreeView-itemChildrenIndentation": typeof params.itemChildrenIndentation === "number" ? `${params.itemChildrenIndentation}px` : params.itemChildrenIndentation
      }
    }),
    publicAPI: {
      getItem,
      getItemDOMElement,
      getItemTree,
      getItemOrderedChildrenIds
    },
    instance: {
      getItemMeta,
      getItem,
      getItemTree,
      getItemsToRender,
      getItemIndex,
      getItemDOMElement,
      getItemOrderedChildrenIds,
      isItemDisabled,
      isItemNavigable,
      preventItemUpdates,
      areItemUpdatesPrevented
    },
    contextValue: {
      items: {
        onItemClick: params.onItemClick,
        disabledItemsFocusable: params.disabledItemsFocusable,
        indentationAtItemLevel: experimentalFeatures.indentationAtItemLevel ?? false
      }
    }
  };
};
useTreeViewItems.getInitialState = (params) => ({
  items: updateItemsState({
    items: params.items,
    isItemDisabled: params.isItemDisabled,
    getItemId: params.getItemId,
    getItemLabel: params.getItemLabel
  })
});
useTreeViewItems.getDefaultizedParams = ({
  params
}) => _extends({}, params, {
  disabledItemsFocusable: params.disabledItemsFocusable ?? false,
  itemChildrenIndentation: params.itemChildrenIndentation ?? "12px"
});
useTreeViewItems.wrapRoot = ({
  children,
  instance
}) => {
  return (0, import_jsx_runtime63.jsx)(TreeViewItemDepthContext.Provider, {
    value: (itemId) => {
      var _a;
      return ((_a = instance.getItemMeta(itemId)) == null ? void 0 : _a.depth) ?? 0;
    },
    children
  });
};
useTreeViewItems.params = {
  disabledItemsFocusable: true,
  items: true,
  isItemDisabled: true,
  getItemLabel: true,
  getItemId: true,
  onItemClick: true,
  itemChildrenIndentation: true
};

// node_modules/@mui/x-tree-view/internals/plugins/useTreeViewExpansion/useTreeViewExpansion.js
var React29 = __toESM(require_react());
var useTreeViewExpansion = ({
  instance,
  params,
  models
}) => {
  const expandedItemsMap = React29.useMemo(() => {
    const temp = /* @__PURE__ */ new Map();
    models.expandedItems.value.forEach((id) => {
      temp.set(id, true);
    });
    return temp;
  }, [models.expandedItems.value]);
  const setExpandedItems = (event, value) => {
    var _a;
    (_a = params.onExpandedItemsChange) == null ? void 0 : _a.call(params, event, value);
    models.expandedItems.setControlledValue(value);
  };
  const isItemExpanded = React29.useCallback((itemId) => expandedItemsMap.has(itemId), [expandedItemsMap]);
  const isItemExpandable3 = React29.useCallback((itemId) => {
    var _a;
    return !!((_a = instance.getItemMeta(itemId)) == null ? void 0 : _a.expandable);
  }, [instance]);
  const toggleItemExpansion = useEventCallback_default((event, itemId) => {
    const isExpandedBefore = instance.isItemExpanded(itemId);
    instance.setItemExpansion(event, itemId, !isExpandedBefore);
  });
  const setItemExpansion = useEventCallback_default((event, itemId, isExpanded) => {
    const isExpandedBefore = instance.isItemExpanded(itemId);
    if (isExpandedBefore === isExpanded) {
      return;
    }
    let newExpanded;
    if (isExpanded) {
      newExpanded = [itemId].concat(models.expandedItems.value);
    } else {
      newExpanded = models.expandedItems.value.filter((id) => id !== itemId);
    }
    if (params.onItemExpansionToggle) {
      params.onItemExpansionToggle(event, itemId, isExpanded);
    }
    setExpandedItems(event, newExpanded);
  });
  const expandAllSiblings = (event, itemId) => {
    const itemMeta = instance.getItemMeta(itemId);
    const siblings = instance.getItemOrderedChildrenIds(itemMeta.parentId);
    const diff = siblings.filter((child) => instance.isItemExpandable(child) && !instance.isItemExpanded(child));
    const newExpanded = models.expandedItems.value.concat(diff);
    if (diff.length > 0) {
      if (params.onItemExpansionToggle) {
        diff.forEach((newlyExpandedItemId) => {
          params.onItemExpansionToggle(event, newlyExpandedItemId, true);
        });
      }
      setExpandedItems(event, newExpanded);
    }
  };
  const expansionTrigger = React29.useMemo(() => {
    if (params.expansionTrigger) {
      return params.expansionTrigger;
    }
    if (instance.isTreeViewEditable) {
      return "iconContainer";
    }
    return "content";
  }, [params.expansionTrigger, instance.isTreeViewEditable]);
  return {
    publicAPI: {
      setItemExpansion
    },
    instance: {
      isItemExpanded,
      isItemExpandable: isItemExpandable3,
      setItemExpansion,
      toggleItemExpansion,
      expandAllSiblings
    },
    contextValue: {
      expansion: {
        expansionTrigger
      }
    }
  };
};
useTreeViewExpansion.models = {
  expandedItems: {
    getDefaultValue: (params) => params.defaultExpandedItems
  }
};
var DEFAULT_EXPANDED_ITEMS = [];
useTreeViewExpansion.getDefaultizedParams = ({
  params
}) => _extends({}, params, {
  defaultExpandedItems: params.defaultExpandedItems ?? DEFAULT_EXPANDED_ITEMS
});
useTreeViewExpansion.params = {
  expandedItems: true,
  defaultExpandedItems: true,
  onExpandedItemsChange: true,
  onItemExpansionToggle: true,
  expansionTrigger: true
};

// node_modules/@mui/x-tree-view/internals/plugins/useTreeViewSelection/useTreeViewSelection.js
var React30 = __toESM(require_react());

// node_modules/@mui/x-tree-view/internals/utils/tree.js
var getLastNavigableItemInArray = (instance, items) => {
  let itemIndex = items.length - 1;
  while (itemIndex >= 0 && !instance.isItemNavigable(items[itemIndex])) {
    itemIndex -= 1;
  }
  if (itemIndex === -1) {
    return void 0;
  }
  return items[itemIndex];
};
var getPreviousNavigableItem = (instance, itemId) => {
  const itemMeta = instance.getItemMeta(itemId);
  const siblings = instance.getItemOrderedChildrenIds(itemMeta.parentId);
  const itemIndex = instance.getItemIndex(itemId);
  if (itemIndex === 0) {
    return itemMeta.parentId;
  }
  let previousNavigableSiblingIndex = itemIndex - 1;
  while (!instance.isItemNavigable(siblings[previousNavigableSiblingIndex]) && previousNavigableSiblingIndex >= 0) {
    previousNavigableSiblingIndex -= 1;
  }
  if (previousNavigableSiblingIndex === -1) {
    if (itemMeta.parentId == null) {
      return null;
    }
    return getPreviousNavigableItem(instance, itemMeta.parentId);
  }
  let currentItemId = siblings[previousNavigableSiblingIndex];
  let lastNavigableChild = getLastNavigableItemInArray(instance, instance.getItemOrderedChildrenIds(currentItemId));
  while (instance.isItemExpanded(currentItemId) && lastNavigableChild != null) {
    currentItemId = lastNavigableChild;
    lastNavigableChild = instance.getItemOrderedChildrenIds(currentItemId).find(instance.isItemNavigable);
  }
  return currentItemId;
};
var getNextNavigableItem = (instance, itemId) => {
  if (instance.isItemExpanded(itemId)) {
    const firstNavigableChild = instance.getItemOrderedChildrenIds(itemId).find(instance.isItemNavigable);
    if (firstNavigableChild != null) {
      return firstNavigableChild;
    }
  }
  let itemMeta = instance.getItemMeta(itemId);
  while (itemMeta != null) {
    const siblings = instance.getItemOrderedChildrenIds(itemMeta.parentId);
    const currentItemIndex = instance.getItemIndex(itemMeta.id);
    if (currentItemIndex < siblings.length - 1) {
      let nextItemIndex = currentItemIndex + 1;
      while (!instance.isItemNavigable(siblings[nextItemIndex]) && nextItemIndex < siblings.length - 1) {
        nextItemIndex += 1;
      }
      if (instance.isItemNavigable(siblings[nextItemIndex])) {
        return siblings[nextItemIndex];
      }
    }
    itemMeta = instance.getItemMeta(itemMeta.parentId);
  }
  return null;
};
var getLastNavigableItem = (instance) => {
  let itemId = null;
  while (itemId == null || instance.isItemExpanded(itemId)) {
    const children = instance.getItemOrderedChildrenIds(itemId);
    const lastNavigableChild = getLastNavigableItemInArray(instance, children);
    if (lastNavigableChild == null) {
      return itemId;
    }
    itemId = lastNavigableChild;
  }
  return itemId;
};
var getFirstNavigableItem = (instance) => instance.getItemOrderedChildrenIds(null).find(instance.isItemNavigable);
var findOrderInTremauxTree = (instance, itemAId, itemBId) => {
  if (itemAId === itemBId) {
    return [itemAId, itemBId];
  }
  const itemMetaA = instance.getItemMeta(itemAId);
  const itemMetaB = instance.getItemMeta(itemBId);
  if (itemMetaA.parentId === itemMetaB.id || itemMetaB.parentId === itemMetaA.id) {
    return itemMetaB.parentId === itemMetaA.id ? [itemMetaA.id, itemMetaB.id] : [itemMetaB.id, itemMetaA.id];
  }
  const aFamily = [itemMetaA.id];
  const bFamily = [itemMetaB.id];
  let aAncestor = itemMetaA.parentId;
  let bAncestor = itemMetaB.parentId;
  let aAncestorIsCommon = bFamily.indexOf(aAncestor) !== -1;
  let bAncestorIsCommon = aFamily.indexOf(bAncestor) !== -1;
  let continueA = true;
  let continueB = true;
  while (!bAncestorIsCommon && !aAncestorIsCommon) {
    if (continueA) {
      aFamily.push(aAncestor);
      aAncestorIsCommon = bFamily.indexOf(aAncestor) !== -1;
      continueA = aAncestor !== null;
      if (!aAncestorIsCommon && continueA) {
        aAncestor = instance.getItemMeta(aAncestor).parentId;
      }
    }
    if (continueB && !aAncestorIsCommon) {
      bFamily.push(bAncestor);
      bAncestorIsCommon = aFamily.indexOf(bAncestor) !== -1;
      continueB = bAncestor !== null;
      if (!bAncestorIsCommon && continueB) {
        bAncestor = instance.getItemMeta(bAncestor).parentId;
      }
    }
  }
  const commonAncestor = aAncestorIsCommon ? aAncestor : bAncestor;
  const ancestorFamily = instance.getItemOrderedChildrenIds(commonAncestor);
  const aSide = aFamily[aFamily.indexOf(commonAncestor) - 1];
  const bSide = bFamily[bFamily.indexOf(commonAncestor) - 1];
  return ancestorFamily.indexOf(aSide) < ancestorFamily.indexOf(bSide) ? [itemAId, itemBId] : [itemBId, itemAId];
};
var getNonDisabledItemsInRange = (instance, itemAId, itemBId) => {
  const getNextItem = (itemId) => {
    if (instance.isItemExpandable(itemId) && instance.isItemExpanded(itemId)) {
      return instance.getItemOrderedChildrenIds(itemId)[0];
    }
    let itemMeta = instance.getItemMeta(itemId);
    while (itemMeta != null) {
      const siblings = instance.getItemOrderedChildrenIds(itemMeta.parentId);
      const currentItemIndex = instance.getItemIndex(itemMeta.id);
      if (currentItemIndex < siblings.length - 1) {
        return siblings[currentItemIndex + 1];
      }
      itemMeta = instance.getItemMeta(itemMeta.parentId);
    }
    throw new Error("Invalid range");
  };
  const [first, last] = findOrderInTremauxTree(instance, itemAId, itemBId);
  const items = [first];
  let current = first;
  while (current !== last) {
    current = getNextItem(current);
    if (!instance.isItemDisabled(current)) {
      items.push(current);
    }
  }
  return items;
};
var getAllNavigableItems = (instance) => {
  let item = getFirstNavigableItem(instance);
  const navigableItems = [];
  while (item != null) {
    navigableItems.push(item);
    item = getNextNavigableItem(instance, item);
  }
  return navigableItems;
};
var isTargetInDescendants = (target, itemRoot) => {
  return itemRoot !== target.closest('*[role="treeitem"]');
};

// node_modules/@mui/x-tree-view/internals/plugins/useTreeViewSelection/useTreeViewSelection.utils.js
var convertSelectedItemsToArray = (model) => {
  if (Array.isArray(model)) {
    return model;
  }
  if (model != null) {
    return [model];
  }
  return [];
};
var getLookupFromArray = (array) => {
  const lookup = {};
  array.forEach((itemId) => {
    lookup[itemId] = true;
  });
  return lookup;
};

// node_modules/@mui/x-tree-view/internals/plugins/useTreeViewSelection/useTreeViewSelection.js
var useTreeViewSelection = ({
  instance,
  params,
  models
}) => {
  const lastSelectedItem = React30.useRef(null);
  const lastSelectedRange = React30.useRef({});
  const selectedItemsMap = React30.useMemo(() => {
    const temp = /* @__PURE__ */ new Map();
    if (Array.isArray(models.selectedItems.value)) {
      models.selectedItems.value.forEach((id) => {
        temp.set(id, true);
      });
    } else if (models.selectedItems.value != null) {
      temp.set(models.selectedItems.value, true);
    }
    return temp;
  }, [models.selectedItems.value]);
  const setSelectedItems = (event, newSelectedItems) => {
    if (params.onItemSelectionToggle) {
      if (params.multiSelect) {
        const addedItems = newSelectedItems.filter((itemId) => !instance.isItemSelected(itemId));
        const removedItems = models.selectedItems.value.filter((itemId) => !newSelectedItems.includes(itemId));
        addedItems.forEach((itemId) => {
          params.onItemSelectionToggle(event, itemId, true);
        });
        removedItems.forEach((itemId) => {
          params.onItemSelectionToggle(event, itemId, false);
        });
      } else if (newSelectedItems !== models.selectedItems.value) {
        if (models.selectedItems.value != null) {
          params.onItemSelectionToggle(event, models.selectedItems.value, false);
        }
        if (newSelectedItems != null) {
          params.onItemSelectionToggle(event, newSelectedItems, true);
        }
      }
    }
    if (params.onSelectedItemsChange) {
      params.onSelectedItemsChange(event, newSelectedItems);
    }
    models.selectedItems.setControlledValue(newSelectedItems);
  };
  const isItemSelected = (itemId) => selectedItemsMap.has(itemId);
  const selectItem = ({
    event,
    itemId,
    keepExistingSelection = false,
    shouldBeSelected
  }) => {
    if (params.disableSelection) {
      return;
    }
    let newSelected;
    if (keepExistingSelection) {
      const cleanSelectedItems = convertSelectedItemsToArray(models.selectedItems.value);
      const isSelectedBefore = instance.isItemSelected(itemId);
      if (isSelectedBefore && (shouldBeSelected === false || shouldBeSelected == null)) {
        newSelected = cleanSelectedItems.filter((id) => id !== itemId);
      } else if (!isSelectedBefore && (shouldBeSelected === true || shouldBeSelected == null)) {
        newSelected = [itemId].concat(cleanSelectedItems);
      } else {
        newSelected = cleanSelectedItems;
      }
    } else {
      if (shouldBeSelected === false || shouldBeSelected == null && instance.isItemSelected(itemId)) {
        newSelected = params.multiSelect ? [] : null;
      } else {
        newSelected = params.multiSelect ? [itemId] : itemId;
      }
    }
    setSelectedItems(event, newSelected);
    lastSelectedItem.current = itemId;
    lastSelectedRange.current = {};
  };
  const selectRange = (event, [start, end]) => {
    if (params.disableSelection || !params.multiSelect) {
      return;
    }
    let newSelectedItems = convertSelectedItemsToArray(models.selectedItems.value).slice();
    if (Object.keys(lastSelectedRange.current).length > 0) {
      newSelectedItems = newSelectedItems.filter((id) => !lastSelectedRange.current[id]);
    }
    const selectedItemsLookup = getLookupFromArray(newSelectedItems);
    const range = getNonDisabledItemsInRange(instance, start, end);
    const itemsToAddToModel = range.filter((id) => !selectedItemsLookup[id]);
    newSelectedItems = newSelectedItems.concat(itemsToAddToModel);
    setSelectedItems(event, newSelectedItems);
    lastSelectedRange.current = getLookupFromArray(range);
  };
  const expandSelectionRange = (event, itemId) => {
    if (lastSelectedItem.current != null) {
      const [start, end] = findOrderInTremauxTree(instance, itemId, lastSelectedItem.current);
      selectRange(event, [start, end]);
    }
  };
  const selectRangeFromStartToItem = (event, itemId) => {
    selectRange(event, [getFirstNavigableItem(instance), itemId]);
  };
  const selectRangeFromItemToEnd = (event, itemId) => {
    selectRange(event, [itemId, getLastNavigableItem(instance)]);
  };
  const selectAllNavigableItems = (event) => {
    if (params.disableSelection || !params.multiSelect) {
      return;
    }
    const navigableItems = getAllNavigableItems(instance);
    setSelectedItems(event, navigableItems);
    lastSelectedRange.current = getLookupFromArray(navigableItems);
  };
  const selectItemFromArrowNavigation = (event, currentItem, nextItem) => {
    if (params.disableSelection || !params.multiSelect) {
      return;
    }
    let newSelectedItems = convertSelectedItemsToArray(models.selectedItems.value).slice();
    if (Object.keys(lastSelectedRange.current).length === 0) {
      newSelectedItems.push(nextItem);
      lastSelectedRange.current = {
        [currentItem]: true,
        [nextItem]: true
      };
    } else {
      if (!lastSelectedRange.current[currentItem]) {
        lastSelectedRange.current = {};
      }
      if (lastSelectedRange.current[nextItem]) {
        newSelectedItems = newSelectedItems.filter((id) => id !== currentItem);
        delete lastSelectedRange.current[currentItem];
      } else {
        newSelectedItems.push(nextItem);
        lastSelectedRange.current[nextItem] = true;
      }
    }
    setSelectedItems(event, newSelectedItems);
  };
  return {
    getRootProps: () => ({
      "aria-multiselectable": params.multiSelect
    }),
    publicAPI: {
      selectItem
    },
    instance: {
      isItemSelected,
      selectItem,
      selectAllNavigableItems,
      expandSelectionRange,
      selectRangeFromStartToItem,
      selectRangeFromItemToEnd,
      selectItemFromArrowNavigation
    },
    contextValue: {
      selection: {
        multiSelect: params.multiSelect,
        checkboxSelection: params.checkboxSelection,
        disableSelection: params.disableSelection
      }
    }
  };
};
useTreeViewSelection.models = {
  selectedItems: {
    getDefaultValue: (params) => params.defaultSelectedItems
  }
};
var DEFAULT_SELECTED_ITEMS = [];
useTreeViewSelection.getDefaultizedParams = ({
  params
}) => _extends({}, params, {
  disableSelection: params.disableSelection ?? false,
  multiSelect: params.multiSelect ?? false,
  checkboxSelection: params.checkboxSelection ?? false,
  defaultSelectedItems: params.defaultSelectedItems ?? (params.multiSelect ? DEFAULT_SELECTED_ITEMS : null)
});
useTreeViewSelection.params = {
  disableSelection: true,
  multiSelect: true,
  checkboxSelection: true,
  defaultSelectedItems: true,
  selectedItems: true,
  onSelectedItemsChange: true,
  onItemSelectionToggle: true
};

// node_modules/@mui/x-tree-view/internals/plugins/useTreeViewFocus/useTreeViewFocus.js
var React33 = __toESM(require_react());

// node_modules/@mui/x-tree-view/internals/hooks/useInstanceEventHandler.js
var React31 = __toESM(require_react());

// node_modules/@mui/x-tree-view/internals/utils/cleanupTracking/TimerBasedCleanupTracking.js
var CLEANUP_TIMER_LOOP_MILLIS = 1e3;
var TimerBasedCleanupTracking = class {
  constructor(timeout = CLEANUP_TIMER_LOOP_MILLIS) {
    this.timeouts = /* @__PURE__ */ new Map();
    this.cleanupTimeout = CLEANUP_TIMER_LOOP_MILLIS;
    this.cleanupTimeout = timeout;
  }
  register(object, unsubscribe, unregisterToken) {
    if (!this.timeouts) {
      this.timeouts = /* @__PURE__ */ new Map();
    }
    const timeout = setTimeout(() => {
      if (typeof unsubscribe === "function") {
        unsubscribe();
      }
      this.timeouts.delete(unregisterToken.cleanupToken);
    }, this.cleanupTimeout);
    this.timeouts.set(unregisterToken.cleanupToken, timeout);
  }
  unregister(unregisterToken) {
    const timeout = this.timeouts.get(unregisterToken.cleanupToken);
    if (timeout) {
      this.timeouts.delete(unregisterToken.cleanupToken);
      clearTimeout(timeout);
    }
  }
  reset() {
    if (this.timeouts) {
      this.timeouts.forEach((value, key2) => {
        this.unregister({
          cleanupToken: key2
        });
      });
      this.timeouts = void 0;
    }
  }
};

// node_modules/@mui/x-tree-view/internals/utils/cleanupTracking/FinalizationRegistryBasedCleanupTracking.js
var FinalizationRegistryBasedCleanupTracking = class {
  constructor() {
    this.registry = new FinalizationRegistry((unsubscribe) => {
      if (typeof unsubscribe === "function") {
        unsubscribe();
      }
    });
  }
  register(object, unsubscribe, unregisterToken) {
    this.registry.register(object, unsubscribe, unregisterToken);
  }
  unregister(unregisterToken) {
    this.registry.unregister(unregisterToken);
  }
  // eslint-disable-next-line class-methods-use-this
  reset() {
  }
};

// node_modules/@mui/x-tree-view/internals/hooks/useInstanceEventHandler.js
var ObjectToBeRetainedByReact = class {
};
function createUseInstanceEventHandler(registryContainer2) {
  let cleanupTokensCounter = 0;
  return function useInstanceEventHandler2(instance, eventName, handler) {
    if (registryContainer2.registry === null) {
      registryContainer2.registry = typeof FinalizationRegistry !== "undefined" ? new FinalizationRegistryBasedCleanupTracking() : new TimerBasedCleanupTracking();
    }
    const [objectRetainedByReact] = React31.useState(new ObjectToBeRetainedByReact());
    const subscription = React31.useRef(null);
    const handlerRef = React31.useRef();
    handlerRef.current = handler;
    const cleanupTokenRef = React31.useRef(null);
    if (!subscription.current && handlerRef.current) {
      const enhancedHandler = (params, event) => {
        var _a;
        if (!event.defaultMuiPrevented) {
          (_a = handlerRef.current) == null ? void 0 : _a.call(handlerRef, params, event);
        }
      };
      subscription.current = instance.$$subscribeEvent(eventName, enhancedHandler);
      cleanupTokensCounter += 1;
      cleanupTokenRef.current = {
        cleanupToken: cleanupTokensCounter
      };
      registryContainer2.registry.register(
        objectRetainedByReact,
        // The callback below will be called once this reference stops being retained
        () => {
          var _a;
          (_a = subscription.current) == null ? void 0 : _a.call(subscription);
          subscription.current = null;
          cleanupTokenRef.current = null;
        },
        cleanupTokenRef.current
      );
    } else if (!handlerRef.current && subscription.current) {
      subscription.current();
      subscription.current = null;
      if (cleanupTokenRef.current) {
        registryContainer2.registry.unregister(cleanupTokenRef.current);
        cleanupTokenRef.current = null;
      }
    }
    React31.useEffect(() => {
      if (!subscription.current && handlerRef.current) {
        const enhancedHandler = (params, event) => {
          var _a;
          if (!event.defaultMuiPrevented) {
            (_a = handlerRef.current) == null ? void 0 : _a.call(handlerRef, params, event);
          }
        };
        subscription.current = instance.$$subscribeEvent(eventName, enhancedHandler);
      }
      if (cleanupTokenRef.current && registryContainer2.registry) {
        registryContainer2.registry.unregister(cleanupTokenRef.current);
        cleanupTokenRef.current = null;
      }
      return () => {
        var _a;
        (_a = subscription.current) == null ? void 0 : _a.call(subscription);
        subscription.current = null;
      };
    }, [instance, eventName]);
  };
}
var registryContainer = {
  registry: null
};
var useInstanceEventHandler = createUseInstanceEventHandler(registryContainer);

// node_modules/@mui/x-tree-view/internals/utils/utils.js
var getActiveElement = (root2 = document) => {
  const activeEl = root2.activeElement;
  if (!activeEl) {
    return null;
  }
  if (activeEl.shadowRoot) {
    return getActiveElement(activeEl.shadowRoot);
  }
  return activeEl;
};
function escapeOperandAttributeSelector(operand) {
  return operand.replace(/["\\]/g, "\\$&");
}

// node_modules/@mui/x-tree-view/internals/plugins/useTreeViewFocus/useTreeViewFocus.js
var useDefaultFocusableItemId = (instance, selectedItems) => {
  let tabbableItemId = convertSelectedItemsToArray(selectedItems).find((itemId) => {
    if (!instance.isItemNavigable(itemId)) {
      return false;
    }
    const itemMeta = instance.getItemMeta(itemId);
    return itemMeta && (itemMeta.parentId == null || instance.isItemExpanded(itemMeta.parentId));
  });
  if (tabbableItemId == null) {
    tabbableItemId = getFirstNavigableItem(instance);
  }
  return tabbableItemId;
};
var useTreeViewFocus = ({
  instance,
  params,
  state,
  setState,
  models,
  rootRef
}) => {
  const defaultFocusableItemId = useDefaultFocusableItemId(instance, models.selectedItems.value);
  const setFocusedItemId = useEventCallback_default((itemId) => {
    const cleanItemId = typeof itemId === "function" ? itemId(state.focusedItemId) : itemId;
    if (state.focusedItemId !== cleanItemId) {
      setState((prevState) => _extends({}, prevState, {
        focusedItemId: cleanItemId
      }));
    }
  });
  const isTreeViewFocused = React33.useCallback(() => !!rootRef.current && rootRef.current.contains(getActiveElement(ownerDocument(rootRef.current))), [rootRef]);
  const isItemFocused = React33.useCallback((itemId) => state.focusedItemId === itemId && isTreeViewFocused(), [state.focusedItemId, isTreeViewFocused]);
  const isItemVisible = (itemId) => {
    const itemMeta = instance.getItemMeta(itemId);
    return itemMeta && (itemMeta.parentId == null || instance.isItemExpanded(itemMeta.parentId));
  };
  const innerFocusItem = (event, itemId) => {
    const itemElement = instance.getItemDOMElement(itemId);
    if (itemElement) {
      itemElement.focus();
    }
    setFocusedItemId(itemId);
    if (params.onItemFocus) {
      params.onItemFocus(event, itemId);
    }
  };
  const focusItem = useEventCallback_default((event, itemId) => {
    if (isItemVisible(itemId)) {
      innerFocusItem(event, itemId);
    }
  });
  const removeFocusedItem = useEventCallback_default(() => {
    if (state.focusedItemId == null) {
      return;
    }
    const itemMeta = instance.getItemMeta(state.focusedItemId);
    if (itemMeta) {
      const itemElement = instance.getItemDOMElement(state.focusedItemId);
      if (itemElement) {
        itemElement.blur();
      }
    }
    setFocusedItemId(null);
  });
  const canItemBeTabbed = (itemId) => itemId === defaultFocusableItemId;
  useInstanceEventHandler(instance, "removeItem", ({
    id
  }) => {
    if (state.focusedItemId === id) {
      innerFocusItem(null, defaultFocusableItemId);
    }
  });
  const createRootHandleFocus = (otherHandlers) => (event) => {
    var _a;
    (_a = otherHandlers.onFocus) == null ? void 0 : _a.call(otherHandlers, event);
    if (event.defaultMuiPrevented) {
      return;
    }
    if (event.target === event.currentTarget) {
      innerFocusItem(event, defaultFocusableItemId);
    }
  };
  return {
    getRootProps: (otherHandlers) => ({
      onFocus: createRootHandleFocus(otherHandlers)
    }),
    publicAPI: {
      focusItem
    },
    instance: {
      isItemFocused,
      canItemBeTabbed,
      focusItem,
      removeFocusedItem
    }
  };
};
useTreeViewFocus.getInitialState = () => ({
  focusedItemId: null
});
useTreeViewFocus.params = {
  onItemFocus: true
};

// node_modules/@mui/x-tree-view/internals/plugins/useTreeViewKeyboardNavigation/useTreeViewKeyboardNavigation.js
var React36 = __toESM(require_react());

// node_modules/@mui/x-tree-view/internals/utils/plugins.js
var hasPlugin = (instance, plugin) => {
  const plugins = instance.getAvailablePlugins();
  return plugins.has(plugin);
};

// node_modules/@mui/x-tree-view/internals/plugins/useTreeViewLabel/useTreeViewLabel.js
var React35 = __toESM(require_react());

// node_modules/@mui/x-tree-view/internals/plugins/useTreeViewLabel/useTreeViewLabel.itemPlugin.js
var React34 = __toESM(require_react());
var useTreeViewLabelItemPlugin = ({
  props: props2
}) => {
  const {
    instance
  } = useTreeViewContext();
  const {
    label,
    itemId
  } = props2;
  const [labelInputValue, setLabelInputValue] = React34.useState(label);
  const isItemBeingEdited = instance.isItemBeingEdited(itemId);
  React34.useEffect(() => {
    if (!isItemBeingEdited) {
      setLabelInputValue(label);
    }
  }, [isItemBeingEdited, label]);
  return {
    propsEnhancers: {
      labelInput: ({
        externalEventHandlers,
        interactions
      }) => {
        const editable = instance.isItemEditable(itemId);
        if (!editable) {
          return {};
        }
        const handleKeydown = (event) => {
          var _a;
          (_a = externalEventHandlers.onKeyDown) == null ? void 0 : _a.call(externalEventHandlers, event);
          if (event.defaultMuiPrevented) {
            return;
          }
          const target = event.target;
          if (event.key === "Enter" && target.value) {
            interactions.handleSaveItemLabel(event, target.value);
          } else if (event.key === "Escape") {
            interactions.handleCancelItemLabelEditing(event);
          }
        };
        const handleBlur = (event) => {
          var _a;
          (_a = externalEventHandlers.onBlur) == null ? void 0 : _a.call(externalEventHandlers, event);
          if (event.defaultMuiPrevented) {
            return;
          }
          if (event.target.value) {
            interactions.handleSaveItemLabel(event, event.target.value);
          }
        };
        const handleInputChange = (event) => {
          var _a;
          (_a = externalEventHandlers.onChange) == null ? void 0 : _a.call(externalEventHandlers, event);
          setLabelInputValue(event.target.value);
        };
        return {
          value: labelInputValue ?? "",
          "data-element": "labelInput",
          onChange: handleInputChange,
          onKeyDown: handleKeydown,
          onBlur: handleBlur,
          autoFocus: true,
          type: "text"
        };
      }
    }
  };
};

// node_modules/@mui/x-tree-view/internals/plugins/useTreeViewLabel/useTreeViewLabel.js
var useTreeViewLabel = ({
  instance,
  state,
  setState,
  params
}) => {
  const editedItemRef = React35.useRef(state.editedItemId);
  const isItemBeingEditedRef = (itemId) => editedItemRef.current === itemId;
  const setEditedItemId = (editedItemId) => {
    setState((prevState) => _extends({}, prevState, {
      editedItemId
    }));
    editedItemRef.current = editedItemId;
  };
  const isItemBeingEdited = (itemId) => itemId === state.editedItemId;
  const isTreeViewEditable = Boolean(params.isItemEditable);
  const isItemEditable = (itemId) => {
    if (itemId == null || !isTreeViewEditable) {
      return false;
    }
    const item = instance.getItem(itemId);
    if (!item) {
      return false;
    }
    return typeof params.isItemEditable === "function" ? params.isItemEditable(item) : Boolean(params.isItemEditable);
  };
  const updateItemLabel = (itemId, label) => {
    if (!label) {
      throw new Error(["MUI X: The Tree View component requires all items to have a `label` property.", "The label of an item cannot be empty.", itemId].join("\n"));
    }
    setState((prevState) => {
      const item = prevState.items.itemMetaMap[itemId];
      if (item.label !== label) {
        return _extends({}, prevState, {
          items: _extends({}, prevState.items, {
            itemMetaMap: _extends({}, prevState.items.itemMetaMap, {
              [itemId]: _extends({}, item, {
                label
              })
            })
          })
        });
      }
      return prevState;
    });
    if (params.onItemLabelChange) {
      params.onItemLabelChange(itemId, label);
    }
  };
  return {
    instance: {
      setEditedItemId,
      isItemBeingEdited,
      updateItemLabel,
      isItemEditable,
      isTreeViewEditable,
      isItemBeingEditedRef
    },
    publicAPI: {
      updateItemLabel
    }
  };
};
useTreeViewLabel.itemPlugin = useTreeViewLabelItemPlugin;
useTreeViewLabel.getDefaultizedParams = ({
  params,
  experimentalFeatures
}) => {
  const canUseFeature = experimentalFeatures == null ? void 0 : experimentalFeatures.labelEditing;
  if (true) {
    if (params.isItemEditable && !canUseFeature) {
      warnOnce(["MUI X: The label editing feature requires the `labelEditing` experimental feature to be enabled.", "You can do it by passing `experimentalFeatures={{ labelEditing: true}}` to the Rich Tree View Pro component.", "Check the documentation for more details: https://mui.com/x/react-tree-view/rich-tree-view/editing/"]);
    }
  }
  return _extends({}, params, {
    isItemEditable: canUseFeature ? params.isItemEditable ?? false : false
  });
};
useTreeViewLabel.getInitialState = () => ({
  editedItemId: null
});
useTreeViewLabel.params = {
  onItemLabelChange: true,
  isItemEditable: true
};

// node_modules/@mui/x-tree-view/internals/plugins/useTreeViewKeyboardNavigation/useTreeViewKeyboardNavigation.js
function isPrintableKey(string) {
  return !!string && string.length === 1 && !!string.match(/\S/);
}
var useTreeViewKeyboardNavigation = ({
  instance,
  params,
  state
}) => {
  const isRtl = useRtl();
  const firstCharMap = React36.useRef({});
  const updateFirstCharMap = useEventCallback_default((callback) => {
    firstCharMap.current = callback(firstCharMap.current);
  });
  React36.useEffect(() => {
    if (instance.areItemUpdatesPrevented()) {
      return;
    }
    const newFirstCharMap = {};
    const processItem = (item) => {
      newFirstCharMap[item.id] = item.label.substring(0, 1).toLowerCase();
    };
    Object.values(state.items.itemMetaMap).forEach(processItem);
    firstCharMap.current = newFirstCharMap;
  }, [state.items.itemMetaMap, params.getItemId, instance]);
  const getFirstMatchingItem = (itemId, query) => {
    const cleanQuery = query.toLowerCase();
    const getNextItem = (itemIdToCheck) => {
      const nextItemId = getNextNavigableItem(instance, itemIdToCheck);
      if (nextItemId === null) {
        return getFirstNavigableItem(instance);
      }
      return nextItemId;
    };
    let matchingItemId = null;
    let currentItemId = getNextItem(itemId);
    const checkedItems = {};
    while (matchingItemId == null && !checkedItems[currentItemId]) {
      if (firstCharMap.current[currentItemId] === cleanQuery) {
        matchingItemId = currentItemId;
      } else {
        checkedItems[currentItemId] = true;
        currentItemId = getNextItem(currentItemId);
      }
    }
    return matchingItemId;
  };
  const canToggleItemSelection = (itemId) => !params.disableSelection && !instance.isItemDisabled(itemId);
  const canToggleItemExpansion = (itemId) => {
    return !instance.isItemDisabled(itemId) && instance.isItemExpandable(itemId);
  };
  const handleItemKeyDown = (event, itemId) => {
    if (event.defaultMuiPrevented) {
      return;
    }
    if (event.altKey || isTargetInDescendants(event.target, event.currentTarget)) {
      return;
    }
    const ctrlPressed = event.ctrlKey || event.metaKey;
    const key2 = event.key;
    switch (true) {
      case (key2 === " " && canToggleItemSelection(itemId)): {
        event.preventDefault();
        if (params.multiSelect && event.shiftKey) {
          instance.expandSelectionRange(event, itemId);
        } else {
          instance.selectItem({
            event,
            itemId,
            keepExistingSelection: params.multiSelect,
            shouldBeSelected: params.multiSelect ? void 0 : true
          });
        }
        break;
      }
      case key2 === "Enter": {
        if (hasPlugin(instance, useTreeViewLabel) && instance.isItemEditable(itemId) && !instance.isItemBeingEdited(itemId)) {
          instance.setEditedItemId(itemId);
        } else if (canToggleItemExpansion(itemId)) {
          instance.toggleItemExpansion(event, itemId);
          event.preventDefault();
        } else if (canToggleItemSelection(itemId)) {
          if (params.multiSelect) {
            event.preventDefault();
            instance.selectItem({
              event,
              itemId,
              keepExistingSelection: true
            });
          } else if (!instance.isItemSelected(itemId)) {
            instance.selectItem({
              event,
              itemId
            });
            event.preventDefault();
          }
        }
        break;
      }
      case key2 === "ArrowDown": {
        const nextItem = getNextNavigableItem(instance, itemId);
        if (nextItem) {
          event.preventDefault();
          instance.focusItem(event, nextItem);
          if (params.multiSelect && event.shiftKey && canToggleItemSelection(nextItem)) {
            instance.selectItemFromArrowNavigation(event, itemId, nextItem);
          }
        }
        break;
      }
      case key2 === "ArrowUp": {
        const previousItem = getPreviousNavigableItem(instance, itemId);
        if (previousItem) {
          event.preventDefault();
          instance.focusItem(event, previousItem);
          if (params.multiSelect && event.shiftKey && canToggleItemSelection(previousItem)) {
            instance.selectItemFromArrowNavigation(event, itemId, previousItem);
          }
        }
        break;
      }
      case (key2 === "ArrowRight" && !isRtl || key2 === "ArrowLeft" && isRtl): {
        if (ctrlPressed) {
          return;
        }
        if (instance.isItemExpanded(itemId)) {
          const nextItemId = getNextNavigableItem(instance, itemId);
          if (nextItemId) {
            instance.focusItem(event, nextItemId);
            event.preventDefault();
          }
        } else if (canToggleItemExpansion(itemId)) {
          instance.toggleItemExpansion(event, itemId);
          event.preventDefault();
        }
        break;
      }
      case (key2 === "ArrowLeft" && !isRtl || key2 === "ArrowRight" && isRtl): {
        if (ctrlPressed) {
          return;
        }
        if (canToggleItemExpansion(itemId) && instance.isItemExpanded(itemId)) {
          instance.toggleItemExpansion(event, itemId);
          event.preventDefault();
        } else {
          const parent = instance.getItemMeta(itemId).parentId;
          if (parent) {
            instance.focusItem(event, parent);
            event.preventDefault();
          }
        }
        break;
      }
      case key2 === "Home": {
        if (canToggleItemSelection(itemId) && params.multiSelect && ctrlPressed && event.shiftKey) {
          instance.selectRangeFromStartToItem(event, itemId);
        } else {
          instance.focusItem(event, getFirstNavigableItem(instance));
        }
        event.preventDefault();
        break;
      }
      case key2 === "End": {
        if (canToggleItemSelection(itemId) && params.multiSelect && ctrlPressed && event.shiftKey) {
          instance.selectRangeFromItemToEnd(event, itemId);
        } else {
          instance.focusItem(event, getLastNavigableItem(instance));
        }
        event.preventDefault();
        break;
      }
      case key2 === "*": {
        instance.expandAllSiblings(event, itemId);
        event.preventDefault();
        break;
      }
      case (String.fromCharCode(event.keyCode) === "A" && ctrlPressed && params.multiSelect && !params.disableSelection): {
        instance.selectAllNavigableItems(event);
        event.preventDefault();
        break;
      }
      case (!ctrlPressed && !event.shiftKey && isPrintableKey(key2)): {
        const matchingItem = getFirstMatchingItem(itemId, key2);
        if (matchingItem != null) {
          instance.focusItem(event, matchingItem);
          event.preventDefault();
        }
        break;
      }
    }
  };
  return {
    instance: {
      updateFirstCharMap,
      handleItemKeyDown
    }
  };
};
useTreeViewKeyboardNavigation.params = {};

// node_modules/@mui/x-tree-view/internals/plugins/useTreeViewIcons/useTreeViewIcons.js
var useTreeViewIcons = ({
  slots,
  slotProps
}) => {
  return {
    contextValue: {
      icons: {
        slots: {
          collapseIcon: slots.collapseIcon,
          expandIcon: slots.expandIcon,
          endIcon: slots.endIcon
        },
        slotProps: {
          collapseIcon: slotProps.collapseIcon,
          expandIcon: slotProps.expandIcon,
          endIcon: slotProps.endIcon
        }
      }
    }
  };
};
useTreeViewIcons.params = {};

// node_modules/@mui/x-tree-view/internals/plugins/useTreeViewJSXItems/useTreeViewJSXItems.js
var React38 = __toESM(require_react());

// node_modules/@mui/x-tree-view/internals/TreeViewProvider/TreeViewChildrenItemProvider.js
var React37 = __toESM(require_react());
var import_prop_types = __toESM(require_prop_types());
var import_jsx_runtime64 = __toESM(require_jsx_runtime());
var TreeViewChildrenItemContext = React37.createContext(null);
if (true) {
  TreeViewChildrenItemContext.displayName = "TreeViewChildrenItemContext";
}
function TreeViewChildrenItemProvider(props2) {
  const {
    children,
    itemId = null
  } = props2;
  const {
    instance,
    treeId,
    rootRef
  } = useTreeViewContext();
  const childrenIdAttrToIdRef = React37.useRef(/* @__PURE__ */ new Map());
  React37.useEffect(() => {
    if (!rootRef.current) {
      return;
    }
    let idAttr = null;
    if (itemId == null) {
      idAttr = rootRef.current.id;
    } else {
      const itemMeta = instance.getItemMeta(itemId);
      if (itemMeta !== void 0) {
        idAttr = generateTreeItemIdAttribute({
          itemId,
          treeId,
          id: itemMeta.idAttribute
        });
      }
    }
    if (idAttr == null) {
      return;
    }
    const previousChildrenIds = instance.getItemOrderedChildrenIds(itemId ?? null) ?? [];
    const escapedIdAttr = escapeOperandAttributeSelector(idAttr);
    const childrenElements = rootRef.current.querySelectorAll(`${itemId == null ? "" : `*[id="${escapedIdAttr}"] `}[role="treeitem"]:not(*[id="${escapedIdAttr}"] [role="treeitem"] [role="treeitem"])`);
    const childrenIds = Array.from(childrenElements).map((child) => childrenIdAttrToIdRef.current.get(child.id));
    const hasChanged = childrenIds.length !== previousChildrenIds.length || childrenIds.some((childId, index) => childId !== previousChildrenIds[index]);
    if (hasChanged) {
      instance.setJSXItemsOrderedChildrenIds(itemId ?? null, childrenIds);
    }
  });
  const value = React37.useMemo(() => ({
    registerChild: (childIdAttribute, childItemId) => childrenIdAttrToIdRef.current.set(childIdAttribute, childItemId),
    unregisterChild: (childIdAttribute) => childrenIdAttrToIdRef.current.delete(childIdAttribute),
    parentId: itemId
  }), [itemId]);
  return (0, import_jsx_runtime64.jsx)(TreeViewChildrenItemContext.Provider, {
    value,
    children
  });
}
true ? TreeViewChildrenItemProvider.propTypes = {
  children: import_prop_types.default.node,
  id: import_prop_types.default.string
} : void 0;

// node_modules/@mui/x-tree-view/internals/plugins/useTreeViewJSXItems/useTreeViewJSXItems.js
var import_jsx_runtime65 = __toESM(require_jsx_runtime());
var useTreeViewJSXItems = ({
  instance,
  setState
}) => {
  instance.preventItemUpdates();
  const insertJSXItem = useEventCallback_default((item) => {
    setState((prevState) => {
      if (prevState.items.itemMetaMap[item.id] != null) {
        throw new Error(["MUI X: The Tree View component requires all items to have a unique `id` property.", "Alternatively, you can use the `getItemId` prop to specify a custom id for each item.", `Two items were provided with the same id in the \`items\` prop: "${item.id}"`].join("\n"));
      }
      return _extends({}, prevState, {
        items: _extends({}, prevState.items, {
          itemMetaMap: _extends({}, prevState.items.itemMetaMap, {
            [item.id]: item
          }),
          // For Simple Tree View, we don't have a proper `item` object, so we create a very basic one.
          itemMap: _extends({}, prevState.items.itemMap, {
            [item.id]: {
              id: item.id,
              label: item.label
            }
          })
        })
      });
    });
    return () => {
      setState((prevState) => {
        const newItemMetaMap = _extends({}, prevState.items.itemMetaMap);
        const newItemMap = _extends({}, prevState.items.itemMap);
        delete newItemMetaMap[item.id];
        delete newItemMap[item.id];
        return _extends({}, prevState, {
          items: _extends({}, prevState.items, {
            itemMetaMap: newItemMetaMap,
            itemMap: newItemMap
          })
        });
      });
      publishTreeViewEvent(instance, "removeItem", {
        id: item.id
      });
    };
  });
  const setJSXItemsOrderedChildrenIds = (parentId, orderedChildrenIds) => {
    const parentIdWithDefault = parentId ?? TREE_VIEW_ROOT_PARENT_ID;
    setState((prevState) => _extends({}, prevState, {
      items: _extends({}, prevState.items, {
        itemOrderedChildrenIds: _extends({}, prevState.items.itemOrderedChildrenIds, {
          [parentIdWithDefault]: orderedChildrenIds
        }),
        itemChildrenIndexes: _extends({}, prevState.items.itemChildrenIndexes, {
          [parentIdWithDefault]: buildSiblingIndexes(orderedChildrenIds)
        })
      })
    }));
  };
  const mapFirstCharFromJSX = useEventCallback_default((itemId, firstChar) => {
    instance.updateFirstCharMap((firstCharMap) => {
      firstCharMap[itemId] = firstChar;
      return firstCharMap;
    });
    return () => {
      instance.updateFirstCharMap((firstCharMap) => {
        const newMap = _extends({}, firstCharMap);
        delete newMap[itemId];
        return newMap;
      });
    };
  });
  return {
    instance: {
      insertJSXItem,
      setJSXItemsOrderedChildrenIds,
      mapFirstCharFromJSX
    }
  };
};
var isItemExpandable = (reactChildren) => {
  if (Array.isArray(reactChildren)) {
    return reactChildren.length > 0 && reactChildren.some(isItemExpandable);
  }
  return Boolean(reactChildren);
};
var useTreeViewJSXItemsItemPlugin = ({
  props: props2,
  rootRef,
  contentRef
}) => {
  const {
    instance,
    treeId
  } = useTreeViewContext();
  const {
    children,
    disabled = false,
    label,
    itemId,
    id
  } = props2;
  const parentContext = React38.useContext(TreeViewChildrenItemContext);
  if (parentContext == null) {
    throw new Error(["MUI X: Could not find the Tree View Children Item context.", "It looks like you rendered your component outside of a SimpleTreeView parent component.", "This can also happen if you are bundling multiple versions of the Tree View."].join("\n"));
  }
  const {
    registerChild,
    unregisterChild,
    parentId
  } = parentContext;
  const expandable = isItemExpandable(children);
  const pluginContentRef = React38.useRef(null);
  const handleContentRef = useForkRef(pluginContentRef, contentRef);
  useEnhancedEffect_default(() => {
    const idAttribute = generateTreeItemIdAttribute({
      itemId,
      treeId,
      id
    });
    registerChild(idAttribute, itemId);
    return () => {
      unregisterChild(idAttribute);
    };
  }, [registerChild, unregisterChild, itemId, id, treeId]);
  React38.useEffect(() => {
    return instance.insertJSXItem({
      id: itemId,
      idAttribute: id,
      parentId,
      expandable,
      disabled
    });
  }, [instance, parentId, itemId, expandable, disabled, id]);
  React38.useEffect(() => {
    var _a;
    if (label) {
      return instance.mapFirstCharFromJSX(itemId, (((_a = pluginContentRef.current) == null ? void 0 : _a.textContent) ?? "").substring(0, 1).toLowerCase());
    }
    return void 0;
  }, [instance, itemId, label]);
  return {
    contentRef: handleContentRef,
    rootRef
  };
};
useTreeViewJSXItems.itemPlugin = useTreeViewJSXItemsItemPlugin;
useTreeViewJSXItems.wrapItem = ({
  children,
  itemId
}) => {
  const depthContext = React38.useContext(TreeViewItemDepthContext);
  return (0, import_jsx_runtime65.jsx)(TreeViewChildrenItemProvider, {
    itemId,
    children: (0, import_jsx_runtime65.jsx)(TreeViewItemDepthContext.Provider, {
      value: depthContext + 1,
      children
    })
  });
};
useTreeViewJSXItems.wrapRoot = ({
  children
}) => (0, import_jsx_runtime65.jsx)(TreeViewChildrenItemProvider, {
  children: (0, import_jsx_runtime65.jsx)(TreeViewItemDepthContext.Provider, {
    value: 0,
    children
  })
});
useTreeViewJSXItems.params = {};

// node_modules/@mui/x-tree-view/SimpleTreeView/SimpleTreeView.plugins.js
var SIMPLE_TREE_VIEW_PLUGINS = [useTreeViewItems, useTreeViewExpansion, useTreeViewSelection, useTreeViewFocus, useTreeViewKeyboardNavigation, useTreeViewIcons, useTreeViewJSXItems];

// node_modules/@mui/x-tree-view/SimpleTreeView/SimpleTreeView.js
var import_jsx_runtime66 = __toESM(require_jsx_runtime());
var useThemeProps2 = createUseThemeProps("MuiSimpleTreeView");
var useUtilityClasses = (ownerState) => {
  const {
    classes: classes12
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getSimpleTreeViewUtilityClass, classes12);
};
var SimpleTreeViewRoot = styled_default("ul", {
  name: "MuiSimpleTreeView",
  slot: "Root",
  overridesResolver: (props2, styles) => styles.root
})({
  padding: 0,
  margin: 0,
  listStyle: "none",
  outline: 0,
  position: "relative"
});
var EMPTY_ITEMS = [];
var SimpleTreeView = React39.forwardRef(function SimpleTreeView2(inProps, ref) {
  const props2 = useThemeProps2({
    props: inProps,
    name: "MuiSimpleTreeView"
  });
  const ownerState = props2;
  if (true) {
    if (props2.items != null) {
      warnOnce(["MUI X: The Simple Tree View component does not support the `items` prop.", "If you want to add items, you need to pass them as JSX children.", "Check the documentation for more details: https://mui.com/x/react-tree-view/simple-tree-view/items/."]);
    }
  }
  const {
    getRootProps,
    contextValue
  } = useTreeView({
    plugins: SIMPLE_TREE_VIEW_PLUGINS,
    rootRef: ref,
    props: _extends({}, props2, {
      items: EMPTY_ITEMS
    })
  });
  const {
    slots,
    slotProps
  } = props2;
  const classes12 = useUtilityClasses(props2);
  const Root2 = (slots == null ? void 0 : slots.root) ?? SimpleTreeViewRoot;
  const rootProps = useSlotProps_default({
    elementType: Root2,
    externalSlotProps: slotProps == null ? void 0 : slotProps.root,
    className: classes12.root,
    getSlotProps: getRootProps,
    ownerState
  });
  return (0, import_jsx_runtime66.jsx)(TreeViewProvider, {
    value: contextValue,
    children: (0, import_jsx_runtime66.jsx)(Root2, _extends({}, rootProps))
  });
});
true ? SimpleTreeView.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The ref object that allows Tree View manipulation. Can be instantiated with `useTreeViewApiRef()`.
   */
  apiRef: import_prop_types2.default.shape({
    current: import_prop_types2.default.shape({
      focusItem: import_prop_types2.default.func.isRequired,
      getItem: import_prop_types2.default.func.isRequired,
      getItemDOMElement: import_prop_types2.default.func.isRequired,
      getItemOrderedChildrenIds: import_prop_types2.default.func.isRequired,
      getItemTree: import_prop_types2.default.func.isRequired,
      selectItem: import_prop_types2.default.func.isRequired,
      setItemExpansion: import_prop_types2.default.func.isRequired
    })
  }),
  /**
   * If `true`, the Tree View renders a checkbox at the left of its label that allows selecting it.
   * @default false
   */
  checkboxSelection: import_prop_types2.default.bool,
  /**
   * The content of the component.
   */
  children: import_prop_types2.default.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types2.default.object,
  className: import_prop_types2.default.string,
  /**
   * Expanded item ids.
   * Used when the item's expansion is not controlled.
   * @default []
   */
  defaultExpandedItems: import_prop_types2.default.arrayOf(import_prop_types2.default.string),
  /**
   * Selected item ids. (Uncontrolled)
   * When `multiSelect` is true this takes an array of strings; when false (default) a string.
   * @default []
   */
  defaultSelectedItems: import_prop_types2.default.any,
  /**
   * If `true`, will allow focus on disabled items.
   * @default false
   */
  disabledItemsFocusable: import_prop_types2.default.bool,
  /**
   * If `true` selection is disabled.
   * @default false
   */
  disableSelection: import_prop_types2.default.bool,
  /**
   * Expanded item ids.
   * Used when the item's expansion is controlled.
   */
  expandedItems: import_prop_types2.default.arrayOf(import_prop_types2.default.string),
  /**
   * The slot that triggers the item's expansion when clicked.
   * @default 'content'
   */
  expansionTrigger: import_prop_types2.default.oneOf(["content", "iconContainer"]),
  /**
   * Unstable features, breaking changes might be introduced.
   * For each feature, if the flag is not explicitly set to `true`,
   * the feature will be fully disabled and any property / method call will not have any effect.
   */
  experimentalFeatures: import_prop_types2.default.shape({
    indentationAtItemLevel: import_prop_types2.default.bool
  }),
  /**
   * This prop is used to help implement the accessibility logic.
   * If you don't provide this prop. It falls back to a randomly generated id.
   */
  id: import_prop_types2.default.string,
  /**
   * Horizontal indentation between an item and its children.
   * Examples: 24, "24px", "2rem", "2em".
   * @default 12px
   */
  itemChildrenIndentation: import_prop_types2.default.oneOfType([import_prop_types2.default.number, import_prop_types2.default.string]),
  /**
   * If `true`, `ctrl` and `shift` will trigger multiselect.
   * @default false
   */
  multiSelect: import_prop_types2.default.bool,
  /**
   * Callback fired when Tree Items are expanded/collapsed.
   * @param {React.SyntheticEvent} event The DOM event that triggered the change.
   * @param {array} itemIds The ids of the expanded items.
   */
  onExpandedItemsChange: import_prop_types2.default.func,
  /**
   * Callback fired when the `content` slot of a given Tree Item is clicked.
   * @param {React.MouseEvent} event The DOM event that triggered the change.
   * @param {string} itemId The id of the focused item.
   */
  onItemClick: import_prop_types2.default.func,
  /**
   * Callback fired when a Tree Item is expanded or collapsed.
   * @param {React.SyntheticEvent} event The DOM event that triggered the change.
   * @param {array} itemId The itemId of the modified item.
   * @param {array} isExpanded `true` if the item has just been expanded, `false` if it has just been collapsed.
   */
  onItemExpansionToggle: import_prop_types2.default.func,
  /**
   * Callback fired when a given Tree Item is focused.
   * @param {React.SyntheticEvent | null} event The DOM event that triggered the change. **Warning**: This is a generic event not a focus event.
   * @param {string} itemId The id of the focused item.
   */
  onItemFocus: import_prop_types2.default.func,
  /**
   * Callback fired when a Tree Item is selected or deselected.
   * @param {React.SyntheticEvent} event The DOM event that triggered the change.
   * @param {array} itemId The itemId of the modified item.
   * @param {array} isSelected `true` if the item has just been selected, `false` if it has just been deselected.
   */
  onItemSelectionToggle: import_prop_types2.default.func,
  /**
   * Callback fired when Tree Items are selected/deselected.
   * @param {React.SyntheticEvent} event The DOM event that triggered the change.
   * @param {string[] | string} itemIds The ids of the selected items.
   * When `multiSelect` is `true`, this is an array of strings; when false (default) a string.
   */
  onSelectedItemsChange: import_prop_types2.default.func,
  /**
   * Selected item ids. (Controlled)
   * When `multiSelect` is true this takes an array of strings; when false (default) a string.
   */
  selectedItems: import_prop_types2.default.any,
  /**
   * The props used for each component slot.
   */
  slotProps: import_prop_types2.default.object,
  /**
   * Overridable component slots.
   */
  slots: import_prop_types2.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types2.default.oneOfType([import_prop_types2.default.arrayOf(import_prop_types2.default.oneOfType([import_prop_types2.default.func, import_prop_types2.default.object, import_prop_types2.default.bool])), import_prop_types2.default.func, import_prop_types2.default.object])
} : void 0;

// node_modules/@mui/x-tree-view/TreeView/TreeView.js
var import_jsx_runtime67 = __toESM(require_jsx_runtime());
var useThemeProps3 = createUseThemeProps("MuiTreeView");
var useUtilityClasses2 = (ownerState) => {
  const {
    classes: classes12
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getTreeViewUtilityClass, classes12);
};
var TreeViewRoot = styled_default(SimpleTreeViewRoot, {
  name: "MuiTreeView",
  slot: "Root",
  overridesResolver: (props2, styles) => styles.root
})({});
var warnedOnce = false;
var warn = () => {
  if (!warnedOnce) {
    console.warn(["MUI X: The TreeView component was renamed SimpleTreeView.", "The component with the old naming will be removed in the version v8.0.0.", "", "You should use `import { SimpleTreeView } from '@mui/x-tree-view'`", "or `import { SimpleTreeView } from '@mui/x-tree-view/TreeView'`"].join("\n"));
    warnedOnce = true;
  }
};
var TreeView2 = React40.forwardRef(function TreeView3(inProps, ref) {
  if (true) {
    warn();
  }
  const props2 = useThemeProps3({
    props: inProps,
    name: "MuiTreeView"
  });
  const classes12 = useUtilityClasses2(props2);
  return (0, import_jsx_runtime67.jsx)(SimpleTreeView, _extends({}, props2, {
    ref,
    classes: classes12,
    slots: _extends({
      root: TreeViewRoot
    }, props2.slots)
  }));
});
true ? TreeView2.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The ref object that allows Tree View manipulation. Can be instantiated with `useTreeViewApiRef()`.
   */
  apiRef: import_prop_types3.default.shape({
    current: import_prop_types3.default.shape({
      focusItem: import_prop_types3.default.func.isRequired,
      getItem: import_prop_types3.default.func.isRequired,
      getItemDOMElement: import_prop_types3.default.func.isRequired,
      getItemOrderedChildrenIds: import_prop_types3.default.func.isRequired,
      getItemTree: import_prop_types3.default.func.isRequired,
      selectItem: import_prop_types3.default.func.isRequired,
      setItemExpansion: import_prop_types3.default.func.isRequired
    })
  }),
  /**
   * If `true`, the Tree View renders a checkbox at the left of its label that allows selecting it.
   * @default false
   */
  checkboxSelection: import_prop_types3.default.bool,
  /**
   * The content of the component.
   */
  children: import_prop_types3.default.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types3.default.object,
  className: import_prop_types3.default.string,
  /**
   * Expanded item ids.
   * Used when the item's expansion is not controlled.
   * @default []
   */
  defaultExpandedItems: import_prop_types3.default.arrayOf(import_prop_types3.default.string),
  /**
   * Selected item ids. (Uncontrolled)
   * When `multiSelect` is true this takes an array of strings; when false (default) a string.
   * @default []
   */
  defaultSelectedItems: import_prop_types3.default.any,
  /**
   * If `true`, will allow focus on disabled items.
   * @default false
   */
  disabledItemsFocusable: import_prop_types3.default.bool,
  /**
   * If `true` selection is disabled.
   * @default false
   */
  disableSelection: import_prop_types3.default.bool,
  /**
   * Expanded item ids.
   * Used when the item's expansion is controlled.
   */
  expandedItems: import_prop_types3.default.arrayOf(import_prop_types3.default.string),
  /**
   * The slot that triggers the item's expansion when clicked.
   * @default 'content'
   */
  expansionTrigger: import_prop_types3.default.oneOf(["content", "iconContainer"]),
  /**
   * Unstable features, breaking changes might be introduced.
   * For each feature, if the flag is not explicitly set to `true`,
   * the feature will be fully disabled and any property / method call will not have any effect.
   */
  experimentalFeatures: import_prop_types3.default.shape({
    indentationAtItemLevel: import_prop_types3.default.bool
  }),
  /**
   * This prop is used to help implement the accessibility logic.
   * If you don't provide this prop. It falls back to a randomly generated id.
   */
  id: import_prop_types3.default.string,
  /**
   * Horizontal indentation between an item and its children.
   * Examples: 24, "24px", "2rem", "2em".
   * @default 12px
   */
  itemChildrenIndentation: import_prop_types3.default.oneOfType([import_prop_types3.default.number, import_prop_types3.default.string]),
  /**
   * If `true`, `ctrl` and `shift` will trigger multiselect.
   * @default false
   */
  multiSelect: import_prop_types3.default.bool,
  /**
   * Callback fired when Tree Items are expanded/collapsed.
   * @param {React.SyntheticEvent} event The DOM event that triggered the change.
   * @param {array} itemIds The ids of the expanded items.
   */
  onExpandedItemsChange: import_prop_types3.default.func,
  /**
   * Callback fired when the `content` slot of a given Tree Item is clicked.
   * @param {React.MouseEvent} event The DOM event that triggered the change.
   * @param {string} itemId The id of the focused item.
   */
  onItemClick: import_prop_types3.default.func,
  /**
   * Callback fired when a Tree Item is expanded or collapsed.
   * @param {React.SyntheticEvent} event The DOM event that triggered the change.
   * @param {array} itemId The itemId of the modified item.
   * @param {array} isExpanded `true` if the item has just been expanded, `false` if it has just been collapsed.
   */
  onItemExpansionToggle: import_prop_types3.default.func,
  /**
   * Callback fired when a given Tree Item is focused.
   * @param {React.SyntheticEvent | null} event The DOM event that triggered the change. **Warning**: This is a generic event not a focus event.
   * @param {string} itemId The id of the focused item.
   */
  onItemFocus: import_prop_types3.default.func,
  /**
   * Callback fired when a Tree Item is selected or deselected.
   * @param {React.SyntheticEvent} event The DOM event that triggered the change.
   * @param {array} itemId The itemId of the modified item.
   * @param {array} isSelected `true` if the item has just been selected, `false` if it has just been deselected.
   */
  onItemSelectionToggle: import_prop_types3.default.func,
  /**
   * Callback fired when Tree Items are selected/deselected.
   * @param {React.SyntheticEvent} event The DOM event that triggered the change.
   * @param {string[] | string} itemIds The ids of the selected items.
   * When `multiSelect` is `true`, this is an array of strings; when false (default) a string.
   */
  onSelectedItemsChange: import_prop_types3.default.func,
  /**
   * Selected item ids. (Controlled)
   * When `multiSelect` is true this takes an array of strings; when false (default) a string.
   */
  selectedItems: import_prop_types3.default.any,
  /**
   * The props used for each component slot.
   */
  slotProps: import_prop_types3.default.object,
  /**
   * Overridable component slots.
   */
  slots: import_prop_types3.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types3.default.oneOfType([import_prop_types3.default.arrayOf(import_prop_types3.default.oneOfType([import_prop_types3.default.func, import_prop_types3.default.object, import_prop_types3.default.bool])), import_prop_types3.default.func, import_prop_types3.default.object])
} : void 0;

// node_modules/@mui/x-tree-view/RichTreeView/RichTreeView.js
var React47 = __toESM(require_react());
var import_prop_types7 = __toESM(require_prop_types());

// node_modules/@mui/x-tree-view/RichTreeView/richTreeViewClasses.js
function getRichTreeViewUtilityClass(slot) {
  return generateUtilityClass("MuiRichTreeView", slot);
}
var richTreeViewClasses = generateUtilityClasses("MuiRichTreeView", ["root"]);

// node_modules/@mui/x-tree-view/RichTreeView/RichTreeView.plugins.js
var RICH_TREE_VIEW_PLUGINS = [useTreeViewItems, useTreeViewExpansion, useTreeViewSelection, useTreeViewFocus, useTreeViewKeyboardNavigation, useTreeViewIcons, useTreeViewLabel];

// node_modules/@mui/x-tree-view/internals/components/RichTreeViewItems.js
var React46 = __toESM(require_react());

// node_modules/@mui/x-tree-view/TreeItem/TreeItem.js
var React45 = __toESM(require_react());
var import_prop_types6 = __toESM(require_prop_types());

// node_modules/@mui/x-tree-view/TreeItem/TreeItemContent.js
var React43 = __toESM(require_react());
var import_prop_types4 = __toESM(require_prop_types());

// node_modules/@mui/x-tree-view/TreeItem/useTreeItemState.js
function useTreeItemState(itemId) {
  const {
    instance,
    items: {
      onItemClick
    },
    selection: {
      multiSelect,
      checkboxSelection,
      disableSelection
    },
    expansion: {
      expansionTrigger
    }
  } = useTreeViewContext();
  const expandable = instance.isItemExpandable(itemId);
  const expanded = instance.isItemExpanded(itemId);
  const focused = instance.isItemFocused(itemId);
  const selected = instance.isItemSelected(itemId);
  const disabled = instance.isItemDisabled(itemId);
  const editing = (instance == null ? void 0 : instance.isItemBeingEdited) ? instance == null ? void 0 : instance.isItemBeingEdited(itemId) : false;
  const editable = instance.isItemEditable ? instance.isItemEditable(itemId) : false;
  const handleExpansion = (event) => {
    if (!disabled) {
      if (!focused) {
        instance.focusItem(event, itemId);
      }
      const multiple = multiSelect && (event.shiftKey || event.ctrlKey || event.metaKey);
      if (expandable && !(multiple && instance.isItemExpanded(itemId))) {
        instance.toggleItemExpansion(event, itemId);
      }
    }
  };
  const handleSelection = (event) => {
    if (!disabled) {
      if (!focused) {
        instance.focusItem(event, itemId);
      }
      const multiple = multiSelect && (event.shiftKey || event.ctrlKey || event.metaKey);
      if (multiple) {
        if (event.shiftKey) {
          instance.expandSelectionRange(event, itemId);
        } else {
          instance.selectItem({
            event,
            itemId,
            keepExistingSelection: true
          });
        }
      } else {
        instance.selectItem({
          event,
          itemId,
          shouldBeSelected: true
        });
      }
    }
  };
  const handleCheckboxSelection = (event) => {
    if (disableSelection || disabled) {
      return;
    }
    const hasShift = event.nativeEvent.shiftKey;
    if (multiSelect && hasShift) {
      instance.expandSelectionRange(event, itemId);
    } else {
      instance.selectItem({
        event,
        itemId,
        keepExistingSelection: multiSelect,
        shouldBeSelected: event.target.checked
      });
    }
  };
  const preventSelection = (event) => {
    if (event.shiftKey || event.ctrlKey || event.metaKey || disabled) {
      event.preventDefault();
    }
  };
  const toggleItemEditing = () => {
    if (!hasPlugin(instance, useTreeViewLabel)) {
      return;
    }
    if (instance.isItemEditable(itemId)) {
      if (instance.isItemBeingEdited(itemId)) {
        instance.setEditedItemId(null);
      } else {
        instance.setEditedItemId(itemId);
      }
    }
  };
  const handleSaveItemLabel = (event, label) => {
    if (!hasPlugin(instance, useTreeViewLabel)) {
      return;
    }
    if (instance.isItemBeingEditedRef(itemId)) {
      instance.updateItemLabel(itemId, label);
      toggleItemEditing();
      instance.focusItem(event, itemId);
    }
  };
  const handleCancelItemLabelEditing = (event) => {
    if (!hasPlugin(instance, useTreeViewLabel)) {
      return;
    }
    if (instance.isItemBeingEditedRef(itemId)) {
      toggleItemEditing();
      instance.focusItem(event, itemId);
    }
  };
  return {
    disabled,
    expanded,
    selected,
    focused,
    editable,
    editing,
    disableSelection,
    checkboxSelection,
    handleExpansion,
    handleSelection,
    handleCheckboxSelection,
    handleContentClick: onItemClick,
    preventSelection,
    expansionTrigger,
    toggleItemEditing,
    handleSaveItemLabel,
    handleCancelItemLabelEditing
  };
}

// node_modules/@mui/x-tree-view/TreeItem2DragAndDropOverlay/TreeItem2DragAndDropOverlay.js
var React41 = __toESM(require_react());
var import_jsx_runtime68 = __toESM(require_jsx_runtime());
var TreeItem2DragAndDropOverlayRoot = styled_default("div", {
  name: "MuiTreeItem2DragAndDropOverlay",
  slot: "Root",
  overridesResolver: (props2, styles) => styles.root,
  shouldForwardProp: (prop) => shouldForwardProp(prop) && prop !== "action"
})(({
  theme: theme3
}) => ({
  position: "absolute",
  left: 0,
  display: "flex",
  top: 0,
  bottom: 0,
  right: 0,
  pointerEvents: "none",
  variants: [{
    props: {
      action: "make-child"
    },
    style: {
      marginLeft: "calc(var(--TreeView-indentMultiplier) * var(--TreeView-itemDepth))",
      borderRadius: theme3.shape.borderRadius,
      backgroundColor: theme3.vars ? `rgba(${theme3.vars.palette.primary.dark} / ${0.15})` : alpha(theme3.palette.primary.dark, 0.15)
    }
  }, {
    props: {
      action: "reorder-above"
    },
    style: _extends({
      marginLeft: "calc(var(--TreeView-indentMultiplier) * var(--TreeView-itemDepth))",
      borderTop: theme3.vars ? `1px solid rgba(${theme3.vars.palette.grey[900]} / ${0.6})` : `1px solid ${alpha(theme3.palette.grey[900], 0.6)}`
    }, theme3.applyStyles("dark", {
      borderTopColor: theme3.vars ? `rgba(${theme3.vars.palette.grey[100]} / ${0.6})` : alpha(theme3.palette.grey[100], 0.6)
    }))
  }, {
    props: {
      action: "reorder-below"
    },
    style: _extends({
      marginLeft: "calc(var(--TreeView-indentMultiplier) * var(--TreeView-itemDepth))",
      borderBottom: theme3.vars ? `1px solid rgba(${theme3.vars.palette.grey[900]} / ${0.6})` : `1px solid ${alpha(theme3.palette.grey[900], 0.6)}`
    }, theme3.applyStyles("dark", {
      borderBottomColor: theme3.vars ? `rgba(${theme3.vars.palette.grey[100]} / ${0.6})` : alpha(theme3.palette.grey[100], 0.6)
    }))
  }, {
    props: {
      action: "move-to-parent"
    },
    style: _extends({
      marginLeft: "calc(var(--TreeView-indentMultiplier) * calc(var(--TreeView-itemDepth) - 1))",
      borderBottom: theme3.vars ? `1px solid rgba(${theme3.vars.palette.grey[900]} / ${0.6})` : `1px solid ${alpha(theme3.palette.grey[900], 0.6)}`
    }, theme3.applyStyles("dark", {
      borderBottomColor: theme3.vars ? `rgba(${theme3.vars.palette.grey[100]} / ${0.6})` : alpha(theme3.palette.grey[100], 0.6)
    }))
  }]
}));
function TreeItem2DragAndDropOverlay(props2) {
  if (props2.action == null) {
    return null;
  }
  return (0, import_jsx_runtime68.jsx)(TreeItem2DragAndDropOverlayRoot, _extends({}, props2));
}

// node_modules/@mui/x-tree-view/TreeItem2LabelInput/TreeItem2LabelInput.js
var TreeItem2LabelInput = styled_default("input", {
  name: "MuiTreeItem2",
  slot: "LabelInput",
  overridesResolver: (props2, styles) => styles.labelInput
})(({
  theme: theme3
}) => _extends({}, theme3.typography.body1, {
  width: "100%",
  backgroundColor: theme3.palette.background.paper,
  borderRadius: theme3.shape.borderRadius,
  border: "none",
  padding: "0 2px",
  boxSizing: "border-box",
  "&:focus": {
    outline: `1px solid ${theme3.palette.primary.main}`
  }
}));

// node_modules/@mui/x-tree-view/TreeItem/TreeItemContent.js
var import_jsx_runtime69 = __toESM(require_jsx_runtime());
var _excluded3 = ["classes", "className", "displayIcon", "expansionIcon", "icon", "label", "itemId", "onClick", "onMouseDown", "dragAndDropOverlayProps", "labelInputProps"];
var TreeItemContent = React43.forwardRef(function TreeItemContent2(props2, ref) {
  const {
    classes: classes12,
    className,
    displayIcon,
    expansionIcon,
    icon: iconProp,
    label,
    itemId,
    onClick,
    onMouseDown,
    dragAndDropOverlayProps,
    labelInputProps
  } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded3);
  const {
    disabled,
    expanded,
    selected,
    focused,
    editing,
    editable,
    disableSelection,
    checkboxSelection,
    handleExpansion,
    handleSelection,
    handleCheckboxSelection,
    handleContentClick,
    preventSelection,
    expansionTrigger,
    toggleItemEditing
  } = useTreeItemState(itemId);
  const icon = iconProp || expansionIcon || displayIcon;
  const checkboxRef = React43.useRef(null);
  const handleMouseDown = (event) => {
    preventSelection(event);
    if (onMouseDown) {
      onMouseDown(event);
    }
  };
  const handleClick = (event) => {
    var _a;
    handleContentClick == null ? void 0 : handleContentClick(event, itemId);
    if ((_a = checkboxRef.current) == null ? void 0 : _a.contains(event.target)) {
      return;
    }
    if (expansionTrigger === "content") {
      handleExpansion(event);
    }
    if (!checkboxSelection) {
      handleSelection(event);
    }
    if (onClick) {
      onClick(event);
    }
  };
  const handleLabelDoubleClick = (event) => {
    if (event.defaultMuiPrevented) {
      return;
    }
    toggleItemEditing();
  };
  return (
    /* eslint-disable-next-line jsx-a11y/click-events-have-key-events,jsx-a11y/no-static-element-interactions -- Key event is handled by the TreeView */
    (0, import_jsx_runtime69.jsxs)("div", _extends({}, other, {
      className: clsx_default(classes12.root, className, expanded && classes12.expanded, selected && classes12.selected, focused && classes12.focused, disabled && classes12.disabled, editing && classes12.editing, editable && classes12.editable),
      onClick: handleClick,
      onMouseDown: handleMouseDown,
      ref,
      children: [(0, import_jsx_runtime69.jsx)("div", {
        className: classes12.iconContainer,
        children: icon
      }), checkboxSelection && (0, import_jsx_runtime69.jsx)(Checkbox_default, {
        className: classes12.checkbox,
        checked: selected,
        onChange: handleCheckboxSelection,
        disabled: disabled || disableSelection,
        ref: checkboxRef,
        tabIndex: -1
      }), editing ? (0, import_jsx_runtime69.jsx)(TreeItem2LabelInput, _extends({}, labelInputProps, {
        className: classes12.labelInput
      })) : (0, import_jsx_runtime69.jsx)("div", _extends({
        className: classes12.label
      }, editable && {
        onDoubleClick: handleLabelDoubleClick
      }, {
        children: label
      })), dragAndDropOverlayProps && (0, import_jsx_runtime69.jsx)(TreeItem2DragAndDropOverlay, _extends({}, dragAndDropOverlayProps))]
    }))
  );
});
true ? TreeItemContent.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types4.default.object.isRequired,
  className: import_prop_types4.default.string,
  /**
   * The icon to display next to the Tree Item's label. Either a parent or end icon.
   */
  displayIcon: import_prop_types4.default.node,
  dragAndDropOverlayProps: import_prop_types4.default.shape({
    action: import_prop_types4.default.oneOf(["make-child", "move-to-parent", "reorder-above", "reorder-below"]),
    style: import_prop_types4.default.object
  }),
  /**
   * The icon to display next to the Tree Item's label. Either an expansion or collapse icon.
   */
  expansionIcon: import_prop_types4.default.node,
  /**
   * The icon to display next to the Tree Item's label.
   */
  icon: import_prop_types4.default.node,
  /**
   * The id of the item.
   */
  itemId: import_prop_types4.default.string.isRequired,
  /**
   * The Tree Item label.
   */
  label: import_prop_types4.default.node,
  labelInputProps: import_prop_types4.default.shape({
    autoFocus: import_prop_types4.default.oneOf([true]),
    "data-element": import_prop_types4.default.oneOf(["labelInput"]),
    onBlur: import_prop_types4.default.func,
    onChange: import_prop_types4.default.func,
    onKeyDown: import_prop_types4.default.func,
    type: import_prop_types4.default.oneOf(["text"]),
    value: import_prop_types4.default.string
  })
} : void 0;

// node_modules/@mui/x-tree-view/TreeItem/treeItemClasses.js
function getTreeItemUtilityClass(slot) {
  return generateUtilityClass("MuiTreeItem", slot);
}
var treeItemClasses = generateUtilityClasses("MuiTreeItem", ["root", "groupTransition", "content", "expanded", "selected", "focused", "disabled", "iconContainer", "label", "checkbox", "labelInput", "editable", "editing", "dragAndDropOverlay"]);

// node_modules/@mui/x-tree-view/icons/icons.js
var React44 = __toESM(require_react());
var import_jsx_runtime70 = __toESM(require_jsx_runtime());
var TreeViewExpandIcon = createSvgIcon((0, import_jsx_runtime70.jsx)("path", {
  d: "M10 6 8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"
}), "TreeViewExpandIcon");
var TreeViewCollapseIcon = createSvgIcon((0, import_jsx_runtime70.jsx)("path", {
  d: "M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6z"
}), "TreeViewCollapseIcon");

// node_modules/@mui/x-tree-view/TreeItem2Provider/TreeItem2Provider.js
var import_prop_types5 = __toESM(require_prop_types());
function TreeItem2Provider(props2) {
  const {
    children,
    itemId
  } = props2;
  const {
    wrapItem,
    instance
  } = useTreeViewContext();
  return wrapItem({
    children,
    itemId,
    instance
  });
}
TreeItem2Provider.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  children: import_prop_types5.default.node,
  itemId: import_prop_types5.default.string.isRequired
};

// node_modules/@mui/x-tree-view/TreeItem/TreeItem.js
var import_jsx_runtime71 = __toESM(require_jsx_runtime());
var _excluded4 = ["children", "className", "slots", "slotProps", "ContentComponent", "ContentProps", "itemId", "id", "label", "onClick", "onMouseDown", "onFocus", "onBlur", "onKeyDown"];
var _excluded22 = ["ownerState"];
var _excluded32 = ["ownerState"];
var _excluded42 = ["ownerState"];
var useThemeProps4 = createUseThemeProps("MuiTreeItem");
var useUtilityClasses3 = (ownerState) => {
  const {
    classes: classes12
  } = ownerState;
  const slots = {
    root: ["root"],
    content: ["content"],
    expanded: ["expanded"],
    selected: ["selected"],
    focused: ["focused"],
    disabled: ["disabled"],
    iconContainer: ["iconContainer"],
    checkbox: ["checkbox"],
    label: ["label"],
    labelInput: ["labelInput"],
    editing: ["editing"],
    editable: ["editable"],
    groupTransition: ["groupTransition"]
  };
  return composeClasses(slots, getTreeItemUtilityClass, classes12);
};
var TreeItemRoot = styled_default("li", {
  name: "MuiTreeItem",
  slot: "Root",
  overridesResolver: (props2, styles) => styles.root
})({
  listStyle: "none",
  margin: 0,
  padding: 0,
  outline: 0
});
var StyledTreeItemContent = styled_default(TreeItemContent, {
  name: "MuiTreeItem",
  slot: "Content",
  overridesResolver: (props2, styles) => {
    return [styles.content, styles.iconContainer && {
      [`& .${treeItemClasses.iconContainer}`]: styles.iconContainer
    }, styles.label && {
      [`& .${treeItemClasses.label}`]: styles.label
    }];
  },
  shouldForwardProp: (prop) => shouldForwardProp(prop) && prop !== "indentationAtItemLevel"
})(({
  theme: theme3
}) => ({
  padding: theme3.spacing(0.5, 1),
  borderRadius: theme3.shape.borderRadius,
  width: "100%",
  boxSizing: "border-box",
  // prevent width + padding to overflow
  position: "relative",
  display: "flex",
  alignItems: "center",
  gap: theme3.spacing(1),
  cursor: "pointer",
  WebkitTapHighlightColor: "transparent",
  "&:hover": {
    backgroundColor: (theme3.vars || theme3).palette.action.hover,
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  [`&.${treeItemClasses.disabled}`]: {
    opacity: (theme3.vars || theme3).palette.action.disabledOpacity,
    backgroundColor: "transparent"
  },
  [`&.${treeItemClasses.focused}`]: {
    backgroundColor: (theme3.vars || theme3).palette.action.focus
  },
  [`&.${treeItemClasses.selected}`]: {
    backgroundColor: theme3.vars ? `rgba(${theme3.vars.palette.primary.mainChannel} / ${theme3.vars.palette.action.selectedOpacity})` : alpha(theme3.palette.primary.main, theme3.palette.action.selectedOpacity),
    "&:hover": {
      backgroundColor: theme3.vars ? `rgba(${theme3.vars.palette.primary.mainChannel} / calc(${theme3.vars.palette.action.selectedOpacity} + ${theme3.vars.palette.action.hoverOpacity}))` : alpha(theme3.palette.primary.main, theme3.palette.action.selectedOpacity + theme3.palette.action.hoverOpacity),
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: theme3.vars ? `rgba(${theme3.vars.palette.primary.mainChannel} / ${theme3.vars.palette.action.selectedOpacity})` : alpha(theme3.palette.primary.main, theme3.palette.action.selectedOpacity)
      }
    },
    [`&.${treeItemClasses.focused}`]: {
      backgroundColor: theme3.vars ? `rgba(${theme3.vars.palette.primary.mainChannel} / calc(${theme3.vars.palette.action.selectedOpacity} + ${theme3.vars.palette.action.focusOpacity}))` : alpha(theme3.palette.primary.main, theme3.palette.action.selectedOpacity + theme3.palette.action.focusOpacity)
    }
  },
  [`& .${treeItemClasses.iconContainer}`]: {
    width: 16,
    display: "flex",
    flexShrink: 0,
    justifyContent: "center",
    "& svg": {
      fontSize: 18
    }
  },
  [`& .${treeItemClasses.label}`]: _extends({
    width: "100%",
    boxSizing: "border-box",
    // prevent width + padding to overflow
    // fixes overflow - see https://github.com/mui/material-ui/issues/27372
    minWidth: 0,
    position: "relative"
  }, theme3.typography.body1),
  [`& .${treeItemClasses.checkbox}`]: {
    padding: 0
  },
  variants: [{
    props: {
      indentationAtItemLevel: true
    },
    style: {
      paddingLeft: `calc(${theme3.spacing(1)} + var(--TreeView-itemChildrenIndentation) * var(--TreeView-itemDepth))`
    }
  }]
}));
var TreeItemGroup = styled_default(Collapse_default, {
  name: "MuiTreeItem",
  slot: "GroupTransition",
  overridesResolver: (props2, styles) => styles.groupTransition,
  shouldForwardProp: (prop) => shouldForwardProp(prop) && prop !== "indentationAtItemLevel"
})({
  margin: 0,
  padding: 0,
  paddingLeft: "var(--TreeView-itemChildrenIndentation)",
  variants: [{
    props: {
      indentationAtItemLevel: true
    },
    style: {
      paddingLeft: 0
    }
  }]
});
var TreeItem = React45.forwardRef(function TreeItem2(inProps, inRef) {
  var _a, _b, _c, _d;
  const {
    icons: contextIcons,
    runItemPlugins,
    items: {
      disabledItemsFocusable,
      indentationAtItemLevel
    },
    selection: {
      disableSelection
    },
    expansion: {
      expansionTrigger
    },
    treeId,
    instance
  } = useTreeViewContext();
  const depthContext = React45.useContext(TreeViewItemDepthContext);
  const props2 = useThemeProps4({
    props: inProps,
    name: "MuiTreeItem"
  });
  const {
    children,
    className,
    slots: inSlots,
    slotProps: inSlotProps,
    ContentComponent = TreeItemContent,
    ContentProps,
    itemId,
    id,
    label,
    onClick,
    onMouseDown,
    onBlur,
    onKeyDown
  } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded4);
  const {
    expanded,
    focused,
    selected,
    disabled,
    editing,
    handleExpansion,
    handleCancelItemLabelEditing,
    handleSaveItemLabel
  } = useTreeItemState(itemId);
  if (true) {
    if (props2.ContentComponent) {
      warnOnce(["MUI X: The ContentComponent prop of the TreeItem component is deprecated and will be removed in the next major release.", "You can use the new TreeItem2 component or the new useTreeItem2 hook to customize the rendering of the content.", "For more detail, see https://mui.com/x/react-tree-view/tree-item-customization/."]);
    }
    if (props2.ContentProps) {
      warnOnce(["MUI X: The ContentProps prop of the TreeItem component is deprecated and will be removed in the next major release.", "You can use the new TreeItem2 component or the new useTreeItem2 hook to customize the rendering of the content.", "For more detail, see https://mui.com/x/react-tree-view/tree-item-customization/."]);
    }
  }
  const {
    contentRef,
    rootRef,
    propsEnhancers
  } = runItemPlugins(props2);
  const rootRefObject = React45.useRef(null);
  const contentRefObject = React45.useRef(null);
  const handleRootRef = useForkRef(inRef, rootRef, rootRefObject);
  const handleContentRef = useForkRef(ContentProps == null ? void 0 : ContentProps.ref, contentRef, contentRefObject);
  const slots = {
    expandIcon: (inSlots == null ? void 0 : inSlots.expandIcon) ?? contextIcons.slots.expandIcon ?? TreeViewExpandIcon,
    collapseIcon: (inSlots == null ? void 0 : inSlots.collapseIcon) ?? contextIcons.slots.collapseIcon ?? TreeViewCollapseIcon,
    endIcon: (inSlots == null ? void 0 : inSlots.endIcon) ?? contextIcons.slots.endIcon,
    icon: inSlots == null ? void 0 : inSlots.icon,
    groupTransition: inSlots == null ? void 0 : inSlots.groupTransition
  };
  const isExpandable = (reactChildren) => {
    if (Array.isArray(reactChildren)) {
      return reactChildren.length > 0 && reactChildren.some(isExpandable);
    }
    return Boolean(reactChildren);
  };
  const expandable = isExpandable(children);
  const ownerState = _extends({}, props2, {
    expanded,
    focused,
    selected,
    disabled,
    indentationAtItemLevel
  });
  const classes12 = useUtilityClasses3(ownerState);
  const GroupTransition = slots.groupTransition ?? void 0;
  const groupTransitionProps = useSlotProps_default({
    elementType: GroupTransition,
    ownerState: {},
    externalSlotProps: inSlotProps == null ? void 0 : inSlotProps.groupTransition,
    additionalProps: _extends({
      unmountOnExit: true,
      in: expanded,
      component: "ul",
      role: "group"
    }, indentationAtItemLevel ? {
      indentationAtItemLevel: true
    } : {}),
    className: classes12.groupTransition
  });
  const handleIconContainerClick = (event) => {
    if (expansionTrigger === "iconContainer") {
      handleExpansion(event);
    }
  };
  const ExpansionIcon = expanded ? slots.collapseIcon : slots.expandIcon;
  const _useSlotProps = useSlotProps_default({
    elementType: ExpansionIcon,
    ownerState: {},
    externalSlotProps: (tempOwnerState) => {
      if (expanded) {
        return _extends({}, resolveComponentProps_default(contextIcons.slotProps.collapseIcon, tempOwnerState), resolveComponentProps_default(inSlotProps == null ? void 0 : inSlotProps.collapseIcon, tempOwnerState));
      }
      return _extends({}, resolveComponentProps_default(contextIcons.slotProps.expandIcon, tempOwnerState), resolveComponentProps_default(inSlotProps == null ? void 0 : inSlotProps.expandIcon, tempOwnerState));
    },
    additionalProps: {
      onClick: handleIconContainerClick
    }
  }), expansionIconProps = _objectWithoutPropertiesLoose(_useSlotProps, _excluded22);
  const expansionIcon = expandable && !!ExpansionIcon ? (0, import_jsx_runtime71.jsx)(ExpansionIcon, _extends({}, expansionIconProps)) : null;
  const DisplayIcon = expandable ? void 0 : slots.endIcon;
  const _useSlotProps2 = useSlotProps_default({
    elementType: DisplayIcon,
    ownerState: {},
    externalSlotProps: (tempOwnerState) => {
      if (expandable) {
        return {};
      }
      return _extends({}, resolveComponentProps_default(contextIcons.slotProps.endIcon, tempOwnerState), resolveComponentProps_default(inSlotProps == null ? void 0 : inSlotProps.endIcon, tempOwnerState));
    }
  }), displayIconProps = _objectWithoutPropertiesLoose(_useSlotProps2, _excluded32);
  const displayIcon = DisplayIcon ? (0, import_jsx_runtime71.jsx)(DisplayIcon, _extends({}, displayIconProps)) : null;
  const Icon = slots.icon;
  const _useSlotProps3 = useSlotProps_default({
    elementType: Icon,
    ownerState: {},
    externalSlotProps: inSlotProps == null ? void 0 : inSlotProps.icon
  }), iconProps = _objectWithoutPropertiesLoose(_useSlotProps3, _excluded42);
  const icon = Icon ? (0, import_jsx_runtime71.jsx)(Icon, _extends({}, iconProps)) : null;
  let ariaSelected;
  if (selected) {
    ariaSelected = true;
  } else if (disableSelection || disabled) {
    ariaSelected = void 0;
  } else {
    ariaSelected = false;
  }
  function handleFocus(event) {
    const canBeFocused = !disabled || disabledItemsFocusable;
    if (!focused && canBeFocused && event.currentTarget === event.target) {
      instance.focusItem(event, itemId);
    }
  }
  function handleBlur(event) {
    var _a2, _b2, _c2, _d2;
    onBlur == null ? void 0 : onBlur(event);
    if (editing || // we can exit the editing state by clicking outside the input (within the Tree Item) or by pressing Enter or Escape -> we don't want to remove the focused item from the state in these cases
    // we can also exit the editing state by clicking on the root itself -> want to remove the focused item from the state in this case
    event.relatedTarget && isTargetInDescendants(event.relatedTarget, rootRefObject.current) && (event.target && ((_b2 = (_a2 = event.target) == null ? void 0 : _a2.dataset) == null ? void 0 : _b2.element) === "labelInput" && isTargetInDescendants(event.target, rootRefObject.current) || ((_d2 = (_c2 = event.relatedTarget) == null ? void 0 : _c2.dataset) == null ? void 0 : _d2.element) === "labelInput")) {
      return;
    }
    instance.removeFocusedItem();
  }
  const handleKeyDown = (event) => {
    var _a2, _b2;
    onKeyDown == null ? void 0 : onKeyDown(event);
    if (((_b2 = (_a2 = event.target) == null ? void 0 : _a2.dataset) == null ? void 0 : _b2.element) === "labelInput") {
      return;
    }
    instance.handleItemKeyDown(event, itemId);
  };
  const idAttribute = generateTreeItemIdAttribute({
    itemId,
    treeId,
    id
  });
  const tabIndex = instance.canItemBeTabbed(itemId) ? 0 : -1;
  const sharedPropsEnhancerParams = {
    rootRefObject,
    contentRefObject,
    interactions: {
      handleSaveItemLabel,
      handleCancelItemLabelEditing
    }
  };
  const enhancedRootProps = ((_a = propsEnhancers.root) == null ? void 0 : _a.call(propsEnhancers, _extends({}, sharedPropsEnhancerParams, {
    externalEventHandlers: extractEventHandlers_default(other)
  }))) ?? {};
  const enhancedContentProps = ((_b = propsEnhancers.content) == null ? void 0 : _b.call(propsEnhancers, _extends({}, sharedPropsEnhancerParams, {
    externalEventHandlers: extractEventHandlers_default(ContentProps)
  }))) ?? {};
  const enhancedDragAndDropOverlayProps = ((_c = propsEnhancers.dragAndDropOverlay) == null ? void 0 : _c.call(propsEnhancers, _extends({}, sharedPropsEnhancerParams, {
    externalEventHandlers: {}
  }))) ?? {};
  const enhancedLabelInputProps = ((_d = propsEnhancers.labelInput) == null ? void 0 : _d.call(propsEnhancers, _extends({}, sharedPropsEnhancerParams, {
    externalEventHandlers: {}
  }))) ?? {};
  return (0, import_jsx_runtime71.jsx)(TreeItem2Provider, {
    itemId,
    children: (0, import_jsx_runtime71.jsxs)(TreeItemRoot, _extends({
      className: clsx_default(classes12.root, className),
      role: "treeitem",
      "aria-expanded": expandable ? expanded : void 0,
      "aria-selected": ariaSelected,
      "aria-disabled": disabled || void 0,
      id: idAttribute,
      tabIndex
    }, other, {
      ownerState,
      onFocus: handleFocus,
      onBlur: handleBlur,
      onKeyDown: handleKeyDown,
      ref: handleRootRef,
      style: indentationAtItemLevel ? _extends({}, other.style, {
        "--TreeView-itemDepth": typeof depthContext === "function" ? depthContext(itemId) : depthContext
      }) : other.style
    }, enhancedRootProps, {
      children: [(0, import_jsx_runtime71.jsx)(StyledTreeItemContent, _extends({
        as: ContentComponent,
        classes: {
          root: classes12.content,
          expanded: classes12.expanded,
          selected: classes12.selected,
          focused: classes12.focused,
          disabled: classes12.disabled,
          editable: classes12.editable,
          editing: classes12.editing,
          iconContainer: classes12.iconContainer,
          label: classes12.label,
          labelInput: classes12.labelInput,
          checkbox: classes12.checkbox
        },
        label,
        itemId,
        onClick,
        onMouseDown,
        icon,
        expansionIcon,
        displayIcon,
        ownerState
      }, ContentProps, enhancedContentProps, enhancedDragAndDropOverlayProps.action == null ? {} : {
        dragAndDropOverlayProps: enhancedDragAndDropOverlayProps
      }, enhancedLabelInputProps.value == null ? {} : {
        labelInputProps: enhancedLabelInputProps
      }, {
        ref: handleContentRef
      })), children && (0, import_jsx_runtime71.jsx)(TreeItemGroup, _extends({
        as: GroupTransition
      }, groupTransitionProps, {
        children
      }))]
    }))
  });
});
true ? TreeItem.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: import_prop_types6.default.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types6.default.object,
  className: import_prop_types6.default.string,
  /**
   * The component used to render the content of the item.
   * @deprecated Consider using the `<TreeItem2 />` component or the `useTreeItem2` hook instead. For more details, see https://mui.com/x/react-tree-view/tree-item-customization/.
   * @default TreeItemContent
   */
  ContentComponent: elementTypeAcceptingRef_default,
  /**
   * Props applied to ContentComponent.
   * @deprecated Consider using the `<TreeItem2 />` component or the `useTreeItem2` hook instead. For more details, see https://mui.com/x/react-tree-view/tree-item-customization/.
   */
  ContentProps: import_prop_types6.default.object,
  /**
   * If `true`, the item is disabled.
   * @default false
   */
  disabled: import_prop_types6.default.bool,
  /**
   * The id of the item.
   */
  itemId: import_prop_types6.default.string.isRequired,
  /**
   * The Tree Item label.
   */
  label: import_prop_types6.default.node,
  /**
   * This prop isn't supported.
   * Use the `onItemFocus` callback on the tree if you need to monitor a item's focus.
   */
  onFocus: unsupportedProp,
  /**
   * Callback fired when a key of the keyboard is pressed on the item.
   */
  onKeyDown: import_prop_types6.default.func,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types6.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types6.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types6.default.oneOfType([import_prop_types6.default.arrayOf(import_prop_types6.default.oneOfType([import_prop_types6.default.func, import_prop_types6.default.object, import_prop_types6.default.bool])), import_prop_types6.default.func, import_prop_types6.default.object])
} : void 0;

// node_modules/@mui/x-tree-view/internals/components/RichTreeViewItems.js
var import_jsx_runtime72 = __toESM(require_jsx_runtime());
var _excluded5 = ["ownerState"];
function WrappedTreeItem({
  slots,
  slotProps,
  label,
  id,
  itemId,
  itemsToRender
}) {
  const Item = (slots == null ? void 0 : slots.item) ?? TreeItem;
  const _useSlotProps = useSlotProps_default({
    elementType: Item,
    externalSlotProps: slotProps == null ? void 0 : slotProps.item,
    additionalProps: {
      itemId,
      id,
      label
    },
    ownerState: {
      itemId,
      label
    }
  }), itemProps = _objectWithoutPropertiesLoose(_useSlotProps, _excluded5);
  const children = React46.useMemo(() => itemsToRender ? (0, import_jsx_runtime72.jsx)(RichTreeViewItems, {
    itemsToRender,
    slots,
    slotProps
  }) : null, [itemsToRender, slots, slotProps]);
  return (0, import_jsx_runtime72.jsx)(Item, _extends({}, itemProps, {
    children
  }));
}
function RichTreeViewItems(props2) {
  const {
    itemsToRender,
    slots,
    slotProps
  } = props2;
  return (0, import_jsx_runtime72.jsx)(React46.Fragment, {
    children: itemsToRender.map((item) => (0, import_jsx_runtime72.jsx)(WrappedTreeItem, {
      slots,
      slotProps,
      label: item.label,
      id: item.id,
      itemId: item.itemId,
      itemsToRender: item.children
    }, item.itemId))
  });
}

// node_modules/@mui/x-tree-view/RichTreeView/RichTreeView.js
var import_jsx_runtime73 = __toESM(require_jsx_runtime());
var useThemeProps5 = createUseThemeProps("MuiRichTreeView");
var useUtilityClasses4 = (ownerState) => {
  const {
    classes: classes12
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getRichTreeViewUtilityClass, classes12);
};
var RichTreeViewRoot = styled_default("ul", {
  name: "MuiRichTreeView",
  slot: "Root",
  overridesResolver: (props2, styles) => styles.root
})({
  padding: 0,
  margin: 0,
  listStyle: "none",
  outline: 0,
  position: "relative"
});
var RichTreeView = React47.forwardRef(function RichTreeView2(inProps, ref) {
  const props2 = useThemeProps5({
    props: inProps,
    name: "MuiRichTreeView"
  });
  if (true) {
    if (props2.children != null) {
      warnOnce(["MUI X: The Rich Tree View component does not support JSX children.", "If you want to add items, you need to use the `items` prop.", "Check the documentation for more details: https://mui.com/x/react-tree-view/rich-tree-view/items/."]);
    }
  }
  const {
    getRootProps,
    contextValue,
    instance
  } = useTreeView({
    plugins: RICH_TREE_VIEW_PLUGINS,
    rootRef: ref,
    props: props2
  });
  const {
    slots,
    slotProps
  } = props2;
  const classes12 = useUtilityClasses4(props2);
  const Root2 = (slots == null ? void 0 : slots.root) ?? RichTreeViewRoot;
  const rootProps = useSlotProps_default({
    elementType: Root2,
    externalSlotProps: slotProps == null ? void 0 : slotProps.root,
    className: classes12.root,
    getSlotProps: getRootProps,
    ownerState: props2
  });
  return (0, import_jsx_runtime73.jsx)(TreeViewProvider, {
    value: contextValue,
    children: (0, import_jsx_runtime73.jsx)(Root2, _extends({}, rootProps, {
      children: (0, import_jsx_runtime73.jsx)(RichTreeViewItems, {
        slots,
        slotProps,
        itemsToRender: instance.getItemsToRender()
      })
    }))
  });
});
true ? RichTreeView.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The ref object that allows Tree View manipulation. Can be instantiated with `useTreeViewApiRef()`.
   */
  apiRef: import_prop_types7.default.shape({
    current: import_prop_types7.default.shape({
      focusItem: import_prop_types7.default.func.isRequired,
      getItem: import_prop_types7.default.func.isRequired,
      getItemDOMElement: import_prop_types7.default.func.isRequired,
      getItemOrderedChildrenIds: import_prop_types7.default.func.isRequired,
      getItemTree: import_prop_types7.default.func.isRequired,
      selectItem: import_prop_types7.default.func.isRequired,
      setItemExpansion: import_prop_types7.default.func.isRequired,
      updateItemLabel: import_prop_types7.default.func.isRequired
    })
  }),
  /**
   * If `true`, the Tree View renders a checkbox at the left of its label that allows selecting it.
   * @default false
   */
  checkboxSelection: import_prop_types7.default.bool,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types7.default.object,
  className: import_prop_types7.default.string,
  /**
   * Expanded item ids.
   * Used when the item's expansion is not controlled.
   * @default []
   */
  defaultExpandedItems: import_prop_types7.default.arrayOf(import_prop_types7.default.string),
  /**
   * Selected item ids. (Uncontrolled)
   * When `multiSelect` is true this takes an array of strings; when false (default) a string.
   * @default []
   */
  defaultSelectedItems: import_prop_types7.default.any,
  /**
   * If `true`, will allow focus on disabled items.
   * @default false
   */
  disabledItemsFocusable: import_prop_types7.default.bool,
  /**
   * If `true` selection is disabled.
   * @default false
   */
  disableSelection: import_prop_types7.default.bool,
  /**
   * Expanded item ids.
   * Used when the item's expansion is controlled.
   */
  expandedItems: import_prop_types7.default.arrayOf(import_prop_types7.default.string),
  /**
   * The slot that triggers the item's expansion when clicked.
   * @default 'content'
   */
  expansionTrigger: import_prop_types7.default.oneOf(["content", "iconContainer"]),
  /**
   * Unstable features, breaking changes might be introduced.
   * For each feature, if the flag is not explicitly set to `true`,
   * the feature will be fully disabled and any property / method call will not have any effect.
   */
  experimentalFeatures: import_prop_types7.default.shape({
    indentationAtItemLevel: import_prop_types7.default.bool,
    labelEditing: import_prop_types7.default.bool
  }),
  /**
   * Used to determine the id of a given item.
   *
   * @template R
   * @param {R} item The item to check.
   * @returns {string} The id of the item.
   * @default (item) => item.id
   */
  getItemId: import_prop_types7.default.func,
  /**
   * Used to determine the string label for a given item.
   *
   * @template R
   * @param {R} item The item to check.
   * @returns {string} The label of the item.
   * @default (item) => item.label
   */
  getItemLabel: import_prop_types7.default.func,
  /**
   * This prop is used to help implement the accessibility logic.
   * If you don't provide this prop. It falls back to a randomly generated id.
   */
  id: import_prop_types7.default.string,
  /**
   * Used to determine if a given item should be disabled.
   * @template R
   * @param {R} item The item to check.
   * @returns {boolean} `true` if the item should be disabled.
   */
  isItemDisabled: import_prop_types7.default.func,
  /**
   * Determines if a given item is editable or not.
   * Make sure to also enable the `labelEditing` experimental feature:
   * `<RichTreeViewPro experimentalFeatures={{ labelEditing: true }}  />`.
   * By default, the items are not editable.
   * @template R
   * @param {R} item The item to check.
   * @returns {boolean} `true` if the item is editable.
   */
  isItemEditable: import_prop_types7.default.oneOfType([import_prop_types7.default.func, import_prop_types7.default.bool]),
  /**
   * Horizontal indentation between an item and its children.
   * Examples: 24, "24px", "2rem", "2em".
   * @default 12px
   */
  itemChildrenIndentation: import_prop_types7.default.oneOfType([import_prop_types7.default.number, import_prop_types7.default.string]),
  items: import_prop_types7.default.array.isRequired,
  /**
   * If `true`, `ctrl` and `shift` will trigger multiselect.
   * @default false
   */
  multiSelect: import_prop_types7.default.bool,
  /**
   * Callback fired when Tree Items are expanded/collapsed.
   * @param {React.SyntheticEvent} event The DOM event that triggered the change.
   * @param {array} itemIds The ids of the expanded items.
   */
  onExpandedItemsChange: import_prop_types7.default.func,
  /**
   * Callback fired when the `content` slot of a given Tree Item is clicked.
   * @param {React.MouseEvent} event The DOM event that triggered the change.
   * @param {string} itemId The id of the focused item.
   */
  onItemClick: import_prop_types7.default.func,
  /**
   * Callback fired when a Tree Item is expanded or collapsed.
   * @param {React.SyntheticEvent} event The DOM event that triggered the change.
   * @param {array} itemId The itemId of the modified item.
   * @param {array} isExpanded `true` if the item has just been expanded, `false` if it has just been collapsed.
   */
  onItemExpansionToggle: import_prop_types7.default.func,
  /**
   * Callback fired when a given Tree Item is focused.
   * @param {React.SyntheticEvent | null} event The DOM event that triggered the change. **Warning**: This is a generic event not a focus event.
   * @param {string} itemId The id of the focused item.
   */
  onItemFocus: import_prop_types7.default.func,
  /**
   * Callback fired when the label of an item changes.
   * @param {TreeViewItemId} itemId The id of the item that was edited.
   * @param {string} newLabel The new label of the items.
   */
  onItemLabelChange: import_prop_types7.default.func,
  /**
   * Callback fired when a Tree Item is selected or deselected.
   * @param {React.SyntheticEvent} event The DOM event that triggered the change.
   * @param {array} itemId The itemId of the modified item.
   * @param {array} isSelected `true` if the item has just been selected, `false` if it has just been deselected.
   */
  onItemSelectionToggle: import_prop_types7.default.func,
  /**
   * Callback fired when Tree Items are selected/deselected.
   * @param {React.SyntheticEvent} event The DOM event that triggered the change.
   * @param {string[] | string} itemIds The ids of the selected items.
   * When `multiSelect` is `true`, this is an array of strings; when false (default) a string.
   */
  onSelectedItemsChange: import_prop_types7.default.func,
  /**
   * Selected item ids. (Controlled)
   * When `multiSelect` is true this takes an array of strings; when false (default) a string.
   */
  selectedItems: import_prop_types7.default.any,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types7.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types7.default.object,
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: import_prop_types7.default.oneOfType([import_prop_types7.default.arrayOf(import_prop_types7.default.oneOfType([import_prop_types7.default.func, import_prop_types7.default.object, import_prop_types7.default.bool])), import_prop_types7.default.func, import_prop_types7.default.object])
} : void 0;

// node_modules/@mui/x-tree-view/TreeItem2/TreeItem2.js
var React50 = __toESM(require_react());
var import_prop_types9 = __toESM(require_prop_types());

// node_modules/@mui/x-tree-view/useTreeItem2/useTreeItem2.js
var React48 = __toESM(require_react());

// node_modules/@mui/x-tree-view/hooks/useTreeItem2Utils/useTreeItem2Utils.js
var isItemExpandable2 = (reactChildren) => {
  if (Array.isArray(reactChildren)) {
    return reactChildren.length > 0 && reactChildren.some(isItemExpandable2);
  }
  return Boolean(reactChildren);
};
var useTreeItem2Utils = ({
  itemId,
  children
}) => {
  const {
    instance,
    selection: {
      multiSelect
    },
    publicAPI
  } = useTreeViewContext();
  const status = {
    expandable: isItemExpandable2(children),
    expanded: instance.isItemExpanded(itemId),
    focused: instance.isItemFocused(itemId),
    selected: instance.isItemSelected(itemId),
    disabled: instance.isItemDisabled(itemId),
    editing: (instance == null ? void 0 : instance.isItemBeingEdited) ? instance == null ? void 0 : instance.isItemBeingEdited(itemId) : false,
    editable: instance.isItemEditable ? instance.isItemEditable(itemId) : false
  };
  const handleExpansion = (event) => {
    if (status.disabled) {
      return;
    }
    if (!status.focused) {
      instance.focusItem(event, itemId);
    }
    const multiple = multiSelect && (event.shiftKey || event.ctrlKey || event.metaKey);
    if (status.expandable && !(multiple && instance.isItemExpanded(itemId))) {
      instance.toggleItemExpansion(event, itemId);
    }
  };
  const handleSelection = (event) => {
    if (status.disabled) {
      return;
    }
    if (!status.focused) {
      instance.focusItem(event, itemId);
    }
    const multiple = multiSelect && (event.shiftKey || event.ctrlKey || event.metaKey);
    if (multiple) {
      if (event.shiftKey) {
        instance.expandSelectionRange(event, itemId);
      } else {
        instance.selectItem({
          event,
          itemId,
          keepExistingSelection: true
        });
      }
    } else {
      instance.selectItem({
        event,
        itemId,
        shouldBeSelected: true
      });
    }
  };
  const handleCheckboxSelection = (event) => {
    const hasShift = event.nativeEvent.shiftKey;
    if (multiSelect && hasShift) {
      instance.expandSelectionRange(event, itemId);
    } else {
      instance.selectItem({
        event,
        itemId,
        keepExistingSelection: multiSelect,
        shouldBeSelected: event.target.checked
      });
    }
  };
  const toggleItemEditing = () => {
    if (!hasPlugin(instance, useTreeViewLabel)) {
      return;
    }
    if (instance.isItemEditable(itemId)) {
      if (instance.isItemBeingEdited(itemId)) {
        instance.setEditedItemId(null);
      } else {
        instance.setEditedItemId(itemId);
      }
    }
  };
  const handleSaveItemLabel = (event, label) => {
    if (!hasPlugin(instance, useTreeViewLabel)) {
      return;
    }
    if (instance.isItemBeingEditedRef(itemId)) {
      instance.updateItemLabel(itemId, label);
      toggleItemEditing();
      instance.focusItem(event, itemId);
    }
  };
  const handleCancelItemLabelEditing = (event) => {
    if (!hasPlugin(instance, useTreeViewLabel)) {
      return;
    }
    if (instance.isItemBeingEditedRef(itemId)) {
      toggleItemEditing();
      instance.focusItem(event, itemId);
    }
  };
  const interactions = {
    handleExpansion,
    handleSelection,
    handleCheckboxSelection,
    toggleItemEditing,
    handleSaveItemLabel,
    handleCancelItemLabelEditing
  };
  return {
    interactions,
    status,
    publicAPI
  };
};

// node_modules/@mui/x-tree-view/useTreeItem2/useTreeItem2.js
var useTreeItem2 = (parameters) => {
  const {
    runItemPlugins,
    items: {
      onItemClick,
      disabledItemsFocusable,
      indentationAtItemLevel
    },
    selection: {
      disableSelection,
      checkboxSelection
    },
    expansion: {
      expansionTrigger
    },
    treeId,
    instance,
    publicAPI
  } = useTreeViewContext();
  const depthContext = React48.useContext(TreeViewItemDepthContext);
  const {
    id,
    itemId,
    label,
    children,
    rootRef
  } = parameters;
  const {
    rootRef: pluginRootRef,
    contentRef,
    propsEnhancers
  } = runItemPlugins(parameters);
  const {
    interactions,
    status
  } = useTreeItem2Utils({
    itemId,
    children
  });
  const rootRefObject = React48.useRef(null);
  const contentRefObject = React48.useRef(null);
  const handleRootRef = useForkRef(rootRef, pluginRootRef, rootRefObject);
  const handleContentRef = useForkRef(contentRef, contentRefObject);
  const checkboxRef = React48.useRef(null);
  const idAttribute = generateTreeItemIdAttribute({
    itemId,
    treeId,
    id
  });
  const rootTabIndex = instance.canItemBeTabbed(itemId) ? 0 : -1;
  const sharedPropsEnhancerParams = {
    rootRefObject,
    contentRefObject,
    interactions
  };
  const createRootHandleFocus = (otherHandlers) => (event) => {
    var _a;
    (_a = otherHandlers.onFocus) == null ? void 0 : _a.call(otherHandlers, event);
    if (event.defaultMuiPrevented) {
      return;
    }
    const canBeFocused = !status.disabled || disabledItemsFocusable;
    if (!status.focused && canBeFocused && event.currentTarget === event.target) {
      instance.focusItem(event, itemId);
    }
  };
  const createRootHandleBlur = (otherHandlers) => (event) => {
    var _a, _b, _c, _d, _e2;
    (_a = otherHandlers.onBlur) == null ? void 0 : _a.call(otherHandlers, event);
    if (event.defaultMuiPrevented) {
      return;
    }
    const rootElement = instance.getItemDOMElement(itemId);
    if (status.editing || // we can exit the editing state by clicking outside the input (within the Tree Item) or by pressing Enter or Escape -> we don't want to remove the focused item from the state in these cases
    // we can also exit the editing state by clicking on the root itself -> want to remove the focused item from the state in this case
    event.relatedTarget && isTargetInDescendants(event.relatedTarget, rootElement) && (event.target && ((_c = (_b = event.target) == null ? void 0 : _b.dataset) == null ? void 0 : _c.element) === "labelInput" && isTargetInDescendants(event.target, rootElement) || ((_e2 = (_d = event.relatedTarget) == null ? void 0 : _d.dataset) == null ? void 0 : _e2.element) === "labelInput")) {
      return;
    }
    instance.removeFocusedItem();
  };
  const createRootHandleKeyDown = (otherHandlers) => (event) => {
    var _a, _b, _c;
    (_a = otherHandlers.onKeyDown) == null ? void 0 : _a.call(otherHandlers, event);
    if (event.defaultMuiPrevented || ((_c = (_b = event.target) == null ? void 0 : _b.dataset) == null ? void 0 : _c.element) === "labelInput") {
      return;
    }
    instance.handleItemKeyDown(event, itemId);
  };
  const createLabelHandleDoubleClick = (otherHandlers) => (event) => {
    var _a;
    (_a = otherHandlers.onDoubleClick) == null ? void 0 : _a.call(otherHandlers, event);
    if (event.defaultMuiPrevented) {
      return;
    }
    interactions.toggleItemEditing();
  };
  const createContentHandleClick = (otherHandlers) => (event) => {
    var _a, _b;
    (_a = otherHandlers.onClick) == null ? void 0 : _a.call(otherHandlers, event);
    onItemClick == null ? void 0 : onItemClick(event, itemId);
    if (event.defaultMuiPrevented || ((_b = checkboxRef.current) == null ? void 0 : _b.contains(event.target))) {
      return;
    }
    if (expansionTrigger === "content") {
      interactions.handleExpansion(event);
    }
    if (!checkboxSelection) {
      interactions.handleSelection(event);
    }
  };
  const createContentHandleMouseDown = (otherHandlers) => (event) => {
    var _a;
    (_a = otherHandlers.onMouseDown) == null ? void 0 : _a.call(otherHandlers, event);
    if (event.defaultMuiPrevented) {
      return;
    }
    if (event.shiftKey || event.ctrlKey || event.metaKey || status.disabled) {
      event.preventDefault();
    }
  };
  const createCheckboxHandleChange = (otherHandlers) => (event) => {
    var _a;
    (_a = otherHandlers.onChange) == null ? void 0 : _a.call(otherHandlers, event);
    if (event.defaultMuiPrevented) {
      return;
    }
    if (disableSelection || status.disabled) {
      return;
    }
    interactions.handleCheckboxSelection(event);
  };
  const createIconContainerHandleClick = (otherHandlers) => (event) => {
    var _a;
    (_a = otherHandlers.onClick) == null ? void 0 : _a.call(otherHandlers, event);
    if (event.defaultMuiPrevented) {
      return;
    }
    if (expansionTrigger === "iconContainer") {
      interactions.handleExpansion(event);
    }
  };
  const getRootProps = (externalProps = {}) => {
    var _a;
    const externalEventHandlers = _extends({}, extractEventHandlers_default(parameters), extractEventHandlers_default(externalProps));
    let ariaSelected;
    if (status.selected) {
      ariaSelected = true;
    } else if (disableSelection || status.disabled) {
      ariaSelected = void 0;
    } else {
      ariaSelected = false;
    }
    const props2 = _extends({}, externalEventHandlers, {
      ref: handleRootRef,
      role: "treeitem",
      tabIndex: rootTabIndex,
      id: idAttribute,
      "aria-expanded": status.expandable ? status.expanded : void 0,
      "aria-selected": ariaSelected,
      "aria-disabled": status.disabled || void 0
    }, externalProps, {
      onFocus: createRootHandleFocus(externalEventHandlers),
      onBlur: createRootHandleBlur(externalEventHandlers),
      onKeyDown: createRootHandleKeyDown(externalEventHandlers)
    });
    if (indentationAtItemLevel) {
      props2.style = {
        "--TreeView-itemDepth": typeof depthContext === "function" ? depthContext(itemId) : depthContext
      };
    }
    const enhancedRootProps = ((_a = propsEnhancers.root) == null ? void 0 : _a.call(propsEnhancers, _extends({}, sharedPropsEnhancerParams, {
      externalEventHandlers
    }))) ?? {};
    return _extends({}, props2, enhancedRootProps);
  };
  const getContentProps = (externalProps = {}) => {
    var _a;
    const externalEventHandlers = extractEventHandlers_default(externalProps);
    const props2 = _extends({}, externalEventHandlers, externalProps, {
      ref: handleContentRef,
      onClick: createContentHandleClick(externalEventHandlers),
      onMouseDown: createContentHandleMouseDown(externalEventHandlers),
      status
    });
    if (indentationAtItemLevel) {
      props2.indentationAtItemLevel = true;
    }
    const enhancedContentProps = ((_a = propsEnhancers.content) == null ? void 0 : _a.call(propsEnhancers, _extends({}, sharedPropsEnhancerParams, {
      externalEventHandlers
    }))) ?? {};
    return _extends({}, props2, enhancedContentProps);
  };
  const getCheckboxProps = (externalProps = {}) => {
    const externalEventHandlers = extractEventHandlers_default(externalProps);
    return _extends({}, externalEventHandlers, {
      visible: checkboxSelection,
      ref: checkboxRef,
      checked: status.selected,
      disabled: disableSelection || status.disabled,
      tabIndex: -1
    }, externalProps, {
      onChange: createCheckboxHandleChange(externalEventHandlers)
    });
  };
  const getLabelProps = (externalProps = {}) => {
    const externalEventHandlers = _extends({}, extractEventHandlers_default(externalProps));
    const props2 = _extends({}, externalEventHandlers, {
      children: label
    }, externalProps, {
      onDoubleClick: createLabelHandleDoubleClick(externalEventHandlers)
    });
    if (instance.isTreeViewEditable) {
      props2.editable = status.editable;
    }
    return props2;
  };
  const getLabelInputProps = (externalProps = {}) => {
    var _a;
    const externalEventHandlers = extractEventHandlers_default(externalProps);
    const enhancedLabelInputProps = ((_a = propsEnhancers.labelInput) == null ? void 0 : _a.call(propsEnhancers, {
      rootRefObject,
      contentRefObject,
      externalEventHandlers,
      interactions
    })) ?? {};
    return _extends({}, externalProps, enhancedLabelInputProps);
  };
  const getIconContainerProps = (externalProps = {}) => {
    const externalEventHandlers = extractEventHandlers_default(externalProps);
    return _extends({}, externalEventHandlers, externalProps, {
      onClick: createIconContainerHandleClick(externalEventHandlers)
    });
  };
  const getGroupTransitionProps = (externalProps = {}) => {
    const externalEventHandlers = extractEventHandlers_default(externalProps);
    const response = _extends({}, externalEventHandlers, {
      unmountOnExit: true,
      component: "ul",
      role: "group",
      in: status.expanded,
      children
    }, externalProps);
    if (indentationAtItemLevel) {
      response.indentationAtItemLevel = true;
    }
    return response;
  };
  const getDragAndDropOverlayProps = (externalProps = {}) => {
    var _a;
    const externalEventHandlers = extractEventHandlers_default(externalProps);
    const enhancedDragAndDropOverlayProps = ((_a = propsEnhancers.dragAndDropOverlay) == null ? void 0 : _a.call(propsEnhancers, _extends({}, sharedPropsEnhancerParams, {
      externalEventHandlers
    }))) ?? {};
    return _extends({}, externalProps, enhancedDragAndDropOverlayProps);
  };
  return {
    getRootProps,
    getContentProps,
    getGroupTransitionProps,
    getIconContainerProps,
    getCheckboxProps,
    getLabelProps,
    getLabelInputProps,
    getDragAndDropOverlayProps,
    rootRef: handleRootRef,
    status,
    publicAPI
  };
};

// node_modules/@mui/x-tree-view/useTreeItem2/index.js
var useTreeItem22 = useTreeItem2;

// node_modules/@mui/x-tree-view/TreeItem2Icon/TreeItem2Icon.js
var React49 = __toESM(require_react());
var import_prop_types8 = __toESM(require_prop_types());
var import_jsx_runtime74 = __toESM(require_jsx_runtime());
function TreeItem2Icon(props2) {
  const {
    slots,
    slotProps,
    status
  } = props2;
  const context = useTreeViewContext();
  const contextIcons = _extends({}, context.icons.slots, {
    expandIcon: context.icons.slots.expandIcon ?? TreeViewExpandIcon,
    collapseIcon: context.icons.slots.collapseIcon ?? TreeViewCollapseIcon
  });
  const contextIconProps = context.icons.slotProps;
  let iconName;
  if (slots == null ? void 0 : slots.icon) {
    iconName = "icon";
  } else if (status.expandable) {
    if (status.expanded) {
      iconName = "collapseIcon";
    } else {
      iconName = "expandIcon";
    }
  } else {
    iconName = "endIcon";
  }
  const Icon = (slots == null ? void 0 : slots[iconName]) ?? contextIcons[iconName];
  const iconProps = useSlotProps_default({
    elementType: Icon,
    externalSlotProps: (tempOwnerState) => _extends({}, resolveComponentProps_default(contextIconProps[iconName], tempOwnerState), resolveComponentProps_default(slotProps == null ? void 0 : slotProps[iconName], tempOwnerState)),
    // TODO: Add proper ownerState
    ownerState: {}
  });
  if (!Icon) {
    return null;
  }
  return (0, import_jsx_runtime74.jsx)(Icon, _extends({}, iconProps));
}
true ? TreeItem2Icon.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types8.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types8.default.object,
  status: import_prop_types8.default.shape({
    disabled: import_prop_types8.default.bool.isRequired,
    editable: import_prop_types8.default.bool.isRequired,
    editing: import_prop_types8.default.bool.isRequired,
    expandable: import_prop_types8.default.bool.isRequired,
    expanded: import_prop_types8.default.bool.isRequired,
    focused: import_prop_types8.default.bool.isRequired,
    selected: import_prop_types8.default.bool.isRequired
  }).isRequired
} : void 0;

// node_modules/@mui/x-tree-view/TreeItem2/TreeItem2.js
var import_jsx_runtime75 = __toESM(require_jsx_runtime());
var _excluded6 = ["visible"];
var _excluded23 = ["id", "itemId", "label", "disabled", "children", "slots", "slotProps"];
var useThemeProps6 = createUseThemeProps("MuiTreeItem2");
var TreeItem2Root = styled_default("li", {
  name: "MuiTreeItem2",
  slot: "Root",
  overridesResolver: (props2, styles) => styles.root
})({
  listStyle: "none",
  margin: 0,
  padding: 0,
  outline: 0
});
var TreeItem2Content = styled_default("div", {
  name: "MuiTreeItem2",
  slot: "Content",
  overridesResolver: (props2, styles) => styles.content,
  shouldForwardProp: (prop) => shouldForwardProp(prop) && prop !== "status" && prop !== "indentationAtItemLevel"
})(({
  theme: theme3
}) => ({
  padding: theme3.spacing(0.5, 1),
  borderRadius: theme3.shape.borderRadius,
  width: "100%",
  boxSizing: "border-box",
  // prevent width + padding to overflow
  position: "relative",
  display: "flex",
  alignItems: "center",
  gap: theme3.spacing(1),
  cursor: "pointer",
  WebkitTapHighlightColor: "transparent",
  "&:hover": {
    backgroundColor: (theme3.vars || theme3).palette.action.hover,
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  variants: [{
    props: {
      indentationAtItemLevel: true
    },
    style: {
      paddingLeft: `calc(${theme3.spacing(1)} + var(--TreeView-itemChildrenIndentation) * var(--TreeView-itemDepth))`
    }
  }, {
    props: ({
      status
    }) => status.disabled,
    style: {
      opacity: (theme3.vars || theme3).palette.action.disabledOpacity,
      backgroundColor: "transparent"
    }
  }, {
    props: ({
      status
    }) => status.focused,
    style: {
      backgroundColor: (theme3.vars || theme3).palette.action.focus
    }
  }, {
    props: ({
      status
    }) => status.selected,
    style: {
      backgroundColor: theme3.vars ? `rgba(${theme3.vars.palette.primary.mainChannel} / ${theme3.vars.palette.action.selectedOpacity})` : alpha(theme3.palette.primary.main, theme3.palette.action.selectedOpacity),
      "&:hover": {
        backgroundColor: theme3.vars ? `rgba(${theme3.vars.palette.primary.mainChannel} / calc(${theme3.vars.palette.action.selectedOpacity} + ${theme3.vars.palette.action.hoverOpacity}))` : alpha(theme3.palette.primary.main, theme3.palette.action.selectedOpacity + theme3.palette.action.hoverOpacity),
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: theme3.vars ? `rgba(${theme3.vars.palette.primary.mainChannel} / ${theme3.vars.palette.action.selectedOpacity})` : alpha(theme3.palette.primary.main, theme3.palette.action.selectedOpacity)
        }
      }
    }
  }, {
    props: ({
      status
    }) => status.selected && status.focused,
    style: {
      backgroundColor: theme3.vars ? `rgba(${theme3.vars.palette.primary.mainChannel} / calc(${theme3.vars.palette.action.selectedOpacity} + ${theme3.vars.palette.action.focusOpacity}))` : alpha(theme3.palette.primary.main, theme3.palette.action.selectedOpacity + theme3.palette.action.focusOpacity)
    }
  }]
}));
var TreeItem2Label = styled_default("div", {
  name: "MuiTreeItem2",
  slot: "Label",
  overridesResolver: (props2, styles) => styles.label,
  shouldForwardProp: (prop) => shouldForwardProp(prop) && prop !== "editable"
})(({
  theme: theme3
}) => _extends({
  width: "100%",
  boxSizing: "border-box",
  // prevent width + padding to overflow
  // fixes overflow - see https://github.com/mui/material-ui/issues/27372
  minWidth: 0,
  position: "relative",
  overflow: "hidden"
}, theme3.typography.body1, {
  variants: [{
    props: ({
      editable
    }) => editable,
    style: {
      paddingLeft: "2px"
    }
  }]
}));
var TreeItem2IconContainer = styled_default("div", {
  name: "MuiTreeItem2",
  slot: "IconContainer",
  overridesResolver: (props2, styles) => styles.iconContainer
})({
  width: 16,
  display: "flex",
  flexShrink: 0,
  justifyContent: "center",
  "& svg": {
    fontSize: 18
  }
});
var TreeItem2GroupTransition = styled_default(Collapse_default, {
  name: "MuiTreeItem2",
  slot: "GroupTransition",
  overridesResolver: (props2, styles) => styles.groupTransition,
  shouldForwardProp: (prop) => shouldForwardProp(prop) && prop !== "indentationAtItemLevel"
})({
  margin: 0,
  padding: 0,
  paddingLeft: "var(--TreeView-itemChildrenIndentation)",
  variants: [{
    props: {
      indentationAtItemLevel: true
    },
    style: {
      paddingLeft: 0
    }
  }]
});
var TreeItem2Checkbox = styled_default(React50.forwardRef((props2, ref) => {
  const {
    visible
  } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded6);
  if (!visible) {
    return null;
  }
  return (0, import_jsx_runtime75.jsx)(Checkbox_default, _extends({}, other, {
    ref
  }));
}), {
  name: "MuiTreeItem2",
  slot: "Checkbox",
  overridesResolver: (props2, styles) => styles.checkbox
})({
  padding: 0
});
var useUtilityClasses5 = (ownerState) => {
  const {
    classes: classes12
  } = ownerState;
  const slots = {
    root: ["root"],
    content: ["content"],
    expanded: ["expanded"],
    editing: ["editing"],
    editable: ["editable"],
    selected: ["selected"],
    focused: ["focused"],
    disabled: ["disabled"],
    iconContainer: ["iconContainer"],
    checkbox: ["checkbox"],
    label: ["label"],
    groupTransition: ["groupTransition"],
    labelInput: ["labelInput"],
    dragAndDropOverlay: ["dragAndDropOverlay"]
  };
  return composeClasses(slots, getTreeItemUtilityClass, classes12);
};
var TreeItem22 = React50.forwardRef(function TreeItem23(inProps, forwardedRef) {
  const props2 = useThemeProps6({
    props: inProps,
    name: "MuiTreeItem2"
  });
  const {
    id,
    itemId,
    label,
    disabled,
    children,
    slots = {},
    slotProps = {}
  } = props2, other = _objectWithoutPropertiesLoose(props2, _excluded23);
  const {
    getRootProps,
    getContentProps,
    getIconContainerProps,
    getCheckboxProps,
    getLabelProps,
    getGroupTransitionProps,
    getLabelInputProps,
    getDragAndDropOverlayProps,
    status
  } = useTreeItem22({
    id,
    itemId,
    children,
    label,
    disabled
  });
  const ownerState = _extends({}, props2, status);
  const classes12 = useUtilityClasses5(ownerState);
  const Root2 = slots.root ?? TreeItem2Root;
  const rootProps = useSlotProps_default({
    elementType: Root2,
    getSlotProps: getRootProps,
    externalForwardedProps: other,
    externalSlotProps: slotProps.root,
    additionalProps: {
      ref: forwardedRef
    },
    ownerState: {},
    className: classes12.root
  });
  const Content = slots.content ?? TreeItem2Content;
  const contentProps = useSlotProps_default({
    elementType: Content,
    getSlotProps: getContentProps,
    externalSlotProps: slotProps.content,
    ownerState: {},
    className: clsx_default(classes12.content, status.expanded && classes12.expanded, status.selected && classes12.selected, status.focused && classes12.focused, status.disabled && classes12.disabled, status.editing && classes12.editing, status.editable && classes12.editable)
  });
  const IconContainer = slots.iconContainer ?? TreeItem2IconContainer;
  const iconContainerProps = useSlotProps_default({
    elementType: IconContainer,
    getSlotProps: getIconContainerProps,
    externalSlotProps: slotProps.iconContainer,
    ownerState: {},
    className: classes12.iconContainer
  });
  const Label = slots.label ?? TreeItem2Label;
  const labelProps = useSlotProps_default({
    elementType: Label,
    getSlotProps: getLabelProps,
    externalSlotProps: slotProps.label,
    ownerState: {},
    className: classes12.label
  });
  const Checkbox = slots.checkbox ?? TreeItem2Checkbox;
  const checkboxProps = useSlotProps_default({
    elementType: Checkbox,
    getSlotProps: getCheckboxProps,
    externalSlotProps: slotProps.checkbox,
    ownerState: {},
    className: classes12.checkbox
  });
  const GroupTransition = slots.groupTransition ?? void 0;
  const groupTransitionProps = useSlotProps_default({
    elementType: GroupTransition,
    getSlotProps: getGroupTransitionProps,
    externalSlotProps: slotProps.groupTransition,
    ownerState: {},
    className: classes12.groupTransition
  });
  const LabelInput = slots.labelInput ?? TreeItem2LabelInput;
  const labelInputProps = useSlotProps_default({
    elementType: LabelInput,
    getSlotProps: getLabelInputProps,
    externalSlotProps: slotProps.labelInput,
    ownerState: {},
    className: classes12.labelInput
  });
  const DragAndDropOverlay = slots.dragAndDropOverlay ?? TreeItem2DragAndDropOverlay;
  const dragAndDropOverlayProps = useSlotProps_default({
    elementType: DragAndDropOverlay,
    getSlotProps: getDragAndDropOverlayProps,
    externalSlotProps: slotProps.dragAndDropOverlay,
    ownerState: {},
    className: classes12.dragAndDropOverlay
  });
  return (0, import_jsx_runtime75.jsx)(TreeItem2Provider, {
    itemId,
    children: (0, import_jsx_runtime75.jsxs)(Root2, _extends({}, rootProps, {
      children: [(0, import_jsx_runtime75.jsxs)(Content, _extends({}, contentProps, {
        children: [(0, import_jsx_runtime75.jsx)(IconContainer, _extends({}, iconContainerProps, {
          children: (0, import_jsx_runtime75.jsx)(TreeItem2Icon, {
            status,
            slots,
            slotProps
          })
        })), (0, import_jsx_runtime75.jsx)(Checkbox, _extends({}, checkboxProps)), status.editing ? (0, import_jsx_runtime75.jsx)(LabelInput, _extends({}, labelInputProps)) : (0, import_jsx_runtime75.jsx)(Label, _extends({}, labelProps)), (0, import_jsx_runtime75.jsx)(DragAndDropOverlay, _extends({}, dragAndDropOverlayProps))]
      })), children && (0, import_jsx_runtime75.jsx)(TreeItem2GroupTransition, _extends({
        as: GroupTransition
      }, groupTransitionProps))]
    }))
  });
});
true ? TreeItem22.propTypes = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // | To update them edit the TypeScript types and run "pnpm proptypes"  |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: import_prop_types9.default.node,
  /**
   * Override or extend the styles applied to the component.
   */
  classes: import_prop_types9.default.object,
  className: import_prop_types9.default.string,
  /**
   * If `true`, the item is disabled.
   * @default false
   */
  disabled: import_prop_types9.default.bool,
  /**
   * The id attribute of the item. If not provided, it will be generated.
   */
  id: import_prop_types9.default.string,
  /**
   * The id of the item.
   * Must be unique.
   */
  itemId: import_prop_types9.default.string.isRequired,
  /**
   * The label of the item.
   */
  label: import_prop_types9.default.node,
  /**
   * Callback fired when the item root is blurred.
   */
  onBlur: import_prop_types9.default.func,
  /**
   * This prop isn't supported.
   * Use the `onItemFocus` callback on the tree if you need to monitor an item's focus.
   */
  onFocus: unsupportedProp,
  /**
   * Callback fired when a key is pressed on the keyboard and the tree is in focus.
   */
  onKeyDown: import_prop_types9.default.func,
  /**
   * The props used for each component slot.
   * @default {}
   */
  slotProps: import_prop_types9.default.object,
  /**
   * Overridable component slots.
   * @default {}
   */
  slots: import_prop_types9.default.object
} : void 0;

// node_modules/@mui/x-tree-view/hooks/useTreeViewApiRef.js
var React51 = __toESM(require_react());

// node_modules/@toolpad/studio/dist/exports/editor.mjs
var import_invariant10 = __toESM(require_browser(), 1);

// node_modules/@toolpad/utils/dist/comparators.js
function defaultComparator(a, b2) {
  if (a < b2) {
    return -1;
  }
  if (a > b2) {
    return 1;
  }
  return 0;
}
function alphabeticComparator(a, b2) {
  const { compare: compare2 } = new Intl.Collator();
  return compare2(a, b2);
}
function createPropComparator(propName, comparator = defaultComparator) {
  return (a, b2) => comparator(a[propName], b2[propName]);
}

// node_modules/@toolpad/studio/dist/exports/editor.mjs
var React76 = __toESM(require_react(), 1);

// node_modules/@mui/icons-material/esm/ModeEdit.js
var import_jsx_runtime76 = __toESM(require_jsx_runtime());
var ModeEdit_default = createSvgIcon((0, import_jsx_runtime76.jsx)("path", {
  d: "M3 17.25V21h3.75L17.81 9.94l-3.75-3.75zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34a.996.996 0 0 0-1.41 0l-1.83 1.83 3.75 3.75z"
}), "ModeEdit");

// node_modules/@toolpad/studio/dist/exports/editor.mjs
var React74 = __toESM(require_react(), 1);
var React75 = __toESM(require_react(), 1);
var React77 = __toESM(require_react(), 1);
var React78 = __toESM(require_react(), 1);
var React80 = __toESM(require_react(), 1);
var import_invariant11 = __toESM(require_browser(), 1);
var React822 = __toESM(require_react(), 1);
var React81 = __toESM(require_react(), 1);
var React83 = __toESM(require_react(), 1);
var import_invariant12 = __toESM(require_browser(), 1);
var React85 = __toESM(require_react(), 1);
var React87 = __toESM(require_react(), 1);

// node_modules/@mui/icons-material/esm/Refresh.js
var import_jsx_runtime77 = __toESM(require_jsx_runtime());
var Refresh_default = createSvgIcon((0, import_jsx_runtime77.jsx)("path", {
  d: "M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4z"
}), "Refresh");

// node_modules/@toolpad/studio/dist/exports/editor.mjs
var React86 = __toESM(require_react(), 1);
var React88 = __toESM(require_react(), 1);
var React89 = __toESM(require_react(), 1);
var React91 = __toESM(require_react(), 1);

// node_modules/@mui/icons-material/esm/ScatterPlot.js
var import_jsx_runtime78 = __toESM(require_jsx_runtime());
var ScatterPlot_default = createSvgIcon([(0, import_jsx_runtime78.jsx)("circle", {
  cx: "7",
  cy: "14",
  r: "3"
}, "0"), (0, import_jsx_runtime78.jsx)("circle", {
  cx: "11",
  cy: "6",
  r: "3"
}, "1"), (0, import_jsx_runtime78.jsx)("circle", {
  cx: "16.6",
  cy: "17.6",
  r: "3"
}, "2")], "ScatterPlot");

// node_modules/@mui/icons-material/esm/BarChart.js
var import_jsx_runtime79 = __toESM(require_jsx_runtime());
var BarChart_default = createSvgIcon((0, import_jsx_runtime79.jsx)("path", {
  d: "M4 9h4v11H4zm12 4h4v7h-4zm-6-9h4v16h-4z"
}), "BarChart");

// node_modules/@mui/icons-material/esm/ShowChart.js
var import_jsx_runtime80 = __toESM(require_jsx_runtime());
var ShowChart_default = createSvgIcon((0, import_jsx_runtime80.jsx)("path", {
  d: "m3.5 18.49 6-6.01 4 4L22 6.92l-1.41-1.41-7.09 7.97-4-4L2 16.99z"
}), "ShowChart");

// node_modules/@mui/icons-material/esm/LegendToggle.js
var import_jsx_runtime81 = __toESM(require_jsx_runtime());
var LegendToggle_default = createSvgIcon((0, import_jsx_runtime81.jsx)("path", {
  d: "M20 15H4v-2h16zm0 2H4v2h16zm-5-6 5-3.55V5l-5 3.55L10 5 4 8.66V11l5.92-3.61z"
}), "LegendToggle");

// node_modules/@toolpad/studio/dist/exports/editor.mjs
var React90 = __toESM(require_react(), 1);
var React922 = __toESM(require_react(), 1);
var React93 = __toESM(require_react(), 1);

// node_modules/@mui/icons-material/esm/AlignHorizontalLeft.js
var import_jsx_runtime82 = __toESM(require_jsx_runtime());
var AlignHorizontalLeft_default = createSvgIcon((0, import_jsx_runtime82.jsx)("path", {
  d: "M4 22H2V2h2zM22 7H6v3h16zm-6 7H6v3h10z"
}), "AlignHorizontalLeft");

// node_modules/@mui/icons-material/esm/AlignHorizontalCenter.js
var import_jsx_runtime83 = __toESM(require_jsx_runtime());
var AlignHorizontalCenter_default = createSvgIcon((0, import_jsx_runtime83.jsx)("path", {
  d: "M11 2h2v5h8v3h-8v4h5v3h-5v5h-2v-5H6v-3h5v-4H3V7h8z"
}), "AlignHorizontalCenter");

// node_modules/@mui/icons-material/esm/AlignHorizontalRight.js
var import_jsx_runtime84 = __toESM(require_jsx_runtime());
var AlignHorizontalRight_default = createSvgIcon((0, import_jsx_runtime84.jsx)("path", {
  d: "M20 2h2v20h-2zM2 10h16V7H2zm6 7h10v-3H8z"
}), "AlignHorizontalRight");

// node_modules/@toolpad/studio/dist/exports/editor.mjs
var React94 = __toESM(require_react(), 1);

// node_modules/@mui/icons-material/esm/AlignVerticalTop.js
var import_jsx_runtime85 = __toESM(require_jsx_runtime());
var AlignVerticalTop_default = createSvgIcon((0, import_jsx_runtime85.jsx)("path", {
  d: "M22 2v2H2V2zM7 22h3V6H7zm7-6h3V6h-3z"
}), "AlignVerticalTop");

// node_modules/@mui/icons-material/esm/AlignVerticalCenter.js
var import_jsx_runtime86 = __toESM(require_jsx_runtime());
var AlignVerticalCenter_default = createSvgIcon((0, import_jsx_runtime86.jsx)("path", {
  d: "M22 11h-5V6h-3v5h-4V3H7v8H1.84v2H7v8h3v-8h4v5h3v-5h5z"
}), "AlignVerticalCenter");

// node_modules/@mui/icons-material/esm/AlignVerticalBottom.js
var import_jsx_runtime87 = __toESM(require_jsx_runtime());
var AlignVerticalBottom_default = createSvgIcon((0, import_jsx_runtime87.jsx)("path", {
  d: "M22 22H2v-2h20zM10 2H7v16h3zm7 6h-3v10h3z"
}), "AlignVerticalBottom");

// node_modules/@toolpad/studio/dist/exports/editor.mjs
var React95 = __toESM(require_react(), 1);
var React96 = __toESM(require_react(), 1);
var React97 = __toESM(require_react(), 1);
var React100 = __toESM(require_react(), 1);
var React99 = __toESM(require_react(), 1);
var import_invariant13 = __toESM(require_browser(), 1);
var React1022 = __toESM(require_react(), 1);
var React107 = __toESM(require_react(), 1);
var React105 = __toESM(require_react(), 1);
var React103 = __toESM(require_react(), 1);

// node_modules/@mui/icons-material/esm/HelpOutlined.js
var import_jsx_runtime88 = __toESM(require_jsx_runtime());
var HelpOutlined_default = createSvgIcon((0, import_jsx_runtime88.jsx)("path", {
  d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m1 17h-2v-2h2zm2.07-7.75-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25"
}), "HelpOutlined");

// node_modules/@toolpad/studio/dist/exports/editor.mjs
var import_invariant14 = __toESM(require_browser(), 1);
var React104 = __toESM(require_react(), 1);

// node_modules/@mui/icons-material/esm/SettingsBrightnessOutlined.js
var import_jsx_runtime89 = __toESM(require_jsx_runtime());
var SettingsBrightnessOutlined_default = createSvgIcon((0, import_jsx_runtime89.jsx)("path", {
  d: "M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2m0 16.01H3V4.99h18zM8 16h2.5l1.5 1.5 1.5-1.5H16v-2.5l1.5-1.5-1.5-1.5V8h-2.5L12 6.5 10.5 8H8v2.5L6.5 12 8 13.5zm4-7c1.66 0 3 1.34 3 3s-1.34 3-3 3z"
}), "SettingsBrightnessOutlined");

// node_modules/@toolpad/studio/dist/exports/editor.mjs
var React106 = __toESM(require_react(), 1);
import productIconDark from "/Users/takutaku/workbench/ReactNext-Tutorial/myreact/studio/dog-app/node_modules/@toolpad/studio/dist/exports/product-icon-dark-XGNA2SGZ.svg";
import productIconLight from "/Users/takutaku/workbench/ReactNext-Tutorial/myreact/studio/dog-app/node_modules/@toolpad/studio/dist/exports/product-icon-light-AJK4O7HC.svg";

// node_modules/@mui/icons-material/esm/Article.js
var import_jsx_runtime90 = __toESM(require_jsx_runtime());
var Article_default = createSvgIcon((0, import_jsx_runtime90.jsx)("path", {
  d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2m-5 14H7v-2h7zm3-4H7v-2h10zm0-4H7V7h10z"
}), "Article");

// node_modules/@mui/icons-material/esm/Functions.js
var import_jsx_runtime91 = __toESM(require_jsx_runtime());
var Functions_default = createSvgIcon((0, import_jsx_runtime91.jsx)("path", {
  d: "M18 4H6v2l6.5 6L6 18v2h12v-3h-7l5-5-5-5h7z"
}), "Functions");

// node_modules/@toolpad/studio/dist/exports/editor.mjs
var React108 = __toESM(require_react(), 1);
var React110 = __toESM(require_react(), 1);

// node_modules/@mui/icons-material/esm/Google.js
var React52 = __toESM(require_react());
var import_jsx_runtime92 = __toESM(require_jsx_runtime());
var Google_default = createSvgIcon((0, import_jsx_runtime92.jsx)("path", {
  d: "M12.545,10.239v3.821h5.445c-0.712,2.315-2.647,3.972-5.445,3.972c-3.332,0-6.033-2.701-6.033-6.032s2.701-6.032,6.033-6.032c1.498,0,2.866,0.549,3.921,1.453l2.814-2.814C17.503,2.988,15.139,2,12.545,2C7.021,2,2.543,6.477,2.543,12s4.478,10,10.002,10c8.396,0,10.249-7.85,9.426-11.748L12.545,10.239z"
}), "Google");

// node_modules/@toolpad/studio/dist/exports/editor.mjs
var import_invariant15 = __toESM(require_browser(), 1);
var React109 = __toESM(require_react(), 1);
var resizablePanels_exports = {};
__export2(resizablePanels_exports, {
  PanelResizeHandle: () => PanelResizeHandle2
});
__reExport(resizablePanels_exports, react_resizable_panels_browser_development_esm_exports);
var RESIZE_HANDLE_OFFSET = 3;
var PanelResizeHandle2 = styled_default(PanelResizeHandle)(
  ({ theme: theme3 }) => ({
    backgroundClip: "padding-box",
    zIndex: 1,
    display: "flex",
    backgroundColor: theme3.palette.divider,
    borderStyle: "solid",
    borderColor: "rgba(255, 255, 255, 0)",
    "&:hover": {
      borderColor: theme3.palette.divider
    },
    transition: "all 250ms ease",
    '&[data-panel-group-direction="horizontal"]': {
      width: 2 * RESIZE_HANDLE_OFFSET + 1,
      marginLeft: -RESIZE_HANDLE_OFFSET,
      marginRight: -RESIZE_HANDLE_OFFSET,
      borderLeftWidth: RESIZE_HANDLE_OFFSET,
      borderRightWidth: RESIZE_HANDLE_OFFSET
    },
    '&[data-panel-group-direction="vertical"]': {
      height: 2 * RESIZE_HANDLE_OFFSET + 1,
      marginTop: -RESIZE_HANDLE_OFFSET,
      marginBottom: -RESIZE_HANDLE_OFFSET,
      borderTopWidth: RESIZE_HANDLE_OFFSET,
      borderBottomWidth: RESIZE_HANDLE_OFFSET
    }
  })
);
async function fetchAppDevManifest(url) {
  const response = await fetch(`${url}/__toolpad_dev__/manifest.json`);
  if (!response.ok) {
    throw new Error(`Failed to fetch app dev manifest: ${response.status}`);
  }
  return response.text();
}
function createProject(url, serializedManifest, queryClient3) {
  const manifest = JSON.parse(serializedManifest);
  const events = new Emitter();
  const ws = new WebSocket(manifest.wsUrl);
  ws.addEventListener("error", () => console.error(`Websocket failed to connect "${ws.url}"`));
  ws.addEventListener("open", () => {
    console.log("Socket connected");
  });
  ws.addEventListener("message", (event) => {
    const message = JSON.parse(event.data);
    switch (message.kind) {
      case "projectEvent": {
        events.emit(message.event, message.payload);
        break;
      }
      default:
        throw new Error(`Unknown message kind: ${message.kind}`);
    }
  });
  const api = createRpcApi(queryClient3, `${url}/__toolpad_dev__/rpc`);
  const unsubExternalChange = events.subscribe("externalChange", () => {
    api.invalidateQueries("loadDom", []);
  });
  const unsubFunctionsChanged = events.subscribe("functionsChanged", () => {
    api.invalidateQueries("introspect", []);
  });
  const dispose = () => {
    if (ws.readyState === ws.OPEN) {
      ws.close();
    } else {
      ws.onopen = () => {
        ws.close();
      };
    }
    unsubExternalChange();
    unsubFunctionsChanged();
  };
  return {
    url,
    rootDir: manifest.rootDir,
    api,
    events,
    dispose
  };
}
var ProjectContext = React53.createContext(void 0);
function ProjectProvider({ url, children, fallback }) {
  const { data: manifest } = useSuspenseQuery({
    queryKey: ["app-dev-manifest", url],
    queryFn: () => fetchAppDevManifest(url)
  });
  (0, import_invariant2.default)(manifest, "manifest should be defined, we're using suspense");
  const queryClient3 = useQueryClient();
  const [project, setProject] = React53.useState();
  React53.useEffect(() => {
    const newProject = createProject(url, manifest, queryClient3);
    setProject(newProject);
    return () => {
      newProject.dispose();
    };
  }, [url, manifest, queryClient3]);
  return React53.createElement(ProjectContext.Provider, { value: project }, project ? children : fallback);
}
function useProject() {
  return useNonNullableContext(ProjectContext);
}
function absolutePositionCss({ x: x2, y: y2, width, height }) {
  return { left: x2, top: y2, width, height };
}
function isHorizontalFlow(flowDirection) {
  return flowDirection === "row" || flowDirection === "row-reverse";
}
function isVerticalFlow(flowDirection) {
  return flowDirection === "column" || flowDirection === "column-reverse";
}
function isReverseFlow(flowDirection) {
  return flowDirection === "row-reverse" || flowDirection === "column-reverse";
}
function getRelativeBoundingRect(containerElm, childElm) {
  const containerRect = containerElm.getBoundingClientRect();
  const childRect = childElm.getBoundingClientRect();
  return {
    x: childRect.x - containerRect.x,
    y: childRect.y - containerRect.y,
    width: childRect.width,
    height: childRect.height
  };
}
function getRelativeOuterRect(containerElm, childElm) {
  const { x: x2, y: y2, width, height } = getRelativeBoundingRect(containerElm, childElm);
  const styles = window.getComputedStyle(childElm);
  const parseMarginStyle = (style) => style === "auto" ? 0 : parseFloat(style);
  let offsetLeft = parseMarginStyle(styles.marginLeft);
  let offsetRight = parseMarginStyle(styles.marginRight);
  let offsetTop = parseMarginStyle(styles.marginTop);
  let offsetBottom = parseMarginStyle(styles.marginBottom);
  if (styles.boxSizing === "content-box") {
    offsetLeft += parseFloat(styles.paddingLeft) + parseFloat(styles.borderLeftWidth);
    offsetRight += parseFloat(styles.paddingRight) + parseFloat(styles.borderRightWidth);
    offsetTop += parseFloat(styles.paddingTop) + parseFloat(styles.borderTopWidth);
    offsetBottom += parseFloat(styles.paddingBottom) + parseFloat(styles.borderBottomWidth);
  }
  return {
    x: x2 - offsetLeft,
    y: y2 - offsetTop,
    width: width + offsetLeft + offsetRight,
    height: height + offsetTop + offsetBottom
  };
}
function rectContainsPoint(rect, x2, y2) {
  return rect.x <= x2 && rect.x + rect.width >= x2 && rect.y <= y2 && rect.y + rect.height >= y2;
}
var RECTANGLE_EDGE_TOP = "top";
var RECTANGLE_EDGE_BOTTOM = "bottom";
var RECTANGLE_EDGE_LEFT = "left";
var RECTANGLE_EDGE_RIGHT = "right";
function getRectanglePointActiveEdge(rect, x2, y2) {
  const { height: rectHeight, width: rectWidth } = rect;
  if (x2 < 0 || x2 > rectWidth || y2 < 0 || y2 > rectHeight) {
    return null;
  }
  const isOverFirstDiagonal = y2 < rectHeight / rectWidth * x2;
  const isOverSecondDiagonal = y2 < -1 * (rectHeight / rectWidth) * x2 + rectHeight;
  if (isOverFirstDiagonal && isOverSecondDiagonal) {
    return RECTANGLE_EDGE_TOP;
  }
  if (isOverFirstDiagonal) {
    return RECTANGLE_EDGE_RIGHT;
  }
  if (isOverSecondDiagonal) {
    return RECTANGLE_EDGE_LEFT;
  }
  return RECTANGLE_EDGE_BOTTOM;
}
function useProjectApi() {
  const project = useProject();
  return project.api;
}
function useShortcut({ key: key2, metaKey = false, disabled = false, shiftKey = false, preventDefault = true }, handler) {
  React210.useEffect(() => {
    if (disabled) {
      return () => {
      };
    }
    const handleKeydown = (event) => {
      if (event.key.toLowerCase() === key2 && (event.metaKey === metaKey || event.ctrlKey === metaKey) && event.shiftKey === shiftKey) {
        handler(event);
        if (preventDefault) {
          event.preventDefault();
        }
      }
    };
    document.addEventListener("keydown", handleKeydown);
    return () => document.removeEventListener("keydown", handleKeydown);
  }, [key2, metaKey, shiftKey, handler, disabled, preventDefault]);
}
var SINGLE_ACTION_INPUT_TYPES = ["checkbox", "radio", "range", "color"];
function hasFieldFocus(documentTarget = document) {
  const activeElement = documentTarget.activeElement;
  if (!activeElement) {
    return false;
  }
  const { nodeName, contentEditable } = activeElement;
  const type = activeElement.getAttribute("type") || "";
  const focusedInput = nodeName === "INPUT" && !SINGLE_ACTION_INPUT_TYPES.includes(type);
  const focusedTextarea = nodeName === "TEXTAREA";
  const focusedContentEditable = contentEditable === "true";
  return focusedInput || focusedTextarea || focusedContentEditable;
}
var PREFIX = "/editor";
function getPathnameFromView(view) {
  switch (view.kind) {
    case "page":
      return view.name ? `${PREFIX}/app/pages/${view.name}` : `${PREFIX}/app/pages`;
    default:
      throw new Error(`Unknown view "${view.kind}".`);
  }
}
function getViewFromPathname(pathname) {
  const pageRouteMatch = matchPath(`${PREFIX}/app/pages/:pageName`, pathname);
  if (pageRouteMatch == null ? void 0 : pageRouteMatch.params.pageName) {
    return {
      kind: "page",
      name: pageRouteMatch.params.pageName,
      selectedNodeId: null,
      pageViewTab: "page"
    };
  }
  return null;
}
function getNodeHashes(dom) {
  return mapValues(dom.nodes, (node) => insecureHash(JSON.stringify(omit(node, "id"))));
}
function domReducer(dom, action) {
  switch (action.type) {
    case "UPDATE": {
      return action.updater ? action.updater(dom) : dom;
    }
    default:
      return dom;
  }
}
var UNDO_HISTORY_LIMIT = 100;
function appStateReducer(state, action) {
  var _a, _b, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l, _m, _n2, _o2, _p, _q, _r2, _s, _t2, _u2, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F, _G, _H, _I;
  if (state.dom) {
    const newDom = domReducer(state.dom, action);
    const hasUnsavedDomChanges = newDom !== state.dom;
    state = update(state, {
      dom: newDom,
      unsavedDomChanges: hasUnsavedDomChanges ? state.unsavedDomChanges + 1 : state.unsavedDomChanges
    });
  }
  switch (action.type) {
    case "DOM_SAVING": {
      return update(state, {
        savingDom: true,
        saveDomError: null
      });
    }
    case "DOM_SAVED": {
      return update(state, {
        savedDom: action.savedDom,
        savingDom: false,
        saveDomError: null,
        unsavedDomChanges: 0
      });
    }
    case "DOM_SAVING_ERROR": {
      return update(state, {
        savingDom: false,
        saveDomError: action.error
      });
    }
    case "DOM_SERVER_UPDATE": {
      if (state.unsavedDomChanges > 0) {
        return state;
      }
      return update(state, { dom: action.dom, savedDom: action.dom });
    }
    case "UPDATE_HISTORY": {
      const updatedUndoStack = [
        ...state.undoStack,
        {
          dom: state.dom,
          view: state.currentView,
          timestamp: Date.now()
        }
      ];
      if (updatedUndoStack.length > UNDO_HISTORY_LIMIT) {
        updatedUndoStack.shift();
      }
      return update(state, {
        undoStack: updatedUndoStack,
        redoStack: []
      });
    }
    case "UNDO": {
      const undoStack = [...state.undoStack];
      const redoStack = [...state.redoStack];
      if (undoStack.length < 2) {
        return state;
      }
      const currentState = undoStack.pop();
      const previousStackEntry = undoStack[undoStack.length - 1];
      if (!previousStackEntry || !currentState) {
        return state;
      }
      redoStack.push(currentState);
      return update(state, {
        dom: previousStackEntry.dom,
        currentView: previousStackEntry.view,
        undoStack,
        redoStack
      });
    }
    case "REDO": {
      const undoStack = [...state.undoStack];
      const redoStack = [...state.redoStack];
      const nextStackEntry = redoStack.pop();
      if (!nextStackEntry) {
        return state;
      }
      undoStack.push(nextStackEntry);
      return update(state, {
        dom: nextStackEntry.dom,
        currentView: nextStackEntry.view,
        undoStack,
        redoStack
      });
    }
    case "SELECT_NODE": {
      if (state.currentView.kind === "page") {
        return update(state, {
          currentView: {
            ...state.currentView,
            selectedNodeId: action.nodeId,
            pageViewTab: "component"
          }
        });
      }
      return state;
    }
    case "DESELECT_NODE": {
      if (state.currentView.kind === "page") {
        return update(state, {
          currentView: { ...state.currentView, selectedNodeId: null, pageViewTab: "page" }
        });
      }
      return state;
    }
    case "HOVER_NODE": {
      if (state.currentView.kind === "page") {
        return update(state, {
          currentView: { ...state.currentView, hoveredNodeId: action.nodeId }
        });
      }
      return state;
    }
    case "BLUR_HOVER_NODE": {
      if (state.currentView.kind === "page") {
        return update(state, {
          currentView: { ...state.currentView, hoveredNodeId: null }
        });
      }
      return state;
    }
    case "SET_VIEW":
    case "UPDATE": {
      if (!action.view) {
        return state;
      }
      let newView = action.view;
      if (action.view.kind === "page") {
        if (typeof action.view.selectedNodeId === "undefined") {
          const isSameNode = action.view.name === state.currentView.name;
          newView = {
            ...action.view,
            selectedNodeId: state.currentView.kind === "page" && isSameNode ? state.currentView.selectedNodeId : null
          };
        }
        if (action.view.selectedNodeId && typeof action.view.pageViewTab === "undefined") {
          newView = {
            ...action.view,
            pageViewTab: "component"
          };
        }
      }
      return update(state, {
        currentView: newView
      });
    }
    case "SET_PAGE_VIEW_TAB": {
      if (state.currentView.kind === "page") {
        return update(state, {
          currentView: { ...state.currentView, pageViewTab: action.tab }
        });
      }
      return state;
    }
    case "SET_HAS_UNSAVED_CHANGES": {
      return update(state, {
        hasUnsavedChanges: action.hasUnsavedChanges
      });
    }
    case "SAVE_QUERY_DRAFT": {
      if (state.currentView.kind === "page" && ((_a = state.currentView.view) == null ? void 0 : _a.kind) === "query") {
        const queryTabs = ((_b = state.currentView.queryPanel) == null ? void 0 : _b.queryTabs) || [];
        const currentTabIndex = (_c = state.currentView.queryPanel) == null ? void 0 : _c.currentTabIndex;
        if (currentTabIndex !== void 0 && queryTabs) {
          let newDom = state.dom;
          let nodeName = action.draft.name;
          let target = action.draft;
          try {
            getNode(state.dom, action.draft.id);
          } catch (err) {
            if ((_d = state.currentView) == null ? void 0 : _d.name) {
              const pageNode = getPageByName(state.dom, state.currentView.name);
              if (pageNode) {
                newDom = addNode(state.dom, action.draft, pageNode, "queries");
                const createdNode = getNode(newDom, action.draft.id, "query");
                nodeName = createdNode.name;
                newDom = saveNode(newDom, createdNode);
                target = createdNode;
              }
            }
          }
          newDom = saveNode(newDom, target);
          return update(state, {
            currentView: {
              ...state.currentView,
              queryPanel: {
                ...state.currentView.queryPanel,
                queryTabs: (_g = (_f = (_e2 = state.currentView) == null ? void 0 : _e2.queryPanel) == null ? void 0 : _f.queryTabs) == null ? void 0 : _g.map((tab, index) => {
                  if (index === currentTabIndex) {
                    return {
                      ...tab,
                      draft: target,
                      meta: {
                        ...tab.meta,
                        name: nodeName
                      },
                      saved: target
                    };
                  }
                  return tab;
                })
              }
            },
            dom: newDom
          });
        }
      }
      return state;
    }
    case "UPDATE_QUERY_DRAFT": {
      if (state.currentView.kind === "page" && ((_h = state.currentView.view) == null ? void 0 : _h.kind) === "query") {
        const queryTabs = ((_i = state.currentView.queryPanel) == null ? void 0 : _i.queryTabs) || [];
        const currentTabIndex = (_j = state.currentView.queryPanel) == null ? void 0 : _j.currentTabIndex;
        if (currentTabIndex !== void 0 && queryTabs) {
          return update(state, {
            currentView: {
              ...state.currentView,
              queryPanel: {
                ...state.currentView.queryPanel,
                queryTabs: (_m = (_l = (_k = state.currentView) == null ? void 0 : _k.queryPanel) == null ? void 0 : _l.queryTabs) == null ? void 0 : _m.map((tab, index) => {
                  if (index === currentTabIndex) {
                    if (action.updater && tab.draft) {
                      return {
                        ...tab,
                        draft: action.updater(tab.draft)
                      };
                    }
                  }
                  return tab;
                })
              }
            }
          });
        }
      }
      return state;
    }
    case "CREATE_QUERY_TAB": {
      if (state.currentView.kind !== "page" || !state.currentView.name) {
        return state;
      }
      const draftNode = createNode(state.dom, "query", {
        name: action.mode === "mutation" ? "action" : "query",
        attributes: {
          query: (_n2 = action.dataSource) == null ? void 0 : _n2.getInitialQueryValue(),
          mode: action.mode ?? void 0,
          connectionId: null,
          dataSource: action == null ? void 0 : action.dataSourceId
        }
      });
      const newView = { ...state.currentView };
      if ((_o2 = state.currentView.queryPanel) == null ? void 0 : _o2.queryTabs) {
        newView.view = { kind: "query", nodeId: draftNode.id };
        newView.queryPanel = {
          queryTabs: [
            ...state.currentView.queryPanel.queryTabs,
            {
              meta: {
                id: draftNode.id,
                name: draftNode.name,
                dataSource: action.dataSourceId,
                mode: (_p = draftNode.attributes) == null ? void 0 : _p.mode
              },
              saved: draftNode,
              draft: draftNode,
              toolsTabType: "preview",
              isPreviewLoading: false
            }
          ],
          currentTabIndex: state.currentView.queryPanel.queryTabs.length
        };
      } else {
        newView.view = { kind: "query", nodeId: draftNode.id };
        newView.queryPanel = {
          queryTabs: [
            {
              meta: {
                id: draftNode.id,
                name: draftNode.name,
                dataSource: action.dataSourceId,
                mode: (_q = draftNode.attributes) == null ? void 0 : _q.mode
              },
              saved: draftNode,
              draft: draftNode,
              isPreviewLoading: false,
              toolsTabType: "preview"
            }
          ],
          currentTabIndex: 0
        };
      }
      return update(state, {
        currentView: newView
      });
    }
    case "OPEN_QUERY_TAB": {
      if (state.currentView.kind !== "page" || !state.currentView.name) {
        return state;
      }
      if (state.currentView.name) {
        if (((_s = (_r2 = state.currentView) == null ? void 0 : _r2.view) == null ? void 0 : _s.kind) === "query" && action.queryId === ((_t2 = state.currentView.view) == null ? void 0 : _t2.nodeId)) {
          return state;
        }
        const selectedQueryTabIndex = (_w = (_v = (_u2 = state == null ? void 0 : state.currentView) == null ? void 0 : _u2.queryPanel) == null ? void 0 : _v.queryTabs) == null ? void 0 : _w.findIndex(
          (tab) => {
            return tab.meta.id === action.queryId;
          }
        );
        if (selectedQueryTabIndex !== void 0 && selectedQueryTabIndex > -1) {
          return update(state, {
            currentView: update(state.currentView, {
              view: { kind: "query", nodeId: action.queryId },
              queryPanel: update(state.currentView.queryPanel, {
                currentTabIndex: selectedQueryTabIndex
              })
            })
          });
        }
        let newTabIndex;
        let newTabs;
        const pageNode = getPageByName(state.dom, state.currentView.name);
        if (pageNode) {
          const queries = getChildNodes(state.dom, pageNode).queries ?? [];
          if (queries.length) {
            const selectedQuery = queries == null ? void 0 : queries.find((query) => (query == null ? void 0 : query.id) === action.queryId);
            const newTab = {
              meta: {
                id: action.queryId,
                name: selectedQuery == null ? void 0 : selectedQuery.name,
                dataSource: (_x = selectedQuery == null ? void 0 : selectedQuery.attributes) == null ? void 0 : _x.dataSource,
                mode: (_y = selectedQuery == null ? void 0 : selectedQuery.attributes) == null ? void 0 : _y.mode
              },
              saved: selectedQuery,
              draft: selectedQuery,
              toolsTabType: "preview",
              isPreviewLoading: false
            };
            if (!((_A = (_z = state.currentView) == null ? void 0 : _z.queryPanel) == null ? void 0 : _A.queryTabs) || ((_D = (_C = (_B = state == null ? void 0 : state.currentView) == null ? void 0 : _B.queryPanel) == null ? void 0 : _C.queryTabs) == null ? void 0 : _D.length) === 0) {
              newTabIndex = 0;
              newTabs = [newTab];
            } else {
              newTabIndex = (_E = state.currentView) == null ? void 0 : _E.queryPanel.queryTabs.length;
              newTabs = [...state.currentView.queryPanel.queryTabs, newTab];
            }
            return update(state, {
              currentView: {
                ...state.currentView,
                view: { kind: "query", nodeId: action.queryId },
                queryPanel: {
                  currentTabIndex: newTabIndex,
                  queryTabs: newTabs
                }
              }
            });
          }
        }
      }
      return state;
    }
    case "UPDATE_QUERY_TAB": {
      if (state.currentView.kind !== "page" || !state.currentView.name) {
        return state;
      }
      return update(state, {
        currentView: {
          ...state.currentView,
          queryPanel: {
            ...state.currentView.queryPanel,
            queryTabs: (_G = (_F = state.currentView.queryPanel) == null ? void 0 : _F.queryTabs) == null ? void 0 : _G.map((tab, index) => {
              var _a2;
              if (index === ((_a2 = state.currentView.queryPanel) == null ? void 0 : _a2.currentTabIndex)) {
                return action.updater ? action.updater(tab) : tab;
              }
              return tab;
            })
          }
        }
      });
    }
    case "CLOSE_QUERY_TAB": {
      if (state.currentView.kind !== "page" || !state.currentView.name) {
        return state;
      }
      const tabs = (_H = state.currentView.queryPanel) == null ? void 0 : _H.queryTabs;
      const newView = { ...state.currentView };
      const newTabs = tabs == null ? void 0 : tabs.filter((tab) => tab.meta.id !== action.queryId);
      let newDom = state.dom;
      if (tabs && action.queryId !== void 0) {
        if (tabs.length === 1) {
          newView.view = void 0;
          newView.queryPanel = {
            queryTabs: void 0,
            currentTabIndex: void 0
          };
        }
      }
      const currentTabIndex = (_I = state.currentView.queryPanel) == null ? void 0 : _I.currentTabIndex;
      if (currentTabIndex !== void 0 && action.queryId && action.queryIndex !== void 0) {
        if (action.queryIndex !== currentTabIndex) {
          const newTabIndex = currentTabIndex > action.queryIndex ? currentTabIndex - 1 : currentTabIndex;
          newView.queryPanel = {
            queryTabs: newTabs,
            currentTabIndex: newTabIndex
          };
        } else {
          const queryIds = tabs == null ? void 0 : tabs.map((tab) => tab.meta.id);
          const replacementQueryId = queryIds == null ? void 0 : queryIds[action.queryIndex === 0 ? currentTabIndex + 1 : currentTabIndex - 1];
          const replacementTabIndex = action.queryIndex === 0 ? currentTabIndex : currentTabIndex - 1;
          if (replacementQueryId) {
            newView.view = { kind: "query", nodeId: replacementQueryId };
            newView.queryPanel = {
              queryTabs: newTabs,
              currentTabIndex: replacementTabIndex
            };
          }
        }
      }
      if (action.deleteQuery) {
        newDom = removeNode(state.dom, action.queryId);
      }
      return update(state, {
        dom: newDom,
        currentView: newView
      });
    }
    case "CLOSE_QUERY_PANEL": {
      if (state.currentView.kind === "page") {
        return update(state, {
          currentView: {
            ...state.currentView,
            view: void 0,
            queryPanel: void 0
          }
        });
      }
      return state;
    }
    default:
      return state;
  }
}
function createDomApi(dispatch) {
  return {
    update(updater) {
      dispatch({
        type: "UPDATE",
        updater
      });
    },
    setNodeName(nodeId, name) {
      dispatch({
        type: "UPDATE",
        updater(dom) {
          const node = getNode(dom, nodeId);
          return setNodeName(dom, node, name);
        }
      });
    },
    saveNode(node) {
      dispatch({
        type: "UPDATE",
        updater(dom) {
          return saveNode(dom, node);
        }
      });
    }
  };
}
function createAppStateApi(dispatch, scheduleTextInputHistoryUpdate) {
  return {
    update(updater, view) {
      dispatch({
        type: "UPDATE",
        updater,
        view
      });
    },
    undo() {
      scheduleTextInputHistoryUpdate == null ? void 0 : scheduleTextInputHistoryUpdate.flush();
      dispatch({ type: "UNDO" });
    },
    redo() {
      dispatch({ type: "REDO" });
    },
    setView(view) {
      dispatch({
        type: "SET_VIEW",
        view
      });
    },
    setPageViewTab(tab) {
      dispatch({
        type: "SET_PAGE_VIEW_TAB",
        tab
      });
    },
    selectNode(nodeId) {
      dispatch({
        type: "SELECT_NODE",
        nodeId
      });
    },
    hoverNode(nodeId) {
      dispatch({
        type: "HOVER_NODE",
        nodeId
      });
    },
    blurHoverNode() {
      dispatch({
        type: "BLUR_HOVER_NODE"
      });
    },
    deselectNode() {
      dispatch({
        type: "DESELECT_NODE"
      });
    },
    setHasUnsavedChanges(hasUnsavedChanges) {
      dispatch({
        type: "SET_HAS_UNSAVED_CHANGES",
        hasUnsavedChanges
      });
    },
    openQueryTab(queryId) {
      dispatch({
        type: "OPEN_QUERY_TAB",
        queryId
      });
    },
    createQueryTab(dataSource3, dataSourceId, mode) {
      dispatch({
        type: "CREATE_QUERY_TAB",
        dataSource: dataSource3,
        dataSourceId,
        mode
      });
    },
    updateQueryTab(updater) {
      dispatch({
        type: "UPDATE_QUERY_TAB",
        updater
      });
    },
    closeQueryTab(queryId, queryIndex, deleteQuery) {
      dispatch({
        type: "CLOSE_QUERY_TAB",
        queryId,
        queryIndex,
        deleteQuery
      });
    },
    closeQueryPanel() {
      dispatch({
        type: "CLOSE_QUERY_PANEL"
      });
    },
    updateQueryDraft(updater) {
      dispatch({
        type: "UPDATE_QUERY_DRAFT",
        updater
      });
    },
    saveQueryDraft(draft) {
      dispatch({
        type: "SAVE_QUERY_DRAFT",
        draft
      });
    }
  };
}
var [useAppStateContext, AppStateProvider] = createProvidedContext("AppState");
function useAppState() {
  return useAppStateContext();
}
var DomApiContext = React310.createContext(createDomApi(() => void 0));
function useDomApi() {
  return React310.useContext(DomApiContext);
}
var AppStateApiContext = React310.createContext(createAppStateApi(() => void 0));
function useAppStateApi() {
  return React310.useContext(AppStateApiContext);
}
var previousUnsavedChanges = 0;
function logUnsavedChanges(unsavedChanges) {
  const hasUnsavedChanges = unsavedChanges >= 1;
  if (!hasUnsavedChanges && previousUnsavedChanges > 0) {
    console.log(`${previousUnsavedChanges} changes saved.`);
  }
  previousUnsavedChanges = unsavedChanges;
}
var UNDOABLE_ACTIONS = /* @__PURE__ */ new Set([
  "UPDATE",
  "SET_VIEW",
  "SET_PAGE_VIEW_TAB",
  "SELECT_NODE",
  "DESELECT_NODE",
  "UPDATE_QUERY_DRAFT",
  "OPEN_QUERY_TAB",
  "CREATE_QUERY_TAB",
  "CLOSE_QUERY_TAB"
]);
function isCancellableAction(action) {
  return Boolean(
    action.type === "SET_VIEW" || action.type === "UPDATE" && action.view || action.type === "UPDATE_QUERY_DRAFT" && action.updater
  );
}
function AppProvider({ appUrl, children }) {
  const projectApi = useProjectApi();
  const { data: dom } = projectApi.useSuspenseQuery("loadDom", []);
  (0, import_invariant3.default)(dom, "Suspense should load the dom");
  const location = useLocation();
  const app = getApp(dom);
  const { pages = [] } = getChildNodes(dom, app);
  const firstPage = pages.length > 0 ? pages[0] : null;
  const initialView = getViewFromPathname(location.pathname) || {
    kind: "page",
    name: firstPage == null ? void 0 : firstPage.name,
    selectedNodeId: null,
    pageViewTab: "page"
  };
  const [state, dispatch] = React310.useReducer(appStateReducer, {
    // DOM state
    dom,
    // base path of the running application
    appUrl,
    // DOM loader state
    savingDom: false,
    unsavedDomChanges: 0,
    saveDomError: null,
    savedDom: dom,
    // App state
    currentView: initialView,
    undoStack: [
      {
        dom,
        view: initialView,
        timestamp: Date.now()
      }
    ],
    redoStack: [],
    hasUnsavedChanges: false
  });
  React310.useEffect(() => {
    dispatch({
      type: "DOM_SERVER_UPDATE",
      dom
    });
  }, [dom]);
  const scheduleTextInputHistoryUpdate = React310.useMemo(
    () => debounce_default(() => {
      dispatch({ type: "UPDATE_HISTORY" });
    }, 500),
    []
  );
  const dispatchWithHistory = useEventCallback_default((action) => {
    if (state.hasUnsavedChanges && isCancellableAction(action)) {
      const ok = window.confirm(
        "You have unsaved changes. Are you sure you want to navigate away? All changes will be discarded."
      );
      if (!ok) {
        return;
      }
    }
    dispatch(action);
    if (UNDOABLE_ACTIONS.has(action.type)) {
      if (hasFieldFocus()) {
        scheduleTextInputHistoryUpdate();
      } else {
        dispatch({ type: "UPDATE_HISTORY" });
      }
    }
  });
  const domApi = React310.useMemo(() => createDomApi(dispatchWithHistory), [dispatchWithHistory]);
  const appStateApi = React310.useMemo(
    () => createAppStateApi(dispatchWithHistory, scheduleTextInputHistoryUpdate),
    [dispatchWithHistory, scheduleTextInputHistoryUpdate]
  );
  const handleSave = React310.useCallback(() => {
    if (!state.dom || state.savingDom || state.savedDom === state.dom) {
      return;
    }
    const domToSave = state.dom;
    dispatch({ type: "DOM_SAVING" });
    const domDiff = createDiff(state.savedDom, domToSave);
    projectApi.methods.applyDomDiff(domDiff).then(() => {
      dispatch({ type: "DOM_SAVED", savedDom: domToSave });
    }).catch((err) => {
      dispatch({ type: "DOM_SAVING_ERROR", error: err.message });
    });
  }, [projectApi, state]);
  const debouncedHandleSave = useDebouncedHandler(handleSave, 100);
  React310.useEffect(() => {
    debouncedHandleSave();
  }, [state.dom, debouncedHandleSave]);
  React310.useEffect(() => {
    logUnsavedChanges(state.unsavedDomChanges);
    if (state.unsavedDomChanges <= 0 && !state.hasUnsavedChanges) {
      return () => {
      };
    }
    const onBeforeUnload = (event) => {
      event.preventDefault();
      event.returnValue = `You have unsaved changes. Are you sure you want to navigate away?`;
    };
    window.addEventListener("beforeunload", onBeforeUnload);
    return () => window.removeEventListener("beforeunload", onBeforeUnload);
  }, [state.hasUnsavedChanges, state.unsavedDomChanges]);
  useShortcut({ key: "s", metaKey: true }, handleSave);
  return React310.createElement(AppStateProvider, { value: state }, React310.createElement(AppStateApiContext.Provider, { value: appStateApi }, React310.createElement(DomApiContext.Provider, { value: domApi }, children)));
}
var FONTS_URL = "https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap";
function scrollIntoViewIfNeeded(target, options2) {
  if (target.getBoundingClientRect().bottom > window.innerHeight) {
    target.scrollIntoView(options2 ?? false);
  }
  if (target.getBoundingClientRect().top < 0) {
    target.scrollIntoView(options2);
  }
}
function updateNodeInfo(nodeInfo, rootElm) {
  const nodeElm = rootElm.querySelector(`[data-toolpad-node-id="${nodeInfo.nodeId}"]`);
  if (!nodeElm) {
    return nodeInfo;
  }
  const rect = getRelativeOuterRect(rootElm, nodeElm);
  const slotElms = rootElm.querySelectorAll(`[data-toolpad-slot-parent="${nodeInfo.nodeId}"]`);
  const slots = {};
  for (const slotElm of slotElms) {
    const slotName = slotElm.getAttribute("data-toolpad-slot-name");
    const slotType = slotElm.getAttribute("data-toolpad-slot-type");
    (0, import_invariant.default)(slotName, "Slot name not found");
    (0, import_invariant.default)(slotType, "Slot type not found");
    if (slots[slotName]) {
      continue;
    }
    const slotRect = slotType === "single" ? getRelativeBoundingRect(rootElm, slotElm) : getRelativeBoundingRect(rootElm, slotElm);
    const display = window.getComputedStyle(slotElm).display;
    let flowDirection = "row";
    if (slotType === "layout") {
      flowDirection = "column";
    } else if (display === "grid") {
      const gridAutoFlow = window.getComputedStyle(slotElm).gridAutoFlow;
      flowDirection = gridAutoFlow === "row" ? "column" : "row";
    } else if (display === "flex") {
      flowDirection = window.getComputedStyle(slotElm).flexDirection;
    }
    slots[slotName] = {
      type: slotType,
      rect: slotRect,
      flowDirection
    };
  }
  return { ...nodeInfo, rect, slots };
}
function Overlay(props2) {
  const { children, container } = props2;
  const cache = React410.useMemo(
    () => createCache({
      key: `toolpad-editor-overlay`,
      prepend: true,
      container
    }),
    [container]
  );
  cache.compat = true;
  return React410.createElement(CacheProvider, { value: cache }, children);
}
var CanvasRoot = styled_default("div")({
  width: "100%",
  position: "relative"
});
var CanvasFrame = styled_default("iframe")({
  border: "none",
  position: "absolute",
  width: "100%",
  height: "100%"
});
function EditorCanvasHost({
  pageName,
  className,
  runtimeState,
  base,
  savedNodes,
  overlay,
  onInit
}) {
  const project = useProject();
  const [canvasEvents, setCanvasEvents] = React410.useState(null);
  const [editorOverlayRoot, setEditorOverlayRoot] = React410.useState(null);
  const [portal, setPortal] = React410.useState(null);
  const appStateApi = useAppStateApi();
  const handleIframeLoad = useEventCallback_default2((event) => {
    (0, import_invariant.default)(event.currentTarget.contentDocument, "iframe contentDocument is not available");
    const root2 = event.currentTarget.contentDocument.getElementById("root");
    (0, import_invariant.default)(root2, "root element not found");
    const iframeWindow = event.currentTarget.contentWindow;
    (0, import_invariant.default)(iframeWindow, "Iframe not attached");
    const handleKeyDown = (keyDownEvent) => {
      const isZ = !!keyDownEvent.key && keyDownEvent.key.toLowerCase() === "z";
      const undoShortcut = isZ && (keyDownEvent.metaKey || keyDownEvent.ctrlKey);
      const redoShortcut = undoShortcut && keyDownEvent.shiftKey;
      if (redoShortcut) {
        keyDownEvent.preventDefault();
        appStateApi.redo();
      } else if (undoShortcut) {
        keyDownEvent.preventDefault();
        appStateApi.undo();
      }
    };
    iframeWindow.addEventListener("keydown", handleKeyDown);
    iframeWindow.addEventListener("unload", () => {
      iframeWindow.removeEventListener("keydown", handleKeyDown);
    });
    setPortal(root2);
  });
  const viewState = React410.useRef({ nodes: {} });
  const canvasHooks = React410.useMemo(
    () => ({
      overlayRef: setEditorOverlayRoot,
      savedNodes,
      registerNode: (node, props2, componentConfig) => {
        viewState.current.nodes[node.id] = {
          nodeId: node.id,
          props: props2,
          componentConfig
        };
        return () => {
          delete viewState.current.nodes[node.id];
        };
      }
    }),
    [savedNodes]
  );
  const appRootCleanupRef = React410.useRef();
  const projectEventSubscriptionRef = React410.useRef();
  const onAppRoot = React410.useCallback(
    (appRoot) => {
      var _a;
      (_a = appRootCleanupRef.current) == null ? void 0 : _a.call(appRootCleanupRef);
      appRootCleanupRef.current = void 0;
      if (!appRoot) {
        return;
      }
      const bridge = {
        canvasEvents: new Emitter(),
        canvasCommands: {
          isReady: () => true,
          getPageViewState: () => {
            let nodes = viewState.current.nodes;
            for (const [nodeId, nodeInfo] of Object.entries(nodes)) {
              nodes = update(nodes, {
                [nodeId]: updateNodeInfo(nodeInfo, appRoot)
              });
            }
            return { nodes };
          },
          getViewCoordinates: (clientX, clientY) => {
            const rect = appRoot.getBoundingClientRect();
            if (rectContainsPoint(rect, clientX, clientY)) {
              return { x: clientX - rect.x, y: clientY - rect.y };
            }
            return null;
          },
          invalidateQueries: () => {
            queryClient.invalidateQueries();
          },
          scrollComponent: (nodeId) => {
            if (!appRoot) {
              return;
            }
            const node = appRoot.querySelector(`[data-node-id='${nodeId}']`);
            if (node) {
              scrollIntoViewIfNeeded(node, { behavior: "instant", block: "center", inline: "end" });
            }
          }
        }
      };
      const handleScreenUpdate = throttle_default(
        () => {
          bridge == null ? void 0 : bridge.canvasEvents.emit("screenUpdate", {});
        },
        50,
        { trailing: true }
      );
      projectEventSubscriptionRef.current = project.events.subscribe("queriesInvalidated", () => {
        queryClient.invalidateQueries();
      });
      const mutationObserver = new MutationObserver(handleScreenUpdate);
      mutationObserver.observe(appRoot, {
        attributes: true,
        childList: true,
        subtree: true,
        characterData: true
      });
      const resizeObserver = new ResizeObserver(handleScreenUpdate);
      resizeObserver.observe(appRoot);
      appRoot.querySelectorAll("*").forEach((elm) => resizeObserver.observe(elm));
      appRootCleanupRef.current = () => {
        handleScreenUpdate.cancel();
        mutationObserver.disconnect();
        resizeObserver.disconnect();
      };
      onInit == null ? void 0 : onInit(bridge);
      setCanvasEvents(bridge.canvasEvents);
    },
    [onInit, project.events]
  );
  React410.useEffect(
    () => () => {
      var _a, _b;
      (_a = appRootCleanupRef.current) == null ? void 0 : _a.call(appRootCleanupRef);
      appRootCleanupRef.current = void 0;
      (_b = projectEventSubscriptionRef.current) == null ? void 0 : _b.call(projectEventSubscriptionRef);
      projectEventSubscriptionRef.current = void 0;
    },
    []
  );
  const page = getPageByName(runtimeState.dom, pageName);
  const appHost = useAppHost();
  return React410.createElement(CanvasRoot, { className }, React410.createElement(
    CanvasFrame,
    {
      name: "data-toolpad-canvas",
      srcDoc: `
          <!doctype html>
          <html lang="en">
            <head>
              <meta charset="UTF-8" />
              <title>Toolpad</title>
              <link rel="preload" href="${FONTS_URL}" as="style" onload="this.onload=null;this.rel='stylesheet'">
              <noscript><link rel="stylesheet" href="${FONTS_URL}"></noscript>
              <link
                rel="stylesheet"
                href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap"
              />
            </head>
            <body className="notranslate">
              <div id="root"></div>
            </body>
          </html>
        `,
      onLoad: handleIframeLoad
    }
  ), page && portal ? ReactDOM.createPortal(
    React410.createElement(Overlay, { container: portal }, React410.createElement(CanvasHooksContext.Provider, { value: canvasHooks }, React410.createElement(CanvasEventsContext.Provider, { value: canvasEvents }, React410.createElement(AppHostProvider, { ...appHost, isCanvas: true, isPreview: true }, React410.createElement(ToolpadAppProvider, { rootRef: onAppRoot, basename: base, state: runtimeState }, React410.createElement(RenderedPage, { page })))))),
    portal
  ) : null, editorOverlayRoot ? ReactDOM.createPortal(
    React410.createElement(Overlay, { container: editorOverlayRoot }, overlay),
    editorOverlayRoot
  ) : null);
}
var DROP_ZONE_TOP = "top";
var DROP_ZONE_BOTTOM = "bottom";
var DROP_ZONE_LEFT = "left";
var DROP_ZONE_RIGHT = "right";
var DROP_ZONE_CENTER = "center";
function createPageEditorState(nodeId) {
  return {
    type: "page",
    nodeId,
    newNode: null,
    draggedNodeId: null,
    isDraggingOver: false,
    dragOverNodeId: null,
    dragOverSlotParentProp: null,
    dragOverZone: null,
    draggedEdge: null,
    viewState: { nodes: {} },
    pageState: {},
    globalScopeMeta: {},
    bindings: {},
    nodeData: {},
    vm: {
      scopes: {},
      bindingScopes: {}
    }
  };
}
function pageEditorReducer(state, action) {
  switch (action.type) {
    case "REPLACE": {
      return action.state;
    }
    case "PAGE_NEW_NODE_DRAG_START": {
      if (state.newNode) {
        return state;
      }
      return update(state, {
        newNode: action.newNode
      });
    }
    case "PAGE_EXISTING_NODE_DRAG_START": {
      return update(state, {
        draggedNodeId: action.node.id
      });
    }
    case "PAGE_EDGE_DRAG_START": {
      const { nodeId, edge } = action.edgeDragState;
      return update(state, {
        draggedNodeId: nodeId,
        draggedEdge: edge
      });
    }
    case "PAGE_DRAG_END":
      return update(state, {
        newNode: null,
        draggedNodeId: null,
        isDraggingOver: false,
        dragOverNodeId: null,
        dragOverSlotParentProp: null,
        dragOverZone: null,
        draggedEdge: null
      });
    case "PAGE_NODE_DRAG_OVER": {
      const { nodeId, parentProp, zone } = action.dragOverState;
      return update(state, {
        isDraggingOver: true,
        dragOverNodeId: nodeId,
        dragOverSlotParentProp: parentProp,
        dragOverZone: zone
      });
    }
    case "PAGE_VIEW_STATE_UPDATE": {
      const { viewState } = action;
      return update(state, {
        viewState
      });
    }
    case "PAGE_STATE_UPDATE": {
      const { pageState, globalScopeMeta } = action;
      return update(state, {
        pageState,
        globalScopeMeta
      });
    }
    case "NODE_DATA_UPDATE": {
      const { nodeId, prop, value } = action;
      return update(state, {
        nodeData: update(state.nodeData, {
          [nodeId]: updateOrCreate(state.nodeData[nodeId], {
            [prop]: value
          })
        })
      });
    }
    case "PAGE_BINDINGS_UPDATE": {
      const { bindings } = action;
      return update(state, {
        bindings
      });
    }
    case "VM_UPDATE": {
      const { vm: vm2 } = action;
      return update(state, { vm: vm2 });
    }
    default:
      return state;
  }
}
function createPageEditorApi(dispatch) {
  return {
    replace: (state) => dispatch({ type: "REPLACE", state }),
    newNodeDragStart(newNode) {
      dispatch({ type: "PAGE_NEW_NODE_DRAG_START", newNode });
    },
    existingNodeDragStart(node) {
      dispatch({ type: "PAGE_EXISTING_NODE_DRAG_START", node });
    },
    edgeDragStart({ nodeId, edge }) {
      dispatch({
        type: "PAGE_EDGE_DRAG_START",
        edgeDragState: { nodeId, edge }
      });
    },
    dragEnd() {
      dispatch({ type: "PAGE_DRAG_END" });
    },
    nodeDragOver({
      nodeId,
      parentProp,
      zone
    }) {
      dispatch({
        type: "PAGE_NODE_DRAG_OVER",
        dragOverState: { nodeId, parentProp, zone }
      });
    },
    pageViewStateUpdate(viewState) {
      dispatch({
        type: "PAGE_VIEW_STATE_UPDATE",
        viewState
      });
    },
    pageStateUpdate(pageState, globalScopeMeta) {
      dispatch({
        type: "PAGE_STATE_UPDATE",
        pageState,
        globalScopeMeta
      });
    },
    nodeDataUpdate(nodeId, prop, value) {
      dispatch({
        type: "NODE_DATA_UPDATE",
        nodeId,
        prop,
        value
      });
    },
    pageBindingsUpdate(bindings) {
      dispatch({
        type: "PAGE_BINDINGS_UPDATE",
        bindings
      });
    },
    vmUpdate(vm2) {
      dispatch({
        type: "VM_UPDATE",
        vm: vm2
      });
    }
  };
}
var PageEditorContext = React54.createContext(null);
function usePageEditorState() {
  const state = React54.useContext(PageEditorContext);
  if (!state) {
    throw new Error(`Missing PageEditorContext`);
  }
  return state;
}
var PageEditorApiContext = React54.createContext(
  createPageEditorApi(() => void 0)
);
function PageEditorProvider({ children, nodeId }) {
  const initialState = createPageEditorState(nodeId);
  const [state, dispatch] = React54.useReducer(pageEditorReducer, initialState);
  const api = React54.useMemo(() => createPageEditorApi(dispatch), []);
  React54.useEffect(() => {
    api.replace(createPageEditorState(nodeId));
  }, [api, nodeId]);
  return React54.createElement(PageEditorContext.Provider, { value: state }, React54.createElement(PageEditorApiContext.Provider, { value: api }, children));
}
function usePageEditorApi() {
  return React54.useContext(PageEditorApiContext);
}
var HINT_POSITION_TOP = "top";
var HINT_POSITION_BOTTOM = "bottom";
var HUD_HEIGHT = 30;
function stopPropagationHandler(event) {
  event.stopPropagation();
}
var nodeHudClasses = {
  selected: "NodeHud_Selected",
  hovered: "NodeHud_Hovered",
  selectionHint: "NodeHud_SelectionHint"
};
var NodeHudWrapper = styled_default("div", {
  shouldForwardProp: (prop) => prop !== "isOutlineVisible" && prop !== "isHoverable"
})(({ isOutlineVisible, isHoverable, theme: theme3 }) => {
  const defaultOutline = `1px dotted ${isOutlineVisible ? theme3.palette.primary[500] : "transparent"}`;
  return {
    // capture mouse events
    pointerEvents: "initial",
    position: "absolute",
    userSelect: "none",
    outline: defaultOutline,
    zIndex: 80,
    [`&:hover, &.${nodeHudClasses.hovered}`]: {
      outline: `2px dashed ${isHoverable ? theme3.palette.primary[500] : defaultOutline}`
    },
    [`.${nodeHudClasses.selected}`]: {
      position: "absolute",
      height: "100%",
      width: "100%",
      outline: `2px solid ${theme3.palette.primary[500]}`,
      left: 0,
      top: 0,
      zIndex: 80
    }
  };
});
var SelectionHintWrapper = styled_default("div", {
  shouldForwardProp: (prop) => prop !== "hintPosition"
})(({ hintPosition, theme: theme3 }) => ({
  position: "absolute",
  [`.${nodeHudClasses.selectionHint}`]: {
    // capture mouse events
    pointerEvents: "initial",
    cursor: "grab",
    display: "flex",
    position: "absolute",
    alignItems: "center",
    right: -1,
    background: theme3.palette.primary[500],
    color: "white",
    fontSize: 11,
    padding: `0 0 0 8px`,
    height: HUD_HEIGHT,
    zIndex: 1e3,
    ...hintPosition === HINT_POSITION_TOP ? { top: 0, transform: "translate(0, -100%)" } : {
      bottom: 0,
      transform: "translate(0, 100%)"
    }
  }
}));
var DraggableEdgeWrapper = styled_default("div")({
  userSelect: "none",
  position: "absolute",
  zIndex: 90
});
var DraggableEdge = styled_default("div", {
  shouldForwardProp: (prop) => prop !== "edge"
})(({ edge }) => {
  let dynamicStyles = {};
  if (edge === RECTANGLE_EDGE_RIGHT) {
    dynamicStyles = {
      cursor: "ew-resize",
      top: 0,
      right: -10,
      height: "100%",
      width: 22
    };
  }
  if (edge === RECTANGLE_EDGE_LEFT) {
    dynamicStyles = {
      cursor: "ew-resize",
      top: 0,
      left: -10,
      height: "100%",
      width: 22
    };
  }
  if (edge === RECTANGLE_EDGE_BOTTOM) {
    dynamicStyles = {
      cursor: "ns-resize",
      bottom: -10,
      height: 22,
      left: 0,
      width: "100%"
    };
  }
  if (edge === RECTANGLE_EDGE_TOP) {
    dynamicStyles = {
      cursor: "ns-resize",
      top: -10,
      height: 22,
      left: 0,
      width: "100%"
    };
  }
  return {
    ...dynamicStyles,
    position: "absolute",
    pointerEvents: "initial",
    zIndex: 90
  };
});
var ResizePreview = styled_default("div")(({ theme: theme3 }) => ({
  backgroundColor: theme3.palette.primary[500],
  opacity: 0.2,
  zIndex: 90
}));
function NodeHud({
  node,
  rect,
  selectedNodeRect,
  isSelected,
  isInteractive = false,
  onNodeDragStart,
  draggableEdges = [],
  onEdgeDragStart,
  onDelete,
  isResizing = false,
  resizePreviewElementRef,
  onDuplicate,
  isOutlineVisible = false,
  isHoverable = true,
  isHovered = false
}) {
  let hintPosition = HINT_POSITION_BOTTOM;
  if (rect.y > HUD_HEIGHT) {
    hintPosition = HINT_POSITION_TOP;
  }
  const interactiveNodeClipPath = React62.useMemo(
    () => isInteractive && selectedNodeRect ? `
            polygon(
              -100% -100%, 
              200% -100%,
              200% 200%,
              -100% 200%,
              -100% ${selectedNodeRect.y - rect.y}px,
              ${selectedNodeRect.x - rect.x}px ${selectedNodeRect.y - rect.y}px, 
              ${selectedNodeRect.x - rect.x}px 
              ${selectedNodeRect.y + selectedNodeRect.height - rect.y}px,
              ${selectedNodeRect.x + selectedNodeRect.width - rect.x}px
              ${selectedNodeRect.y + selectedNodeRect.height - rect.y}px, 
              ${selectedNodeRect.x + selectedNodeRect.width - rect.x}px 
              ${selectedNodeRect.y - rect.y}px,
              -100% ${selectedNodeRect.y - rect.y}px
          )` : "",
    [isInteractive, rect, selectedNodeRect]
  );
  return React62.createElement(React62.Fragment, null, React62.createElement(
    NodeHudWrapper,
    {
      "data-node-id": node.id,
      style: {
        ...absolutePositionCss(rect),
        ...interactiveNodeClipPath ? {
          clipPath: interactiveNodeClipPath
        } : {}
      },
      className: isHovered ? nodeHudClasses.hovered : "",
      isOutlineVisible,
      isHoverable
    },
    isSelected ? React62.createElement("span", { className: nodeHudClasses.selected }) : null,
    isResizing ? React62.createElement(ResizePreview, { ref: resizePreviewElementRef, style: absolutePositionCss(rect) }) : null
  ), isSelected ? React62.createElement(
    SelectionHintWrapper,
    {
      style: absolutePositionCss(rect),
      hintPosition,
      "data-testid": "node-hud-selection"
    },
    React62.createElement(
      "div",
      {
        draggable: true,
        "data-testid": "node-hud-tag",
        className: nodeHudClasses.selectionHint,
        onDragStart: onNodeDragStart,
        role: "presentation",
        onClick: stopPropagationHandler,
        onMouseDown: stopPropagationHandler,
        onMouseUp: stopPropagationHandler
      },
      node.name,
      React62.createElement(DragIndicator_default, { color: "inherit" }),
      React62.createElement(IconButton_default, { "aria-label": "Duplicate", color: "inherit", onMouseUp: onDuplicate }, React62.createElement(Tooltip_default, { title: "Duplicate", enterDelay: 400 }, React62.createElement(ContentCopy_default, { color: "inherit" }))),
      React62.createElement(IconButton_default, { "aria-label": "Remove", color: "inherit", onMouseUp: onDelete }, React62.createElement(Tooltip_default, { title: "Remove", enterDelay: 400 }, React62.createElement(Delete_default, { color: "inherit" })))
    )
  ) : null, onEdgeDragStart ? React62.createElement(DraggableEdgeWrapper, { style: absolutePositionCss(rect) }, draggableEdges.map((edge) => React62.createElement(
    DraggableEdge,
    {
      key: `${node.id}-edge-${edge}`,
      edge,
      onMouseDown: onEdgeDragStart(edge)
    }
  ))) : null);
}
var GRID_NUMBER_OF_COLUMNS = 12;
var GRID_COLUMN_GAP = 1;
var GridContainer = styled_default("div")({
  pointerEvents: "none",
  position: "absolute",
  zIndex: 1
});
var StyledGrid = styled_default(Grid2_default)({
  height: "100%"
});
var StyledGridColumn = styled_default("div")(({ theme: theme3 }) => ({
  backgroundColor: theme3.palette.grey[400],
  height: "100%",
  opacity: 0.2
}));
var OverlayGrid = React72.forwardRef(
  function OverlayGrid2(props2, forwardedRef) {
    var _a, _b;
    const gridRef = React72.useRef(null);
    const { dom } = useAppState();
    const { viewState, nodeId: pageNodeId } = usePageEditorState();
    const { nodes: nodesInfo } = viewState;
    const pageNode = nodesInfo[pageNodeId];
    const appTheme = React72.useMemo(() => createToolpadAppTheme(dom), [dom]);
    React72.useImperativeHandle(forwardedRef, () => {
      const gridElement = gridRef.current;
      (0, import_invariant5.default)(gridElement, "Overlay grid ref not bound");
      let columnEdges = [];
      const gridColumnContainers = Array.from(gridElement.children);
      const gridColumnEdges = gridColumnContainers.map((container) => {
        var _a2;
        const containerRect = (_a2 = container.firstElementChild) == null ? void 0 : _a2.getBoundingClientRect();
        return containerRect ? [Math.round(containerRect.x), Math.round(containerRect.x + containerRect.width)] : [];
      });
      columnEdges = gridColumnEdges.flat();
      return {
        gridElement: gridRef.current,
        getMinColumnWidth() {
          return columnEdges[1] - columnEdges[0];
        },
        getLeftColumnEdges() {
          return columnEdges.filter((column2, index) => index % 2 === 0);
        },
        getRightColumnEdges() {
          return columnEdges.filter((column2, index) => index % 2 === 1);
        }
      };
    }, []);
    const pageChildrenSlotRect = (_b = (_a = pageNode == null ? void 0 : pageNode.slots) == null ? void 0 : _a.children) == null ? void 0 : _b.rect;
    return pageChildrenSlotRect ? React72.createElement(GridContainer, { style: { ...absolutePositionCss(pageChildrenSlotRect), height: "100%" } }, React72.createElement(StyledGrid, { ref: gridRef, container: true, columnSpacing: appTheme.spacing(GRID_COLUMN_GAP) }, [...Array(GRID_NUMBER_OF_COLUMNS)].map((column2, index) => React72.createElement(Grid2_default, { key: index, size: { xs: 1 } }, React72.createElement(StyledGridColumn, null))))) : null;
  }
);
var dropAreaHighlightClasses = {
  highlightedTop: "DropArea_HighlightedTop",
  highlightedRight: "DropArea_HighlightedRight",
  highlightedBottom: "DropArea_HighlightedBottom",
  highlightedLeft: "DropArea_HighlightedLeft",
  highlightedCenter: "DropArea_HighlightedCenter"
};
var StyledNodeDropArea = styled_default("div", {
  shouldForwardProp: (prop) => prop !== "highlightRelativeRect"
})(({ highlightRelativeRect = {}, theme: theme3 }) => {
  const {
    x: highlightRelativeX = 0,
    y: highlightRelativeY = 0,
    width: highlightWidth = "100%",
    height: highlightHeight = "100%"
  } = highlightRelativeRect;
  return {
    pointerEvents: "none",
    position: "absolute",
    [`&.${dropAreaHighlightClasses.highlightedTop}`]: {
      "&::after": {
        backgroundColor: theme3.palette.primary[500],
        content: "''",
        position: "absolute",
        height: 2,
        width: highlightWidth,
        top: -1,
        left: highlightRelativeX
      }
    },
    [`&.${dropAreaHighlightClasses.highlightedRight}`]: {
      "&::after": {
        backgroundColor: theme3.palette.primary[500],
        content: "''",
        position: "absolute",
        height: highlightHeight,
        width: 2,
        top: highlightRelativeY,
        right: -1
      }
    },
    [`&.${dropAreaHighlightClasses.highlightedBottom}`]: {
      "&::after": {
        backgroundColor: theme3.palette.primary[500],
        content: "''",
        position: "absolute",
        height: 2,
        width: highlightWidth,
        bottom: -1,
        left: highlightRelativeX
      }
    },
    [`&.${dropAreaHighlightClasses.highlightedLeft}`]: {
      "&::after": {
        backgroundColor: theme3.palette.primary[500],
        content: "''",
        position: "absolute",
        height: highlightHeight,
        width: 2,
        left: -1,
        top: highlightRelativeY
      }
    },
    [`&.${dropAreaHighlightClasses.highlightedCenter}`]: {
      border: `2px solid ${theme3.palette.primary[500]}`
    }
  };
});
var EmptySlot = styled_default("div")(({ theme: theme3 }) => ({
  alignItems: "center",
  border: `2px dotted ${theme3.palette.primary[500]}`,
  color: theme3.palette.primary[500],
  display: "flex",
  flexDirection: "column",
  justifyContent: "center",
  position: "absolute",
  textAlign: "center"
}));
function getChildNodeHighlightedZone(parentFlowDirection) {
  switch (parentFlowDirection) {
    case "row":
      return DROP_ZONE_RIGHT;
    case "column":
      return DROP_ZONE_BOTTOM;
    case "row-reverse":
      return DROP_ZONE_LEFT;
    case "column-reverse":
      return DROP_ZONE_TOP;
    default:
      return null;
  }
}
function getHighlightedZoneOverlayClass(highlightedZone) {
  switch (highlightedZone) {
    case DROP_ZONE_TOP:
      return dropAreaHighlightClasses.highlightedTop;
    case DROP_ZONE_RIGHT:
      return dropAreaHighlightClasses.highlightedRight;
    case DROP_ZONE_BOTTOM:
      return dropAreaHighlightClasses.highlightedBottom;
    case DROP_ZONE_LEFT:
      return dropAreaHighlightClasses.highlightedLeft;
    case DROP_ZONE_CENTER:
      return dropAreaHighlightClasses.highlightedCenter;
    default:
      return null;
  }
}
function NodeDropArea({
  node,
  parentProp,
  dropAreaRect,
  availableDropZones
}) {
  var _a;
  const { dom } = useAppState();
  const { dragOverNodeId, dragOverSlotParentProp, dragOverZone, viewState } = usePageEditorState();
  const { nodes: nodesInfo } = viewState;
  const dropAreaNodeInfo = nodesInfo[node.id];
  const dropAreaNodeRect = (dropAreaNodeInfo == null ? void 0 : dropAreaNodeInfo.rect) || null;
  const dropAreaNodeSlots = dropAreaNodeInfo == null ? void 0 : dropAreaNodeInfo.slots;
  const slotRect = dropAreaNodeSlots && parentProp && ((_a = dropAreaNodeSlots[parentProp]) == null ? void 0 : _a.rect) || null;
  const dropAreaNodeParent = getParent(dom, node);
  const dropAreaNodeParentInfo = dropAreaNodeParent && nodesInfo[dropAreaNodeParent.id];
  const dropAreaNodeParentRect = (dropAreaNodeParentInfo == null ? void 0 : dropAreaNodeParentInfo.rect) || null;
  const dropAreaNodeParentSlots = dropAreaNodeParentInfo == null ? void 0 : dropAreaNodeParentInfo.slots;
  const dropAreaNodeParentSlot = dropAreaNodeParentSlots && parentProp && dropAreaNodeParentSlots[parentProp];
  const isPageNode = isPage(node);
  const isPageChild = dropAreaNodeParent ? isPage(dropAreaNodeParent) : false;
  const isPageRowNode = isElement(node) && isPageRow(node);
  const isPageChildElement = isPageChild && isElement(node) && !isPageRow(node);
  const isPageRowChild = dropAreaNodeParent ? isElement(dropAreaNodeParent) && isPageRow(dropAreaNodeParent) : false;
  const dropAreaNodeChildNodes = React82.useMemo(
    () => getChildNodes(dom, node),
    [dom, node]
  );
  const dropAreaSlotChildNodes = parentProp ? dropAreaNodeChildNodes[parentProp] || [] : [];
  const isEmptySlot = dropAreaSlotChildNodes.length === 0;
  const highlightedZone = React82.useMemo(() => {
    var _a2;
    if (dragOverZone && !availableDropZones.includes(dragOverZone)) {
      return null;
    }
    if (isPageNode && parentProp && !isEmptySlot) {
      return null;
    }
    const dropAreaParentParent = dropAreaNodeParent && getParent(dom, dropAreaNodeParent);
    const pageAwareParentProp = isPageChild ? "children" : parentProp;
    if (dragOverZone === DROP_ZONE_TOP && !parentProp) {
      if (dropAreaNodeParent && dropAreaNodeParent.id === dragOverNodeId && isPage(dropAreaNodeParent) && pageAwareParentProp) {
        const pageFirstChild = getNodeFirstChild(dom, dropAreaNodeParent, "children");
        const isPageFirstChild = pageFirstChild ? node.id === pageFirstChild.id : false;
        return isPageFirstChild ? DROP_ZONE_TOP : null;
      }
    }
    if (dragOverZone === DROP_ZONE_LEFT || dragOverZone === DROP_ZONE_RIGHT) {
      if (dropAreaNodeParent && dropAreaParentParent && dropAreaNodeParent.id === dragOverNodeId && isElement(dropAreaNodeParent) && isPageRowChild && isPage(dropAreaParentParent) && !parentProp) {
        const parentHighlightedChild = dragOverZone === DROP_ZONE_LEFT ? getNodeFirstChild(dom, dropAreaNodeParent, "children") : getNodeLastChild(dom, dropAreaNodeParent, "children");
        const isParentHighlightedChild = parentHighlightedChild ? node.id === parentHighlightedChild.id : false;
        return isParentHighlightedChild ? dragOverZone : null;
      }
      if (dropAreaNodeParent && isPageRowNode && isPageChild) {
        return null;
      }
    }
    if (dragOverZone === DROP_ZONE_CENTER) {
      if (dropAreaNodeParent && dropAreaNodeParent.id === dragOverNodeId && (pageAwareParentProp === dragOverSlotParentProp || !parentProp)) {
        const parentLastChild = isPage(dropAreaNodeParent) || isElement(dropAreaNodeParent) ? getNodeLastChild(dom, dropAreaNodeParent, pageAwareParentProp || "children") : null;
        const isParentLastChild = parentLastChild ? node.id === parentLastChild.id : false;
        const parentSlots = (dropAreaNodeParentInfo == null ? void 0 : dropAreaNodeParentInfo.slots) || null;
        const parentFlowDirection = parentSlots && ((_a2 = parentSlots[pageAwareParentProp || "children"]) == null ? void 0 : _a2.flowDirection);
        return parentFlowDirection && isParentLastChild ? getChildNodeHighlightedZone(parentFlowDirection) : null;
      }
      if (node.id === dragOverNodeId && pageAwareParentProp && pageAwareParentProp === dragOverSlotParentProp && parentProp) {
        if (isPageNode) {
          return DROP_ZONE_CENTER;
        }
        const nodeChildren = pageAwareParentProp && isElement(node) && dropAreaNodeChildNodes[pageAwareParentProp] || [];
        return nodeChildren.length === 0 ? DROP_ZONE_CENTER : null;
      }
    }
    return node.id === dragOverNodeId && parentProp === dragOverSlotParentProp ? dragOverZone : null;
  }, [
    dragOverZone,
    availableDropZones,
    isPageNode,
    parentProp,
    isEmptySlot,
    dropAreaNodeParent,
    dom,
    isPageChild,
    node,
    dragOverNodeId,
    dragOverSlotParentProp,
    isPageRowChild,
    isPageRowNode,
    dropAreaNodeParentInfo == null ? void 0 : dropAreaNodeParentInfo.slots,
    dropAreaNodeChildNodes
  ]);
  const highlightedZoneOverlayClass = highlightedZone && getHighlightedZoneOverlayClass(highlightedZone);
  const isHorizontalContainerChild = dropAreaNodeParentSlot ? isHorizontalFlow(dropAreaNodeParentSlot.flowDirection) : false;
  const isVerticalContainerChild = dropAreaNodeParentSlot ? isVerticalFlow(dropAreaNodeParentSlot.flowDirection) : false;
  const highlightParentRect = slotRect || dropAreaNodeParentRect;
  if (!dropAreaNodeRect) {
    return null;
  }
  const highlightHeight = isHorizontalContainerChild && highlightParentRect && dropAreaNodeParentRect ? highlightParentRect.height : dropAreaNodeRect.height;
  const highlightWidth = !isPageChild && isVerticalContainerChild && highlightParentRect && dropAreaNodeParentRect ? highlightParentRect.width : dropAreaNodeRect.width;
  const highlightRelativeX = (!isPageChild && isVerticalContainerChild && highlightParentRect && dropAreaNodeParentRect ? highlightParentRect.x : dropAreaNodeRect.x) - dropAreaRect.x;
  const highlightRelativeY = (isHorizontalContainerChild && highlightParentRect && dropAreaNodeParentRect ? highlightParentRect.y : dropAreaNodeRect.y) - dropAreaRect.y;
  const isHighlightingCenter = highlightedZone === DROP_ZONE_CENTER;
  const highlightRect = isHighlightingCenter && isEmptySlot && slotRect ? slotRect : {
    ...dropAreaRect,
    x: isPageChildElement ? dropAreaNodeRect.x : dropAreaRect.x,
    width: isPageChildElement ? dropAreaNodeRect.width : dropAreaRect.width
  };
  const highlightRelativeRect = {
    x: isPageChildElement ? 0 : highlightRelativeX,
    y: highlightRelativeY,
    width: highlightWidth,
    height: highlightHeight
  };
  return React82.createElement(React82.Fragment, null, React82.createElement(
    StyledNodeDropArea,
    {
      style: absolutePositionCss(highlightRect),
      className: clsx_default(
        highlightedZoneOverlayClass ? {
          [highlightedZoneOverlayClass]: !isHighlightingCenter || isEmptySlot
        } : {}
      ),
      highlightRelativeRect
    }
  ), isEmptySlot && slotRect ? React82.createElement(EmptySlot, { style: absolutePositionCss(slotRect) }, React82.createElement(Typography_default, { variant: "subtitle2" }, "Drop component here")) : null);
}
var PinholeOverlayRoot = styled_default("div")({
  pointerEvents: "none !important",
  position: "relative",
  "> div": {
    pointerEvents: "initial !important",
    position: "absolute",
    left: 0,
    top: 0,
    right: 0,
    bottom: 0,
    background: "#000",
    opacity: 0
  }
});
var PinholeOverlay = React92.forwardRef(function PinholeOverlay2({ className, onClick, pinhole }, ref) {
  const left = React92.useRef(null);
  const topLeft = React92.useRef(null);
  const top = React92.useRef(null);
  const topRight = React92.useRef(null);
  const right = React92.useRef(null);
  const bottomRight = React92.useRef(null);
  const bottom = React92.useRef(null);
  const bottomLeft = React92.useRef(null);
  React92.useLayoutEffect(() => {
    if (left.current) {
      left.current.style.top = pinhole ? `${pinhole.y}px` : "0";
      left.current.style.width = pinhole ? `${pinhole.x}px` : "unset";
      left.current.style.height = pinhole ? `${pinhole.height}px` : "unset";
    }
    if (topLeft.current) {
      topLeft.current.style.width = pinhole ? `${pinhole.x}px` : "unset";
      topLeft.current.style.height = pinhole ? `${pinhole.y}px` : "unset";
    }
    if (top.current) {
      top.current.style.left = pinhole ? `${pinhole.x}px` : "0";
      top.current.style.width = pinhole ? `${pinhole.width}px` : "unset";
      top.current.style.height = pinhole ? `${pinhole.y}px` : "unset";
    }
    if (topRight.current) {
      topRight.current.style.left = pinhole ? `${pinhole.x + pinhole.width}px` : "0";
      topRight.current.style.height = pinhole ? `${pinhole.y}px` : "unset";
    }
    if (right.current) {
      right.current.style.top = pinhole ? `${pinhole.y}px` : "0";
      right.current.style.left = pinhole ? `${pinhole.x + pinhole.width}px` : "0";
      right.current.style.height = pinhole ? `${pinhole.height}px` : "unset";
    }
    if (bottomRight.current) {
      bottomRight.current.style.left = pinhole ? `${pinhole.x + pinhole.width}px` : "0";
      bottomRight.current.style.top = pinhole ? `${pinhole.y + pinhole.height}px` : "unset";
    }
    if (bottom.current) {
      bottom.current.style.left = pinhole ? `${pinhole.x}px` : "0";
      bottom.current.style.width = pinhole ? `${pinhole.width}px` : "unset";
      bottom.current.style.top = pinhole ? `${pinhole.y + pinhole.height}px` : "unset";
    }
    if (bottomLeft.current) {
      bottomLeft.current.style.width = pinhole ? `${pinhole.x}px` : "0";
      bottomLeft.current.style.top = pinhole ? `${pinhole.y + pinhole.height}px` : "unset";
    }
  }, [pinhole]);
  const handleClick = React92.useCallback(
    (event) => {
      if (onClick) {
        onClick(event);
      }
    },
    [onClick]
  );
  return React92.createElement(PinholeOverlayRoot, { ref, className }, pinhole ? React92.createElement(React92.Fragment, null, React92.createElement("div", { key: "left", ref: left, onClick: handleClick }), React92.createElement("div", { key: "topLeft", ref: topLeft, onClick: handleClick }), React92.createElement("div", { key: "top", ref: top, onClick: handleClick }), React92.createElement("div", { key: "topRight", ref: topRight, onClick: handleClick }), React92.createElement("div", { key: "right", ref: right, onClick: handleClick }), React92.createElement("div", { key: "bottomRight", ref: bottomRight, onClick: handleClick }), React92.createElement("div", { key: "bottom", ref: bottom, onClick: handleClick }), React92.createElement("div", { key: "bottomLeft", ref: bottomLeft, onClick: handleClick })) : (
    // eslint-disable-next-line jsx-a11y/click-events-have-key-events,jsx-a11y/no-static-element-interactions
    React92.createElement("div", { key: "full", onClick: handleClick })
  ));
});
function deleteOrphanedLayoutNodes(domBeforeChange, domAfterChange, movedOrDeletedNode, moveTargetNodeId = null) {
  var _a, _b;
  let updatedDom = domAfterChange;
  let orphanedLayoutNodeIds = [];
  const movedOrDeletedNodeParentProp = movedOrDeletedNode.parentProp;
  const parent = getParent(domBeforeChange, movedOrDeletedNode);
  const parentParent = parent && getParent(domBeforeChange, parent);
  const parentParentParent = parentParent && getParent(domBeforeChange, parentParent);
  const parentChildren = parent && movedOrDeletedNodeParentProp ? getChildNodes(domBeforeChange, parent)[movedOrDeletedNodeParentProp] : [];
  const isOnlyLayoutContainerChild = parent && isElement(parent) && isPageLayoutComponent(parent) && parentChildren.length === 1;
  const isParentOnlyLayoutContainerChild = parentParent && parent.parentProp && isElement(parentParent) && isPageLayoutComponent(parentParent) && getChildNodes(domBeforeChange, parentParent)[parent.parentProp].length === 1;
  const isSecondLastLayoutContainerChild = parent && isElement(parent) && isPageLayoutComponent(parent) && parentChildren.length === 2;
  if (isSecondLastLayoutContainerChild) {
    if (parent.parentIndex && parentParent) {
      const lastContainerChild = parentChildren.filter(
        (child) => child.id !== movedOrDeletedNode.id
      )[0];
      if (lastContainerChild.parentProp && parentParent.parentIndex && moveTargetNodeId !== lastContainerChild.id) {
        if (moveTargetNodeId !== parent.id && (isPage(parentParent) || isElement(parentParent) && getElementNodeComponentId(lastContainerChild) !== getElementNodeComponentId(parentParent))) {
          updatedDom = moveNode(
            updatedDom,
            lastContainerChild,
            parentParent,
            lastContainerChild.parentProp || "children",
            parent.parentIndex
          );
          if (isPageColumn(parent)) {
            updatedDom = setNodeNamespacedProp(
              updatedDom,
              lastContainerChild,
              "layout",
              "columnSize",
              ((_a = parent.layout) == null ? void 0 : _a.columnSize) || 1
            );
          }
          if (isPageColumn(lastContainerChild) && isPage(parentParent)) {
            updatedDom = spreadNode(updatedDom, lastContainerChild);
          }
          orphanedLayoutNodeIds = [...orphanedLayoutNodeIds, parent.id];
        }
        if (parentParentParent && isElement(parentParentParent) && isPageLayoutComponent(parentParentParent) && isParentOnlyLayoutContainerChild) {
          updatedDom = moveNode(
            updatedDom,
            lastContainerChild,
            parentParentParent,
            lastContainerChild.parentProp,
            parentParent.parentIndex
          );
          if (isPageColumn(parentParent)) {
            updatedDom = setNodeNamespacedProp(
              updatedDom,
              lastContainerChild,
              "layout",
              "columnSize",
              ((_b = parentParent.layout) == null ? void 0 : _b.columnSize) || 1
            );
          }
          orphanedLayoutNodeIds = [...orphanedLayoutNodeIds, parentParent.id];
        }
      }
    }
  }
  if (isOnlyLayoutContainerChild) {
    if (isParentOnlyLayoutContainerChild && moveTargetNodeId !== parentParent.id) {
      orphanedLayoutNodeIds = [...orphanedLayoutNodeIds, parentParent.id];
    }
    orphanedLayoutNodeIds = [...orphanedLayoutNodeIds, parent.id];
  }
  orphanedLayoutNodeIds.forEach((nodeId) => {
    updatedDom = removeMaybeNode(updatedDom, nodeId);
  });
  return updatedDom;
}
function normalizePageRowColumnSizes(dom, pageNode) {
  const allPageNodes = getDescendants(dom, pageNode);
  allPageNodes.forEach((node) => {
    if (isElement(node) && isPageRow(node)) {
      const nodeChildren = getChildNodes(dom, node).children;
      const nodeChildrenCount = nodeChildren.length;
      const columnSizes = nodeChildren.map((child) => {
        var _a;
        return ((_a = child.layout) == null ? void 0 : _a.columnSize) || 1;
      });
      const totalColumnsSize = columnSizes.reduce((acc, size) => acc + size, 0);
      if (totalColumnsSize.toFixed(4) !== nodeChildrenCount.toFixed(4)) {
        const normalizedLayoutColumnSizes = columnSizes.map(
          (size) => size * nodeChildren.length / totalColumnsSize
        );
        nodeChildren.forEach((child, childIndex) => {
          dom = setNodeNamespacedProp(
            dom,
            child,
            "layout",
            "columnSize",
            normalizedLayoutColumnSizes[childIndex]
          );
        });
      }
    }
  });
  return dom;
}
function removePageLayoutNode(dom, node) {
  const pageNode = getPageAncestor(dom, node);
  let updatedDom = dom;
  updatedDom = removeMaybeNode(updatedDom, node.id);
  updatedDom = deleteOrphanedLayoutNodes(dom, updatedDom, node);
  if (pageNode) {
    updatedDom = normalizePageRowColumnSizes(updatedDom, pageNode);
  }
  return updatedDom;
}
var VERTICAL_RESIZE_SNAP_UNITS = 4;
var overlayClasses = {
  hud: "Toolpad_Hud",
  nodeHud: "Toolpad_NodeHud",
  container: "Toolpad_Container",
  hudOverlay: "Toolpad_HudOverlay",
  nodeDrag: "Toolpad_NodeDrag",
  resizeHorizontal: "Toolpad_ResizeHorizontal",
  resizeVertical: "Toolpad_ResizeVertical"
};
var OverlayRoot = styled_default("div")({
  pointerEvents: "none",
  width: "100%",
  height: "100%",
  "&:focus": {
    outline: "none"
  },
  [`&.${overlayClasses.nodeDrag}`]: {
    cursor: "copy"
  },
  [`&.${overlayClasses.resizeHorizontal}`]: {
    cursor: "ew-resize"
  },
  [`&.${overlayClasses.resizeVertical}`]: {
    cursor: "ns-resize"
  },
  [`.${overlayClasses.hudOverlay}`]: {
    position: "absolute",
    inset: "0 0 0 0"
  }
});
function findAreaAt(areaRects, x2, y2) {
  const rectEntries = Object.entries(areaRects);
  for (let i = rectEntries.length - 1; i >= 0; i -= 1) {
    const areaRectEntry = rectEntries[i];
    const areaId = areaRectEntry[0];
    const areaRect = areaRectEntry[1];
    if (rectContainsPoint(areaRect, x2, y2)) {
      return areaId;
    }
  }
  return null;
}
function hasFreeNodeSlots(nodeInfo) {
  return Object.keys(nodeInfo.slots || []).length > 0;
}
function getRectangleEdgeDropZone(edge) {
  switch (edge) {
    case RECTANGLE_EDGE_TOP:
      return DROP_ZONE_TOP;
    case RECTANGLE_EDGE_RIGHT:
      return DROP_ZONE_RIGHT;
    case RECTANGLE_EDGE_BOTTOM:
      return DROP_ZONE_BOTTOM;
    case RECTANGLE_EDGE_LEFT:
      return DROP_ZONE_LEFT;
    default:
      return null;
  }
}
function getDropAreaId(nodeId, parentProp) {
  return `${nodeId}:${parentProp}`;
}
function getDropAreaNodeId(dropAreaId) {
  return dropAreaId.split(":")[0];
}
function getDropAreaParentProp(dropAreaId) {
  return dropAreaId.split(":")[1] || null;
}
function RenderOverlay({ bridge }) {
  var _a;
  const { dom } = useAppState();
  const { currentView } = useAppState();
  const selectedNodeId = currentView.kind === "page" ? currentView.selectedNodeId : null;
  const hoveredNodeId = currentView.kind === "page" ? currentView.hoveredNodeId : null;
  const domApi = useDomApi();
  const appStateApi = useAppStateApi();
  const api = usePageEditorApi();
  const {
    viewState,
    nodeId: pageNodeId,
    newNode,
    draggedNodeId,
    draggedEdge,
    dragOverNodeId,
    dragOverSlotParentProp,
    dragOverZone,
    isDraggingOver
  } = usePageEditorState();
  const { nodes: nodesInfo } = viewState;
  const pageNode = getNode(dom, pageNodeId, "page");
  const pageNodes = React102.useMemo(() => {
    return [pageNode, ...getDescendants(dom, pageNode)];
  }, [dom, pageNode]);
  const selectedNode = selectedNodeId && getMaybeNode(dom, selectedNodeId);
  const overlayRef = React102.useRef(null);
  const draggedNode = React102.useMemo(
    () => newNode || draggedNodeId && getNode(dom, draggedNodeId, "element"),
    [dom, draggedNodeId, newNode]
  );
  const selectionRects = React102.useMemo(() => {
    const rects = {};
    pageNodes.forEach((node) => {
      const nodeInfo = nodesInfo[node.id];
      const nodeRect = (nodeInfo == null ? void 0 : nodeInfo.rect) || null;
      if (nodeRect) {
        rects[node.id] = nodeRect;
      }
    });
    return rects;
  }, [nodesInfo, pageNodes]);
  const selectNode = React102.useCallback(
    (nodeId) => {
      if (selectedNodeId !== nodeId) {
        appStateApi.selectNode(nodeId);
      }
    },
    [appStateApi, selectedNodeId]
  );
  const deselectNode = React102.useCallback(() => {
    if (selectedNodeId) {
      appStateApi.deselectNode();
    }
  }, [appStateApi, selectedNodeId]);
  const handleNodeMouseUp = React102.useCallback(
    (event) => {
      const cursorPos = bridge == null ? void 0 : bridge.canvasCommands.getViewCoordinates(event.clientX, event.clientY);
      if (!cursorPos || draggedNodeId) {
        return;
      }
      const newSelectedNodeId = findAreaAt(selectionRects, cursorPos.x, cursorPos.y);
      const newSelectedNode = newSelectedNodeId && getMaybeNode(dom, newSelectedNodeId);
      if (newSelectedNode && isElement(newSelectedNode)) {
        selectNode(newSelectedNodeId);
      } else {
        deselectNode();
      }
    },
    [bridge, deselectNode, dom, draggedNodeId, selectNode, selectionRects]
  );
  const handleNodeDelete = React102.useCallback(
    (nodeId) => (event) => {
      if (event) {
        event.stopPropagation();
      }
      appStateApi.update(
        (draft) => {
          const toRemove = getNode(draft, nodeId);
          if (isElement(toRemove)) {
            draft = removePageLayoutNode(draft, toRemove);
          }
          return draft;
        },
        currentView.kind === "page" ? {
          ...currentView,
          selectedNodeId: null
        } : currentView
      );
    },
    [appStateApi, currentView]
  );
  const selectedRect = selectedNode && !newNode && ((_a = nodesInfo[selectedNode.id]) == null ? void 0 : _a.rect) || null;
  const interactiveNodes = React102.useMemo(() => {
    if (!selectedNode) {
      return /* @__PURE__ */ new Set();
    }
    return new Set(
      [...getPageAncestors(dom, selectedNode), selectedNode].map(
        (interactiveNode) => interactiveNode.id
      )
    );
  }, [dom, selectedNode]);
  const handleNodeDragStart = React102.useCallback(
    (node) => (event) => {
      event.stopPropagation();
      if (isElement(node)) {
        event.dataTransfer.dropEffect = "move";
        selectNode(node.id);
        api.existingNodeDragStart(node);
      }
    },
    [api, selectNode]
  );
  const handleNodeDuplicate = React102.useCallback(
    (node) => (event) => {
      event.stopPropagation();
      domApi.update((draft) => {
        draft = duplicateNode(draft, node);
        draft = normalizePageRowColumnSizes(draft, pageNode);
        return draft;
      });
    },
    [domApi, pageNode]
  );
  const getNodeDraggableHorizontalEdges = React102.useCallback(
    (node) => {
      var _a2, _b;
      const nodeParentProp = node.parentProp;
      const parent = getParent(dom, node);
      const isFirstChild = parent && isElement(parent) && nodeParentProp ? ((_a2 = getNodeFirstChild(dom, parent, nodeParentProp)) == null ? void 0 : _a2.id) === node.id : false;
      const isLastChild = parent && isElement(parent) && nodeParentProp ? ((_b = getNodeLastChild(dom, parent, nodeParentProp)) == null ? void 0 : _b.id) === node.id : false;
      const isPageRowChild = parent ? isElement(parent) && isPageRow(parent) : false;
      const isDraggableLeft = isPageRowChild ? !isFirstChild : false;
      const isDraggableRight = isPageRowChild ? !isLastChild : false;
      return [
        ...isDraggableLeft ? [RECTANGLE_EDGE_LEFT] : [],
        ...isDraggableRight ? [RECTANGLE_EDGE_RIGHT] : []
      ];
    },
    [dom]
  );
  const handleEdgeDragStart = React102.useCallback(
    (node) => (edge) => (event) => {
      event.stopPropagation();
      const parent = getParent(dom, node);
      const isPageColumnChild = parent ? isElement(parent) && isPageColumn(parent) : false;
      const isResizingVertically = edge === RECTANGLE_EDGE_TOP || edge === RECTANGLE_EDGE_BOTTOM;
      const nodeToResize = parent && isPageColumnChild && !isResizingVertically ? parent : node;
      api.edgeDragStart({ nodeId: nodeToResize.id, edge });
      selectNode(nodeToResize.id);
    },
    [api, dom, selectNode]
  );
  const handleKeyDown = React102.useCallback(
    (event) => {
      if (selectedNodeId && event.key === "Backspace") {
        handleNodeDelete(selectedNodeId)();
      }
    },
    [handleNodeDelete, selectedNodeId]
  );
  const isEmptyPage = pageNodes.length <= 1;
  const availableDropTargets = React102.useMemo(() => {
    if (!draggedNode) {
      return [];
    }
    let excludedNodes = /* @__PURE__ */ new Set();
    if (selectedNode && !newNode) {
      excludedNodes = /* @__PURE__ */ new Set([
        selectedNode,
        ...getDescendants(dom, selectedNode)
      ]);
    }
    if (isFormComponent(draggedNode)) {
      const formNodes = getComponentTypeNodes(dom, FORM_COMPONENT_ID);
      const formNodeDescendants = formNodes.map((formNode) => getDescendants(dom, formNode)).flat();
      formNodeDescendants.forEach(excludedNodes.add, excludedNodes);
    }
    return pageNodes.filter((n) => !excludedNodes.has(n));
  }, [dom, draggedNode, newNode, pageNodes, selectedNode]);
  const availableDropTargetIds = React102.useMemo(
    () => new Set(availableDropTargets.map((n) => n.id)),
    [availableDropTargets]
  );
  const availableDropZones = React102.useMemo(() => {
    const dragOverNode = dragOverNodeId && getNode(dom, dragOverNodeId);
    const dragOverNodeInfo = dragOverNodeId && nodesInfo[dragOverNodeId];
    const dragOverNodeParentProp = dragOverNode == null ? void 0 : dragOverNode.parentProp;
    const dragOverNodeSlots = dragOverNodeInfo == null ? void 0 : dragOverNodeInfo.slots;
    const dragOverSlot = dragOverNodeSlots && dragOverSlotParentProp && dragOverNodeSlots[dragOverSlotParentProp];
    const dragOverParent = dragOverNode && getParent(dom, dragOverNode);
    const dragOverParentInfo = dragOverParent && nodesInfo[dragOverParent.id];
    const dragOverParentFreeSlots = dragOverParentInfo == null ? void 0 : dragOverParentInfo.slots;
    const dragOverParentFreeSlot = dragOverParentFreeSlots && dragOverNodeParentProp && dragOverParentFreeSlots[dragOverNodeParentProp];
    const isDraggingOverLayoutChild = dragOverParent && dragOverParentFreeSlot ? isPage(dragOverParent) || dragOverParentFreeSlot.type === "layout" : false;
    const isDraggingOverPageRowChild = dragOverParent && isElement(dragOverParent) ? isPageRow(dragOverParent) : false;
    const isDraggingOverPageColumnChild = dragOverParent && isElement(dragOverParent) ? isPageColumn(dragOverParent) : false;
    const isDraggingOverHorizontalContainerChild = dragOverParentFreeSlot ? isHorizontalFlow(dragOverParentFreeSlot.flowDirection) : false;
    const isDraggingOverVerticalContainerChild = dragOverParentFreeSlot ? isVerticalFlow(dragOverParentFreeSlot.flowDirection) : false;
    const hasChildHorizontalDropZones = !isDraggingOverVerticalContainerChild || isDraggingOverLayoutChild || isDraggingOverPageColumnChild;
    const hasChildVerticalDropZones = !isDraggingOverHorizontalContainerChild || isDraggingOverLayoutChild || isDraggingOverPageRowChild;
    if (draggedNode && dragOverNode) {
      if (isPage(dragOverNode)) {
        return [...isEmptyPage ? [] : [DROP_ZONE_TOP], DROP_ZONE_CENTER];
      }
      if (dragOverNodeInfo && !hasFreeNodeSlots(dragOverNodeInfo) && !dragOverParentFreeSlot) {
        return [];
      }
      const isDraggingPageRow = draggedNode ? isPageRow(draggedNode) : false;
      const isDraggingPageColumn = draggedNode ? isPageColumn(draggedNode) : false;
      const isDraggingOverHorizontalContainer = dragOverSlot && isHorizontalFlow(dragOverSlot.flowDirection);
      const isDraggingOverVerticalContainer = dragOverSlot && isVerticalFlow(dragOverSlot.flowDirection);
      const isDraggingOverPageRow = isElement(dragOverNode) && isPageRow(dragOverNode);
      if (isDraggingPageRow) {
        return [
          ...hasChildVerticalDropZones ? [DROP_ZONE_TOP, DROP_ZONE_BOTTOM] : [],
          ...isDraggingOverVerticalContainer ? [DROP_ZONE_CENTER] : []
        ];
      }
      if (isDraggingPageColumn) {
        return [
          ...hasChildHorizontalDropZones ? [DROP_ZONE_RIGHT, DROP_ZONE_LEFT] : [],
          ...isDraggingOverPageRow && hasChildVerticalDropZones ? [DROP_ZONE_TOP, DROP_ZONE_BOTTOM] : [],
          ...isDraggingOverHorizontalContainer ? [DROP_ZONE_CENTER] : []
        ];
      }
      if (isDraggingOverHorizontalContainer) {
        return [
          DROP_ZONE_TOP,
          DROP_ZONE_BOTTOM,
          DROP_ZONE_CENTER,
          ...isDraggingOverLayoutChild ? [DROP_ZONE_LEFT, DROP_ZONE_RIGHT] : []
        ];
      }
      if (isDraggingOverVerticalContainer) {
        return [DROP_ZONE_RIGHT, DROP_ZONE_LEFT, DROP_ZONE_CENTER];
      }
    }
    return [
      ...hasChildHorizontalDropZones ? [DROP_ZONE_RIGHT, DROP_ZONE_LEFT] : [],
      ...hasChildVerticalDropZones ? [DROP_ZONE_TOP, DROP_ZONE_BOTTOM] : []
    ];
  }, [dom, dragOverNodeId, dragOverSlotParentProp, draggedNode, isEmptyPage, nodesInfo]);
  const dropAreaRects = React102.useMemo(() => {
    const rects = {};
    pageNodes.forEach((node) => {
      const nodeId = node.id;
      const nodeInfo = nodesInfo[nodeId];
      const nodeRect = nodeInfo == null ? void 0 : nodeInfo.rect;
      const nodeParentProp = node.parentProp;
      const nodeSlots = (nodeInfo == null ? void 0 : nodeInfo.slots) || [];
      const nodeSlotEntries = Object.entries(nodeSlots);
      const hasFreeSlots = nodeSlotEntries.length > 0;
      const baseRects = [
        nodeRect,
        ...nodeSlotEntries.map(([, slot]) => slot ? slot.rect : null).filter(Boolean)
      ];
      baseRects.forEach((baseRect, baseRectIndex) => {
        const parent = getParent(dom, node);
        const parentInfo = parent && nodesInfo[parent.id];
        const parentRect = parentInfo == null ? void 0 : parentInfo.rect;
        const parentProp = hasFreeSlots ? Object.keys(nodeSlots)[baseRectIndex - 1] : null;
        let parentAwareBaseRect = baseRect;
        const isPageChild = parent ? isPage(parent) : false;
        if (nodeInfo && parentInfo && baseRect && (isPageChild || isElement(parent)) && hasFreeNodeSlots(parentInfo)) {
          const parentChildren = nodeParentProp ? getChildNodes(dom, parent)[nodeParentProp] : [];
          const parentChildrenCount = parentChildren.length;
          const isFirstChild = parentChildrenCount > 0 ? parentChildren[0].id === node.id : true;
          const isLastChild = parentChildren.length > 0 ? parentChildren[parentChildrenCount - 1].id === node.id : true;
          let gapCount = 2;
          if (isFirstChild || isLastChild) {
            gapCount = 1;
          }
          if (isFirstChild && isLastChild) {
            gapCount = 0;
          }
          const parentSlots = parentInfo == null ? void 0 : parentInfo.slots;
          const parentSlot = parentSlots && nodeParentProp && parentSlots[nodeParentProp] || null;
          const isParentVerticalContainer = parentSlot ? isVerticalFlow(parentSlot.flowDirection) : false;
          const isParentHorizontalContainer = parentSlot ? isHorizontalFlow(parentSlot.flowDirection) : false;
          const isParentReverseContainer = parentSlot ? isReverseFlow(parentSlot.flowDirection) : false;
          let parentGap = 0;
          if (nodesInfo && gapCount > 0) {
            const firstChildInfo = nodesInfo[parentChildren[0].id];
            const secondChildInfo = nodesInfo[parentChildren[1].id];
            const firstChildRect = firstChildInfo == null ? void 0 : firstChildInfo.rect;
            const secondChildRect = secondChildInfo == null ? void 0 : secondChildInfo.rect;
            if (firstChildRect && secondChildRect) {
              if (isParentHorizontalContainer) {
                parentGap = (isParentReverseContainer ? firstChildRect.x - secondChildRect.x - secondChildRect.width : secondChildRect.x - firstChildRect.x - firstChildRect.width) / 2;
              }
              if (isParentVerticalContainer) {
                parentGap = (isParentReverseContainer ? firstChildRect.y - secondChildRect.y - secondChildRect.height : secondChildRect.y - firstChildRect.y - firstChildRect.height) / 2;
              }
            }
          }
          const hasPositionGap = isParentReverseContainer ? isLastChild : isFirstChild;
          if (isParentVerticalContainer) {
            parentAwareBaseRect = {
              x: isPageChild ? 0 : baseRect.x,
              y: hasPositionGap ? baseRect.y : baseRect.y - parentGap,
              width: isPageChild && parentRect ? parentRect.x * 2 + parentRect.width : baseRect.width,
              height: baseRect.height + gapCount * parentGap
            };
          }
          if (isParentHorizontalContainer) {
            parentAwareBaseRect = {
              ...baseRect,
              x: hasPositionGap ? baseRect.x : baseRect.x - parentGap,
              width: baseRect.width + gapCount * parentGap
            };
          }
          if (parentAwareBaseRect) {
            if (parentProp) {
              rects[getDropAreaId(nodeId, parentProp)] = parentAwareBaseRect;
            } else {
              rects[nodeId] = parentAwareBaseRect;
            }
          }
        } else if (parentProp && baseRect) {
          rects[getDropAreaId(nodeId, parentProp)] = baseRect;
        } else if (baseRect) {
          rects[nodeId] = baseRect;
        }
      });
    });
    return rects;
  }, [dom, nodesInfo, pageNodes]);
  const getDropAreaRect = React102.useCallback(
    (nodeId, parentProp) => {
      if (parentProp) {
        const dropAreaId = getDropAreaId(nodeId, parentProp);
        return dropAreaRects[dropAreaId];
      }
      return dropAreaRects[nodeId];
    },
    [dropAreaRects]
  );
  const handleNodeDragOver = React102.useCallback(
    (event) => {
      event.preventDefault();
      const cursorPos = bridge == null ? void 0 : bridge.canvasCommands.getViewCoordinates(event.clientX, event.clientY);
      if (!cursorPos || !draggedNode) {
        return;
      }
      const activeDropAreaId = findAreaAt(dropAreaRects, cursorPos.x, cursorPos.y);
      const activeDropNodeId = activeDropAreaId && getDropAreaNodeId(activeDropAreaId) || pageNode.id;
      const activeDropNode = getNode(dom, activeDropNodeId);
      const activeDropNodeInfo = nodesInfo[activeDropNodeId];
      const activeDropNodeRect = activeDropNodeInfo == null ? void 0 : activeDropNodeInfo.rect;
      const activeDropNodeParent = getParent(dom, activeDropNode);
      const activeDropNodeSiblings = getSiblings(dom, activeDropNode);
      const isDraggingOverPage = isPage(activeDropNode);
      const isDraggingOverElement = isElement(activeDropNode);
      const activeDropSlotParentProp = isDraggingOverPage ? "children" : activeDropAreaId && getDropAreaParentProp(activeDropAreaId);
      const isDraggingOverContainer = activeDropNodeInfo ? hasFreeNodeSlots(activeDropNodeInfo) && activeDropSlotParentProp : false;
      let activeDropZone = null;
      const activeDropNodeSlots = (activeDropNodeInfo == null ? void 0 : activeDropNodeInfo.slots) || null;
      const activeDropSlot = activeDropNodeSlots && activeDropSlotParentProp && activeDropNodeSlots[activeDropSlotParentProp];
      const activeDropNodeChildren = activeDropSlotParentProp && (isDraggingOverPage || isElement(activeDropNode)) && getChildNodes(dom, activeDropNode)[activeDropSlotParentProp] || [];
      const isDraggingOverEmptyContainer = activeDropNodeInfo ? isDraggingOverContainer && activeDropNodeChildren.length === 0 : false;
      const activeDropAreaRect = isDraggingOverContainer && activeDropSlotParentProp ? getDropAreaRect(activeDropNodeId, activeDropSlotParentProp) : getDropAreaRect(activeDropNodeId);
      if (activeDropAreaRect) {
        const relativeX = cursorPos.x - activeDropAreaRect.x;
        const relativeY = cursorPos.y - activeDropAreaRect.y;
        activeDropZone = isDraggingOverEmptyContainer ? DROP_ZONE_CENTER : getRectangleEdgeDropZone(
          getRectanglePointActiveEdge(activeDropAreaRect, relativeX, relativeY)
        );
        if (isDraggingOverPage) {
          if (activeDropNodeRect && relativeY < 0 && !isEmptyPage) {
            activeDropZone = DROP_ZONE_TOP;
          } else {
            activeDropZone = DROP_ZONE_CENTER;
          }
        }
        const edgeDetectionMargin = 10;
        if (isDraggingOverElement && activeDropNodeInfo) {
          const isDraggingOverPageChild = activeDropNodeParent ? isPage(activeDropNodeParent) : false;
          if (!activeDropSlot || isHorizontalFlow(activeDropSlot.flowDirection)) {
            if (isDraggingOverPageChild && activeDropNodeRect && relativeX <= activeDropNodeRect.x) {
              activeDropZone = DROP_ZONE_LEFT;
            } else if (isDraggingOverPageChild && activeDropNodeRect && relativeX >= activeDropNodeRect.x + activeDropNodeRect.width) {
              activeDropZone = DROP_ZONE_RIGHT;
            } else if (relativeY <= edgeDetectionMargin && !isDraggingOverEmptyContainer) {
              activeDropZone = DROP_ZONE_TOP;
            } else if (activeDropAreaRect.height - relativeY <= edgeDetectionMargin && !isDraggingOverEmptyContainer) {
              activeDropZone = DROP_ZONE_BOTTOM;
            } else if (activeDropSlot) {
              activeDropZone = DROP_ZONE_CENTER;
            }
          }
          if (activeDropSlot && !isDraggingOverEmptyContainer && isVerticalFlow(activeDropSlot.flowDirection)) {
            if (relativeX <= edgeDetectionMargin) {
              activeDropZone = DROP_ZONE_LEFT;
            } else if (activeDropAreaRect.width - relativeX <= edgeDetectionMargin) {
              activeDropZone = DROP_ZONE_RIGHT;
            } else {
              activeDropZone = DROP_ZONE_CENTER;
            }
          }
        }
      }
      const hasChangedDropArea = activeDropNodeId !== dragOverNodeId || activeDropSlotParentProp !== dragOverSlotParentProp || activeDropZone !== dragOverZone;
      if (activeDropZone && hasChangedDropArea && availableDropTargetIds.has(activeDropNodeId)) {
        const isDragOverParentPageRow = activeDropNodeParent && isElement(activeDropNodeParent) && isPageRow(activeDropNodeParent);
        const activeDropNodeParentParent = activeDropNodeParent && getParent(dom, activeDropNodeParent);
        const activeDropNodeParentParentInfo = activeDropNodeParentParent && nodesInfo[activeDropNodeParentParent.id];
        const hasActiveDropNodeParentParentSlot = !!((activeDropNodeParentParentInfo == null ? void 0 : activeDropNodeParentParentInfo.slots) && (activeDropNodeParentParentInfo == null ? void 0 : activeDropNodeParentParentInfo.slots[activeDropSlotParentProp || "children"]));
        const hasDragOverParentRowOverride = isDragOverParentPageRow && hasActiveDropNodeParentParentSlot && activeDropNodeSiblings.length === 0 && (activeDropZone === DROP_ZONE_TOP || activeDropZone === DROP_ZONE_BOTTOM);
        api.nodeDragOver({
          nodeId: hasDragOverParentRowOverride ? activeDropNodeParent.id : activeDropNodeId,
          parentProp: activeDropSlotParentProp,
          zone: activeDropZone
        });
      }
    },
    [
      bridge,
      draggedNode,
      dropAreaRects,
      pageNode.id,
      dom,
      nodesInfo,
      getDropAreaRect,
      dragOverNodeId,
      dragOverSlotParentProp,
      dragOverZone,
      availableDropTargetIds,
      isEmptyPage,
      api
    ]
  );
  const handleNodeDrop = React102.useCallback(
    (event) => {
      const cursorPos = bridge == null ? void 0 : bridge.canvasCommands.getViewCoordinates(event.clientX, event.clientY);
      if (!draggedNode || !cursorPos || !dragOverNodeId || !dragOverZone || !availableDropZones.includes(dragOverZone)) {
        return;
      }
      let dragOverNode = getNode(dom, dragOverNodeId);
      if (!isElement(dragOverNode) && !isPage(dragOverNode)) {
        return;
      }
      const dragOverNodeInfo = nodesInfo[dragOverNodeId];
      const dragOverNodeParentProp = (dragOverNode == null ? void 0 : dragOverNode.parentProp) || null;
      if (!dragOverNodeParentProp) {
        return;
      }
      const dragOverNodeSlots = (dragOverNodeInfo == null ? void 0 : dragOverNodeInfo.slots) || null;
      const dragOverSlot = dragOverNodeSlots && dragOverSlotParentProp && dragOverNodeSlots[dragOverSlotParentProp] || null;
      const isDraggingOverLayout = dragOverNode && dragOverSlot ? isPage(dragOverNode) || dragOverSlot.type === "layout" : false;
      const isDraggingOverElement = isElement(dragOverNode);
      appStateApi.update(
        (draft) => {
          var _a2, _b;
          let parent = getParent(draft, dragOverNode);
          const originalParent = parent;
          const originalParentInfo = parent && nodesInfo[parent.id];
          const originalParentFreeSlots = originalParentInfo == null ? void 0 : originalParentInfo.slots;
          const originalParentFreeSlot = originalParentFreeSlots && dragOverNodeParentProp && originalParentFreeSlots[dragOverNodeParentProp];
          const isOriginalParentLayout = originalParent && originalParentFreeSlot ? isPage(originalParent) || originalParentFreeSlot.type === "layout" : false;
          const isOriginalParentRow = originalParent && isElement(originalParent) ? isPageRow(originalParent) : false;
          const isOriginalParentColumn = originalParent && isElement(originalParent) ? isPageColumn(originalParent) : false;
          const isMovingNode = selectedNodeId && !newNode;
          let addOrMoveNode = addNode;
          if (isMovingNode) {
            addOrMoveNode = moveNode;
          }
          if (isDraggingOverLayout && dragOverSlotParentProp) {
            const newParentIndex = dragOverZone === DROP_ZONE_TOP ? getNewFirstParentIndexInNode(draft, dragOverNode, dragOverSlotParentProp) : getNewLastParentIndexInNode(draft, dragOverNode, dragOverSlotParentProp);
            draft = addOrMoveNode(
              draft,
              draggedNode,
              dragOverNode,
              dragOverSlotParentProp,
              newParentIndex
            );
          }
          if (isDraggingOverElement && parent && (isPage(parent) || isElement(parent))) {
            const isDraggingOverRow = isDraggingOverElement && isPageRow(dragOverNode);
            const isDraggingOverHorizontalContainer = dragOverSlot ? isHorizontalFlow(dragOverSlot.flowDirection) : false;
            const isDraggingOverVerticalContainer = dragOverSlot ? isVerticalFlow(dragOverSlot.flowDirection) : false;
            if (dragOverZone === DROP_ZONE_CENTER && dragOverSlotParentProp) {
              draft = addOrMoveNode(draft, draggedNode, dragOverNode, dragOverSlotParentProp);
            }
            if ([DROP_ZONE_TOP, DROP_ZONE_BOTTOM].includes(dragOverZone)) {
              if (!isDraggingOverVerticalContainer) {
                const newParentIndex = dragOverZone === DROP_ZONE_TOP ? getNewParentIndexBeforeNode(
                  draft,
                  dragOverNode,
                  dragOverNodeParentProp
                ) : getNewParentIndexAfterNode(
                  draft,
                  dragOverNode,
                  dragOverNodeParentProp
                );
                if (isDraggingOverRow && !isPageRow(draggedNode)) {
                  draft = addOrMoveNode(
                    draft,
                    draggedNode,
                    parent,
                    dragOverNodeParentProp,
                    newParentIndex
                  );
                }
                if (isOriginalParentRow) {
                  const columnContainer = createElement(
                    draft,
                    PAGE_COLUMN_COMPONENT_ID,
                    {},
                    {
                      columnSize: ((_a2 = dragOverNode.layout) == null ? void 0 : _a2.columnSize) || 1
                    }
                  );
                  draft = setNodeNamespacedProp(
                    draft,
                    dragOverNode,
                    "layout",
                    "columnSize",
                    1
                  );
                  dragOverNode = getNode(draft, dragOverNodeId);
                  draft = addNode(
                    draft,
                    columnContainer,
                    parent,
                    dragOverNodeParentProp,
                    getNewParentIndexAfterNode(draft, dragOverNode, dragOverNodeParentProp)
                  );
                  parent = columnContainer;
                  if (dragOverZone === DROP_ZONE_BOTTOM) {
                    draft = moveNode(draft, dragOverNode, parent, dragOverNodeParentProp);
                  }
                }
                if (!isDraggingOverRow || isPageRow(draggedNode)) {
                  draft = addOrMoveNode(
                    draft,
                    draggedNode,
                    parent,
                    dragOverNodeParentProp,
                    newParentIndex
                  );
                }
                if (isOriginalParentRow && !isDraggingOverVerticalContainer && dragOverZone === DROP_ZONE_TOP) {
                  draft = moveNode(draft, dragOverNode, parent, dragOverNodeParentProp);
                }
              }
              if (dragOverSlotParentProp && isDraggingOverVerticalContainer) {
                const isDraggingOverDirectionStart = dragOverZone === ((dragOverSlot == null ? void 0 : dragOverSlot.flowDirection) === "column" ? DROP_ZONE_TOP : DROP_ZONE_BOTTOM);
                const newParentIndex = isDraggingOverDirectionStart ? getNewFirstParentIndexInNode(draft, dragOverNode, dragOverSlotParentProp) : getNewLastParentIndexInNode(draft, dragOverNode, dragOverSlotParentProp);
                draft = addOrMoveNode(
                  draft,
                  draggedNode,
                  dragOverNode,
                  dragOverSlotParentProp,
                  newParentIndex
                );
              }
            }
            if ([DROP_ZONE_RIGHT, DROP_ZONE_LEFT].includes(dragOverZone)) {
              if (!isDraggingOverHorizontalContainer) {
                const hasNewPageRow = isOriginalParentLayout || isOriginalParentColumn;
                if (hasNewPageRow) {
                  const rowContainer = createElement(draft, PAGE_ROW_COMPONENT_ID, {
                    justifyContent: (originalParentInfo == null ? void 0 : originalParentInfo.props.alignItems) || "start"
                  });
                  draft = addNode(
                    draft,
                    rowContainer,
                    parent,
                    dragOverNodeParentProp,
                    getNewParentIndexAfterNode(draft, dragOverNode, dragOverNodeParentProp)
                  );
                  parent = rowContainer;
                  if (dragOverZone === DROP_ZONE_RIGHT) {
                    draft = moveNode(draft, dragOverNode, parent, "children");
                  }
                }
                const newParentIndex = dragOverZone === DROP_ZONE_RIGHT ? getNewParentIndexAfterNode(draft, dragOverNode, dragOverNodeParentProp) : getNewParentIndexBeforeNode(
                  draft,
                  dragOverNode,
                  dragOverNodeParentProp
                );
                draft = addOrMoveNode(
                  draft,
                  draggedNode,
                  parent,
                  hasNewPageRow ? "children" : dragOverNodeParentProp,
                  newParentIndex
                );
                if (hasNewPageRow && dragOverZone === DROP_ZONE_LEFT) {
                  draft = moveNode(draft, dragOverNode, parent, "children");
                }
              }
              if (dragOverSlotParentProp && isDraggingOverHorizontalContainer) {
                const isDraggingOverDirectionStart = dragOverZone === ((dragOverSlot == null ? void 0 : dragOverSlot.flowDirection) === "row" ? DROP_ZONE_LEFT : DROP_ZONE_RIGHT);
                const newParentIndex = isDraggingOverDirectionStart ? getNewFirstParentIndexInNode(draft, dragOverNode, dragOverSlotParentProp) : getNewLastParentIndexInNode(draft, dragOverNode, dragOverSlotParentProp);
                draft = addOrMoveNode(
                  draft,
                  draggedNode,
                  dragOverNode,
                  dragOverSlotParentProp,
                  newParentIndex
                );
              }
            }
            const draggedNodeParent = isMovingNode ? getParent(draft, draggedNode) : null;
            if (((_b = draggedNode.layout) == null ? void 0 : _b.columnSize) && draggedNodeParent && originalParent && draggedNodeParent.id !== originalParent.id) {
              draft = setNodeNamespacedProp(draft, draggedNode, "layout", "columnSize", 1);
            }
          }
          if (isMovingNode) {
            draft = deleteOrphanedLayoutNodes(dom, draft, draggedNode, dragOverNodeId);
          }
          return normalizePageRowColumnSizes(draft, pageNode);
        },
        currentView.kind === "page" ? { ...omit(currentView, "pageViewTab"), selectedNodeId: (newNode == null ? void 0 : newNode.id) || draggedNodeId } : currentView
      );
      api.dragEnd();
      if (newNode) {
        const overlayElement = overlayRef.current;
        (0, import_invariant4.default)(overlayElement, "Overlay ref not bound");
        overlayElement.focus();
      }
    },
    [
      api,
      appStateApi,
      availableDropZones,
      bridge == null ? void 0 : bridge.canvasCommands,
      currentView,
      dom,
      dragOverNodeId,
      dragOverSlotParentProp,
      dragOverZone,
      draggedNode,
      draggedNodeId,
      newNode,
      nodesInfo,
      pageNode,
      selectedNodeId
    ]
  );
  const handleNodeDragEnd = React102.useCallback(
    (event) => {
      event.preventDefault();
      api.dragEnd();
    },
    [api]
  );
  React102.useEffect(() => {
    const handleNodeDragOverDefault = (event) => {
      event.preventDefault();
    };
    window.addEventListener("dragover", handleNodeDragOverDefault);
    window.addEventListener("dragend", handleNodeDragEnd);
    return () => {
      window.removeEventListener("dragover", handleNodeDragOverDefault);
      window.removeEventListener("dragend", handleNodeDragEnd);
    };
  }, [handleNodeDragEnd]);
  const scrollSelectedNode = React102.useCallback(() => {
    if (!selectedNode) {
      return;
    }
    bridge == null ? void 0 : bridge.canvasCommands.scrollComponent(selectedNode.id);
  }, [bridge == null ? void 0 : bridge.canvasCommands, selectedNode]);
  React102.useEffect(() => {
    scrollSelectedNode();
  }, [scrollSelectedNode]);
  const resizePreviewElementRef = React102.useRef(null);
  const overlayGridRef = React102.useRef({
    gridElement: null,
    getMinColumnWidth: () => 0,
    getLeftColumnEdges: () => [],
    getRightColumnEdges: () => []
  });
  const handleEdgeDragOver = React102.useCallback(
    (event) => {
      var _a2, _b;
      if (!draggedNode) {
        return;
      }
      const resizePreviewElement = resizePreviewElementRef.current;
      const draggedNodeInfo = nodesInfo[draggedNode.id];
      const draggedNodeRect = draggedNodeInfo == null ? void 0 : draggedNodeInfo.rect;
      const parent = draggedNode && getParent(dom, draggedNode);
      const parentInfo = parent ? nodesInfo[parent.id] : null;
      const parentRect = parentInfo == null ? void 0 : parentInfo.rect;
      const cursorPos = bridge == null ? void 0 : bridge.canvasCommands.getViewCoordinates(event.clientX, event.clientY);
      const previousSibling = getSiblingBeforeNode(dom, draggedNode, "children");
      const previousSiblingInfo = previousSibling && nodesInfo[previousSibling.id];
      const previousSiblingRect = previousSiblingInfo == null ? void 0 : previousSiblingInfo.rect;
      if (draggedNodeRect && parentRect && resizePreviewElement && cursorPos) {
        if (draggedEdge === RECTANGLE_EDGE_LEFT || draggedEdge === RECTANGLE_EDGE_RIGHT) {
          let snappedToGridCursorRelativePosX = cursorPos.x - draggedNodeRect.x;
          const activeSnapGridColumnEdges = draggedEdge === RECTANGLE_EDGE_LEFT ? overlayGridRef.current.getLeftColumnEdges() : overlayGridRef.current.getRightColumnEdges();
          const minGridColumnWidth = overlayGridRef.current.getMinColumnWidth();
          for (const gridColumnEdge of activeSnapGridColumnEdges) {
            if (Math.abs(gridColumnEdge - cursorPos.x) <= minGridColumnWidth) {
              snappedToGridCursorRelativePosX = gridColumnEdge - draggedNodeRect.x;
            }
          }
          if (draggedEdge === RECTANGLE_EDGE_LEFT && cursorPos.x > Math.max(parentRect.x, (previousSiblingRect == null ? void 0 : previousSiblingRect.x) || 0) + minGridColumnWidth && cursorPos.x < draggedNodeRect.x + draggedNodeRect.width - minGridColumnWidth) {
            const updatedTransformScale = 1 - snappedToGridCursorRelativePosX / draggedNodeRect.width;
            resizePreviewElement.style.transformOrigin = "100% 50%";
            resizePreviewElement.style.transform = `scaleX(${updatedTransformScale})`;
          }
          const nextSibling = getSiblingAfterNode(dom, draggedNode, "children");
          const nextSiblingInfo = nextSibling && nodesInfo[nextSibling.id];
          const nextSiblingRect = nextSiblingInfo == null ? void 0 : nextSiblingInfo.rect;
          if (draggedEdge === RECTANGLE_EDGE_RIGHT && cursorPos.x > draggedNodeRect.x + minGridColumnWidth && cursorPos.x < Math.min(
            parentRect.x + parentRect.width,
            nextSiblingRect ? nextSiblingRect.x + nextSiblingRect.width : 0
          ) - minGridColumnWidth) {
            const updatedTransformScale = snappedToGridCursorRelativePosX / draggedNodeRect.width;
            resizePreviewElement.style.transformOrigin = "0 50%";
            resizePreviewElement.style.transform = `scaleX(${updatedTransformScale})`;
          }
        }
        const defaultMinimumResizableHeight = 16;
        const minimumVerticalResizeHeight = ((_a2 = draggedNodeInfo.componentConfig) == null ? void 0 : _a2.minimumLayoutHeight) ?? defaultMinimumResizableHeight;
        const previousSiblingMinimumVerticalResizeHeight = ((_b = previousSiblingInfo == null ? void 0 : previousSiblingInfo.componentConfig) == null ? void 0 : _b.minimumLayoutHeight) ?? defaultMinimumResizableHeight;
        if (draggedEdge === RECTANGLE_EDGE_BOTTOM && cursorPos.y > draggedNodeRect.y + minimumVerticalResizeHeight) {
          const snappedToGridCursorRelativePosY = Math.ceil((cursorPos.y - draggedNodeRect.y) / VERTICAL_RESIZE_SNAP_UNITS) * VERTICAL_RESIZE_SNAP_UNITS;
          const updatedTransformScale = snappedToGridCursorRelativePosY / draggedNodeRect.height;
          resizePreviewElement.style.transformOrigin = "50% 0";
          resizePreviewElement.style.transform = `scaleY(${updatedTransformScale})`;
        }
        if (draggedEdge === RECTANGLE_EDGE_TOP && cursorPos.y < draggedNodeRect.y + draggedNodeRect.height - minimumVerticalResizeHeight && (!previousSiblingRect || cursorPos.y > draggedNodeRect.y - previousSiblingRect.height + previousSiblingMinimumVerticalResizeHeight)) {
          const snappedToGridCursorRelativePosY = Math.ceil(
            (draggedNodeRect.y + draggedNodeRect.height - cursorPos.y) / VERTICAL_RESIZE_SNAP_UNITS
          ) * VERTICAL_RESIZE_SNAP_UNITS;
          const updatedTransformScale = snappedToGridCursorRelativePosY / draggedNodeRect.height;
          resizePreviewElement.style.transformOrigin = "50% 100%";
          resizePreviewElement.style.transform = `scaleY(${updatedTransformScale})`;
        }
      }
    },
    [bridge, dom, draggedEdge, draggedNode, nodesInfo]
  );
  const handleEdgeDragEnd = React102.useCallback(
    (event) => {
      event.preventDefault();
      if (!draggedNode) {
        return;
      }
      const draggedNodeInfo = nodesInfo[draggedNode.id];
      const draggedNodeRect = draggedNodeInfo == null ? void 0 : draggedNodeInfo.rect;
      const resizePreviewElement = resizePreviewElementRef.current;
      const resizePreviewRect = resizePreviewElement == null ? void 0 : resizePreviewElement.getBoundingClientRect();
      if (draggedNodeRect && resizePreviewRect) {
        domApi.update((draft) => {
          var _a2, _b, _c, _d;
          const previousSibling = getSiblingBeforeNode(draft, draggedNode, "children");
          let previousSiblingInfo = null;
          let previousSiblingRect = null;
          if (previousSibling) {
            previousSiblingInfo = nodesInfo[previousSibling.id];
            previousSiblingRect = previousSiblingInfo == null ? void 0 : previousSiblingInfo.rect;
          }
          if (draggedEdge === RECTANGLE_EDGE_LEFT || draggedEdge === RECTANGLE_EDGE_RIGHT) {
            if (draggedEdge === RECTANGLE_EDGE_LEFT) {
              if (previousSibling && previousSiblingRect) {
                const totalResizedColumnsSize = (((_a2 = draggedNode.layout) == null ? void 0 : _a2.columnSize) || 1) + (((_b = previousSibling.layout) == null ? void 0 : _b.columnSize) || 1);
                const totalResizedColumnsWidth = draggedNodeRect.width + previousSiblingRect.width;
                const updatedDraggedNodeColumnSize = resizePreviewRect.width / totalResizedColumnsWidth * totalResizedColumnsSize;
                const updatedPreviousSiblingColumnSize = totalResizedColumnsSize - updatedDraggedNodeColumnSize;
                draft = setNodeNamespacedProp(
                  draft,
                  draggedNode,
                  "layout",
                  "columnSize",
                  updatedDraggedNodeColumnSize
                );
                draft = setNodeNamespacedProp(
                  draft,
                  previousSibling,
                  "layout",
                  "columnSize",
                  updatedPreviousSiblingColumnSize
                );
              }
            }
            if (draggedEdge === RECTANGLE_EDGE_RIGHT) {
              const nextSibling = getSiblingAfterNode(draft, draggedNode, "children");
              if (nextSibling) {
                const nextSiblingInfo = nodesInfo[nextSibling.id];
                const nextSiblingRect = nextSiblingInfo == null ? void 0 : nextSiblingInfo.rect;
                if (nextSiblingRect) {
                  const totalResizedColumnsSize = (((_c = draggedNode.layout) == null ? void 0 : _c.columnSize) || 1) + (((_d = nextSibling.layout) == null ? void 0 : _d.columnSize) || 1);
                  const totalResizedColumnsWidth = draggedNodeRect.width + nextSiblingRect.width;
                  const updatedDraggedNodeColumnSize = resizePreviewRect.width / totalResizedColumnsWidth * totalResizedColumnsSize;
                  const updatedNextSiblingColumnSize = totalResizedColumnsSize - updatedDraggedNodeColumnSize;
                  draft = setNodeNamespacedProp(
                    draft,
                    draggedNode,
                    "layout",
                    "columnSize",
                    updatedDraggedNodeColumnSize
                  );
                  draft = setNodeNamespacedProp(
                    draft,
                    nextSibling,
                    "layout",
                    "columnSize",
                    updatedNextSiblingColumnSize
                  );
                }
              }
            }
          }
          if (draggedEdge === RECTANGLE_EDGE_BOTTOM || draggedEdge === RECTANGLE_EDGE_TOP) {
            const isValidTopResize = draggedEdge === RECTANGLE_EDGE_TOP && previousSibling && previousSiblingRect && !isPageRow(previousSibling);
            if (draggedEdge === RECTANGLE_EDGE_BOTTOM || isValidTopResize) {
              draft = setNodeNamespacedProp(
                draft,
                draggedNode,
                "layout",
                "height",
                resizePreviewRect.height
              );
            }
            if (isValidTopResize && previousSiblingRect) {
              draft = setNodeNamespacedProp(
                draft,
                previousSibling,
                "layout",
                "height",
                previousSiblingRect.height + (draggedNodeRect.height - resizePreviewRect.height)
              );
            }
          }
          return draft;
        });
      }
      api.dragEnd();
    },
    [api, domApi, draggedEdge, draggedNode, nodesInfo]
  );
  return React102.createElement(
    OverlayRoot,
    {
      "data-testid": "page-overlay",
      ref: overlayRef,
      className: clsx_default({
        [overlayClasses.nodeDrag]: isDraggingOver,
        [overlayClasses.resizeHorizontal]: draggedEdge === RECTANGLE_EDGE_LEFT || draggedEdge === RECTANGLE_EDGE_RIGHT,
        [overlayClasses.resizeVertical]: draggedEdge === RECTANGLE_EDGE_TOP || draggedEdge === RECTANGLE_EDGE_BOTTOM
      }),
      tabIndex: 0,
      onKeyDown: handleKeyDown,
      ...draggedEdge ? {
        onMouseMove: handleEdgeDragOver,
        onMouseUp: handleEdgeDragEnd
      } : {
        onDragOver: handleNodeDragOver,
        onDrop: handleNodeDrop,
        onDragEnd: handleNodeDragEnd,
        // This component has `pointer-events: none`, but we will selectively enable pointer-events
        // for its children. We can still capture the click gobally
        onMouseUp: handleNodeMouseUp
      }
    },
    pageNodes.map((node) => {
      const nodeInfo = nodesInfo[node.id];
      const nodeRect = (nodeInfo == null ? void 0 : nodeInfo.rect) || null;
      const parent = getParent(dom, node);
      const isPageNode = isPage(node);
      const isElementNode = isElement(node);
      const isPageRowChild = parent ? isElement(parent) && isPageRow(parent) : false;
      const isPageColumnChild = parent ? isElement(parent) && isPageColumn(parent) : false;
      const isSelected = selectedNode && !newNode ? selectedNode.id === node.id : false;
      const isHovered = hoveredNodeId === node.id;
      const isHorizontallyResizable = isPageRowChild || isPageColumnChild;
      const nodeComponentId = isElementNode ? getElementNodeComponentId(node) : null;
      const isVerticallyResizable = isElementNode && !isPageRow(node) && !isPageColumn(node) && (nodeComponentId === "Chart" || nodeComponentId === "DataGrid" || nodeComponentId === "Spacer");
      const isResizing = Boolean(draggedEdge);
      const isResizingNode = isResizing && node.id === draggedNodeId;
      const isInteractive = interactiveNodes.has(node.id) && !isResizing && !isDraggingOver;
      if (!nodeRect) {
        return null;
      }
      return React102.createElement(React102.Fragment, { key: node.id }, !isPageNode ? React102.createElement(
        NodeHud,
        {
          node,
          rect: nodeRect,
          selectedNodeRect: selectedRect,
          isSelected,
          isInteractive,
          onNodeDragStart: handleNodeDragStart(node),
          onDuplicate: handleNodeDuplicate(node),
          draggableEdges: [
            ...isHorizontallyResizable ? getNodeDraggableHorizontalEdges(parent && isPageColumnChild ? parent : node) : [],
            ...isVerticallyResizable ? [
              RECTANGLE_EDGE_BOTTOM
              // @TODO: Improve solution for resizing from top, it's still not a great UX
              // ...(!isFirstChild ? [RECTANGLE_EDGE_TOP as RectangleEdge] : []),
            ] : []
          ],
          onEdgeDragStart: isSelected ? handleEdgeDragStart(node) : void 0,
          onDelete: handleNodeDelete(node.id),
          isResizing: isResizingNode,
          resizePreviewElementRef,
          isHovered,
          isHoverable: !isResizing && !isDraggingOver,
          isOutlineVisible: isDraggingOver
        }
      ) : null);
    }),
    Object.entries(dropAreaRects).map(([dropAreaId, dropAreaRect]) => {
      const dropAreaNodeId = getDropAreaNodeId(dropAreaId);
      const dropAreaParentProp = getDropAreaParentProp(dropAreaId);
      const dropAreaNode = getNode(dom, dropAreaNodeId);
      return React102.createElement(
        NodeDropArea,
        {
          key: dropAreaId,
          node: dropAreaNode,
          parentProp: dropAreaParentProp,
          dropAreaRect,
          availableDropZones
        }
      );
    }),
    React102.createElement(PinholeOverlay, { className: overlayClasses.hudOverlay, pinhole: selectedRect }),
    draggedEdge ? React102.createElement(OverlayGrid, { ref: overlayGridRef }) : null
  );
}
var classes = {
  view: "Toolpad_View"
};
var RenderPanelRoot = styled_default("div")({
  position: "relative",
  overflow: "hidden",
  [`& .${classes.view}`]: {
    height: "100%"
  }
});
function useRuntimeState() {
  const { dom } = useAppState();
  return React112.useMemo(() => createRuntimeState({ dom }), [dom]);
}
function RenderPanel({ className }) {
  const appState = useAppState();
  const domApi = useDomApi();
  const appStateApi = useAppStateApi();
  const pageEditorApi = usePageEditorApi();
  const { nodeId: pageNodeId } = usePageEditorState();
  const page = getNode(appState.dom, pageNodeId, "page");
  const [bridge, setBridge] = React112.useState(null);
  const savedNodes = React112.useMemo(
    () => getNodeHashes(appState.savedDom),
    [appState.savedDom]
  );
  const handleInit = useEventCallback_default((initializedBridge) => {
    initializedBridge.canvasEvents.on("propUpdated", (event) => {
      domApi.update((draft) => {
        var _a;
        const node = getMaybeNode(draft, event.nodeId, "element");
        if (!node) {
          return draft;
        }
        const actual = (_a = node.props) == null ? void 0 : _a[event.prop];
        if (actual && getBindingType(actual) !== "const") {
          console.warn(`Can't update a non-const prop "${event.prop}" on node "${node.id}"`);
          return draft;
        }
        const newValue = typeof event.value === "function" ? event.value(actual) : event.value;
        draft = setNodeNamespacedProp(draft, node, "props", event.prop, newValue);
        return draft;
      });
    });
    initializedBridge.canvasEvents.on("editorNodeDataUpdated", (event) => {
      pageEditorApi.nodeDataUpdate(event.nodeId, event.prop, event.value);
    });
    initializedBridge.canvasEvents.on("pageStateUpdated", (event) => {
      pageEditorApi.pageStateUpdate(event.pageState, event.globalScopeMeta);
    });
    initializedBridge.canvasEvents.on("pageBindingsUpdated", (event) => {
      pageEditorApi.pageBindingsUpdate(event.bindings);
    });
    initializedBridge.canvasEvents.on("vmUpdated", (event) => {
      pageEditorApi.vmUpdate(event.vm);
    });
    initializedBridge.canvasEvents.on("screenUpdate", () => {
      const pageViewState = initializedBridge.canvasCommands.getPageViewState();
      pageEditorApi.pageViewStateUpdate(pageViewState);
    });
    initializedBridge.canvasEvents.on("pageNavigationRequest", (event) => {
      appStateApi.setView({ kind: "page", name: event.pageName });
    });
    setBridge(initializedBridge);
  });
  const runtimeState = useRuntimeState();
  return React112.createElement(RenderPanelRoot, { className }, React112.createElement(
    EditorCanvasHost,
    {
      className: classes.view,
      runtimeState,
      base: appState.appUrl,
      savedNodes,
      pageName: page.name,
      overlay: React112.createElement(RenderOverlay, { bridge }),
      onInit: handleInit
    }
  ));
}
var RenderPanel_default = RenderPanel;
function renderStringValueEditor({
  label,
  disabled,
  value,
  onChange
}) {
  return React122.createElement(
    TextField_default,
    {
      label,
      disabled,
      value,
      onChange: (event) => onChange(event.target.value)
    }
  );
}
function MapEntriesEditor({
  value,
  onChange,
  label,
  fieldLabel = "field",
  valueLabel = "value",
  defaultValue: defaultValueProp,
  autoFocus = false,
  sx,
  renderValueEditor: renderValueEditorProp,
  disabled,
  isEntryDisabled
}) {
  const fieldInputRef = React122.useRef(null);
  const handleRemove = React122.useCallback(
    (index) => () => {
      onChange(value.filter((entry, i) => i !== index));
    },
    [onChange, value]
  );
  const isValidFieldName = React122.useMemo(() => {
    const counts = {};
    value.forEach(([field]) => {
      counts[field] = counts[field] ? counts[field] + 1 : 1;
    });
    return value.map(([field]) => !!field && counts[field] <= 1);
  }, [value]);
  const renderValueEditor = renderValueEditorProp ?? renderStringValueEditor;
  const defaultValue = defaultValueProp ?? "";
  return React122.createElement(Box_default2, { sx, display: "grid", gridTemplateColumns: "1fr 2fr auto", alignItems: "center", gap: 1 }, label ? React122.createElement(Box_default2, { gridColumn: "span 3" }, label, ":") : null, value.map((entry, index) => {
    const [field, fieldValue] = entry;
    const entryDisabled = disabled || (isEntryDisabled == null ? void 0 : isEntryDisabled(entry, index));
    return React122.createElement(React122.Fragment, { key: index }, React122.createElement(
      TextField_default,
      {
        disabled: entryDisabled,
        label: fieldLabel,
        value: field,
        autoFocus: true,
        onChange: (event) => onChange(
          value.map(
            (existingEntry, i) => i === index ? [event.target.value, existingEntry[1]] : existingEntry
          )
        ),
        error: !isValidFieldName[index]
      }
    ), renderValueEditor({
      label: valueLabel,
      value: fieldValue,
      onChange(newValue) {
        onChange(
          value.map(
            (existingEntry, i) => i === index ? [existingEntry[0], newValue] : existingEntry
          )
        );
      },
      disabled: entryDisabled
    }), React122.createElement(
      IconButton_default,
      {
        "aria-label": "Delete property",
        onClick: handleRemove(index),
        disabled: entryDisabled
      },
      React122.createElement(Delete_default, null)
    ));
  }), React122.createElement("form", { autoComplete: "off", style: { display: "contents" } }, React122.createElement(
    TextField_default,
    {
      inputRef: fieldInputRef,
      label: fieldLabel,
      value: "",
      onChange: (event) => {
        onChange([...value, [event.target.value, defaultValue]]);
      },
      autoFocus,
      disabled
    }
  )));
}
function useUnsavedChangesConfirm({
  hasUnsavedChanges,
  onClose
}) {
  const handleCloseWithUnsavedChanges = React132.useCallback(() => {
    if (hasUnsavedChanges) {
      const hasConfirmed = window.confirm(
        'You have unsaved changes. Are you sure you want to navigate away? All changes will be discarded when you press "OK".'
      );
      if (!hasConfirmed) {
        return;
      }
    }
    onClose();
  }, [hasUnsavedChanges, onClose]);
  return { handleCloseWithUnsavedChanges };
}
function UrlQueryString({ input }) {
  const queryString = React142.useMemo(() => {
    const search = new URLSearchParams(input).toString();
    return search.length ? search : "";
  }, [input]);
  return React142.createElement(React142.Fragment, null, React142.createElement(Divider_default, { variant: "middle", sx: { alignSelf: "stretch", marginTop: "20px" } }), React142.createElement(Typography_default, { variant: "overline" }, "Usage Preview:"), React142.createElement(Typography_default, null, React142.createElement("code", null, queryString)));
}
function UrlQueryEditor({ pageNodeId }) {
  const { dom } = useAppState();
  const { currentView } = useAppState();
  const domApi = useDomApi();
  const appStateApi = useAppStateApi();
  const page = getNode(dom, pageNodeId, "page");
  const { value: isDialogOpen, setTrue: openDialog, setFalse: closeDialog } = useBoolean(false);
  const value = page.attributes.parameters;
  const [input, setInput] = React142.useState(value);
  const hasUnsavedChanges = input !== value;
  React142.useEffect(() => {
    if (isDialogOpen) {
      setInput(value);
    }
  }, [isDialogOpen, value]);
  const handleButtonClick = React142.useCallback(() => {
    appStateApi.setView({
      ...currentView,
      kind: "page",
      name: page.name,
      pageParametersDialogOpen: true
    });
  }, [appStateApi, page.name, currentView]);
  const handleDialogClose = React142.useCallback(() => {
    appStateApi.setView({
      ...currentView,
      kind: "page",
      name: page.name,
      pageParametersDialogOpen: false
    });
  }, [appStateApi, page.name, currentView]);
  const { handleCloseWithUnsavedChanges } = useUnsavedChangesConfirm({
    hasUnsavedChanges,
    onClose: handleDialogClose
  });
  const handleSave = React142.useCallback(() => {
    domApi.update(
      (draft) => setNodeNamespacedProp(draft, page, "attributes", "parameters", input || [])
    );
    handleDialogClose();
  }, [domApi, handleDialogClose, input, page]);
  React142.useEffect(() => {
    if (currentView.kind === "page" && currentView.pageParametersDialogOpen) {
      openDialog();
    } else {
      closeDialog();
    }
  }, [closeDialog, currentView, openDialog]);
  return React142.createElement("div", null, React142.createElement(Button_default, { color: "inherit", startIcon: React142.createElement(Add_default, null), onClick: handleButtonClick }, "Add page parameters"), React142.createElement(Dialog_default, { fullWidth: true, open: isDialogOpen, onClose: handleCloseWithUnsavedChanges }, React142.createElement(DialogTitle_default, null, "Edit page parameters"), React142.createElement(DialogContent_default, null, React142.createElement(Typography_default, null, "Page parameters allow you to pass external data into the Toolpad Studio page state via the URL query. Read more in the", " ", React142.createElement(
    Link_default,
    {
      href: "https://mui.com/toolpad/studio/concepts/page-properties/#page-parameters",
      target: "_blank",
      rel: "noopener"
    },
    "docs"
  ), "."), React142.createElement(UrlQueryString, { input }), React142.createElement(
    MapEntriesEditor,
    {
      sx: { my: 3 },
      fieldLabel: "Parameter",
      valueLabel: "Default value",
      value: input || [],
      onChange: setInput
    }
  )), React142.createElement(DialogActions_default, null, React142.createElement(Button_default, { color: "inherit", variant: "text", onClick: handleDialogClose }, "Close"), React142.createElement(Button_default, { disabled: value === input, onClick: handleSave }, "Save"))));
}
function useNodeNameValidation(name, disallowedNames, kind) {
  return React152.useMemo(
    () => validateNodeName(name, disallowedNames, kind),
    [name, disallowedNames, kind]
  );
}
function NodeNameEditor({ node, sx }) {
  const domApi = useDomApi();
  const { dom } = useAppState();
  const projectApi = useProjectApi();
  const [nameInput, setNameInput] = React162.useState(node.name);
  React162.useEffect(() => setNameInput(node.name), [node.name]);
  const handleNameInputChange = React162.useCallback(
    (event) => setNameInput(event.target.value),
    []
  );
  const existingNames = React162.useMemo(() => getExistingNamesForNode(dom, node), [dom, node]);
  const nodeNameError = useNodeNameValidation(nameInput, existingNames, node.type);
  const isNameValid = !nodeNameError;
  const handleNameCommit = React162.useCallback(() => {
    if (isNameValid) {
      domApi.setNodeName(node.id, nameInput);
    } else {
      setNameInput(node.name);
    }
    const oldname = dom.nodes[node.id];
    if (isNameValid && oldname.type === "page" && nameInput !== oldname.name) {
      setTimeout(async () => {
        await projectApi.methods.deletePage(oldname.name);
      }, 300);
    }
  }, [projectApi, isNameValid, domApi, node.id, node.name, nameInput, dom]);
  const handleKeyPress = React162.useCallback(
    (event) => {
      if (event.key === "Enter") {
        handleNameCommit();
      }
    },
    [handleNameCommit]
  );
  return React162.createElement(
    TextField_default,
    {
      sx,
      fullWidth: true,
      label: "Node name",
      error: !isNameValid,
      helperText: nodeNameError,
      value: nameInput,
      onChange: handleNameInputChange,
      onBlur: handleNameCommit,
      onKeyPress: handleKeyPress
    }
  );
}
function validateInput(input) {
  if (!input) {
    return "Input required";
  }
  return null;
}
function PageTitleEditor({ node }) {
  const domApi = useDomApi();
  const [pageTitleInput, setPageTitleInput] = React172.useState(getPageTitle(node));
  const handlePageTitleChange = React172.useCallback(
    (event) => setPageTitleInput(event.target.value),
    []
  );
  const handleCommit = React172.useCallback(() => {
    domApi.update(
      (dom) => setNodeNamespacedProp(dom, node, "attributes", "title", pageTitleInput)
    );
  }, [node, pageTitleInput, domApi]);
  const handleKeyPress = React172.useCallback(
    (event) => {
      if (event.code === "Enter") {
        handleCommit();
      }
    },
    [handleCommit]
  );
  return React172.createElement(
    TextField_default,
    {
      fullWidth: true,
      label: "Page title",
      value: pageTitleInput,
      onChange: handlePageTitleChange,
      onBlur: handleCommit,
      onKeyDown: handleKeyPress,
      error: !pageTitleInput,
      helperText: validateInput(pageTitleInput)
    }
  );
}
function validateInput2(input) {
  if (!input) {
    return "Input required";
  }
  return null;
}
function PageDisplayNameEditor({ node }) {
  const domApi = useDomApi();
  const pageDisplayName = React182.useMemo(() => getPageDisplayName(node), [node]);
  const [pageDisplayNameInput, setPageDisplayNameInput] = React182.useState(pageDisplayName);
  React182.useEffect(() => setPageDisplayNameInput(pageDisplayName), [pageDisplayName]);
  const handlePageDisplayNameChange = React182.useCallback(
    (event) => setPageDisplayNameInput(event.target.value),
    []
  );
  const handleCommit = React182.useCallback(() => {
    domApi.update(
      (dom) => setNodeNamespacedProp(dom, node, "attributes", "displayName", pageDisplayNameInput)
    );
  }, [node, pageDisplayNameInput, domApi]);
  const handleReset = React182.useCallback(() => {
    domApi.update(
      (dom) => setNodeNamespacedProp(dom, node, "attributes", "displayName", void 0)
    );
  }, [node, domApi]);
  const handleKeyPress = React182.useCallback(
    (event) => {
      if (event.code === "Enter") {
        handleCommit();
      }
    },
    [handleCommit]
  );
  return React182.createElement(
    TextField_default,
    {
      fullWidth: true,
      label: "Display name",
      value: pageDisplayNameInput,
      onChange: handlePageDisplayNameChange,
      onBlur: handleCommit,
      onKeyDown: handleKeyPress,
      error: !pageDisplayNameInput,
      helperText: validateInput2(pageDisplayNameInput),
      slotProps: {
        input: {
          endAdornment: pageDisplayNameInput === node.attributes.displayName ? React182.createElement(InputAdornment_default, { position: "end" }, React182.createElement(Tooltip_default, { title: "Reset to default value" }, React182.createElement(IconButton_default, { onClick: handleReset, edge: "end" }, React182.createElement(RestartAlt_default, null)))) : null
        }
      }
    }
  );
}
var AlertRoot = styled_default(Alert_default)({
  ".MuiAlert-action": {
    paddingTop: 0
  }
});
function UpgradeAlert({ sx, type, action, message }) {
  return React192.createElement(
    AlertRoot,
    {
      severity: type ?? "info",
      sx,
      action: action ? React192.createElement(
        Button_default,
        {
          variant: "text",
          size: "small",
          href: UPGRADE_URL,
          target: "_blank",
          rel: "noopener",
          endIcon: React192.createElement(OpenInNew_default, { fontSize: "small" })
        },
        "Upgrade"
      ) : null
    },
    message
  );
}
function UpgradeChip({
  sx,
  message = `This feature requires a paid plan.`,
  url = UPGRADE_URL
}) {
  return React192.createElement(Tooltip_default, { title: `${message} Click to learn more.` }, React192.createElement(
    Chip_default,
    {
      variant: "outlined",
      color: "primary",
      component: "a",
      href: url,
      target: "_blank",
      rel: "noopener",
      size: "small",
      clickable: true,
      label: "Pro",
      sx
    }
  ));
}
var PAGE_DISPLAY_OPTIONS = [
  { value: "shell", label: "App shell" },
  { value: "standalone", label: "No shell" }
];
var PAGE_CONTAINER_WIDTH_OPTIONS = [
  { value: "xs", label: "xs" },
  { value: "sm", label: "sm" },
  { value: "md", label: "md" },
  { value: "lg", label: "lg" },
  { value: "xl", label: "xl" },
  { value: "none", label: "None" }
];
function PageOptionsPanel() {
  var _a, _b;
  const { nodeId: pageNodeId } = usePageEditorState();
  const { dom } = useAppState();
  const plan = getPlan(dom);
  const isPaidPlan = plan !== void 0 && plan !== "free";
  const domApi = useDomApi();
  const appNode = getApp(dom);
  const page = getNode(dom, pageNodeId, "page");
  const handleDisplayModeChange = React202.useCallback(
    (event, newValue) => {
      domApi.update(
        (draft) => setNodeNamespacedProp(draft, page, "attributes", "display", newValue)
      );
    },
    [domApi, page]
  );
  const handleContainerModeChange = React202.useCallback(
    (event, newValue) => {
      domApi.update(
        (draft) => setNodeNamespacedProp(draft, page, "attributes", "maxWidth", newValue)
      );
    },
    [domApi, page]
  );
  const availableRoles = React202.useMemo(() => {
    var _a2, _b2, _c;
    return new Map((_c = (_b2 = (_a2 = appNode.attributes) == null ? void 0 : _a2.authorization) == null ? void 0 : _b2.roles) == null ? void 0 : _c.map((role) => [role.name, role]));
  }, [appNode]);
  const handleAllowedRolesChange = React202.useCallback(
    (event, newValue) => {
      domApi.update(
        (draft) => setNodeNamespacedProp(draft, page, "attributes", "authorization", {
          ...page.attributes.authorization,
          allowedRoles: newValue
        })
      );
    },
    [domApi, page]
  );
  const handleAllowAllChange = React202.useCallback(
    (event, isAllowed) => {
      domApi.update(
        (draft) => setNodeNamespacedProp(draft, page, "attributes", "authorization", {
          allowAll: isAllowed,
          ...isAllowed ? { allowedRoles: [] } : {}
        })
      );
    },
    [domApi, page]
  );
  const allowAll = ((_a = page.attributes.authorization) == null ? void 0 : _a.allowAll) ?? true;
  const allowedRoles = ((_b = page.attributes.authorization) == null ? void 0 : _b.allowedRoles) ?? [];
  return React202.createElement(Stack_default, { spacing: 2, alignItems: "stretch", "data-testid": "page-editor" }, React202.createElement(Typography_default, { variant: "subtitle1" }, "Page"), React202.createElement("div", null, React202.createElement(NodeNameEditor, { node: page }), React202.createElement(PageDisplayNameEditor, { node: page }), React202.createElement(PageTitleEditor, { node: page })), React202.createElement("div", null, React202.createElement(Typography_default, { variant: "overline" }, "Display mode"), React202.createElement(
    Tooltip_default,
    {
      arrow: true,
      placement: "left-start",
      title: React202.createElement(Typography_default, { variant: "inherit" }, "Control how the app shell is displayed in the final application. Read more in the", " ", React202.createElement(
        Link_default,
        {
          href: "https://mui.com/toolpad/studio/concepts/page-properties/#display-mode",
          target: "_blank",
          rel: "noopener"
        },
        "docs"
      ), ".")
    },
    React202.createElement(
      ToggleButtonGroup_default,
      {
        exclusive: true,
        value: page.attributes.display ?? "shell",
        onChange: handleDisplayModeChange,
        "aria-label": "Display mode",
        fullWidth: true
      },
      PAGE_DISPLAY_OPTIONS.map((option) => {
        return React202.createElement(ToggleButton_default, { key: option.value, value: option.value }, option.label);
      })
    )
  )), React202.createElement("div", null, React202.createElement(Typography_default, { variant: "overline" }, "Container width"), React202.createElement(
    Tooltip_default,
    {
      arrow: true,
      placement: "left-start",
      title: React202.createElement(Typography_default, { variant: "inherit" }, "Set the maximum width of the top-level container.")
    },
    React202.createElement(
      ToggleButtonGroup_default,
      {
        exclusive: true,
        value: page.attributes.maxWidth ?? DEFAULT_CONTAINER_WIDTH,
        onChange: handleContainerModeChange,
        "aria-label": "Container mode",
        fullWidth: true
      },
      PAGE_CONTAINER_WIDTH_OPTIONS.map((option) => {
        return React202.createElement(ToggleButton_default, { key: option.value, value: option.value }, option.label);
      })
    )
  )), React202.createElement("div", null, React202.createElement(Typography_default, { variant: "overline" }, "Authorization", !isPaidPlan ? React202.createElement(UpgradeChip, { message: "Authorization requires a paid plan.", sx: { ml: 1 } }) : null), isPaidPlan ? React202.createElement(React202.Fragment, null, React202.createElement(
    FormControlLabel_default,
    {
      control: React202.createElement(Checkbox_default, { checked: allowAll, onChange: handleAllowAllChange }),
      label: "Allow access to all roles"
    }
  ), React202.createElement(
    Autocomplete_default,
    {
      multiple: true,
      options: Array.from(availableRoles.keys()),
      value: allowAll ? [] : allowedRoles,
      onChange: handleAllowedRolesChange,
      disabled: allowAll,
      fullWidth: true,
      noOptionsText: "No roles defined",
      renderInput: (params) => React202.createElement(TextField_default, { ...params, label: "Allowed roles", placeholder: "Roles" })
    }
  )) : null), React202.createElement("div", null, React202.createElement(Divider_default, { variant: "middle", sx: { alignSelf: "stretch" } }), React202.createElement(Typography_default, { variant: "overline" }, "Page State"), React202.createElement(UrlQueryEditor, { pageNodeId })));
}
function MarkdownTooltip({ title, children, ...props2 }) {
  const renderedTitle = React212.useMemo(
    () => title ? React212.createElement(
      index_modern_default,
      {
        options: {
          overrides: {
            a: {
              component: Link_default,
              props: {
                target: "_blank"
              }
            }
          }
        }
      },
      title
    ) : null,
    [title]
  );
  return React212.createElement(Tooltip_default, { title: renderedTitle, ...props2 }, children);
}
function PropertyControl({ propType, children }) {
  return React222.createElement(MarkdownTooltip, { placement: "left", title: propType.helperText ?? "" }, children);
}
function StringPropEditor({ propType, label, value, onChange, disabled }) {
  const handleChange = React232.useCallback(
    (event) => {
      onChange(event.target.value === propType.default ? void 0 : event.target.value);
    },
    [onChange, propType.default]
  );
  return React232.createElement(PropertyControl, { propType }, React232.createElement(
    TextField_default,
    {
      fullWidth: true,
      value: value ?? "",
      disabled,
      onChange: handleChange,
      label
    }
  ));
}
var string_default = StringPropEditor;
function BooleanPropEditor({ propType, label, value, onChange, disabled }) {
  const handleChange = React242.useCallback(
    (event) => {
      onChange(event.target.checked);
    },
    [onChange]
  );
  return React242.createElement(PropertyControl, { propType }, React242.createElement(
    FormControlLabel_default,
    {
      control: React242.createElement(Checkbox_default, { checked: !!value, disabled, onChange: handleChange }),
      label
    }
  ));
}
var boolean_default = BooleanPropEditor;
function NumberPropEditor({ label, value, onChange, disabled, propType }) {
  const { minimum, maximum } = propType;
  const [inputValue, setInputValue] = React252.useState(value);
  const handleChange = React252.useCallback(
    (event) => {
      const newValue = Number(event.target.value);
      setInputValue(newValue);
      if (minimum && newValue < minimum) {
        onChange(minimum);
      } else if (maximum && newValue > maximum) {
        onChange(maximum);
      } else {
        onChange(newValue);
      }
    },
    [maximum, minimum, onChange]
  );
  const handleBlur = React252.useCallback(
    (event) => {
      const blurValue = Number(event.target.value);
      if (minimum && blurValue < minimum) {
        setInputValue(minimum);
      } else if (maximum && blurValue > maximum) {
        setInputValue(maximum);
      }
    },
    [maximum, minimum]
  );
  return React252.createElement(PropertyControl, { propType }, React252.createElement(
    TextField_default,
    {
      fullWidth: true,
      value: String(inputValue ?? 0),
      disabled,
      type: "number",
      onChange: handleChange,
      onBlur: handleBlur,
      label,
      slotProps: {
        htmlInput: { step: "any" }
      }
    }
  ));
}
var number_default = NumberPropEditor;
function SelectPropEditor({ label, propType, value, onChange, disabled }) {
  const items = propType.type === "string" ? propType.enum ?? [] : [];
  const handleChange = React262.useCallback(
    (event) => {
      onChange(event.target.value || void 0);
    },
    [onChange]
  );
  const enumLabels = propType.type === "string" ? propType.enumLabels ?? {} : {};
  return React262.createElement(PropertyControl, { propType }, React262.createElement(
    TextField_default,
    {
      select: true,
      fullWidth: true,
      label,
      value: value ?? "",
      disabled,
      onChange: handleChange
    },
    typeof propType.default === "undefined" ? React262.createElement(MenuItem_default, { value: "" }, "-") : null,
    items.map((item) => React262.createElement(MenuItem_default, { key: item, value: item }, enumLabels[item] || item))
  ));
}
var select_default = SelectPropEditor;
function NoSsr({ children, fallback = null }) {
  const isSsr = useSsr();
  return React272.createElement(React272.Fragment, null, isSsr ? fallback : children);
}
function lazyComponent(importComponent, { noSsr, fallback } = {}) {
  const LazyComponent = React282.lazy(importComponent);
  return React282.forwardRef((props2, ref) => {
    let content = React282.createElement(LazyComponent, { ref, ...props2 });
    if (noSsr) {
      content = React282.createElement(NoSsr, null, content);
    }
    if (fallback) {
      content = React282.createElement(React282.Suspense, { fallback }, content);
    }
    return content;
  });
}
var JsonEditor = lazyComponent(() => import("./JsonEditor-2EDQONBP-OYOBFM6G.js"), {
  noSsr: true,
  fallback: React292.createElement(Skeleton_default, { variant: "rectangular", height: "100%" })
});
function JsonPropEditor({ label, propType, value, onChange, disabled }) {
  const [dialogOpen, setDialogOpen] = React292.useState(false);
  const valueAsString = React292.useMemo(() => JSON.stringify(value, null, 2), [value]);
  const [input, setInput] = React292.useState(valueAsString);
  React292.useEffect(() => setInput(valueAsString), [valueAsString]);
  const normalizedInitial = React292.useMemo(() => JSON.stringify(value), [value]);
  const normalizedInput = React292.useMemo(() => {
    if (!input) {
      return "";
    }
    try {
      return JSON.stringify(dist_default.parse(input));
    } catch {
      return null;
    }
  }, [input]);
  const handleSave = React292.useCallback(() => {
    const newValue = input === "" ? void 0 : dist_default.parse(input);
    onChange(newValue);
  }, [onChange, input]);
  const [schemaUri, setSchemaUri] = React292.useState(void 0);
  React292.useEffect(() => {
    if (propType.type !== "object" && propType.type !== "array") {
      return () => {
      };
    }
    if (!propType.schema) {
      return () => {
      };
    }
    const blob = new Blob([JSON.stringify(propType.schema, null, 2)], {
      type: "application/json"
    });
    const uri = URL.createObjectURL(blob);
    setSchemaUri(uri);
    return () => {
      URL.revokeObjectURL(uri);
    };
  }, [propType]);
  useShortcut({ key: "s", metaKey: true, disabled: !dialogOpen }, handleSave);
  return React292.createElement(React292.Fragment, null, React292.createElement(PropertyControl, { propType }, React292.createElement(
    Button_default,
    {
      variant: "outlined",
      color: "inherit",
      sx: { my: 0.5 },
      fullWidth: true,
      onClick: () => setDialogOpen(true)
    },
    label
  )), React292.createElement(Dialog_default, { fullWidth: true, open: dialogOpen, onClose: () => setDialogOpen(false) }, React292.createElement(DialogTitle_default, null, "Edit JSON"), React292.createElement(DialogContent_default, null, React292.createElement(Box_default2, { sx: { height: 200 } }, React292.createElement(
    JsonEditor,
    {
      value: input,
      onChange: (newValue = "") => setInput(newValue),
      schemaUri,
      disabled
    }
  ))), React292.createElement(DialogActions_default, null, React292.createElement(Button_default, { color: "inherit", variant: "text", onClick: () => setDialogOpen(false) }, "Cancel"), React292.createElement(
    Button_default,
    {
      disabled: normalizedInput === null || normalizedInitial === normalizedInput,
      onClick: handleSave
    },
    "Save"
  ))));
}
var json_default = JsonPropEditor;
function Editor({ propType, label }) {
  return React302.createElement(PropertyControl, { propType }, React302.createElement(Typography_default, null, label));
}
var event_default = Editor;
var [usePropControlsContext, PropControlsContextProvider] = createProvidedContext("PropControls");
function getDefaultControlForType(propType) {
  switch (propType.type) {
    case "string":
      return propType.enum ? select_default : string_default;
    case "number":
      return number_default;
    case "boolean":
      return boolean_default;
    case "object":
      return json_default;
    case "array":
      return json_default;
    case "event":
      return event_default;
    default:
      return null;
  }
}
var modePropTypeMap = /* @__PURE__ */ new Map([
  // Text component modes
  ["text", "string"],
  ["markdown", "markdown"],
  ["link", "string"]
]);
function getDefaultControl(controls, argType, liveProps) {
  if (argType.control) {
    if (argType.control.type === "markdown") {
      if (liveProps) {
        const { mode } = liveProps;
        if (mode && typeof mode === "string") {
          const mappedControlFromMode = modePropTypeMap.get(mode);
          if (!mappedControlFromMode) {
            return null;
          }
          return controls[mappedControlFromMode] ?? null;
        }
      }
    }
    return controls[argType.control.type] ?? getDefaultControlForType(argType);
  }
  return getDefaultControlForType(argType);
}
var ElementContext_default = React312.createContext(void 0);
var TypescriptEditor = lazyComponent(() => import("./TypescriptEditor-DSHJDXYS-HRJWDKX4.js"), {
  noSsr: true,
  fallback: React322.createElement(Skeleton_default, { variant: "rectangular", height: "100%" })
});
var JsExpressionEditorRoot = styled_default("div")(({ theme: theme3 }) => ({
  height: 150,
  border: `1px solid ${theme3.palette.divider}`
}));
function JsExpressionEditor({
  value,
  onChange,
  globalScope,
  globalScopeMeta,
  disabled,
  autoFocus,
  functionBody,
  topLevelAwait,
  onFocus,
  onBlur,
  sx
}) {
  const element = React322.useContext(ElementContext_default);
  const nodeName = element == null ? void 0 : element.name;
  const extraLibs = React322.useMemo(() => {
    const withoutCircularRefs = replaceRecursive(globalScope, getCircularReplacer());
    const generatedTypes = (0, import_json_to_ts.default)(withoutCircularRefs);
    const globalDeclarations = Object.keys(globalScope).map((key2) => {
      const metaData = globalScopeMeta[key2];
      const overrides = {};
      if ((metaData == null ? void 0 : metaData.kind) === "element") {
        const { props: props2 } = metaData;
        if (props2) {
          for (const [prop, meta] of Object.entries(props2)) {
            if (meta.tsType) {
              overrides[prop] = meta.tsType;
            }
          }
        }
      }
      const commentLines = [];
      if (metaData == null ? void 0 : metaData.description) {
        commentLines.push(metaData.description);
      }
      if (typeof (metaData == null ? void 0 : metaData.deprecated) === "boolean") {
        commentLines.push("@deprecated");
      } else if (typeof (metaData == null ? void 0 : metaData.deprecated) === "string") {
        commentLines.push(`@deprecated ${metaData.deprecated}`);
      }
      const comment = commentLines.length > 0 ? ["/**", ...commentLines.map((line2) => ` * ${line2}`), " */"] : [];
      const overridesType = `{ 
        ${Object.entries(overrides).map(([propKey, propValue]) => {
        return `${propKey}: ${propValue.replaceAll(
          /\bThisComponent\b/g,
          () => `RootObject[${JSON.stringify(key2)}]`
        )}`;
      }).join("\n")} 
      }`;
      const globalType = typeof (metaData == null ? void 0 : metaData.tsType) === "string" ? metaData.tsType : `OverrideProps<RootObject[${JSON.stringify(key2)}], ${overridesType}>;`;
      const declaration = `declare const ${key2}: Expand<${globalType}>`;
      return [...comment, declaration].join("\n");
    });
    const content = `
      type OverrideProps<T, S extends Partial<Record<keyof T, unknown>>> = {
        [K in keyof T]:  S extends { [M in K]: any } ? S[K] : T[K]
      }

      // Pretty-print types on hover:
      // See https://github.com/microsoft/vscode/issues/94679#issuecomment-755194161
      type Expand<T> = T extends infer O ? { [K in keyof O]: Expand<O[K]> } : never;
      
      ${generatedTypes.join("\n")}

      ${globalDeclarations.join("\n")}

      ${nodeName ? `type ThisComponent = typeof ${nodeName}` : ""}
    `;
    return [{ content, filePath: "global.d.ts" }];
  }, [globalScope, globalScopeMeta, nodeName]);
  return React322.createElement(JsExpressionEditorRoot, { sx }, React322.createElement(
    TypescriptEditor,
    {
      value,
      onChange: (code = "") => onChange(code),
      disabled,
      extraLibs,
      functionBody,
      topLevelAwait,
      onFocus,
      onBlur,
      autoFocus
    }
  ));
}
function useInspectorTheme() {
  const theme3 = useTheme();
  return React332.useMemo(() => {
    return {
      ...theme3.palette.mode === "dark" ? theme : theme2,
      BASE_BACKGROUND_COLOR: "inherit",
      TREENODE_FONT_FAMILY: "inherit",
      TREENODE_FONT_SIZE: "inherit",
      ARROW_FONT_SIZE: "inherit",
      TREENODE_LINE_HEIGHT: "inherit",
      OBJECT_PREVIEW_ARRAY_MAX_PROPERTIES: 1,
      OBJECT_PREVIEW_OBJECT_MAX_PROPERTIES: 1
    };
  }, [theme3]);
}
var ObjectInspector_default = function ObjectInspector2(props2) {
  const inspectorTheme = useInspectorTheme();
  return React332.createElement(themedObjectInspector, { theme: inspectorTheme, ...props2 });
};
var classes2 = {
  viewport: "Toolpad_ObjectInspectorViewport",
  copyToClipboardButton: "Toolpad_CopyToClipboardButton",
  disabled: "Toolpad_ObjectInspectorDisabled"
};
var JsonViewRoot = styled_default("div")(({ theme: theme3 }) => ({
  whiteSpace: "nowrap",
  position: "relative",
  display: "flex",
  minHeight: 0,
  minWidth: 0,
  [`&.${classes2.disabled}`]: {
    opacity: 0.5,
    pointerEvents: "none"
  },
  [`& .${classes2.viewport}`]: {
    overflow: "auto",
    flex: 1,
    padding: theme3.spacing(1)
  },
  [`& .${classes2.copyToClipboardButton}`]: {
    position: "absolute",
    top: 0,
    right: 0,
    marginTop: theme3.spacing(1),
    marginRight: theme3.spacing(2)
  },
  fontSize: 12,
  lineHeight: 1.2,
  fontFamily: 'Consolas, Menlo, Monaco, "Andale Mono", "Ubuntu Mono", monospace'
}));
function JsonView({ src, sx, copyToClipboard, disabled, ...props2 }) {
  const expandPaths = Array.isArray(src) ? ["$", "$.0", "$.1", "$.2", "$.3", "$.4"] : void 0;
  const [confirmSnackbarOpen, setConfirmSnackbarOpen] = React342.useState(false);
  const handleCopyToClipboard = React342.useCallback(() => {
    window.navigator.clipboard.writeText(JSON.stringify(src, null, 2));
    setConfirmSnackbarOpen(true);
  }, [src]);
  const handleCopySnackbarClose = React342.useCallback(() => setConfirmSnackbarOpen(false), []);
  return React342.createElement(JsonViewRoot, { sx, className: clsx_default({ [classes2.disabled]: disabled }) }, React342.createElement(React342.Fragment, null, React342.createElement("div", { className: classes2.viewport }, React342.createElement(ObjectInspector_default, { expandLevel: 1, expandPaths, data: src, ...props2 })), copyToClipboard ? React342.createElement(React342.Fragment, null, React342.createElement(Tooltip_default, { title: "Copy the source" }, React342.createElement(IconButton_default, { onClick: handleCopyToClipboard, className: classes2.copyToClipboardButton }, React342.createElement(ContentCopy_default, null))), React342.createElement(
    Snackbar_default,
    {
      open: confirmSnackbarOpen,
      autoHideDuration: 3e3,
      onClose: handleCopySnackbarClose,
      message: "Source Copied to clipboard"
    }
  )) : null));
}
function evaluateBindableAttrEntries(jsRuntime, input, globalScope) {
  return input.map(([key2, bindable]) => [
    key2,
    evaluateBindable(jsRuntime, bindable || null, globalScope)
  ]);
}
function evaluateBindableAttrValues(jsRuntime, input, globalScope) {
  return mapValues(input, (bindable) => evaluateBindable(jsRuntime, bindable || null, globalScope));
}
function useEvaluateLiveBinding({
  jsRuntime,
  input,
  globalScope
}) {
  return React352.useMemo(() => {
    return evaluateBindable(jsRuntime, input, globalScope);
  }, [jsRuntime, input, globalScope]);
}
function useEvaluateLiveBindings({
  jsRuntime,
  input,
  globalScope
}) {
  return React352.useMemo(() => {
    return evaluateBindableAttrValues(jsRuntime, input, globalScope);
  }, [jsRuntime, input, globalScope]);
}
function useEvaluateLiveBindingEntries({
  jsRuntime,
  input,
  globalScope
}) {
  return React352.useMemo(() => {
    return evaluateBindableAttrEntries(jsRuntime, input, globalScope);
  }, [jsRuntime, input, globalScope]);
}
var ExplorerRoot = styled_default("div")({
  display: "flex",
  flexDirection: "column"
});
function groupScopeMeta(value, meta) {
  const structure = {
    local: {
      displayName: "Locals",
      items: []
    },
    element: {
      displayName: "Elements",
      items: []
    },
    query: {
      displayName: "Queries",
      items: []
    },
    action: {
      displayName: "Actions",
      items: []
    },
    other: {
      displayName: "Other",
      items: []
    }
  };
  const scopeKeys = /* @__PURE__ */ new Set([...Object.keys(value), ...Object.keys(meta)]);
  for (const key2 of scopeKeys) {
    const metaField = meta[key2];
    const group = (metaField == null ? void 0 : metaField.kind) || "other";
    structure[group].items.push({
      ...metaField,
      key: key2,
      value: value[key2]
    });
  }
  return structure;
}
function GlobalScopeExplorer({ meta, value, sx }) {
  const structure = React362.useMemo(() => groupScopeMeta(value, meta), [meta, value]);
  return React362.createElement(ExplorerRoot, { sx }, React362.createElement(Typography_default, { sx: { ml: 1, mb: 1 }, variant: "subtitle2" }, "Scope"), React362.createElement(Box_default2, { sx: { overflow: "auto", border: 1, borderColor: "divider" } }, React362.createElement(Box_default2, { sx: { display: "flex", flexDirection: "column", justifyContent: "stretch" } }, Object.entries(structure).map(([key2, group]) => {
    if (group.items.length <= 0) {
      return null;
    }
    return React362.createElement(React362.Fragment, { key: key2 }, React362.createElement(Typography_default, { sx: { mx: 1, my: 0.5 } }, group.displayName), React362.createElement(Divider_default, null), React362.createElement(Box_default2, { sx: { m: 1 } }, group.items.map((item) => {
      return React362.createElement(React362.Fragment, { key: item.key }, React362.createElement(ObjectInspector_default, { expandLevel: 0, name: item.key, data: item.value }));
    })), React362.createElement(Divider_default, null));
  }))));
}
var TabPanel = styled_default(TabPanel_default, {
  shouldForwardProp: (prop) => prop !== "disableGutters"
})(({ disableGutters }) => ({
  ...disableGutters && {
    padding: 0
  }
}));
var TabPanel_default2 = TabPanel;
var [useBindingEditorContext, BindingEditorContextProvider] = createProvidedContext("BindingEditor");
var ErrorTooltip = styled_default(({ className, ...props2 }) => React372.createElement(Tooltip_default, { ...props2, classes: { popper: className } }))(({ theme: theme3 }) => ({
  [`& .${tooltipClasses_default.tooltip}`]: {
    backgroundColor: theme3.palette.error.dark
  }
}));
function JsExpressionBindingEditor({
  globalScope,
  globalScopeMeta,
  value,
  onChange
}) {
  const handleChange = React372.useCallback(
    (newValue) => onChange({ $$jsExpression: newValue }),
    [onChange]
  );
  return React372.createElement(
    JsExpressionEditor,
    {
      globalScope,
      globalScopeMeta,
      value: (value == null ? void 0 : value.$$jsExpression) || "",
      onChange: handleChange,
      autoFocus: true
    }
  );
}
function JsExpressionPreview({ jsRuntime, input, globalScope }) {
  const previewValue = useEvaluateLiveBinding({ jsRuntime, input, globalScope });
  const lastGoodPreview = useLatest_default((previewValue == null ? void 0 : previewValue.error) ? void 0 : previewValue);
  const previewErrorDebounced = useDebounced(previewValue == null ? void 0 : previewValue.error, 500);
  const previewError = (previewValue == null ? void 0 : previewValue.error) && previewErrorDebounced;
  return React372.createElement(React372.Fragment, null, React372.createElement(Toolbar_default, { disableGutters: true }, React372.createElement(Typography_default, { color: "error" }, previewError == null ? void 0 : previewError.message)), React372.createElement(JsonView, { sx: { flex: 1 }, src: lastGoodPreview == null ? void 0 : lastGoodPreview.value }));
}
function EnvBindingEditor({ value, onChange }) {
  const { declaredEnvKeys, env } = useBindingEditorContext();
  const handleInputChange = React372.useCallback(
    (event, newValue) => {
      onChange({ $$env: newValue || "" });
    },
    [onChange]
  );
  return React372.createElement(Box_default2, { sx: { my: 1 } }, React372.createElement(Typography_default, null, "Assign to an environment variable"), React372.createElement(
    Autocomplete_default,
    {
      freeSolo: true,
      options: declaredEnvKeys,
      value: (value == null ? void 0 : value.$$env) || "",
      onInputChange: handleInputChange,
      renderInput: (params) => React372.createElement(
        TextField_default,
        {
          ...params,
          fullWidth: true,
          sx: { my: 3 },
          label: "Environment variable name",
          helperText: (value == null ? void 0 : value.$$env) && !declaredEnvKeys.includes(value.$$env) ? "Warning: This variable is not in your env file!" : ""
        }
      )
    }
  ), "Value:", React372.createElement(JsonView, { sx: { flex: 1 }, src: (value == null ? void 0 : value.$$env) ? env[value == null ? void 0 : value.$$env] : void 0 }));
}
function getValueBindingTab(value) {
  if ((value == null ? void 0 : value.$$env) === void 0) {
    return "jsExpression";
  }
  return "env";
}
function ValueBindingEditor({ value, onChange, error }) {
  const {
    label,
    globalScope,
    globalScopeMeta = {},
    jsRuntime,
    propType,
    env
  } = useBindingEditorContext();
  const hasEnv = Boolean(env);
  const [activeTab, setActiveTab] = React372.useState(getValueBindingTab(value));
  React372.useEffect(() => {
    setActiveTab(getValueBindingTab(value));
  }, [value]);
  const handleTabChange = (event, newValue) => {
    setActiveTab(newValue);
  };
  const jsExpressionBindingEditor = React372.createElement(Stack_default, { direction: "row", sx: { height: 400, gap: 2, my: hasEnv ? 3 : 0 } }, React372.createElement(GlobalScopeExplorer, { sx: { width: 250 }, value: globalScope, meta: globalScopeMeta }), React372.createElement(
    Box_default2,
    {
      sx: {
        height: "100%",
        display: "flex",
        flex: 1,
        flexDirection: "column",
        overflow: "hidden"
      }
    },
    React372.createElement(Typography_default, { sx: { mb: 2 } }, 'Make the "', label, '" property dynamic with a JavaScript expression. This property expects a type: ', React372.createElement("code", null, (propType == null ? void 0 : propType.type) || "any"), "."),
    React372.createElement(
      JsExpressionBindingEditor,
      {
        globalScope,
        globalScopeMeta,
        value: (value == null ? void 0 : value.$$jsExpression) ? value : null,
        onChange
      }
    ),
    error ? React372.createElement(
      Box_default2,
      {
        sx: {
          marginTop: "20px"
        }
      },
      React372.createElement(Typography_default, { sx: { mb: 2, color: "red" } }, "Error while reading the prettier configuration:", errorFrom(error).message ?? "The prettier config could not be loaded and therefore the code would not be formatted")
    ) : null,
    React372.createElement(JsExpressionPreview, { jsRuntime, input: value, globalScope })
  ));
  const envBindingEditor = React372.createElement(
    EnvBindingEditor,
    {
      value: (value == null ? void 0 : value.$$env) !== void 0 ? value : null,
      onChange
    }
  );
  return React372.createElement(TabContext, { value: activeTab }, React372.createElement(Box_default2, { sx: { borderBottom: 1, borderColor: "divider" } }, React372.createElement(TabList_default, { onChange: handleTabChange, "aria-label": "Choose action kind " }, React372.createElement(Tab_default, { label: "JS expression", value: "jsExpression" }), React372.createElement(Tab_default, { label: "Environment variable", value: "env" }))), React372.createElement(TabPanel_default2, { value: "jsExpression", disableGutters: true }, React372.createElement(Box_default2, { sx: { my: 1 } }, React372.createElement(Typography_default, null, "Bind to a JavaScript expression. Read more about binding in the", " ", React372.createElement(
    Link_default,
    {
      href: "https://mui.com/toolpad/studio/concepts/data-binding/",
      target: "_blank",
      rel: "noopener"
    },
    "docs"
  ), "."), jsExpressionBindingEditor)), React372.createElement(TabPanel_default2, { value: "env", disableGutters: true }, envBindingEditor));
}
function JsExpressionActionEditor({ value, onChange }) {
  const { globalScope, globalScopeMeta } = useBindingEditorContext();
  const handleCodeChange = React372.useCallback(
    (newValue) => onChange({ $$jsExpressionAction: newValue }),
    [onChange]
  );
  return React372.createElement(Box_default2, { sx: { my: 1 } }, React372.createElement(Typography_default, null, "Run code when this event fires. Read more in the", " ", React372.createElement(
    Link_default,
    {
      href: "https://mui.com/toolpad/studio/concepts/event-handling/#js-expression-actions",
      target: "_blank",
      rel: "noopener"
    },
    "docs"
  ), "."), React372.createElement(
    Box_default2,
    {
      sx: {
        my: 3,
        display: "flex",
        flexDirection: "row",
        maxHeight: 250,
        alignItems: "stretch",
        gap: 2
      }
    },
    React372.createElement(GlobalScopeExplorer, { sx: { width: 250 }, value: globalScope, meta: globalScopeMeta }),
    React372.createElement(
      JsExpressionEditor,
      {
        sx: { flex: 1 },
        globalScope,
        globalScopeMeta,
        value: (value == null ? void 0 : value.$$jsExpressionAction) || "",
        onChange: handleCodeChange,
        functionBody: true,
        topLevelAwait: true
      }
    )
  ));
}
function NavigationActionParameterEditor({
  label,
  value,
  onChange
}) {
  const { jsRuntime, globalScope, globalScopeMeta } = useBindingEditorContext();
  const liveBinding = useEvaluateLiveBinding({
    jsRuntime,
    input: value,
    globalScope
  });
  return React372.createElement(
    BindableEditor,
    {
      liveBinding,
      jsRuntime,
      globalScope,
      globalScopeMeta,
      label,
      propType: { type: "string" },
      value: value || null,
      onChange
    }
  );
}
function NavigationActionEditor({ value, onChange }) {
  var _a;
  const { dom } = useAppState();
  const root2 = getApp(dom);
  const { pages = [] } = getChildNodes(dom, root2);
  const getDefaultActionParameters = React372.useCallback((page) => {
    const defaultPageParameters = page.attributes.parameters || [];
    return Object.fromEntries(defaultPageParameters);
  }, []);
  const handlePageChange = React372.useCallback(
    (event) => {
      const pageName = event.target.value;
      const page = getPageByName(dom, pageName);
      const defaultActionParameters2 = page && isPage(page) ? getDefaultActionParameters(page) : {};
      onChange({
        $$navigationAction: {
          page: pageName,
          parameters: defaultActionParameters2
        }
      });
    },
    [dom, getDefaultActionParameters, onChange]
  );
  const actionPageAliasOrName = ((_a = value == null ? void 0 : value.$$navigationAction) == null ? void 0 : _a.page) || null;
  const actionParameters = React372.useMemo(
    () => (value == null ? void 0 : value.$$navigationAction.parameters) || {},
    [value == null ? void 0 : value.$$navigationAction.parameters]
  );
  const actionPage = pages.find((availablePage) => availablePage.name === actionPageAliasOrName) || pages.find(
    (availablePage) => {
      var _a2;
      return (_a2 = availablePage.attributes.alias) == null ? void 0 : _a2.some((alias) => alias === actionPageAliasOrName);
    }
  );
  const handleActionParameterChange = React372.useCallback(
    (actionParameterName) => (newValue) => {
      if (actionPageAliasOrName) {
        onChange({
          $$navigationAction: {
            page: actionPageAliasOrName,
            parameters: {
              ...actionParameters,
              ...newValue ? { [actionParameterName]: newValue } : {}
            }
          }
        });
      }
    },
    [actionPageAliasOrName, actionParameters, onChange]
  );
  const hasPagesAvailable = pages.length > 0;
  const defaultActionParameters = actionPage ? getDefaultActionParameters(actionPage) : {};
  const actionParameterEntries = Object.entries(actionParameters || defaultActionParameters);
  return React372.createElement(Box_default2, { sx: { my: 1 } }, React372.createElement(Typography_default, null, "Navigate to a page on this event"), React372.createElement(
    TextField_default,
    {
      fullWidth: true,
      sx: { my: 3 },
      label: "Select a page",
      select: true,
      value: actionPageAliasOrName || "",
      onChange: handlePageChange,
      disabled: !hasPagesAvailable,
      helperText: hasPagesAvailable ? null : "No other pages available"
    },
    pages.map((page) => React372.createElement(MenuItem_default, { key: page.name, value: page.name }, page.name))
  ), actionParameterEntries.length > 0 ? React372.createElement(React372.Fragment, null, React372.createElement(Typography_default, { variant: "overline" }, "Page parameters:"), Object.entries(actionParameters || defaultActionParameters).map((actionParameter) => {
    const [actionParameterName, actionParameterValue] = actionParameter;
    return React372.createElement(
      NavigationActionParameterEditor,
      {
        key: actionParameterName,
        label: actionParameterName,
        value: actionParameterValue,
        onChange: handleActionParameterChange(actionParameterName)
      }
    );
  })) : null);
}
function getActionTab(value) {
  if (value == null ? void 0 : value.$$navigationAction) {
    return "navigationAction";
  }
  return "jsExpressionAction";
}
function ActionEditor({ value, onChange }) {
  const [activeTab, setActiveTab] = React372.useState(getActionTab(value));
  React372.useEffect(() => setActiveTab(getActionTab(value)), [value]);
  const handleTabChange = (event, newValue) => {
    setActiveTab(newValue);
  };
  return React372.createElement(TabContext, { value: activeTab }, React372.createElement(Box_default2, { sx: { borderBottom: 1, borderColor: "divider" } }, React372.createElement(TabList_default, { onChange: handleTabChange, "aria-label": "Choose action kind " }, React372.createElement(Tab_default, { label: "JS expression", value: "jsExpressionAction" }), React372.createElement(Tab_default, { label: "Navigation", value: "navigationAction" }))), React372.createElement(TabPanel_default2, { value: "jsExpressionAction", disableGutters: true }, React372.createElement(
    JsExpressionActionEditor,
    {
      value: (value == null ? void 0 : value.$$jsExpressionAction) ? value : null,
      onChange
    }
  )), React372.createElement(TabPanel_default2, { value: "navigationAction", disableGutters: true }, React372.createElement(
    NavigationActionEditor,
    {
      value: (value == null ? void 0 : value.$$navigationAction) ? value : null,
      onChange
    }
  )));
}
function BindingEditorDialog({
  value,
  onChange,
  open,
  onClose
}) {
  const projectApi = useProjectApi();
  const { error, data } = projectApi.useQuery("getPrettierConfig", []);
  const { propType, label } = useBindingEditorContext();
  const [input, setInput] = React372.useState(value);
  React372.useEffect(() => {
    setInput(value);
  }, [open, value]);
  const committedInput = React372.useRef(input);
  const handleSave = React372.useCallback(async () => {
    let newValue = input;
    if (input == null ? void 0 : input.$$jsExpression) {
      const jsExpression = await tryFormatExpression(
        input.$$jsExpression,
        data
      );
      const cleanedExpression = jsExpression.trim().replace(/;*$/, "");
      newValue = {
        $$jsExpression: cleanedExpression
      };
    }
    committedInput.current = newValue;
    onChange(newValue);
  }, [onChange, input, data]);
  const hasUnsavedChanges = input ? getBindingType(input) !== (committedInput.current && getBindingType(committedInput.current)) || getBindingValue(input) !== (committedInput.current && getBindingValue(committedInput.current)) : false;
  const { handleCloseWithUnsavedChanges } = useUnsavedChangesConfirm({
    hasUnsavedChanges,
    onClose
  });
  const handleCommit = React372.useCallback(() => {
    handleSave();
    onClose();
  }, [onClose, handleSave]);
  const handleRemove = React372.useCallback(() => {
    committedInput.current = null;
    onChange(null);
    onClose();
  }, [onClose, onChange]);
  useShortcut({ key: "s", metaKey: true, disabled: !open }, handleSave);
  return React372.createElement(
    Dialog_default,
    {
      onClose: handleCloseWithUnsavedChanges,
      open,
      fullWidth: true,
      scroll: "body",
      maxWidth: "lg"
    },
    React372.createElement(DialogTitle_default, null, 'Bind property "', label, '"'),
    React372.createElement(
      DialogContent_default,
      {
        sx: {
          height: "100vh",
          maxHeight: 560
        }
      },
      (propType == null ? void 0 : propType.type) === "event" ? React372.createElement(ActionEditor, { value: input, onChange: (newValue) => setInput(newValue) }) : React372.createElement(
        ValueBindingEditor,
        {
          error,
          value: (input == null ? void 0 : input.$$jsExpression) !== void 0 || (input == null ? void 0 : input.$$env) !== void 0 ? input : null,
          onChange: (newValue) => setInput(newValue)
        }
      )
    ),
    React372.createElement(DialogActions_default, null, React372.createElement(Button_default, { color: "inherit", variant: "text", onClick: onClose }, hasUnsavedChanges ? "Cancel" : "Close"), React372.createElement(Button_default, { color: "inherit", disabled: !value, onClick: handleRemove }, "Remove binding"), React372.createElement(Button_default, { disabled: !hasUnsavedChanges, color: "primary", onClick: handleCommit }, "Update binding"))
  );
}
function BindingEditor({
  label,
  globalScope,
  globalScopeMeta,
  jsRuntime,
  disabled,
  hidden = false,
  propType,
  value,
  onChange,
  liveBinding,
  env,
  declaredEnvKeys
}) {
  var _a;
  const [open, setOpen] = React372.useState(false);
  const handleOpen = React372.useCallback(() => setOpen(true), []);
  const handleClose = React372.useCallback(() => setOpen(false), []);
  const hasBinding = !!value && getBindingType(value) !== "const";
  const error = (_a = liveBinding == null ? void 0 : liveBinding.error) == null ? void 0 : _a.message;
  const bindingButton = React372.createElement(
    Checkbox_default,
    {
      "aria-label": `Bind property "${label}"`,
      checked: hasBinding,
      disabled,
      icon: React372.createElement(AddLink_default, { fontSize: "inherit" }),
      checkedIcon: React372.createElement(Link_default2, { fontSize: "inherit" }),
      onClick: handleOpen,
      color: error ? "error" : void 0,
      sx: { visibility: hidden ? "hidden" : "visible" }
    }
  );
  const TooltipComponent = error ? ErrorTooltip : Tooltip_default;
  const tooltipTitle = error ?? (hasBinding ? `Update "${label}" binding…` : `Bind "${label}"…`);
  const bindingButtonWithTooltip = disabled ? bindingButton : React372.createElement(TooltipComponent, { disableInteractive: true, placement: "top", title: tooltipTitle }, bindingButton);
  const resolvedMeta = React372.useMemo(() => {
    const meta = { ...globalScopeMeta };
    if ((propType == null ? void 0 : propType.type) === "event" && propType.arguments) {
      for (const { name, tsType } of propType.arguments) {
        const metaField = meta[name] ?? {};
        metaField.kind = "local";
        metaField.tsType = tsType;
        meta[name] = metaField;
      }
    }
    return meta;
  }, [propType, globalScopeMeta]);
  const bindingEditorContext = React372.useMemo(
    () => ({
      label,
      globalScope,
      globalScopeMeta: resolvedMeta,
      jsRuntime,
      disabled,
      propType,
      liveBinding,
      env: env ?? {},
      declaredEnvKeys: declaredEnvKeys ?? []
    }),
    [
      disabled,
      env,
      globalScope,
      jsRuntime,
      label,
      liveBinding,
      propType,
      resolvedMeta,
      declaredEnvKeys
    ]
  );
  return React372.createElement(BindingEditorContextProvider, { value: bindingEditorContext }, bindingButtonWithTooltip, React372.createElement(BindingEditorDialog, { open, onClose: handleClose, value, onChange }));
}
var EditorRoot = styled_default(Stack_default)({
  display: "flex",
  flexDirection: "row",
  alignItems: "center",
  justifyContent: "space-between",
  [`& .${inputBaseClasses_default.root}`]: { fontSize: 12 },
  [`& .${formLabelClasses_default.root}`]: { fontSize: 12 },
  [`& .${typographyClasses_default.root}`]: { fontSize: 12 }
});
function BindableEditor({
  label,
  bindable = true,
  disabled,
  propType,
  renderControl: renderControlProp,
  value,
  jsRuntime,
  onChange,
  liveBinding,
  globalScope = {},
  globalScopeMeta = {},
  env,
  declaredEnvKeys,
  sx
}) {
  var _a;
  const propTypeControls = usePropControlsContext();
  const renderDefaultControl = React382.useCallback(
    (params) => {
      const Control = getDefaultControl(propTypeControls, params.propType);
      return Control ? React382.createElement(Control, { ...params }) : null;
    },
    [propTypeControls]
  );
  const renderControl = renderControlProp || renderDefaultControl;
  const handlePropConstChange = React382.useCallback((newValue) => onChange(newValue), [onChange]);
  const valueBindingType = value && getBindingType(value);
  const initConstValue = React382.useCallback(() => {
    if (valueBindingType && valueBindingType === "const") {
      return value;
    }
    if (valueBindingType && valueBindingType === "env") {
      return value.$$env;
    }
    return liveBinding == null ? void 0 : liveBinding.value;
  }, [liveBinding, value, valueBindingType]);
  const constValue = React382.useMemo(initConstValue, [value, initConstValue]);
  const hasBinding = value && valueBindingType !== "const";
  return React382.createElement(EditorRoot, { sx }, renderControl({
    label,
    propType,
    disabled: disabled || !!hasBinding,
    value: constValue,
    onChange: handlePropConstChange
  }), ((_a = propType.control) == null ? void 0 : _a.bindable) === false ? null : React382.createElement(
    BindingEditor,
    {
      globalScope,
      globalScopeMeta,
      label,
      jsRuntime,
      propType,
      value,
      onChange,
      disabled: disabled || !bindable,
      hidden: !bindable,
      liveBinding,
      env,
      declaredEnvKeys
    }
  ));
}
function buildScopeMeta(vm2, bindingScope) {
  if (bindingScope == null ? void 0 : bindingScope.parentScope) {
    return {
      ...buildScopeMeta(vm2, bindingScope == null ? void 0 : bindingScope.parentScope),
      ...bindingScope == null ? void 0 : bindingScope.meta
    };
  }
  return (bindingScope == null ? void 0 : bindingScope.meta) ?? {};
}
function NodeAttributeEditor({
  node,
  namespace = "attributes",
  name,
  argType,
  props: props2,
  sx
}) {
  var _a, _b, _c;
  const domApi = useDomApi();
  const initialPropValue = (_a = node[namespace]) == null ? void 0 : _a[name];
  const [propValue, setPropValue] = React392.useState(
    initialPropValue
  );
  React392.useEffect(() => {
    setPropValue(initialPropValue);
  }, [initialPropValue]);
  const handlePropChange = React392.useCallback(
    (newValue) => {
      setPropValue(newValue);
      React392.startTransition(() => {
        domApi.update(
          (draft) => setNodeNamespacedProp(draft, node, namespace, name, newValue)
        );
      });
    },
    [node, namespace, name, domApi]
  );
  const bindingId = `${node.id}${namespace ? `.${namespace}` : ""}.${name}`;
  const { vm: vm2 } = usePageEditorState();
  const scopeId = vm2.bindingScopes[bindingId];
  const bindingScope = scopeId ? vm2.scopes[scopeId] : void 0;
  const liveBinding = bindingScope == null ? void 0 : bindingScope.bindings[bindingId];
  const scopeMeta = React392.useMemo(() => buildScopeMeta(vm2, bindingScope), [vm2, bindingScope]);
  const propTypeControls = usePropControlsContext();
  const Control = getDefaultControl(propTypeControls, argType, props2);
  const isDisabled = !!argType.onChangeProp;
  const isBindable = !isDisabled && namespace !== "layout" && ((_b = argType.control) == null ? void 0 : _b.bindable) !== false;
  const jsBrowserRuntime = useBrowserJsRuntime();
  return Control ? React392.createElement(
    BindableEditor,
    {
      liveBinding,
      globalScope: (bindingScope == null ? void 0 : bindingScope.values) ?? {},
      globalScopeMeta: scopeMeta,
      label: ((_c = argType.control) == null ? void 0 : _c.hideLabel) ? "" : argType.label || name,
      bindable: isBindable,
      disabled: isDisabled,
      propType: argType,
      jsRuntime: jsBrowserRuntime,
      renderControl: (params) => React392.createElement(Box_default2, { sx: { flex: 1, minWidth: 0 } }, React392.createElement(Control, { nodeId: node.id, ...params, propType: argType })),
      value: propValue,
      onChange: handlePropChange,
      sx
    }
  ) : React392.createElement(Alert_default, { severity: "warning" }, `No control for '${name}' (type '${argType.type}' ${argType.control ? `, control: '${argType.control.type}'` : ""})`);
}
var INTERNAL_COMPONENTS = /* @__PURE__ */ new Map([
  [PAGE_ROW_COMPONENT_ID, { displayName: "Row", builtIn: "PageRow", system: true, synonyms: [] }],
  [
    PAGE_COLUMN_COMPONENT_ID,
    { displayName: "Column", builtIn: "PageColumn", system: true, synonyms: [] }
  ],
  [STACK_COMPONENT_ID, { displayName: "Stack", builtIn: "Stack", system: true, synonyms: [] }],
  [
    "Autocomplete",
    {
      displayName: "Autocomplete",
      builtIn: "Autocomplete",
      synonyms: ["combobox", "select", "dropdown"]
    }
  ],
  [
    "Button",
    {
      displayName: "Button",
      builtIn: "Button",
      synonyms: ["click", "action"]
    }
  ],
  ["Image", { displayName: "Image", builtIn: "Image", synonyms: ["picture"] }],
  ["DataGrid", { displayName: "Data Grid", builtIn: "DataGrid", synonyms: ["table"] }],
  [
    "Chart",
    {
      displayName: "Chart",
      builtIn: "Chart",
      synonyms: ["graph", "bar chart", "pie chart", "line chart", "plot"]
    }
  ],
  [
    "TextField",
    { displayName: "Text Field", builtIn: "TextField", synonyms: ["input", "field", "password"] }
  ],
  ["DatePicker", { displayName: "Date Picker", builtIn: "DatePicker", synonyms: ["time"] }],
  ["FilePicker", { displayName: "File Picker", builtIn: "FilePicker", synonyms: [] }],
  ["Text", { displayName: "Text", builtIn: "Text", synonyms: ["markdown", "link", "output"] }],
  [
    "Markdown",
    {
      displayName: "Markdown",
      builtIn: "Text",
      initialProps: {
        mode: "markdown"
      },
      synonyms: []
    }
  ],
  [
    "Link",
    {
      displayName: "Link",
      builtIn: "Text",
      initialProps: {
        mode: "link"
      },
      synonyms: []
    }
  ],
  ["Select", { displayName: "Select", builtIn: "Select", synonyms: ["combobox", "dropdown"] }],
  ["List", { displayName: "List", builtIn: "List", synonyms: ["repeat"] }],
  ["Paper", { displayName: "Paper", builtIn: "Paper", synonyms: ["surface"] }],
  ["Tabs", { displayName: "Tabs", builtIn: "Tabs", synonyms: [] }],
  ["Container", { displayName: "Container", builtIn: "Container", synonyms: [] }],
  ["Metric", { displayName: "Metric", builtIn: "Metric", synonyms: ["value", "number", "output"] }],
  [
    "Checkbox",
    {
      displayName: "Checkbox",
      initialProps: {
        mode: "checkbox"
      },
      builtIn: "Checkbox",
      synonyms: ["switch"]
    }
  ],
  [
    "Switch",
    {
      displayName: "Switch",
      initialProps: {
        mode: "switch"
      },
      builtIn: "Checkbox",
      synonyms: ["switch"]
    }
  ],
  [FORM_COMPONENT_ID, { displayName: "Form", builtIn: "Form", synonyms: [] }],
  [
    SPACER_COMPONENT_ID,
    { displayName: "Spacer", builtIn: "Spacer", synonyms: ["margin", "blank", "empty", "void"] }
  ],
  [
    "Password",
    {
      displayName: "Password",
      builtIn: "TextField",
      synonyms: [],
      initialProps: { password: true }
    }
  ]
]);
function useCodeComponents() {
  const project = useProject();
  const { data: codeComponents, refetch } = useSuspenseQuery({
    queryKey: ["codeComponents"],
    queryFn: () => project.api.methods.getComponents()
  });
  React402.useEffect(
    () => project.events.subscribe("componentsListChanged", refetch),
    [project.events, refetch]
  );
  return React402.useMemo(
    () => Object.fromEntries(
      codeComponents.map((codeComponent) => [
        `codeComponent.${codeComponent.name}`,
        {
          displayName: codeComponent.name,
          synonyms: []
        }
      ])
    ),
    [codeComponents]
  );
}
function useToolpadComponents() {
  const codeComponents = useCodeComponents();
  return React402.useMemo(
    () => ({ ...Object.fromEntries(INTERNAL_COMPONENTS), ...codeComponents }),
    [codeComponents]
  );
}
function useToolpadComponent(id) {
  const components = useToolpadComponents();
  return React402.useMemo(() => components[id] || null, [components, id]);
}
var classes3 = {
  control: "Toolpad_Control",
  sectionHeading: "Toolpad_ControlsSectionHeading"
};
var ComponentEditorRoot = styled_default("div")(({ theme: theme3 }) => ({
  [`& .${classes3.control}`]: {
    margin: theme3.spacing(0, 0)
  },
  [`& .${classes3.sectionHeading}`]: {
    margin: theme3.spacing(0, 0, -0.5, 0)
  }
}));
function shouldRenderControl(propTypeDef, propName, props2) {
  var _a, _b, _c;
  if (propTypeDef.type === "element" || propTypeDef.type === "template") {
    return ((_a = propTypeDef.control) == null ? void 0 : _a.type) !== "slot" && ((_b = propTypeDef.control) == null ? void 0 : _b.type) !== "slots" && ((_c = propTypeDef.control) == null ? void 0 : _c.type) !== "layoutSlot";
  }
  if (typeof propTypeDef.visible === "boolean") {
    return propTypeDef.visible;
  }
  if (typeof propTypeDef.visible === "function") {
    return propTypeDef.visible(props2);
  }
  return true;
}
function ComponentPropsEditor({
  componentConfig,
  bindings,
  node
}) {
  const { layoutDirection } = componentConfig;
  const hasLayoutHorizontalControls = layoutDirection === LAYOUT_DIRECTION_HORIZONTAL || layoutDirection === LAYOUT_DIRECTION_BOTH;
  const hasLayoutVerticalControls = layoutDirection === LAYOUT_DIRECTION_VERTICAL || layoutDirection === LAYOUT_DIRECTION_BOTH;
  const hasLayoutControls = hasLayoutHorizontalControls || hasLayoutVerticalControls;
  const props2 = React412.useMemo(() => {
    const propsPattern = new RegExp(`(?<=${node.id}.props.)(.*)`);
    return Object.fromEntries(
      Object.entries(bindings).map(([key2, binding]) => {
        var _a;
        return [
          (_a = key2.match(propsPattern)) == null ? void 0 : _a[0],
          binding == null ? void 0 : binding.value
        ];
      })
    );
  }, [bindings, node.id]);
  const argTypesByCategory = groupBy_default(
    Object.entries(componentConfig.argTypes || {}),
    ([, propTypeDef]) => (propTypeDef == null ? void 0 : propTypeDef.category) || "properties"
  );
  return React412.createElement(React412.Fragment, null, hasLayoutControls ? React412.createElement(React412.Fragment, null, React412.createElement(Typography_default, { variant: "overline", className: classes3.sectionHeading }, "Layout:"), React412.createElement("div", { className: classes3.control }, React412.createElement(Typography_default, { variant: "body2" }, "Alignment:"), React412.createElement(
    Box_default,
    {
      sx: {
        display: "flex",
        flexDirection: "row",
        alignItems: "center",
        flexWrap: "wrap",
        gap: 1
      }
    },
    hasLayoutHorizontalControls ? React412.createElement(
      NodeAttributeEditor,
      {
        node,
        namespace: "layout",
        name: "horizontalAlign",
        argType: layoutBoxArgTypes.horizontalAlign,
        sx: { maxWidth: 110 }
      }
    ) : null,
    hasLayoutVerticalControls ? React412.createElement(
      NodeAttributeEditor,
      {
        node,
        namespace: "layout",
        name: "verticalAlign",
        argType: layoutBoxArgTypes.verticalAlign
      }
    ) : null
  )), React412.createElement(Divider_default, { sx: { mt: 1 } })) : null, Object.entries(argTypesByCategory).map(([category, argTypeEntries]) => React412.createElement(React412.Fragment, { key: category }, React412.createElement(Typography_default, { variant: "overline", className: classes3.sectionHeading }, category, ":"), argTypeEntries.map(
    ([propName, propTypeDef]) => propTypeDef && shouldRenderControl(propTypeDef, propName, props2) ? React412.createElement("div", { key: propName, className: classes3.control }, React412.createElement(
      NodeAttributeEditor,
      {
        node,
        namespace: "props",
        props: props2,
        name: propName,
        argType: propTypeDef
      }
    )) : null
  ))));
}
function SelectedNodeEditor({ node }) {
  var _a;
  const { bindings, viewState } = usePageEditorState();
  const componentConfig = ((_a = viewState.nodes[node.id]) == null ? void 0 : _a.componentConfig) || { argTypes: {} };
  const component = useToolpadComponent(getElementNodeComponentId(node));
  const displayName = (component == null ? void 0 : component.displayName) || "<unknown>";
  return React412.createElement(ElementContext_default.Provider, { value: node }, React412.createElement(Stack_default, { direction: "column", gap: 0 }, React412.createElement(MarkdownTooltip, { placement: "left", title: componentConfig.helperText ?? displayName }, React412.createElement(Typography_default, { variant: "body1" }, node.name)), React412.createElement(Divider_default, { sx: { mt: 1 } }), node ? React412.createElement(ComponentPropsEditor, { bindings, componentConfig, node }) : null));
}
function ComponentEditor({ node, className }) {
  return React412.createElement(ComponentEditorRoot, { className, "data-testid": "component-editor" }, React412.createElement(SelectedNodeEditor, { key: node.id, node }));
}
var isRgb = (string) => /rgb\([0-9]{1,3}\s*,\s*[0-9]{1,3}\s*,\s*[0-9]{1,3}\)/i.test(string);
var isHex = (string) => /^#?([0-9a-f]{3})$|^#?([0-9a-f]){6}$/i.test(string);
function parseColor(color) {
  if (isRgb(color)) {
    return color;
  }
  if (isHex(color)) {
    if (!color.startsWith("#")) {
      return `#${color}`;
    }
    return color;
  }
  return null;
}
var hues = [
  "red",
  "pink",
  "purple",
  "deepPurple",
  "indigo",
  "blue",
  "lightBlue",
  "cyan",
  "teal",
  "green",
  "lightGreen",
  "lime",
  "yellow",
  "amber",
  "orange",
  "deepOrange"
];
var shades = [
  900,
  800,
  700,
  600,
  500,
  400,
  300,
  200,
  100,
  50,
  "A700",
  "A400",
  "A200",
  "A100"
];
var TooltipRadio = React422.forwardRef(
  function TooltipRadio2(props2, ref) {
    const {
      "aria-labelledby": ariaLabelledBy,
      "aria-label": ariaLabel,
      inputProps,
      ...other
    } = props2;
    return React422.createElement(
      Radio_default,
      {
        ref,
        ...other,
        inputProps: {
          ...inputProps,
          "aria-labelledby": ariaLabelledBy,
          "aria-label": ariaLabel
        }
      }
    );
  }
);
function ColorTool({ sx, label, value, onChange }) {
  const theme3 = useTheme();
  const [state, setState] = React422.useState({
    input: value,
    hue: "blue",
    shade: 4,
    valid: true
  });
  const handleChangeColor = (event) => {
    let {
      target: { value: color2 }
    } = event;
    const parsed = parseColor(color2);
    const valid = !!parsed;
    if (parsed) {
      color2 = parsed;
    }
    setState((oldState) => ({
      ...oldState,
      input: color2,
      valid
    }));
    if (valid) {
      onChange == null ? void 0 : onChange(color2);
    }
  };
  const handleChangeHue = (event) => {
    const hue = event.target.value;
    const color2 = colors_exports[hue][shades[state.shade]];
    if (color2) {
      setState({
        ...state,
        hue,
        input: color2
      });
      onChange == null ? void 0 : onChange(color2);
    }
  };
  const handleChangeShade = (event, shade) => {
    (0, import_invariant6.default)(!Array.isArray(shade), "Material-UI: `shade` must not be an array.");
    const color2 = colors_exports[state.hue][shades[shade]];
    if (color2) {
      setState({
        ...state,
        shade,
        input: color2
      });
      onChange == null ? void 0 : onChange(color2);
    }
  };
  const intentInput = state.input;
  const intentShade = state.shade;
  const color = value;
  const background = color ? theme3.palette.augmentColor({
    color: {
      main: color
    }
  }) : void 0;
  const id = React422.useId();
  return React422.createElement(Box_default2, { sx }, React422.createElement(Typography_default, { component: "label", gutterBottom: true, htmlFor: id, variant: "h6" }, label), React422.createElement(
    Input_default,
    {
      id,
      value: intentInput,
      onChange: handleChangeColor,
      fullWidth: true,
      error: !state.valid
    }
  ), React422.createElement(Box_default2, { sx: { display: "flex", alignItems: "center", mt: 2, mb: 2 } }, React422.createElement(Typography_default, { id: `${id}ShadeSliderLabel` }, "Shade:"), React422.createElement(
    Slider_default,
    {
      sx: { width: "calc(100% - 80px)", ml: 3, mr: 3 },
      value: intentShade,
      min: 0,
      max: 13,
      step: 1,
      onChange: handleChangeShade,
      "aria-labelledby": `${id}ShadeSliderLabel`
    }
  ), React422.createElement(Typography_default, null, shades[intentShade])), React422.createElement(Box_default2, { sx: { width: 192, margin: "auto" } }, hues.map((hue) => {
    const shade = shades[state.shade];
    const backgroundColor = colors_exports[hue][shade];
    return React422.createElement(Tooltip_default, { placement: "right", title: hue, key: hue, disableInteractive: true }, React422.createElement(
      TooltipRadio,
      {
        sx: { p: 0 },
        color: "default",
        checked: color === backgroundColor,
        onChange: handleChangeHue,
        value: hue,
        name: label,
        icon: React422.createElement(Box_default2, { sx: { width: 48, height: 48 }, style: { backgroundColor } }),
        checkedIcon: React422.createElement(
          Box_default2,
          {
            sx: {
              width: 48,
              height: 48,
              border: 1,
              borderColor: "white",
              color: "common.white",
              display: "flex",
              justifyContent: "center",
              alignItems: "center"
            },
            style: { backgroundColor }
          },
          React422.createElement(Check_default, { style: { fontSize: 30 } })
        )
      }
    ));
  })), React422.createElement(Stack_default, { direction: "row", sx: { mt: 2, justifyContent: "center" } }, ["dark", "main", "light"].map((key2) => React422.createElement(
    Box_default2,
    {
      sx: {
        width: 64,
        height: 64,
        display: "flex",
        justifyContent: "center",
        alignItems: "center"
      },
      style: { backgroundColor: background == null ? void 0 : background[key2] },
      key: key2
    },
    React422.createElement(
      Typography_default,
      {
        variant: "caption",
        style: {
          color: background ? theme3.palette.getContrastText(background[key2]) : void 0
        }
      },
      background ? rgbToHex(background[key2]) : ""
    )
  ))));
}
var ColorTool_default = ColorTool;
var FlexFill = styled_default("div")({ flex: 1 });
var FlexFill_default = FlexFill;
var IconToggleButton = styled_default(ToggleButton_default)({
  display: "flex",
  justifyContent: "center",
  width: "100%",
  "& > *": {
    marginRight: "8px"
  }
});
function PaletteColorPicker({ label, value, onChange }) {
  const theme3 = useTheme();
  const [anchorEl, setAnchorEl] = React432.useState(null);
  const handleClick = (event) => {
    setAnchorEl(event.currentTarget);
  };
  const handleClose = () => {
    setAnchorEl(null);
  };
  const open = Boolean(anchorEl);
  const id = React432.useId();
  return React432.createElement(React432.Fragment, null, React432.createElement(Button_default, { "aria-describedby": id, variant: "outlined", onClick: handleClick }, label, React432.createElement(FlexFill_default, null), React432.createElement(
    Box_default2,
    {
      sx: {
        ml: 2,
        p: "2px 8px",
        background: value,
        color: value ? theme3.palette.getContrastText(value) : void 0,
        borderRadius: 1
      }
    },
    value
  )), React432.createElement(
    Popover_default,
    {
      id: open ? id : void 0,
      open,
      anchorEl,
      onClose: handleClose,
      anchorOrigin: {
        vertical: "bottom",
        horizontal: "left"
      }
    },
    React432.createElement(ColorTool_default, { sx: { m: 2 }, label, value, onChange })
  ));
}
function MuiThemeEditor({ value, onChange }) {
  var _a, _b;
  const theme3 = useTheme();
  const defaultTheme = React432.useMemo(
    () => {
      var _a2;
      return createTheme({ palette: { mode: (_a2 = value == null ? void 0 : value.palette) == null ? void 0 : _a2.mode } });
    },
    [(_a = value == null ? void 0 : value.palette) == null ? void 0 : _a.mode]
  );
  const colorPicker = (intent) => {
    var _a2, _b2;
    return React432.createElement(
      PaletteColorPicker,
      {
        label: capitalize_default(intent),
        value: ((_b2 = (_a2 = value == null ? void 0 : value.palette) == null ? void 0 : _a2[intent]) == null ? void 0 : _b2.main) || defaultTheme.palette[intent].main,
        onChange: (newMain) => {
          onChange({
            ...value,
            palette: {
              ...value == null ? void 0 : value.palette,
              [intent]: newMain ? {
                main: newMain,
                contrastText: theme3.palette.getContrastText(newMain)
              } : void 0
            }
          });
        }
      }
    );
  };
  return React432.createElement(Stack_default, { direction: "column", spacing: 2 }, React432.createElement(
    ToggleButtonGroup_default,
    {
      exclusive: true,
      value: ((_b = value == null ? void 0 : value.palette) == null ? void 0 : _b.mode) || defaultTheme.palette.mode,
      onChange: (event, newMode) => {
        if (newMode) {
          onChange({
            ...value,
            palette: {
              ...value == null ? void 0 : value.palette,
              mode: newMode
            }
          });
        }
      },
      "aria-label": "Mode"
    },
    React432.createElement(IconToggleButton, { value: "light", "aria-label": "light" }, React432.createElement(LightMode_default, null), "Light"),
    React432.createElement(IconToggleButton, { value: "dark", "aria-label": "dark" }, React432.createElement(DarkMode_default, null), "Dark")
  ), colorPicker("primary"), colorPicker("secondary"));
}
function ComponentEditor2({ className }) {
  const { dom } = useAppState();
  const domApi = useDomApi();
  const app = getApp(dom);
  const { themes = [] } = getChildNodes(dom, app);
  const theme3 = themes.length > 0 ? themes[0] : null;
  return React442.createElement("div", { className, "data-testid": "theme-editor" }, React442.createElement(
    MuiThemeEditor,
    {
      value: (theme3 == null ? void 0 : theme3.theme) || {},
      onChange: (newTheme) => {
        domApi.update((draft) => {
          if (theme3) {
            draft = setNodeProp(draft, theme3, "theme", newTheme);
            return draft;
          }
          const newThemeNode = createNode(dom, "theme", {
            name: "Theme",
            theme: newTheme,
            attributes: {}
          });
          draft = addNode(draft, newThemeNode, app, "themes");
          return draft;
        });
      }
    }
  ));
}
var classes4 = {
  panel: "Toolpad_Panel",
  themesDocsLink: "Toolpad_ThemesDocsLink"
};
var ComponentPanelRoot = styled_default("div")(({ theme: theme3 }) => ({
  display: "flex",
  flexDirection: "column",
  height: "100%",
  [`& .${classes4.panel}`]: {
    flex: 1,
    padding: theme3.spacing(2),
    overflow: "auto"
  },
  [`& .${classes4.themesDocsLink}`]: {
    marginBottom: theme3.spacing(1)
  }
}));
function ComponentPanel({ className }) {
  const { dom, currentView } = useAppState();
  const appStateApi = useAppStateApi();
  const currentTab = currentView.kind === "page" ? currentView.pageViewTab : null;
  const selectedNodeId = currentView.kind === "page" ? currentView.selectedNodeId : null;
  const selectedNode = selectedNodeId ? getMaybeNode(dom, selectedNodeId) : null;
  const handleChange = (_2, newValue) => {
    appStateApi.setPageViewTab(newValue);
  };
  return React452.createElement(ComponentPanelRoot, { className }, React452.createElement(TabContext, { value: currentTab || "page" }, React452.createElement(Box_default2, { sx: { borderBottom: 1, borderColor: "divider" } }, React452.createElement(TabList_default, { onChange: handleChange, "aria-label": "Component options" }, React452.createElement(Tab_default, { label: "Page", value: "page" }), React452.createElement(Tab_default, { label: "Component", value: "component", disabled: !selectedNode }), React452.createElement(Tab_default, { label: "Theme", value: "theme" }))), React452.createElement(TabPanel_default, { value: "page", className: classes4.panel }, React452.createElement(PageOptionsPanel, null)), React452.createElement(TabPanel_default, { value: "component", className: classes4.panel }, selectedNode && isElement(selectedNode) ? React452.createElement(ComponentEditor, { node: selectedNode }) : React452.createElement(Typography_default, { variant: "body1" }, "No component selected.")), React452.createElement(TabPanel_default, { value: "theme", className: classes4.panel }, React452.createElement(Typography_default, { className: classes4.themesDocsLink, variant: "body2" }, "Customize the app with a Material UI theme. Read more about theming in the", " ", React452.createElement(
    Link_default,
    {
      href: "https://mui.com/toolpad/studio/concepts/theming/",
      target: "_blank",
      rel: "noopener"
    },
    "docs"
  ), "."), React452.createElement(ComponentEditor2, null))));
}
var iconMap = new Map(
  [
    ["Password", Password_default],
    ["Autocomplete", ManageSearch_default],
    ["Text", Notes_default],
    ["Link", Link_default2],
    ["Markdown", TextFormat_default],
    ["Button", SmartButton_default],
    ["Image", Image_default],
    ["DataGrid", GridOn_default],
    ["TextField", Crop75_default],
    ["Select", ArrowDropDownCircle_default],
    ["List", List_default2],
    ["Paper", Layers_default],
    ["Form", Dns_default],
    ["Card", ContactPage_default],
    ["Tabs", Tab_default2],
    ["Slider", Tune_default],
    ["Switch", ToggleOn_default],
    ["Radio", RadioButtonChecked_default],
    ["DatePicker", DateRange_default],
    ["FilePicker", UploadFile_default],
    ["Checkbox", CheckBox_default],
    ["CodeComponent", DashboardCustomizeSharp_default],
    ["CreateNew", Add_default],
    ["Tabs", Tab_default2],
    ["Container", AutoAwesomeMosaic_default],
    ["Chart", Insights_default],
    ["Map", Place_default],
    ["Drawer", ViewSidebar_default],
    ["Pie Chart", PieChart_default],
    ["Icon", Mood_default],
    ["Html", Html_default],
    ["PageRow", TableRows_default],
    ["PageColumn", ViewColumn_default],
    ["Metric", Tag_default],
    ["Spacer", SpaceBar_default]
  ].map(([id, Icon]) => {
    const StyledIcon = styled_default(Icon, {
      shouldForwardProp: (prop) => prop !== "kind"
    })(({ kind }) => ({
      fontSize: 24,
      opacity: kind === "future" ? 0.75 : 1
    }));
    return [id, StyledIcon];
  })
);
function ComponentIcon({ id: componentId, kind, ...props2 }) {
  const Icon = iconMap.get(kind === "custom" ? "CodeComponent" : componentId);
  return Icon ? React462.createElement(Icon, { ...props2 }) : null;
}
function ComponentCatalogItem({
  draggable,
  onClick,
  id,
  displayName,
  builtIn,
  kind,
  onDragStart
}) {
  return React462.createElement(
    Box_default2,
    {
      className: "ComponentCatalogItem",
      onClick,
      draggable,
      onDragStart,
      component: ButtonBase_default,
      sx: {
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
        width: builtIn ? 65 : 60,
        height: builtIn ? 65 : 60,
        padding: 1,
        borderRadius: 1,
        border: 1,
        borderColor: "divider",
        borderStyle: kind === "create" ? "dashed" : "solid",
        color: "text.secondary",
        backgroundColor: "paper",
        // https://stackoverflow.com/q/22922761
        transform: "translate(0, 0)",
        "&:hover": {
          backgroundColor: "action.hover"
        },
        ...draggable ? { cursor: "grab" } : {},
        ...onClick ? { cursor: "pointer" } : {}
      }
    },
    React462.createElement(ComponentIcon, { id, kind }),
    React462.createElement(
      "span",
      {
        style: {
          fontSize: "0.625rem",
          maxWidth: builtIn ? 65 : 60,
          whiteSpace: "nowrap",
          opacity: kind === "future" ? 0.75 : 1,
          textOverflow: "ellipsis",
          overflow: "hidden"
        }
      },
      displayName
    )
  );
}
var ComponentCatalogItem_default = ComponentCatalogItem;
var StyledDialogForm = styled_default("form")({
  overflowY: "auto",
  display: "flex",
  flexDirection: "column"
});
function DialogForm({ children, onKeyDown = () => {
}, ...rest }) {
  const handleKeyDown = React472.useCallback(
    (event) => {
      const modifierKey = (event.metaKey || event.ctrlKey) && !event.shiftKey;
      if (event.key === "Enter" && modifierKey) {
        const submitButton = event.currentTarget.querySelector('[type="submit"]');
        if (submitButton) {
          submitButton.click();
        }
      }
      onKeyDown(event);
    },
    [onKeyDown]
  );
  return React472.createElement(StyledDialogForm, { onKeyDown: handleKeyDown, ...rest }, children);
}
function MissingEditorDialog({ open, onClose }) {
  const handleMissingEditorDialogClose = React482.useCallback(() => {
    onClose(false);
  }, [onClose]);
  const id = React482.useId();
  return React482.createElement(
    Dialog_default,
    {
      open,
      onClose: handleMissingEditorDialogClose,
      "aria-labelledby": `${id}-title`,
      "aria-describedby": "alert-dialog-description",
      onClick: (event) => event.stopPropagation()
    },
    React482.createElement(DialogTitle_default, { id: `${id}-title` }, "Editor not found"),
    React482.createElement(DialogContent_default, null, React482.createElement(DialogContentText_default, { id: "alert-dialog-description" }, 'No editor was detected on your system. If you use Visual Studio Code, this may be due to a missing "code" command in your PATH. Otherwise you can set the', " ", React482.createElement("code", null, "$EDITOR"), " environment variable. ", React482.createElement("br", null), "Check the", " ", React482.createElement(
      Link_default,
      {
        href: "https://mui.com/toolpad/studio/how-to-guides/editor-path/",
        target: "_blank",
        rel: "noopener"
      },
      "docs"
    ), " ", "for more information.")),
    React482.createElement(DialogActions_default, null, React482.createElement(Button_default, { onClick: handleMissingEditorDialogClose }, "Dismiss"))
  );
}
function OpenCodeEditorButton({
  filePath,
  fileType,
  iconButton,
  onSuccess,
  actionText = "Open",
  disabled,
  ...rest
}) {
  const [missingEditorDialog, setMissingEditorDialog] = React482.useState(false);
  const [busy, setBusy] = React482.useState(false);
  const projectApi = useProjectApi();
  const handleClick = React482.useCallback(
    async (event) => {
      event.stopPropagation();
      setBusy(true);
      try {
        await projectApi.methods.openCodeEditor(filePath, fileType);
        onSuccess == null ? void 0 : onSuccess();
      } catch {
        setMissingEditorDialog(true);
      } finally {
        setBusy(false);
      }
    },
    [projectApi, filePath, fileType, onSuccess]
  );
  return React482.createElement(React482.Fragment, null, iconButton ? React482.createElement(Tooltip_default, { title: "Open in code editor" }, React482.createElement(IconButton_default, { disabled: disabled || busy, size: "small", onClick: handleClick, ...rest }, busy ? React482.createElement(CircularProgress_default, { color: "inherit", size: 16 }) : React482.createElement(Code_default, { fontSize: "inherit", color: "primary" }))) : React482.createElement(
    LoadingButton_default,
    {
      disabled: disabled || busy,
      onClick: handleClick,
      loading: busy,
      startIcon: rest.variant === "outlined" ? React482.createElement(Code_default, { fontSize: "inherit", color: "primary" }) : null,
      ...rest
    },
    actionText
  ), React482.createElement(MissingEditorDialog, { open: missingEditorDialog, onClose: setMissingEditorDialog }));
}
function handleInputFocus(event) {
  event.target.select();
}
var DEFAULT_NAME = "MyComponent";
function CreateCodeComponentDialog({
  open,
  onClose,
  ...props2
}) {
  const projectApi = useProjectApi();
  const codeComponents = useToolpadComponents();
  const existingNames = React492.useMemo(
    () => new Set(
      Object.values(codeComponents).map((component) => component == null ? void 0 : component.displayName).filter(Boolean)
    ),
    [codeComponents]
  );
  const [name, setName] = React492.useState(proposeName(DEFAULT_NAME, existingNames));
  const handleReset = useEventCallback_default(
    () => setName(proposeName(DEFAULT_NAME, existingNames))
  );
  React492.useEffect(() => {
    if (open) {
      handleReset();
    }
  }, [open, handleReset]);
  const inputErrorMsg = useNodeNameValidation(name, existingNames, "component");
  const isNameValid = !inputErrorMsg;
  const isFormValid = isNameValid;
  const [snackbarState, setSnackbarState] = React492.useState(null);
  const lastSnackbarState = useLatest_default(snackbarState);
  const handleSnackbarClose = React492.useCallback(() => {
    setSnackbarState(null);
  }, []);
  return React492.createElement(React492.Fragment, null, React492.createElement(Dialog_default, { open, onClose, ...props2 }, React492.createElement(
    DialogForm,
    {
      autoComplete: "off",
      onSubmit: async (event) => {
        event.preventDefault();
        (0, import_invariant8.default)(isFormValid, "Invalid form should not be submitted when submit is disabled");
        await projectApi.methods.createComponent(name);
        onClose();
        setSnackbarState({ name });
      }
    },
    React492.createElement(DialogTitle_default, null, "Create a new Code Component"),
    React492.createElement(DialogContent_default, null, React492.createElement(
      TextField_default,
      {
        sx: { my: 1 },
        required: true,
        onFocus: handleInputFocus,
        autoFocus: true,
        fullWidth: true,
        label: "name",
        value: name,
        onChange: (event) => setName(event.target.value),
        error: open && !isNameValid,
        helperText: inputErrorMsg
      }
    )),
    React492.createElement(DialogActions_default, null, React492.createElement(Button_default, { color: "inherit", variant: "text", onClick: onClose }, "Cancel"), React492.createElement(Button_default, { type: "submit", disabled: !isFormValid }, "Create"))
  )), lastSnackbarState ? React492.createElement(Portal_default, null, React492.createElement(
    Snackbar_default,
    {
      open: !!snackbarState,
      onClose: handleSnackbarClose,
      message: `Component "${lastSnackbarState.name}" created`,
      anchorOrigin: { vertical: "bottom", horizontal: "right" },
      action: React492.createElement(React492.Fragment, null, React492.createElement(
        OpenCodeEditorButton,
        {
          filePath: name,
          variant: "text",
          fileType: "component",
          color: "primary",
          onSuccess: handleSnackbarClose
        }
      ), React492.createElement(
        IconButton_default,
        {
          size: "small",
          "aria-label": "close",
          color: "inherit",
          onClick: handleSnackbarClose
        },
        React492.createElement(Close_default, { fontSize: "small" })
      ))
    }
  )) : null);
}
function useLocalStorageState(key2, initialValue) {
  const [input, setInput] = useStorageState_default("local", key2, () => JSON.stringify(initialValue));
  const value = React502.useMemo(() => JSON.parse(input), [input]);
  const handleChange = React502.useCallback(
    (newValue) => setInput(
      JSON.stringify(typeof newValue === "function" ? newValue(value) : newValue)
    ),
    [setInput, value]
  );
  return [value, handleChange];
}
var HelpIcon = styled_default(HelpOutline_default)(({ theme: theme3 }) => ({
  color: theme3.palette.text.secondary
}));
function HelpTooltipIcon({ helpText, ...props2 }) {
  return React512.createElement(Tooltip_default, { title: helpText }, React512.createElement(HelpIcon, { ...props2 }));
}
var FUTURE_COMPONENTS = /* @__PURE__ */ new Map([
  ["Map", { url: "https://github.com/mui/toolpad/issues/864", displayName: "Map" }],
  ["Pie Chart", { url: "https://github.com/mui/toolpad/issues/2615", displayName: "Pie Chart" }],
  ["Drawer", { url: "https://github.com/mui/toolpad/issues/1540", displayName: "Drawer" }],
  ["Html", { url: "https://github.com/mui/toolpad/issues/1311", displayName: "Html" }],
  ["Icon", { url: "https://github.com/mui/toolpad/issues/83", displayName: "Icon" }],
  ["Card", { url: "https://github.com/mui/toolpad/issues/748", displayName: "Card" }],
  ["Slider", { url: "https://github.com/mui/toolpad/issues/746", displayName: "Slider" }],
  ["Radio", { url: "https://github.com/mui/toolpad/issues/744", displayName: "Radio" }]
]);
var COMPONENT_CATALOG_WIDTH_COLLAPSED = 40;
var ComponentCatalogRoot = styled_default("div")({
  position: "relative",
  width: COMPONENT_CATALOG_WIDTH_COLLAPSED + 1,
  height: "100%",
  zIndex: 1,
  overflow: "visible"
});
function ComponentCatalog({ className }) {
  const api = usePageEditorApi();
  const { dom } = useAppState();
  const [searchTerm, setSearchTerm] = React522.useState("");
  const [searchFocused, setSearchFocused] = React522.useState(false);
  const [openStart, setOpenStart] = React522.useState(0);
  const [openCustomComponents, setOpenCustomComponents] = useLocalStorageState(
    "catalog-custom-expanded",
    true
  );
  const [openFutureComponents, setOpenFutureComponents] = useLocalStorageState(
    "catalog-future-expanded",
    true
  );
  const closeTimeoutRef = React522.useRef();
  const openDrawer = React522.useCallback(() => {
    if (closeTimeoutRef.current) {
      clearTimeout(closeTimeoutRef.current);
    }
    setOpenStart(Date.now());
  }, []);
  const closeDrawer = React522.useCallback(
    (delay) => {
      const timeOpen = Date.now() - openStart;
      const defaultDelay = timeOpen > 750 ? 500 : 0;
      closeTimeoutRef.current = setTimeout(() => {
        setOpenStart(0);
      }, delay ?? defaultDelay);
    },
    [openStart, setOpenStart]
  );
  const toolpadComponents = useToolpadComponents();
  const handleDragStart = (componentType) => (event) => {
    const def = toolpadComponents[componentType];
    (0, import_invariant7.default)(def, `No component definition found for "${componentType}"`);
    event.dataTransfer.dropEffect = "copy";
    const newNode = createElement(
      dom,
      def.builtIn || componentType,
      def.initialProps || {},
      void 0,
      uncapitalize(def.displayName)
    );
    api.newNodeDragStart(newNode);
    closeDrawer(0);
  };
  const handleMouseEnter = React522.useCallback(() => openDrawer(), [openDrawer]);
  const handleMouseLeave = React522.useCallback(() => closeDrawer(), [closeDrawer]);
  const [createCodeComponentDialogOpen, setCreateCodeComponentDialogOpen] = React522.useState(false);
  const handleCreateCodeComponentDialogOpen = React522.useCallback(() => {
    setCreateCodeComponentDialogOpen(true);
    closeDrawer(0);
  }, [closeDrawer]);
  const handleCreateCodeComponentDialogClose = React522.useCallback(
    () => setCreateCodeComponentDialogOpen(false),
    []
  );
  const filteredItems = React522.useMemo(() => {
    const entries = Object.entries(toolpadComponents);
    if (!searchTerm) {
      return entries;
    }
    const regex = new RegExp(searchTerm.split("").join(".*"), "i");
    return entries.filter(
      ([componentName, component]) => regex.test(componentName) || (component == null ? void 0 : component.synonyms.some((name) => regex.test(name)))
    );
  }, [toolpadComponents, searchTerm]);
  const drawerOpen = !!openStart || searchFocused;
  React522.useEffect(() => {
    if (!drawerOpen) {
      setSearchTerm("");
    }
  }, [drawerOpen]);
  return React522.createElement(React522.Fragment, null, React522.createElement(
    ComponentCatalogRoot,
    {
      "data-testid": "component-catalog",
      className,
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave
    },
    React522.createElement(
      Box_default2,
      {
        sx: {
          display: "flex",
          flexDirection: "row",
          position: "absolute",
          top: 0,
          bottom: 0,
          backgroundColor: "background.default",
          borderRight: 1,
          borderColor: "divider"
        }
      },
      React522.createElement(
        Collapse_default,
        {
          in: drawerOpen,
          orientation: "horizontal",
          timeout: 200,
          sx: {
            height: "100%",
            justifyContent: "flex-end",
            display: "flex"
          }
        },
        React522.createElement(Box_default2, { sx: { flexDirection: "column", display: "flex", height: "100%" } }, React522.createElement(
          Box_default2,
          {
            sx: {
              width: "100%",
              pl: 1,
              pr: 1
            }
          },
          React522.createElement(
            TextField_default,
            {
              placeholder: "Search components...",
              value: searchTerm,
              onChange: (event) => setSearchTerm(event.target.value),
              onFocus: () => setSearchFocused(true),
              onBlur: () => setSearchFocused(false),
              slotProps: {
                input: {
                  startAdornment: React522.createElement(InputAdornment_default, { position: "start" }, React522.createElement(Search_default, null))
                }
              }
            }
          )
        ), React522.createElement(
          Box_default2,
          {
            sx: {
              flex: 1,
              width: 250,
              overflow: "auto",
              scrollbarGutter: "stable"
            }
          },
          React522.createElement(Box_default2, { display: "grid", gridTemplateColumns: "1fr 1fr 1fr", gap: 1, padding: 1 }, filteredItems.map(([componentId, componentType]) => {
            (0, import_invariant7.default)(componentType, `No component definition found for "${componentId}"`);
            return componentType.builtIn && !componentType.system ? React522.createElement(
              ComponentCatalogItem_default,
              {
                key: componentId,
                id: componentId,
                draggable: true,
                onDragStart: handleDragStart(componentId),
                displayName: componentType.displayName,
                builtIn: componentType.builtIn,
                kind: "builtIn"
              }
            ) : null;
          })),
          React522.createElement(
            Box_default2,
            {
              pl: 2,
              pr: 1.5,
              pb: 0,
              display: "flex",
              flexDirection: "row",
              justifyContent: "space-between"
            },
            React522.createElement(Box_default2, { display: "flex", alignItems: "center" }, React522.createElement(Typography_default, { mr: 0.5, variant: "overline" }, "Custom Components"), React522.createElement(
              HelpTooltipIcon,
              {
                helpText: React522.createElement(Typography_default, { variant: "inherit" }, "Expand Toolpad Studio with your own React components.", " ", React522.createElement(
                  Link_default,
                  {
                    href: "https://mui.com/toolpad/studio/concepts/custom-components",
                    target: "_blank",
                    rel: "noopener"
                  },
                  "Learn more"
                ), ".")
              }
            )),
            React522.createElement(
              IconButton_default,
              {
                "aria-label": "Expand custom components",
                sx: {
                  p: 0,
                  height: "100%",
                  alignSelf: "center",
                  cursor: "pointer",
                  transform: `rotate(${openCustomComponents ? 180 : 0}deg)`,
                  transition: "all 0.2s ease-in"
                },
                onClick: () => setOpenCustomComponents((prev) => !prev)
              },
              React522.createElement(ArrowDropDownSharp_default, null)
            )
          ),
          React522.createElement(Collapse_default, { in: openCustomComponents, orientation: "vertical" }, React522.createElement(Box_default2, { display: "grid", gridTemplateColumns: "1fr 1fr 1fr", gap: 1, padding: 1, pt: 0 }, filteredItems.map(([componentId, componentType]) => {
            (0, import_invariant7.default)(
              componentType,
              `No component definition found for "${componentId}"`
            );
            return !componentType.builtIn ? React522.createElement(
              ComponentCatalogItem_default,
              {
                key: componentId,
                id: componentId,
                draggable: true,
                onDragStart: handleDragStart(componentId),
                displayName: componentType.displayName,
                kind: "custom"
              }
            ) : null;
          }), React522.createElement(
            ComponentCatalogItem_default,
            {
              id: "CreateNew",
              displayName: "Create",
              kind: "create",
              onClick: handleCreateCodeComponentDialogOpen
            }
          ))),
          React522.createElement(Box_default2, { padding: 1 }, React522.createElement(
            Box_default2,
            {
              sx: (theme3) => ({
                py: 2,
                pl: 1,
                pr: 0.5,
                borderWidth: 1,
                borderStyle: "solid",
                borderRadius: 1,
                backgroundColor: darken(theme3.palette.background.default, 0.1),
                borderColor: theme3.palette.divider
              })
            },
            React522.createElement(Box_default2, { pb: 0, display: "flex", flexDirection: "row", justifyContent: "space-between" }, React522.createElement(Typography_default, { variant: "body2", color: "text.secondary" }, "More components coming soon!"), React522.createElement(
              IconButton_default,
              {
                "aria-label": "Expand custom components",
                sx: {
                  p: 0,
                  height: "100%",
                  alignSelf: "start",
                  cursor: "pointer",
                  transform: `rotate(${openFutureComponents ? 180 : 0}deg)`,
                  transition: "all 0.2s ease-in"
                },
                onClick: () => setOpenFutureComponents((prev) => !prev)
              },
              React522.createElement(ArrowDropDownSharp_default, null)
            )),
            React522.createElement(Collapse_default, { in: openFutureComponents, orientation: "vertical" }, React522.createElement(Typography_default, { variant: "caption", color: "text.secondary" }, "👍 Upvote on GitHub to get it prioritized."), React522.createElement(Box_default2, { display: "grid", gridTemplateColumns: "1fr 1fr 1fr", gap: 1, pt: 1, pb: 0 }, Array.from(FUTURE_COMPONENTS, ([key2, { displayName, url }]) => {
              return React522.createElement(
                Link_default,
                {
                  href: url,
                  underline: "none",
                  target: "_blank",
                  key: `futureComponent.${key2}`
                },
                React522.createElement(
                  ComponentCatalogItem_default,
                  {
                    id: key2,
                    displayName,
                    kind: "future"
                  }
                )
              );
            })))
          ))
        ))
      ),
      React522.createElement(
        Box_default2,
        {
          sx: {
            display: "flex",
            flexDirection: "column",
            alignItems: "center",
            width: COMPONENT_CATALOG_WIDTH_COLLAPSED
          }
        },
        React522.createElement(Box_default2, { sx: { mt: 2 } }, openStart ? React522.createElement(ArrowLeft_default, null) : React522.createElement(ArrowRight_default, null)),
        React522.createElement(Box_default2, { position: "relative" }, React522.createElement(
          Typography_default,
          {
            sx: {
              position: "absolute",
              top: 0,
              display: "flex",
              alignItems: "center",
              fontSize: 20,
              transform: "rotate(90deg) translate(-10px, 0)",
              transformOrigin: "0 50%",
              whiteSpace: "nowrap"
            }
          },
          "Component library"
        ))
      )
    )
  ), React522.createElement(
    CreateCodeComponentDialog,
    {
      open: !!createCodeComponentDialogOpen,
      onClose: handleCreateCodeComponentDialogClose
    }
  ));
}
var ComponentCatalog_default = ComponentCatalog;
function NotFoundEditor({ className, message, severity }) {
  return React532.createElement(Box_default2, { className, sx: { p: 3 } }, React532.createElement(Alert_default, { severity: severity ?? "warning" }, message));
}
function useUndoRedo() {
  const { currentView } = useAppState();
  const appStateApi = useAppStateApi();
  const currentPageView = currentView.kind === "page" ? currentView.view : null;
  const handleUndo = React542.useCallback(
    (event) => {
      if (currentView.kind === "page" && !currentPageView) {
        event.preventDefault();
        appStateApi.undo();
      } else if (!hasFieldFocus()) {
        appStateApi.undo();
      }
    },
    [currentView.kind, currentPageView, appStateApi]
  );
  const handleRedo = React542.useCallback(
    (event) => {
      if (currentView.kind === "page" && !currentPageView) {
        event.preventDefault();
        appStateApi.redo();
      } else if (!hasFieldFocus()) {
        appStateApi.redo();
      }
    },
    [currentView.kind, currentPageView, appStateApi]
  );
  useShortcut({ key: "z", metaKey: true, preventDefault: false }, handleUndo);
  useShortcut({ key: "z", metaKey: true, shiftKey: true, preventDefault: false }, handleRedo);
}
var dataSourceIconMap = /* @__PURE__ */ new Map([
  [
    "rest",
    styled_default(Http_default)(({ theme: theme3 }) => ({
      marginRight: theme3.spacing(0.5),
      marginLeft: theme3.spacing(0.5)
    }))
  ],
  [
    "local",
    styled_default(Javascript_default)(({ theme: theme3 }) => ({
      marginRight: theme3.spacing(0.25),
      marginLeft: theme3.spacing(0)
    }))
  ]
]);
var modeIconMap = /* @__PURE__ */ new Map([
  ["query", AutoMode_default],
  ["action", AdsClick_default],
  ["mutation", AdsClick_default]
]);
function QueryIcon({ id: iconId, mode, sx }) {
  const DataSourceIcon = dataSourceIconMap.get(iconId ?? "");
  const ModeIcon = modeIconMap.get(mode ?? "");
  return React55.createElement("div", { style: { display: "flex", gap: 0.5 } }, ModeIcon ? React55.createElement(
    ModeIcon,
    {
      sx: {
        fontSize: 12,
        alignSelf: "center"
      }
    }
  ) : null, DataSourceIcon ? React55.createElement(DataSourceIcon, { sx }) : null);
}
function ApiKeyAuthEditor({ disabled, value, onChange }) {
  return React56.createElement(Stack_default, { gap: 1 }, React56.createElement(
    TextField_default,
    {
      disabled,
      label: "header",
      value: value.header,
      onChange: (event) => onChange({ ...value, header: event.target.value })
    }
  ), React56.createElement(
    TextField_default,
    {
      disabled,
      label: "key",
      value: value.key,
      onChange: (event) => onChange({ ...value, key: event.target.value })
    }
  ));
}
function BearerTokenAuthEditor({
  disabled,
  value,
  onChange
}) {
  return React56.createElement(Stack_default, { gap: 1 }, React56.createElement(
    TextField_default,
    {
      disabled,
      label: "token",
      value: value.token,
      onChange: (event) => onChange({ ...value, token: event.target.value })
    }
  ));
}
function BasicAuthEditor({ disabled, value, onChange }) {
  return React56.createElement(Stack_default, { gap: 1 }, React56.createElement(
    TextField_default,
    {
      disabled,
      label: "user",
      value: value.user,
      onChange: (event) => onChange({ ...value, user: event.target.value })
    }
  ), React56.createElement(
    TextField_default,
    {
      type: "password",
      disabled,
      label: "password",
      value: value.password,
      onChange: (event) => onChange({ ...value, password: event.target.value })
    }
  ));
}
function AuthenticationDetailsEditor({ value, ...props2 }) {
  switch (value.type) {
    case "basic":
      return React56.createElement(BasicAuthEditor, { value, ...props2 });
    case "bearerToken":
      return React56.createElement(BearerTokenAuthEditor, { value, ...props2 });
    case "apiKey":
      return React56.createElement(ApiKeyAuthEditor, { value, ...props2 });
    default:
      throw new Error(`Unsupported authentication type "${value.type}"`);
  }
}
function getInitialAuthenticationValue(type) {
  if (!type) {
    return null;
  }
  switch (type) {
    case "basic":
      return { type, user: "", password: "" };
    case "bearerToken":
      return { type, token: "" };
    case "apiKey":
      return { type, header: "", key: "" };
    default:
      throw new Error(`Unsupported authentication type "${type}"`);
  }
}
function AuthenticationEditor({
  disabled,
  value,
  onChange
}) {
  const handleTypeChange = React56.useCallback(
    (event) => {
      onChange(getInitialAuthenticationValue(event.target.value));
    },
    [onChange]
  );
  return React56.createElement(Grid_default, { container: true, spacing: 1 }, React56.createElement(Grid_default, { item: true, xs: 4 }, React56.createElement(
    TextField_default,
    {
      disabled,
      select: true,
      label: "authentication",
      value: (value == null ? void 0 : value.type) || "",
      onChange: handleTypeChange,
      fullWidth: true
    },
    React56.createElement(MenuItem_default, { value: "" }, "No authentication"),
    React56.createElement(MenuItem_default, { value: "basic" }, "Basic"),
    React56.createElement(MenuItem_default, { value: "bearerToken" }, "Bearer token"),
    React56.createElement(MenuItem_default, { value: "apiKey" }, "API key")
  )), React56.createElement(Grid_default, { item: true, xs: 4 }, value ? React56.createElement(AuthenticationDetailsEditor, { disabled, value, onChange }) : null));
}
function errorMessage(error) {
  if (error.message) {
    return error.message;
  }
  switch (error.type) {
    case "required":
      return "required";
    default:
      return "invalid";
  }
}
function validation(formState, field) {
  const error = formState.errors[field];
  return {
    error: !!error,
    helperText: error ? errorMessage(error) : void 0
  };
}
function isSaveDisabled(formState) {
  const { isValid, isDirty } = formState;
  return !isValid || !isDirty;
}
function ParametersEditor({
  value,
  onChange,
  liveValue,
  globalScope,
  label,
  fieldLabel = "field",
  valueLabel = "value",
  autoFocus = false,
  sx,
  jsRuntime,
  disabled,
  globalScopeMeta,
  env,
  declaredEnvKeys
}) {
  const fieldInputRef = React57.useRef(null);
  const handleRemove = React57.useCallback(
    (index) => () => {
      onChange(value.filter((entry, i) => i !== index));
    },
    [onChange, value]
  );
  const isValidFieldName = React57.useMemo(() => {
    const counts = {};
    value.forEach(([field]) => {
      counts[field] = counts[field] ? counts[field] + 1 : 1;
    });
    return value.map(([field]) => !!field && counts[field] <= 1);
  }, [value]);
  return React57.createElement(
    Box_default2,
    {
      sx,
      display: "grid",
      gridTemplateColumns: "1fr 2fr auto",
      alignItems: "center",
      columnGap: 1,
      rowGap: 0
    },
    label ? React57.createElement(Box_default2, { gridColumn: "span 3" }, label, ":") : null,
    value.map(([field, fieldValue], index) => {
      var _a;
      const liveBinding = (_a = liveValue[index]) == null ? void 0 : _a[1];
      return React57.createElement(React57.Fragment, { key: index }, React57.createElement(
        TextField_default,
        {
          label: valueLabel,
          value: field,
          autoFocus: true,
          onChange: (event) => onChange(
            value.map((entry, i) => i === index ? [event.target.value, entry[1]] : entry)
          ),
          sx: { [`& .${inputLabelClasses_default.root}`]: { fontSize: 12 } },
          error: !isValidFieldName[index],
          disabled,
          slotProps: {
            htmlInput: { sx: { fontSize: 12 } }
          }
        }
      ), React57.createElement(
        BindableEditor,
        {
          liveBinding,
          jsRuntime,
          globalScope,
          globalScopeMeta,
          label: field,
          propType: { type: "string" },
          value: fieldValue,
          onChange: (newBinding) => onChange(value.map((entry, i) => i === index ? [entry[0], newBinding] : entry)),
          disabled,
          env,
          declaredEnvKeys
        }
      ), React57.createElement(
        IconButton_default,
        {
          "aria-label": "Delete property",
          onClick: handleRemove(index),
          sx: { ml: -0.5 }
        },
        React57.createElement(Delete_default, { fontSize: "inherit" })
      ));
    }),
    React57.createElement("form", { autoComplete: "off", style: { display: "contents" } }, React57.createElement(
      TextField_default,
      {
        inputRef: fieldInputRef,
        label: fieldLabel,
        value: "",
        onChange: (event) => {
          onChange([...value, [event.target.value, null]]);
        },
        sx: { [`& .${inputLabelClasses_default.root}`]: { fontSize: 12 } },
        autoFocus,
        disabled,
        slotProps: {
          htmlInput: { sx: { fontSize: 12 } }
        }
      }
    ))
  );
}
var BodyEditorRoot = styled_default("div")({
  position: "relative"
});
var RAW_CONTENT_TYPES = /* @__PURE__ */ new Map([
  ["text/plain", { alias: "text", language: "plaintext" }],
  ["application/json", { alias: "json", language: "json" }],
  ["text/javascript", { alias: "javascript", language: "typescript" }],
  ["text/csv", { alias: "csv", language: "plaintext" }],
  ["text/html", { alias: "html", language: "html" }],
  ["text/css", { alias: "css", language: "css" }],
  ["application/xml", { alias: "xml", language: "plaintext" }]
]);
var BodyEditorToolbar = styled_default((props2) => React58.createElement(React58.Fragment, null, React58.createElement(Toolbar_default, { disableGutters: true, ...props2 }), React58.createElement(Divider_default, null)))(({ theme: theme3 }) => ({
  gap: theme3.spacing(1),
  marginBottom: theme3.spacing(1)
}));
var MonacoEditor = lazyComponent(() => import("./MonacoEditor-4EVJCOAD-DIRETOTC.js"), {
  noSsr: true,
  fallback: React58.createElement(Skeleton_default, { variant: "rectangular", height: "100%" })
});
function RawBodyEditor({
  renderToolbar,
  value: valueProp,
  onChange,
  globalScope,
  globalScopeMeta,
  disabled
}) {
  const value = React58.useMemo(
    () => valueProp ?? {
      kind: "raw",
      contentType: "text/plain",
      content: ""
    },
    [valueProp]
  );
  const handleContentTypeChange = React58.useCallback(
    (event) => {
      onChange({ ...value, contentType: event.target.value });
    },
    [onChange, value]
  );
  const handleValueChange = React58.useCallback(
    (newContent) => {
      onChange({ ...value, content: newContent || "" });
    },
    [onChange, value]
  );
  const content = (value == null ? void 0 : value.content) ?? null;
  const jsServerRuntime = useServerJsRuntime();
  const liveContent = useEvaluateLiveBinding({
    jsRuntime: jsServerRuntime,
    input: content,
    globalScope
  });
  const { language = "plaintext" } = RAW_CONTENT_TYPES.get(value.contentType) ?? {};
  return React58.createElement(React58.Fragment, null, renderToolbar({
    actions: React58.createElement(
      TextField_default,
      {
        select: true,
        label: "content-type",
        sx: {
          [`& .${inputLabelClasses_default.root}`]: { fontSize: 12 },
          [`& .${inputBaseClasses_default.root}`]: { fontSize: 12 },
          width: 200
        },
        value: value == null ? void 0 : value.contentType,
        onChange: handleContentTypeChange,
        disabled
      },
      Array.from(RAW_CONTENT_TYPES.entries(), ([contentType, { alias }]) => React58.createElement(MenuItem_default, { key: contentType, value: contentType }, alias))
    )
  }), React58.createElement(
    BindableEditor,
    {
      sx: { mt: 1 },
      liveBinding: liveContent,
      globalScope,
      globalScopeMeta,
      propType: { type: "string" },
      jsRuntime: jsServerRuntime,
      renderControl: (props2) => React58.createElement(
        MonacoEditor,
        {
          sx: { flex: 1, height: 250 },
          language,
          value: props2.value,
          onChange: props2.onChange,
          disabled: props2.disabled
        }
      ),
      value: (value == null ? void 0 : value.content) || null,
      onChange: handleValueChange,
      label: "json",
      disabled
    }
  ));
}
function UrlEncodedBodyEditor({
  renderToolbar,
  value: valueProp,
  onChange,
  globalScope,
  globalScopeMeta,
  disabled
}) {
  const value = React58.useMemo(
    () => valueProp ?? {
      kind: "urlEncoded",
      contentType: "text/plain",
      content: []
    },
    [valueProp]
  );
  const handleParamsChange = React58.useCallback(
    (newContent) => {
      onChange({ ...value, content: newContent });
    },
    [onChange, value]
  );
  const jsServerRuntime = useServerJsRuntime();
  const liveContent = useEvaluateLiveBindingEntries({
    jsRuntime: jsServerRuntime,
    input: value.content,
    globalScope
  });
  return React58.createElement(React58.Fragment, null, renderToolbar(), React58.createElement(
    ParametersEditor,
    {
      sx: { mt: 1 },
      value: value.content,
      onChange: handleParamsChange,
      globalScope,
      globalScopeMeta,
      liveValue: liveContent,
      disabled,
      jsRuntime: jsServerRuntime
    }
  ));
}
function BodyEditor({
  globalScope,
  globalScopeMeta,
  value,
  onChange,
  sx,
  method: methodProp
}) {
  const [activeTab, setActiveTab] = React58.useState((value == null ? void 0 : value.kind) || "raw");
  React58.useEffect(() => setActiveTab((value == null ? void 0 : value.kind) || "raw"), [value == null ? void 0 : value.kind]);
  const handleTabChange = (event) => {
    setActiveTab(event.target.value);
  };
  const method = methodProp || "GET";
  const disabled = HTTP_NO_BODY.has(method);
  const renderToolbar = React58.useCallback(
    ({ actions } = {}) => React58.createElement(BodyEditorToolbar, null, React58.createElement(
      TextField_default,
      {
        label: "body",
        select: true,
        value: activeTab,
        onChange: handleTabChange,
        disabled,
        sx: {
          [`& .${inputLabelClasses_default.root}`]: { fontSize: 12 },
          [`& .${inputBaseClasses_default.root}`]: { fontSize: 12 },
          width: 200
        },
        slotProps: {
          htmlInput: { sx: { fontSize: 12 } }
        }
      },
      React58.createElement(MenuItem_default, { value: "raw" }, "raw"),
      React58.createElement(MenuItem_default, { value: "urlEncoded" }, "x-www-form-urlencoded")
    ), actions),
    [activeTab, disabled]
  );
  return React58.createElement(BodyEditorRoot, { sx }, React58.createElement(TabContext, { value: activeTab }, React58.createElement(TabPanel_default2, { disableGutters: true, value: "raw" }, React58.createElement(
    RawBodyEditor,
    {
      renderToolbar,
      globalScope,
      globalScopeMeta,
      value: (value == null ? void 0 : value.kind) === "raw" ? value : null,
      onChange,
      disabled
    }
  )), React58.createElement(TabPanel_default2, { disableGutters: true, value: "urlEncoded" }, React58.createElement(
    UrlEncodedBodyEditor,
    {
      renderToolbar,
      globalScope,
      globalScopeMeta,
      value: (value == null ? void 0 : value.kind) === "urlEncoded" ? value : null,
      onChange,
      disabled
    }
  ))), HTTP_NO_BODY.has(method) ? React58.createElement(
    Box_default2,
    {
      sx: {
        position: "absolute",
        inset: "0 0 0 0",
        display: "flex",
        alignItems: "center",
        justifyContent: "center"
      }
    },
    React58.createElement(Typography_default, { color: "info", variant: "body2" }, '"', method, `" requests can't have a body`)
  ) : null);
}
function useQueryPreview(dofetch, query, params, { onPreview } = {}) {
  const [preview, setPreview] = React59.useState(null);
  const [isLoading, setIsLoading] = React59.useState(false);
  const cancelRunPreview = React59.useRef(null);
  const runPreview = React59.useCallback(() => {
    var _a;
    let canceled = false;
    (_a = cancelRunPreview.current) == null ? void 0 : _a.call(cancelRunPreview);
    cancelRunPreview.current = () => {
      canceled = true;
    };
    setIsLoading(true);
    dofetch(query, params).then(
      (result) => {
        if (!canceled) {
          setPreview(result);
          onPreview == null ? void 0 : onPreview(result);
        }
      },
      (error) => {
        setPreview({ error: errorFrom(error) });
      }
    ).finally(() => {
      setIsLoading(false);
      cancelRunPreview.current = null;
    });
  }, [dofetch, query, params, onPreview]);
  return { preview, runPreview, isLoading };
}
var SCOPE_META = {};
function TransformInput({
  value,
  onChange,
  enabled: enabled2,
  onEnabledChange,
  globalScope,
  loading,
  onUpdatePreview
}) {
  const handleTransformEnabledChange = React60.useCallback(
    (event) => onEnabledChange(event.target.checked),
    [onEnabledChange]
  );
  return React60.createElement(Stack_default, null, React60.createElement(
    FormControlLabel_default,
    {
      label: "Transform response",
      sx: {
        "& .MuiFormControlLabel-label": { fontSize: 12 }
      },
      control: React60.createElement(
        Checkbox_default,
        {
          checked: enabled2,
          sx: { p: 0.25, pl: 1 },
          onChange: handleTransformEnabledChange,
          inputProps: { "aria-label": "controlled" }
        }
      )
    }
  ), React60.createElement(Stack_default, { direction: "row", spacing: 2, width: "100%" }, React60.createElement(
    JsonView,
    {
      src: globalScope,
      disabled: loading || !enabled2,
      sx: {
        width: "300px",
        maxWidth: "600px",
        maxHeight: "150px"
      }
    }
  ), onUpdatePreview ? React60.createElement(
    IconButton_default,
    {
      disabled: !enabled2,
      onClick: onUpdatePreview,
      sx: { alignSelf: "self-start" }
    },
    React60.createElement(
      Autorenew_default,
      {
        sx: {
          animation: "spin 1500ms linear infinite",
          animationPlayState: loading ? "running" : "paused",
          "@keyframes spin": {
            "0%": {
              transform: "rotate(0deg)"
            },
            "100%": {
              transform: "rotate(360deg)"
            }
          }
        },
        fontSize: "inherit"
      }
    )
  ) : null, React60.createElement(
    JsExpressionEditor,
    {
      globalScope,
      globalScopeMeta: SCOPE_META,
      autoFocus: true,
      value,
      sx: {
        minWidth: "300px",
        flex: 1
      },
      functionBody: true,
      onChange,
      disabled: !enabled2 || loading
    }
  )));
}
var classes5 = {
  logEntriesContainer: "Toolpad_ConsoleLogEntriesContainer",
  logEntries: "Toolpad_ConsoleLogEntries",
  logEntry: "Toolpad_ConsoleLogEntry",
  logEntryText: "Toolpad_ConsoleLogEntryTExt"
};
var ConsoleRoot = styled_default("div")(({ theme: theme3 }) => {
  const getColor = (color) => {
    const modify = theme3.palette.mode === "light" ? darken : lighten;
    return modify(color, 0.6);
  };
  const getBackgroundColor = (color) => {
    const modify = theme3.palette.mode === "light" ? lighten : darken;
    return modify(color, 0.9);
  };
  return {
    width: "100%",
    height: "100%",
    display: "flex",
    flexDirection: "column",
    alignItems: "stretch",
    [`& .${classes5.logEntriesContainer}`]: {
      flex: 1,
      // This container has only a single item, but the column-reverse has the effect that it
      // keeps the scroll position at the bottom when the content grows
      display: "flex",
      flexDirection: "column-reverse",
      overflow: "auto",
      fontSize: 12,
      lineHeight: 1.2,
      fontFamily: 'Consolas, Menlo, Monaco, "Andale Mono", "Ubuntu Mono", monospace'
    },
    [`& .${classes5.logEntry}`]: {
      "&:first-of-type": {
        borderTop: `1px solid ${theme3.palette.divider}`
      },
      borderBottom: `1px solid ${theme3.palette.divider}`,
      paddingLeft: theme3.spacing(1),
      paddingRight: theme3.spacing(1),
      paddingTop: 3,
      paddingBottom: 1
    },
    [`& .${classes5.logEntry}.error`]: {
      color: getColor(theme3.palette.error.light),
      background: getBackgroundColor(theme3.palette.error.light)
    },
    [`& .${classes5.logEntry}.warn`]: {
      color: getColor(theme3.palette.warning.light),
      background: getBackgroundColor(theme3.palette.warning.light)
    },
    [`& .${classes5.logEntry}.info`]: {
      color: getColor(theme3.palette.info.light),
      background: getBackgroundColor(theme3.palette.info.light)
    },
    [`& .${classes5.logEntryText} > *`]: {
      display: "inline-block",
      verticalAlign: "top"
    }
  };
});
function ConsoleEntry({ entry }) {
  return React61.createElement("div", { className: clsx_default(classes5.logEntry, entry.level) }, React61.createElement("div", { className: classes5.logEntryText }, interleave(
    entry.args.map(
      (arg, i) => typeof arg === "string" ? arg : React61.createElement(ObjectInspector_default, { key: i, data: arg })
    ),
    " "
  )));
}
function Console({ value = [], sx }) {
  return React61.createElement(ConsoleRoot, { sx }, React61.createElement("div", { className: classes5.logEntriesContainer }, React61.createElement("div", { className: classes5.logEntries }, value.map((entry, i) => React61.createElement(ConsoleEntry, { key: i, entry })))));
}
var Root = styled_default("div")({
  width: "100%",
  height: "100%",
  display: "flex",
  alignItems: "center",
  justifyContent: "center"
});
function CenteredSpinner({ sx }) {
  return React622.createElement(Root, { sx }, React622.createElement(CircularProgress_default, null));
}
var DevtoolsRoot = styled_default("div")({
  flexDirection: "column"
});
var HarViewer = lazyComponent(() => import("./HarViewer-JW34WI6T-UKANFCHQ.js"), {
  fallback: React63.createElement(CenteredSpinner, null)
});
var DebuggerTabPanel = styled_default(TabPanel_default)({ padding: 0, flex: 1, minHeight: 0 });
function Devtools({ sx, log, onLogClear, har, onHarClear }) {
  const [activeTab, setActiveTab] = React63.useState(() => {
    if (log) {
      return "console";
    }
    if (har) {
      return "network";
    }
    return "";
  });
  const handleDebuggerTabChange = (event, newValue) => {
    setActiveTab(newValue);
  };
  const logLength = (log == null ? void 0 : log.length) ?? 0;
  const harLength = (har == null ? void 0 : har.log.entries.length) ?? 0;
  const clearEnabled = React63.useMemo(() => {
    switch (activeTab) {
      case "console":
        return logLength > 0;
      case "network":
        return harLength > 0;
      default:
        throw new Error(`Missing switch case ${activeTab}`);
    }
  }, [activeTab, harLength, logLength]);
  const handleClearClick = React63.useCallback(() => {
    switch (activeTab) {
      case "console":
        return onLogClear == null ? void 0 : onLogClear();
      case "network":
        return onHarClear == null ? void 0 : onHarClear();
      default:
        throw new Error(`Missing switch case ${activeTab}`);
    }
  }, [activeTab, onHarClear, onLogClear]);
  return React63.createElement(DevtoolsRoot, { sx }, React63.createElement(TabContext, { value: activeTab }, React63.createElement(
    Box_default2,
    {
      sx: {
        borderBottom: 1,
        borderColor: "divider",
        display: "flex",
        flexDirection: "row",
        justifyContent: "start",
        pr: 1
      }
    },
    handleClearClick ? React63.createElement(IconButton_default, { disabled: !clearEnabled, onClick: handleClearClick }, React63.createElement(DoDisturb_default, null)) : null,
    React63.createElement(
      TabList_default,
      {
        onChange: handleDebuggerTabChange,
        "aria-label": "Debugger",
        sx: { "& button": { fontSize: 12, fontWeight: "normal" } }
      },
      log ? React63.createElement(
        Tab_default,
        {
          label: "Console",
          value: "console",
          sx: { borderBottom: (theme3) => `1px solid ${theme3.palette.grey[300]}` }
        }
      ) : null,
      har ? React63.createElement(
        Tab_default,
        {
          label: "Network",
          value: "network",
          sx: { borderBottom: (theme3) => `1px solid ${theme3.palette.grey[300]}` }
        }
      ) : null
    )
  ), log ? React63.createElement(DebuggerTabPanel, { value: "console" }, React63.createElement(Console, { sx: { flex: 1 }, value: log })) : null, har ? React63.createElement(DebuggerTabPanel, { value: "network" }, React63.createElement(React63.Suspense, { fallback: React63.createElement(LinearProgress_default, null) }, React63.createElement(HarViewer, { sx: { flex: 1 }, value: har }))) : null));
}
var [useConnectionContext, ConnectionContextProvider] = createProvidedContext("QueryEditor");
function usePrivateQuery(query, options2) {
  const projectApi = useProjectApi();
  const { dataSourceId, connectionId } = useConnectionContext();
  return projectApi.useQuery(
    "dataSourceFetchPrivate",
    query == null ? null : [dataSourceId, connectionId, query],
    options2
  );
}
function useFetchPrivate() {
  const projectApi = useProjectApi();
  const { dataSourceId, connectionId } = useConnectionContext();
  return React64.useCallback(
    (privateQuery) => projectApi.methods.dataSourceFetchPrivate(dataSourceId, connectionId, privateQuery),
    [projectApi, connectionId, dataSourceId]
  );
}
var Pre = styled_default("pre")({
  margin: 0,
  fontFamily: 'Consolas, Menlo, Monaco, "Andale Mono", "Ubuntu Mono", monospace'
});
var Pre_default = Pre;
var AlertRoot2 = styled_default(Alert_default)({
  position: "relative"
});
function formatStack(maybeError) {
  if (!maybeError) {
    return null;
  }
  let causeStack;
  if (maybeError == null ? void 0 : maybeError.cause) {
    causeStack = formatStack(maybeError.cause);
    if (causeStack) {
      causeStack = `cause:
${indent(causeStack, 2)}`;
    }
  }
  let thisStack;
  if (typeof (maybeError == null ? void 0 : maybeError.stack) === "string") {
    thisStack = maybeError.stack;
  }
  return thisStack || causeStack ? [thisStack, causeStack].filter(Boolean).join("\n") : null;
}
function ErrorAlert({ error, sx }) {
  const message = typeof (error == null ? void 0 : error.message) === "string" ? error.message : String(error);
  const stack2 = formatStack(error);
  const [expanded, setExpanded] = React65.useState(false);
  const toggleExpanded = React65.useCallback(() => setExpanded((actual) => !actual), []);
  return React65.createElement(AlertRoot2, { severity: "error", sx }, stack2 ? React65.createElement(
    IconButton_default,
    {
      color: "inherit",
      onClick: toggleExpanded,
      sx: {
        position: "absolute",
        top: 10,
        right: 8
      }
    },
    expanded ? React65.createElement(ExpandLess_default, null) : React65.createElement(ExpandMore_default, null)
  ) : null, React65.createElement(AlertTitle_default, null, React65.createElement(Pre_default, { sx: { whiteSpace: "pre-wrap" } }, message)), stack2 ? React65.createElement(Collapse_default, { in: expanded }, React65.createElement(Box_default2, { sx: { overflow: "auto" } }, React65.createElement(Pre_default, null, stack2))) : null);
}
function QueryPreview({ children, error, isLoading }) {
  return React66.createElement(
    Box_default2,
    {
      "data-testid": "query-preview",
      sx: { height: "100%", display: "flex", flexDirection: "column" }
    },
    isLoading ? React66.createElement(LinearProgress_default, null) : null,
    React66.createElement(Box_default2, { sx: { flex: 1, minHeight: 0, overflow: "auto" } }, error ? React66.createElement(ErrorAlert, { sx: { m: 2 }, error }) : children)
  );
}
var HTTP_METHODS = ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS"];
var QUERY_SCOPE_META = {
  parameters: {
    description: "Parameters that can be bound to app scope variables"
  }
};
var ButtonLink = styled_default("button")(({ theme: theme3 }) => ({
  background: "none",
  border: "none",
  fontSize: "inherit",
  padding: 0,
  color: theme3.palette.primary.main,
  textDecoration: "underline"
}));
function UrlControl({ label, disabled, baseUrl, value, onChange }) {
  const handleChange = React67.useCallback(
    (event) => {
      onChange(event.target.value);
    },
    [onChange]
  );
  return React67.createElement(
    TextField_default,
    {
      fullWidth: true,
      value: value ?? "",
      disabled,
      onChange: handleChange,
      label,
      slotProps: {
        input: baseUrl ? {
          startAdornment: React67.createElement(InputAdornment_default, { position: "start" }, baseUrl)
        } : void 0
      }
    }
  );
}
function withDefaults(value) {
  return {
    baseUrl: "",
    headers: [],
    authentication: null,
    ...value
  };
}
function ConnectionParamsInput({ value, onChange }) {
  const { handleSubmit, register, formState, reset, control, watch } = useForm({
    defaultValues: withDefaults(value),
    reValidateMode: "onChange",
    mode: "all"
  });
  React67.useEffect(() => reset(withDefaults(value)), [reset, value]);
  const doSubmit = handleSubmit(
    (connectionParams) => onChange({
      ...connectionParams,
      baseUrl: connectionParams.baseUrl && parseBaseUrl(connectionParams.baseUrl).href
    })
  );
  const baseUrlValue = watch("baseUrl");
  const headersValue = watch("headers");
  const authenticationValue = watch("authentication");
  const authenticationHeaders = getAuthenticationHeaders(authenticationValue);
  const mustHaveBaseUrl = headersValue && headersValue.length > 0 || !!authenticationValue;
  const headersAllowed = !!baseUrlValue;
  const baseUrlInputProps = {
    label: "base url",
    ...register("baseUrl", {
      validate(input) {
        if (!input) {
          if (mustHaveBaseUrl) {
            return "A base url is required when headers are used";
          }
          return true;
        }
        try {
          return !!parseBaseUrl(input);
        } catch (error) {
          return "Must be an absolute url";
        }
      }
    }),
    ...validation(formState, "baseUrl")
  };
  return React67.createElement(Stack_default, { direction: "column", gap: 3, sx: { py: 3 } }, React67.createElement(TextField_default, { ...baseUrlInputProps }), React67.createElement(Typography_default, null, "Headers:"), React67.createElement(
    Controller,
    {
      name: "headers",
      control,
      render: ({ field: { value: fieldValue = [], onChange: onFieldChange, ref, ...field } }) => {
        const allHeaders = [...authenticationHeaders, ...fieldValue];
        return React67.createElement(
          MapEntriesEditor,
          {
            ...field,
            disabled: !headersAllowed,
            fieldLabel: "header",
            value: allHeaders,
            onChange: (headers) => onFieldChange(headers.slice(authenticationHeaders.length)),
            isEntryDisabled: (entry, index) => index < authenticationHeaders.length
          }
        );
      }
    }
  ), React67.createElement(Typography_default, null, "Authentication:"), React67.createElement(
    Controller,
    {
      name: "authentication",
      control,
      render: ({ field: { value: fieldValue, ref, ...field } }) => React67.createElement(AuthenticationEditor, { ...field, disabled: !headersAllowed, value: fieldValue ?? null })
    }
  ), React67.createElement(Toolbar_default, { disableGutters: true }, React67.createElement(Box_default2, { sx: { flex: 1 } }), React67.createElement(Button_default, { variant: "contained", onClick: doSubmit, disabled: isSaveDisabled(formState) }, "Save")));
}
function ResolvedPreview({
  preview,
  onShowTransform
}) {
  if (!preview) {
    return React67.createElement(
      Alert_default,
      {
        severity: "info",
        sx: (theme3) => ({
          my: theme3.spacing(2),
          mx: "auto",
          p: theme3.spacing(1),
          fontSize: theme3.typography.pxToRem(11),
          width: "fit-content"
        })
      },
      "No request has been sent yet. ",
      React67.createElement("br", null),
      "Click Run",
      React67.createElement(
        PlayArrow_default,
        {
          "aria-label": "Run preview",
          sx: { verticalAlign: "middle", fontSize: "12px", mr: 0.25 }
        }
      ),
      "to preview the response here."
    );
  }
  const { data, untransformedData } = preview;
  let alert = null;
  const responseDataKeys = Object.keys(untransformedData);
  if (typeof data === "undefined" && typeof untransformedData !== "undefined") {
    alert = React67.createElement(Alert_default, { severity: "warning", sx: { m: 1, p: 1, fontSize: 11 } }, React67.createElement(Box_default2, { sx: { mb: 1 } }, "Request successfully completed and returned data", responseDataKeys.length > 0 ? " with the following keys:" : "."), responseDataKeys.map((key2) => React67.createElement(Box_default2, { sx: { display: "block" }, key: key2 }, "- ", key2)), React67.createElement(Box_default2, { sx: { mt: 1 } }, "However, it seems that the ", React67.createElement(ButtonLink, { onClick: onShowTransform }, "transform"), " ", "function returned an ", React67.createElement("code", null, "undefined"), " value."));
  }
  return React67.createElement(React67.Fragment, null, alert, React67.createElement(JsonView, { sx: { height: "100%" }, src: preview == null ? void 0 : preview.data }));
}
var EMPTY_PARAMS = [];
function QueryEditor({
  globalScope,
  globalScopeMeta,
  connectionParams: rawConnectionParams,
  value: input,
  settingsTab
}) {
  var _a, _b, _c;
  const appStateApi = useAppStateApi();
  const { currentView } = useAppState();
  const isBrowserSide = input.attributes.query.browser;
  const connectionParams = isBrowserSide ? null : rawConnectionParams;
  const baseUrl = isBrowserSide ? null : (connectionParams == null ? void 0 : connectionParams.baseUrl) ?? null;
  const urlValue = input.attributes.query.url ?? "";
  const introspection = usePrivateQuery(
    {
      kind: "introspection"
    },
    { retry: false }
  );
  const updateProp = React67.useCallback(
    function updateProp2(prop, value) {
      appStateApi.updateQueryDraft((draft) => ({
        ...draft,
        attributes: {
          ...draft.attributes,
          query: {
            ...draft.attributes.query,
            [prop]: value
          }
        }
      }));
    },
    [appStateApi]
  );
  const env = React67.useMemo(() => {
    var _a2;
    return ((_a2 = introspection == null ? void 0 : introspection.data) == null ? void 0 : _a2.env) ?? {};
  }, [(_a = introspection == null ? void 0 : introspection.data) == null ? void 0 : _a.env]);
  const declaredEnvKeys = React67.useMemo(
    () => {
      var _a2;
      return ((_a2 = introspection == null ? void 0 : introspection.data) == null ? void 0 : _a2.declaredEnvKeys) ?? [];
    },
    [(_b = introspection == null ? void 0 : introspection.data) == null ? void 0 : _b.declaredEnvKeys]
  );
  const handleParamsChange = React67.useCallback(
    (newParams) => {
      appStateApi.updateQueryDraft((draft) => ({
        ...draft,
        params: newParams
      }));
    },
    [appStateApi]
  );
  const handleUrlChange = React67.useCallback(
    (newUrl) => {
      updateProp("url", newUrl ?? "");
    },
    [updateProp]
  );
  const handleMethodChange = React67.useCallback(
    (event) => {
      updateProp("method", event.target.value);
    },
    [updateProp]
  );
  const handleTransformEnabledChange = React67.useCallback(
    (transformEnabled) => {
      updateProp("transformEnabled", transformEnabled);
    },
    [updateProp]
  );
  const handleTransformChange = React67.useCallback(
    (transform) => {
      updateProp("transform", transform);
    },
    [updateProp]
  );
  const handleBodyChange = React67.useCallback(
    (newBody) => {
      updateProp("body", newBody || void 0);
    },
    [updateProp]
  );
  const handleSearchParamsChange = React67.useCallback(
    (newSearchParams) => {
      updateProp("searchParams", newSearchParams);
    },
    [updateProp]
  );
  const handleHeadersChange = React67.useCallback(
    (newHeaders) => {
      updateProp("headers", newHeaders);
    },
    [updateProp]
  );
  const handleResponseTypeChange = React67.useCallback(
    (event) => {
      updateProp("response", {
        kind: event.target.value
      });
    },
    [updateProp]
  );
  const paramsEntries = input.params || EMPTY_PARAMS;
  const jsServerRuntime = React67.useMemo(() => createServerJsRuntime(env ?? {}), [env]);
  const paramsEditorLiveValue = useEvaluateLiveBindingEntries({
    jsRuntime: jsServerRuntime,
    input: paramsEntries,
    globalScope
  });
  const previewParams = React67.useMemo(
    () => Object.fromEntries(paramsEditorLiveValue.map(([key2, binding]) => [key2, binding == null ? void 0 : binding.value])),
    [paramsEditorLiveValue]
  );
  const queryScope = React67.useMemo(
    () => ({
      parameters: previewParams
    }),
    [previewParams]
  );
  const liveUrl = useEvaluateLiveBinding({
    jsRuntime: jsServerRuntime,
    input: urlValue,
    globalScope: queryScope
  });
  const liveSearchParams = useEvaluateLiveBindingEntries({
    jsRuntime: jsServerRuntime,
    input: input.attributes.query.searchParams || [],
    globalScope: queryScope
  });
  const liveHeaders = useEvaluateLiveBindingEntries({
    jsRuntime: jsServerRuntime,
    input: input.attributes.query.headers || [],
    globalScope: queryScope
  });
  const [configTab, setConfigTab] = React67.useState("urlQuery");
  const currentTab = React67.useMemo(() => {
    var _a2, _b2, _c2, _d, _e2;
    if (currentView.kind === "page" && ((_a2 = currentView.view) == null ? void 0 : _a2.kind) === "query" && ((_b2 = currentView.queryPanel) == null ? void 0 : _b2.currentTabIndex) !== void 0) {
      return (_e2 = (_c2 = currentView.queryPanel) == null ? void 0 : _c2.queryTabs) == null ? void 0 : _e2[(_d = currentView.queryPanel) == null ? void 0 : _d.currentTabIndex];
    }
    return null;
  }, [currentView]);
  const handleToolsTabTypeChange = React67.useCallback(
    (value) => {
      appStateApi.updateQueryTab((tab) => ({
        ...tab,
        toolsTabType: value
      }));
    },
    [appStateApi]
  );
  const fetchPrivate = useFetchPrivate();
  const fetchPreview = React67.useCallback(
    (query, params) => fetchPrivate({ kind: "debugExec", query, params }),
    [fetchPrivate]
  );
  const [previewHar, setPreviewHar] = React67.useState(() => createHarLog());
  const { preview, runPreview, isLoading } = useQueryPreview(
    fetchPreview,
    input.attributes.query,
    previewParams,
    {
      onPreview: React67.useCallback((result) => {
        setPreviewHar(
          (existing) => result.har ? mergeHar(createHarLog(), existing, result.har) : existing
        );
      }, [])
    }
  );
  const handleHarClear = React67.useCallback(() => setPreviewHar(createHarLog()), []);
  const handleConfigTabChange = React67.useCallback(
    (event, newValue) => setConfigTab(newValue),
    []
  );
  const handleTabTypeChange = React67.useCallback(
    (event, value) => {
      appStateApi.updateQueryTab((tab) => ({
        ...tab,
        tabType: value
      }));
    },
    [appStateApi]
  );
  return currentTab ? React67.createElement(resizablePanels_exports.PanelGroup, { autoSaveId: "toolpad/rest-panel", direction: "horizontal" }, React67.createElement(resizablePanels_exports.Panel, { id: "rest-query-left", defaultSize: 50, minSize: 40, style: { overflow: "auto" } }, React67.createElement(TabContext, { value: (currentTab == null ? void 0 : currentTab.tabType) ?? "config" }, React67.createElement(Stack_default, { direction: "column", gap: 0 }, React67.createElement(
    Stack_default,
    {
      direction: "row",
      sx: {
        display: "flex",
        justifyContent: "space-between",
        alignItems: "center",
        pr: 0.5
      }
    },
    React67.createElement(
      TabList_default,
      {
        sx: { "& button": { fontSize: 12, fontWeight: "normal" } },
        onChange: handleTabTypeChange,
        "aria-label": "Query editor active tab type"
      },
      React67.createElement(Tab_default, { label: "Config", value: "config" }),
      React67.createElement(Tab_default, { label: "Settings", value: "settings" })
    ),
    React67.createElement(
      HelpTooltipIcon,
      {
        helpText: React67.createElement(Typography_default, { variant: "inherit" }, "To configure a HTTP request, check out the", " ", React67.createElement(
          Link_default,
          {
            href: "https://mui.com/toolpad/studio/concepts/http-requests/",
            target: "_blank",
            rel: "noopener"
          },
          "docs"
        ), ".")
      }
    )
  ), React67.createElement(Divider_default, null), React67.createElement(TabPanel_default2, { value: "config", disableGutters: true }, React67.createElement(React67.Fragment, null, React67.createElement(
    Box_default2,
    {
      sx: {
        display: "grid",
        gridTemplateColumns: "auto 1fr 0.1fr",
        gap: 1,
        my: 1.5,
        ml: 1
      }
    },
    React67.createElement(
      TextField_default,
      {
        select: true,
        value: input.attributes.query.method || "GET",
        size: "small",
        sx: {
          "& .MuiSelect-select": {
            height: (theme3) => theme3.typography.pxToRem(20)
          }
        },
        onChange: handleMethodChange,
        slotProps: {
          htmlInput: { sx: { fontSize: 12 } }
        }
      },
      HTTP_METHODS.map((method) => React67.createElement(MenuItem_default, { key: method, value: method }, method))
    ),
    React67.createElement(
      BindableEditor,
      {
        liveBinding: liveUrl,
        globalScope: queryScope,
        globalScopeMeta: QUERY_SCOPE_META,
        sx: { flex: 1 },
        jsRuntime: jsServerRuntime,
        label: "url",
        propType: { type: "string" },
        renderControl: (props2) => React67.createElement(UrlControl, { baseUrl, ...props2 }),
        value: urlValue,
        onChange: handleUrlChange
      }
    )
  ), React67.createElement(Box_default2, { sx: { display: "flex", flexDirection: "column", gap: 1, mt: 2.5, mx: 0 } }, React67.createElement(TabContext, { value: configTab }, React67.createElement(Box_default2, { sx: { border: 1, borderColor: "divider" } }, React67.createElement(
    TabList_default,
    {
      sx: { "& button": { fontSize: 12, fontWeight: "normal" } },
      onChange: handleConfigTabChange,
      "aria-label": "Fetch options active tab"
    },
    React67.createElement(Tab_default, { label: "URL query", value: "urlQuery" }),
    React67.createElement(Tab_default, { label: "Body", value: "body" }),
    React67.createElement(Tab_default, { label: "Headers", value: "headers" }),
    React67.createElement(Tab_default, { label: "Response", value: "response" }),
    React67.createElement(Tab_default, { label: "Transform", value: "transform" })
  )), React67.createElement(TabPanel_default2, { disableGutters: true, value: "urlQuery", sx: { ml: 1 } }, React67.createElement(
    ParametersEditor,
    {
      value: input.attributes.query.searchParams ?? [],
      onChange: handleSearchParamsChange,
      globalScope: queryScope,
      globalScopeMeta: QUERY_SCOPE_META,
      liveValue: liveSearchParams,
      jsRuntime: jsServerRuntime
    }
  )), React67.createElement(TabPanel_default2, { disableGutters: true, value: "body", sx: { ml: 1 } }, React67.createElement(
    BodyEditor,
    {
      value: input.attributes.query.body,
      onChange: handleBodyChange,
      globalScope: queryScope,
      globalScopeMeta: QUERY_SCOPE_META,
      method: input.attributes.query.method || "GET"
    }
  )), React67.createElement(TabPanel_default2, { disableGutters: true, value: "headers", sx: { ml: 1 } }, React67.createElement(
    ParametersEditor,
    {
      value: input.attributes.query.headers ?? [],
      onChange: handleHeadersChange,
      globalScope: queryScope,
      globalScopeMeta: QUERY_SCOPE_META,
      liveValue: liveHeaders,
      jsRuntime: jsServerRuntime,
      env
    }
  )), React67.createElement(TabPanel_default2, { disableGutters: true, value: "response", sx: { ml: 1 } }, React67.createElement(
    TextField_default,
    {
      select: true,
      label: "response type",
      sx: {
        [`& .${inputLabelClasses_default.root}`]: { fontSize: 12 },
        [`& .${inputBaseClasses_default.root}`]: { fontSize: 12 },
        width: 200
      },
      value: ((_c = input.attributes.query.response) == null ? void 0 : _c.kind) || "json",
      onChange: handleResponseTypeChange
    },
    React67.createElement(MenuItem_default, { value: "raw" }, "raw"),
    React67.createElement(MenuItem_default, { value: "json" }, "JSON"),
    React67.createElement(MenuItem_default, { value: "csv", disabled: true }, "🚧 CSV"),
    React67.createElement(MenuItem_default, { value: "xml", disabled: true }, "🚧 XML")
  )), React67.createElement(TabPanel_default2, { disableGutters: true, value: "transform", sx: { ml: 1 } }, React67.createElement(
    TransformInput,
    {
      value: input.attributes.query.transform ?? "return data;",
      onChange: handleTransformChange,
      enabled: input.attributes.query.transformEnabled ?? false,
      onEnabledChange: handleTransformEnabledChange,
      globalScope: { data: preview == null ? void 0 : preview.untransformedData },
      loading: false
    }
  )))))), React67.createElement(TabPanel_default2, { value: "settings", disableGutters: true }, settingsTab)))), React67.createElement(PanelResizeHandle2, null), React67.createElement(resizablePanels_exports.Panel, { id: "rest-query-right", defaultSize: 50, minSize: 20 }, React67.createElement(resizablePanels_exports.PanelGroup, { autoSaveId: "toolpad/rest/params-tools-split", direction: "vertical" }, React67.createElement(resizablePanels_exports.Panel, { defaultSize: 50, style: { overflow: "auto", scrollbarGutter: "stable" } }, React67.createElement(Box_default2, { display: "flex", flexDirection: "column" }, React67.createElement(TabContext, { value: "parameters" }, React67.createElement(
    TabList_default,
    {
      sx: {
        "& button": { fontSize: 12, fontWeight: "normal", cursor: "default" }
      },
      "aria-label": "Query editor parameters"
    },
    React67.createElement(Tab_default, { label: "Parameters", value: "parameters" })
  ), React67.createElement(Divider_default, { sx: { mb: 1.5 } }), React67.createElement(TabPanel_default2, { value: "parameters", disableGutters: true, sx: { ml: 1 } }, React67.createElement(
    ParametersEditor,
    {
      value: paramsEntries,
      onChange: handleParamsChange,
      globalScope,
      globalScopeMeta,
      liveValue: paramsEditorLiveValue,
      jsRuntime: jsServerRuntime,
      env,
      declaredEnvKeys
    }
  ))))), React67.createElement(PanelResizeHandle2, null), React67.createElement(resizablePanels_exports.Panel, { defaultSize: 50, style: { overflow: "auto", scrollbarGutter: "stable" } }, React67.createElement(TabContext, { value: currentTab.toolsTabType }, React67.createElement(
    Box_default2,
    {
      sx: {
        borderBottom: 1,
        borderColor: "divider",
        display: "flex",
        justifyContent: "space-between",
        height: 34
      }
    },
    React67.createElement(
      TabList_default,
      {
        sx: { "& button": { fontSize: 12, fontWeight: "normal" } },
        onChange: (event, value) => handleToolsTabTypeChange(value),
        "aria-label": "Query tools active tab"
      },
      React67.createElement(Tab_default, { label: "Preview", value: "preview" }),
      React67.createElement(Tab_default, { label: "Dev Tools", value: "devTools" })
    ),
    React67.createElement(
      LoadingButton_default,
      {
        variant: "text",
        size: "small",
        loading: isLoading,
        disabled: isLoading,
        onClick: runPreview,
        endIcon: React67.createElement(PlayArrow_default, { "aria-label": "Run preview", onClick: runPreview })
      },
      "Run"
    )
  ), React67.createElement(TabPanel_default2, { value: "preview", disableGutters: true }, React67.createElement(QueryPreview, { isLoading: currentTab.isPreviewLoading, error: preview == null ? void 0 : preview.error }, React67.createElement(
    ResolvedPreview,
    {
      preview,
      onShowTransform: () => setConfigTab("transform")
    }
  ))), React67.createElement(TabPanel_default2, { value: "devTools", disableGutters: true }, React67.createElement(Devtools, { sx: { overflow: "auto" }, har: previewHar, onHarClear: handleHarClear }))))))) : React67.createElement(Alert_default, { severity: "error" }, "An error occurred while rendering this tab. Please refresh and try again.");
}
function getInitialQueryValue() {
  return {
    method: "GET",
    url: "https://raw.githubusercontent.com/mui/toolpad/master/public/movies.json",
    headers: [],
    browser: false
  };
}
var dataSource = {
  displayName: "REST API",
  ConnectionParamsInput,
  QueryEditor,
  getInitialQueryValue,
  hasDefault: true
};
var client_default = dataSource;
var StyledAutocompletePopper = styled_default("div")(({ theme: theme3 }) => ({
  [`& .${autocompleteClasses_default.paper}`]: {
    boxShadow: "none",
    margin: 0,
    borderRadius: 0,
    color: "inherit",
    fontSize: 12
  },
  [`& .${autocompleteClasses_default.listbox}`]: {
    backgroundColor: theme3.palette.mode === "light" ? theme3.palette.background.paper : theme3.palette.primaryDark[900],
    padding: 0,
    [`& .${autocompleteClasses_default.option}`]: {
      minHeight: "auto",
      alignItems: "flex-start",
      padding: 8,
      borderBottom: `1px solid  ${theme3.palette.divider}`,
      [`&.${autocompleteClasses_default.focused}:not([aria-selected="true"])`]: {
        backgroundColor: theme3.palette.action.hover
      }
    }
  },
  [`&.${autocompleteClasses_default.popperDisablePortal}`]: {
    position: "relative"
  }
}));
function PopperComponent(props2) {
  const { disablePortal, anchorEl, open, ...other } = props2;
  return React68.createElement(StyledAutocompletePopper, { ...other });
}
var StyledPopper = styled_default(Popper_default)(({ theme: theme3 }) => ({
  border: `1px solid ${theme3.palette.divider}`,
  boxShadow: `0 8px 24px ${theme3.palette.mode === "light" ? alpha(theme3.palette.grey[800], 0.5) : alpha(theme3.palette.grey[700], 0.2)}`,
  borderRadius: 6,
  width: 300,
  zIndex: theme3.zIndex.modal,
  fontSize: 12,
  color: theme3.palette.mode === "light" ? theme3.palette.common.black : theme3.palette.grey[500],
  backgroundColor: theme3.palette.background.paper
}));
var StyledInput = styled_default(InputBase_default)(({ theme: theme3 }) => ({
  padding: 10,
  width: "100%",
  border: `1px solid ${theme3.palette.divider}`,
  "& input": {
    borderRadius: 4,
    backgroundColor: theme3.palette.background.paper,
    padding: 8,
    transition: theme3.transitions.create(["border-color", "box-shadow"]),
    border: `1px solid ${theme3.palette.divider}`,
    fontSize: 12,
    color: theme3.palette.mode === "light" ? theme3.palette.common.black : theme3.palette.grey[500],
    "&:focus": {
      boxShadow: `0px 0px 0px 3px ${theme3.palette.mode === "light" ? theme3.palette.primary[100] : theme3.palette.primaryDark[600]}`,
      borderColor: theme3.palette.mode === "light" ? theme3.palette.primary.main : theme3.palette.primaryDark.main
    }
  }
}));
var FunctionButton = styled_default(Chip_default)(({ theme: theme3 }) => ({
  fontSize: 12,
  width: "100%",
  fontFamily: theme3.typography.fontFamilyCode,
  marginTop: theme3.spacing(1),
  fontWeight: "normal",
  color: theme3.palette.primary.main,
  transition: theme3.transitions.create("color", { duration: theme3.transitions.duration.shorter }),
  "&:active": {
    boxShadow: "none"
  },
  "&:focus": {
    backgroundColor: theme3.palette.mode === "light" ? theme3.palette.primary[100] : theme3.palette.primaryDark[600]
  },
  "& svg": {
    width: 12,
    height: 12
  }
}));
var StyledListSubheader = styled_default(ListSubheader_default)(({ theme: theme3 }) => ({
  lineHeight: 2.5,
  fontSize: 13,
  fontFamily: theme3.typography.fontFamilyCode,
  backgroundColor: theme3.palette.mode === "light" ? theme3.palette.grey[200] : alpha(theme3.palette.grey[900], 0.5),
  borderRadius: 0,
  borderBottom: `1px solid ${theme3.palette.divider}`,
  color: theme3.palette.mode === "light" ? theme3.palette.grey[700] : theme3.palette.grey[500]
}));
function FunctionSelector({
  files,
  selectedFunctionId,
  onCreateNew,
  onSelect
}) {
  const [anchorEl, setAnchorEl] = React68.useState(null);
  const [inputValue, setInputValue] = React68.useState("");
  const { selectedFileName, selectedFunctionName } = React68.useMemo(() => {
    const parsed = parseLegacyFunctionId(selectedFunctionId ?? "");
    return {
      selectedFileName: parsed.file,
      selectedFunctionName: parsed.handler
    };
  }, [selectedFunctionId]);
  const selectedFunctionLabel = React68.useMemo(() => {
    if (selectedFunctionName) {
      return `${selectedFileName} > ${selectedFunctionName}`;
    }
    return "Select function";
  }, [selectedFileName, selectedFunctionName]);
  const options2 = React68.useMemo(() => {
    const functions = [];
    files.forEach((file) => {
      file.handlers.forEach((fn2) => {
        functions.push(serializeFunctionId({ file: file.name, handler: fn2.name }));
      });
    });
    return functions;
  }, [files]);
  const handleClick = React68.useCallback((event) => {
    setAnchorEl(event.currentTarget);
  }, []);
  const handleClose = React68.useCallback(() => {
    setAnchorEl(null);
  }, []);
  const open = Boolean(anchorEl);
  const id = open ? "function-selector" : void 0;
  const handleCreateNew = React68.useCallback(async () => {
    const functionId = await onCreateNew();
    onSelect(functionId);
  }, [onCreateNew, onSelect]);
  const handleInput = React68.useCallback((event) => {
    setInputValue(event.target.value);
  }, []);
  return React68.createElement(React68.Fragment, null, React68.createElement(
    FunctionButton,
    {
      "aria-describedby": id,
      clickable: true,
      icon: React68.createElement(DataObjectOutlined_default, { fontSize: "inherit", color: "inherit" }),
      onClick: handleClick,
      label: selectedFunctionLabel
    }
  ), React68.createElement(
    StyledPopper,
    {
      id,
      open,
      anchorEl,
      placement: "auto-start",
      popperOptions: { modifiers: [{ name: "flip", enabled: false }] }
    },
    React68.createElement(ClickAwayListener, { onClickAway: handleClose }, React68.createElement("div", null, React68.createElement(
      Box_default2,
      {
        sx: {
          px: 1,
          py: 0.5,
          fontWeight: "bold"
        }
      },
      "Search for functions"
    ), React68.createElement(
      Autocomplete_default,
      {
        open: true,
        onClose: (event, reason) => {
          if (reason === "escape") {
            handleClose();
          }
        },
        value: selectedFunctionId,
        inputValue,
        onInput: handleInput,
        onChange: (event, newValue, reason) => {
          if (event.type === "keydown" && event.key === "Backspace" && reason === "removeOption") {
            return;
          }
          if (newValue) {
            onSelect(newValue);
          }
          handleClose();
        },
        PopperComponent,
        renderTags: () => null,
        noOptionsText: "No functions",
        groupBy: (option) => parseLegacyFunctionId(option).file ?? "",
        renderGroup: (params) => [
          React68.createElement(StyledListSubheader, { key: params.key }, React68.createElement(Stack_default, { direction: "row", justifyContent: "space-between" }, params.group, React68.createElement(
            OpenCodeEditorButton,
            {
              filePath: params.group,
              fileType: "resource",
              iconButton: true,
              disableRipple: true,
              sx: {
                transition: (theme3) => theme3.transitions.create("color", { duration: 200 }),
                "&:hover": {
                  color: (theme3) => theme3.palette.mode === "light" ? theme3.palette.grey[800] : theme3.palette.grey[300]
                }
              }
            }
          ))),
          params.children
        ],
        renderOption: (props2, option, { selected }) => React68.createElement("li", { ...props2 }, React68.createElement(
          Box_default2,
          {
            component: Done_default,
            sx: {
              width: 17,
              height: 17,
              ml: 1,
              mr: -1,
              mt: 0,
              opacity: 0.75,
              color: selected ? "primary.main" : "text.primary"
            },
            style: {
              visibility: selected ? "visible" : "hidden"
            }
          }
        ), React68.createElement(
          Box_default2,
          {
            component: "span",
            sx: {
              width: 12,
              height: 12,
              flexShrink: 0,
              mr: 1,
              mt: 1
            }
          }
        ), React68.createElement(
          Box_default2,
          {
            sx: {
              flexGrow: 1,
              color: selected ? "primary.main" : "text.primary",
              fontFamily: (theme3) => theme3.typography.fontFamilyCode
            }
          },
          parseLegacyFunctionId(option).handler ?? ""
        )),
        options: options2.sort((a, b2) => {
          if (selectedFunctionId === a) {
            return -1;
          }
          if (selectedFunctionId === b2) {
            return 1;
          }
          const fa = parseLegacyFunctionId(a).file;
          const fb = parseLegacyFunctionId(b2).file;
          const sf = parseLegacyFunctionId(selectedFunctionId ?? "").file;
          if (sf === fa) {
            if (fa === fb) {
              return a.localeCompare(b2);
            }
            return -1;
          }
          if (sf === fb) {
            return 1;
          }
          return (fa == null ? void 0 : fa.localeCompare(fb ?? "")) ?? 0;
        }),
        renderInput: (params) => React68.createElement(
          StyledInput,
          {
            ref: params.InputProps.ref,
            inputProps: params.inputProps,
            placeholder: "Filter functions",
            autoFocus: true
          }
        )
      }
    ), React68.createElement(
      Button_default,
      {
        sx: { m: 1, mb: 0.5 },
        startIcon: React68.createElement(AddOutlined_default, { fontSize: "inherit" }),
        onClick: handleCreateNew
      },
      "New file"
    )))
  ));
}
var EMPTY_PARAMS2 = [];
function ResolvedPreview2({ preview }) {
  if (!preview) {
    return React69.createElement(
      Alert_default,
      {
        severity: "info",
        sx: (theme3) => ({
          my: theme3.spacing(2),
          mx: "auto",
          p: theme3.spacing(1),
          fontSize: theme3.typography.pxToRem(11),
          width: "fit-content"
        })
      },
      "No request has been sent yet. ",
      React69.createElement("br", null),
      "Click Run",
      React69.createElement(
        PlayArrow_default,
        {
          "aria-label": "Run preview",
          sx: { verticalAlign: "middle", fontSize: "12px", mr: 0.25 }
        }
      ),
      "to preview the response here."
    );
  }
  const { data } = preview;
  return React69.createElement(JsonView, { sx: { height: "100%" }, src: data, copyToClipboard: true });
}
function QueryEditor2({
  globalScope,
  globalScopeMeta,
  value: input,
  settingsTab,
  execApi
}) {
  var _a, _b, _c;
  const appStateApi = useAppStateApi();
  const { currentView } = useAppState();
  const introspection = useQuery({
    queryKey: ["introspection"],
    queryFn: () => execApi("introspection", []),
    retry: false
  });
  const updateProp = React69.useCallback(
    function updateProp2(prop, value) {
      appStateApi.updateQueryDraft((draft) => ({
        ...draft,
        attributes: {
          ...draft.attributes,
          query: {
            ...draft.attributes.query,
            [prop]: value
          }
        }
      }));
    },
    [appStateApi]
  );
  const currentTab = React69.useMemo(() => {
    var _a2, _b2, _c2, _d, _e2;
    if (currentView.kind === "page" && ((_a2 = currentView.view) == null ? void 0 : _a2.kind) === "query" && ((_b2 = currentView.queryPanel) == null ? void 0 : _b2.currentTabIndex) !== void 0) {
      return (_e2 = (_c2 = currentView.queryPanel) == null ? void 0 : _c2.queryTabs) == null ? void 0 : _e2[(_d = currentView.queryPanel) == null ? void 0 : _d.currentTabIndex];
    }
    return null;
  }, [currentView]);
  const propTypeControls = usePropControlsContext();
  const { file: selectedFile = void 0, handler: selectedFunction = void 0 } = input.attributes.query.function ? parseLegacyFunctionId(input.attributes.query.function) : {};
  const selectedOption = React69.useMemo(() => {
    var _a2, _b2;
    return (_b2 = (_a2 = introspection.data) == null ? void 0 : _a2.files.find((file) => file.name === selectedFile)) == null ? void 0 : _b2.handlers.find((handler) => handler.name === selectedFunction);
  }, [(_a = introspection.data) == null ? void 0 : _a.files, selectedFile, selectedFunction]);
  const parameterDefs = React69.useMemo(
    () => Object.fromEntries((selectedOption == null ? void 0 : selectedOption.parameters) || []),
    [selectedOption == null ? void 0 : selectedOption.parameters]
  );
  const paramsEntries = React69.useMemo(
    () => {
      var _a2;
      return ((_a2 = input.params) == null ? void 0 : _a2.filter(([key2]) => !!parameterDefs[key2])) || EMPTY_PARAMS2;
    },
    [input.params, parameterDefs]
  );
  const paramsObject = Object.fromEntries(paramsEntries);
  const jsBrowserRuntime = useBrowserJsRuntime();
  const paramsEditorLiveValue = useEvaluateLiveBindingEntries({
    jsRuntime: jsBrowserRuntime,
    input: paramsEntries,
    globalScope
  });
  const previewParams = React69.useMemo(
    () => Object.fromEntries(paramsEditorLiveValue.map(([key2, binding]) => [key2, binding == null ? void 0 : binding.value])),
    [paramsEditorLiveValue]
  );
  const handleToolsTabTypeChange = React69.useCallback(
    (value) => {
      appStateApi.updateQueryTab((tab) => ({
        ...tab,
        toolsTabType: value
      }));
    },
    [appStateApi]
  );
  const fetchServerPreview = React69.useCallback(
    async (query, params) => {
      return execApi("debugExec", [query, params]);
    },
    [execApi]
  );
  const { preview, runPreview, isLoading } = useQueryPreview(
    fetchServerPreview,
    input.attributes.query,
    previewParams
  );
  const handleRunPreview = React69.useCallback(() => {
    runPreview();
  }, [runPreview]);
  React69.useEffect(() => {
    appStateApi.updateQueryTab((tab) => ({
      ...tab,
      previewHandler: handleRunPreview,
      isPreviewLoading: isLoading
    }));
  }, [handleRunPreview, appStateApi, isLoading]);
  const liveBindings = useEvaluateLiveBindings({
    jsRuntime: jsBrowserRuntime,
    input: paramsObject,
    globalScope
  });
  const handleSelectFunction = React69.useCallback(
    (functionId) => {
      updateProp("function", functionId);
    },
    [updateProp]
  );
  const proposedFileName = React69.useMemo(() => {
    var _a2;
    const existingNames = new Set(((_a2 = introspection.data) == null ? void 0 : _a2.files.map((file) => file.name)) || []);
    const baseName = "functions";
    let counter2 = 2;
    while (existingNames.has(`${baseName}${counter2}.ts`)) {
      counter2 += 1;
    }
    return `${baseName}${counter2}.ts`;
  }, [(_b = introspection.data) == null ? void 0 : _b.files]);
  const handleCreateNewCommit = React69.useCallback(async () => {
    try {
      await execApi("createNew", [proposedFileName]);
      await introspection.refetch();
    } catch (error) {
      console.error(errorFrom(error).message);
    }
    return serializeFunctionId({ file: proposedFileName, handler: "default" });
  }, [execApi, introspection, proposedFileName]);
  const handleTabTypeChange = React69.useCallback(
    (value) => {
      appStateApi.updateQueryTab((tab) => ({
        ...tab,
        tabType: value
      }));
    },
    [appStateApi]
  );
  return currentTab ? React69.createElement(resizablePanels_exports.PanelGroup, { autoSaveId: "toolpad/local-panel", direction: "horizontal" }, React69.createElement(
    resizablePanels_exports.Panel,
    {
      defaultSize: 50,
      minSize: 40,
      style: { overflow: "auto", scrollbarGutter: "stable" },
      id: "local-query-left"
    },
    React69.createElement(TabContext, { value: (currentTab == null ? void 0 : currentTab.tabType) ?? "config" }, React69.createElement(Stack_default, { direction: "column", gap: 0 }, React69.createElement(
      Stack_default,
      {
        direction: "row",
        sx: {
          display: "flex",
          justifyContent: "space-between",
          alignItems: "center",
          pr: 0.5
        }
      },
      React69.createElement(
        TabList_default,
        {
          sx: { "& button": { fontSize: 12, fontWeight: "normal" } },
          onChange: (event, value) => handleTabTypeChange(value),
          "aria-label": "Query editor active tab type"
        },
        React69.createElement(Tab_default, { label: "Config", value: "config" }),
        React69.createElement(Tab_default, { label: "Settings", value: "settings" })
      ),
      React69.createElement(
        HelpTooltipIcon,
        {
          helpText: React69.createElement(Typography_default, { variant: "inherit" }, "To configure a custom function, check out the", " ", React69.createElement(
            Link_default,
            {
              href: "https://mui.com/toolpad/studio/concepts/custom-functions/",
              target: "_blank",
              rel: "noopener"
            },
            "docs"
          ), ".")
        }
      )
    ), React69.createElement(Divider_default, null), React69.createElement(TabPanel_default2, { value: "config", disableGutters: true }, React69.createElement(
      Stack_default,
      {
        display: "flex",
        flexDirection: "row",
        sx: {
          alignItems: "flex-start",
          mt: 2,
          mx: 2
        }
      },
      React69.createElement(
        FunctionSelector,
        {
          files: ((_c = introspection.data) == null ? void 0 : _c.files) || [],
          selectedFunctionId: transformLegacyFunctionId(
            input.attributes.query.function || ""
          ),
          onCreateNew: handleCreateNewCommit,
          onSelect: handleSelectFunction
        }
      ),
      React69.createElement(
        OpenCodeEditorButton,
        {
          filePath: selectedFile ?? "",
          fileType: "resource",
          disableRipple: true,
          disabled: !selectedFile,
          sx: (theme3) => ({
            marginTop: theme3.spacing(1),
            marginLeft: theme3.spacing(1),
            border: "1px solid",
            borderColor: theme3.palette.divider
          })
        }
      ),
      introspection.error ? React69.createElement(
        Box_default2,
        {
          sx: {
            position: "absolute",
            inset: "0 0 0 0",
            display: "flex",
            justifyContent: "center",
            alignItems: "center"
          }
        },
        errorFrom(introspection.error).message
      ) : null
    )), React69.createElement(TabPanel_default2, { value: "settings", disableGutters: true }, settingsTab)))
  ), React69.createElement(PanelResizeHandle2, null), React69.createElement(resizablePanels_exports.Panel, { id: "local-query-right", defaultSize: 50, minSize: 20 }, React69.createElement(resizablePanels_exports.PanelGroup, { autoSaveId: "toolpad/local/params-tools-split", direction: "vertical" }, React69.createElement(
    resizablePanels_exports.Panel,
    {
      id: "parameters-editor",
      defaultSize: 50,
      style: { overflow: "auto", scrollbarGutter: "stable" }
    },
    React69.createElement(Box_default2, { display: "flex", flexDirection: "column" }, React69.createElement(TabContext, { value: "parameters" }, React69.createElement(
      TabList_default,
      {
        sx: {
          "& button": { fontSize: 12, fontWeight: "normal", cursor: "default" }
        },
        "aria-label": "Query editor parameters"
      },
      React69.createElement(Tab_default, { label: "Parameters", value: "parameters" })
    ), React69.createElement(Divider_default, { sx: { mb: 1.5 } }), React69.createElement(TabPanel_default2, { value: "parameters", disableGutters: true, sx: { ml: 1 } }, React69.createElement(Grid2_default, { container: true, spacing: 1 }, Object.entries(parameterDefs).map(([name, definiton]) => {
      const Control = getDefaultControl(propTypeControls, definiton, liveBindings);
      if (!Control) {
        return React69.createElement(Grid2_default, { size: 4, key: name, sx: { display: "flex", alignItems: "center" } }, React69.createElement(Typography_default, null, "Can't configure ", name));
      }
      return React69.createElement(Grid2_default, { size: 4, key: name }, React69.createElement(
        BindableEditor,
        {
          liveBinding: liveBindings[name],
          globalScope,
          globalScopeMeta,
          label: name,
          propType: definiton,
          jsRuntime: jsBrowserRuntime,
          renderControl: (renderControlParams) => React69.createElement(Control, { ...renderControlParams, propType: definiton }),
          value: paramsObject[name],
          onChange: (newValue) => {
            const paramKeys = Object.keys(parameterDefs);
            const newParams = paramKeys.flatMap((key2) => {
              const paramValue = key2 === name ? newValue : paramsObject[key2];
              return paramValue ? [[key2, paramValue]] : [];
            });
            appStateApi.updateQueryDraft((draft) => ({
              ...draft,
              params: newParams
            }));
          }
        }
      ));
    })))))
  ), React69.createElement(PanelResizeHandle2, null), React69.createElement(
    resizablePanels_exports.Panel,
    {
      id: "preview",
      defaultSize: 50,
      style: { overflow: "auto", scrollbarGutter: "stable" }
    },
    React69.createElement(TabContext, { value: currentTab.toolsTabType }, React69.createElement(
      Box_default2,
      {
        sx: {
          borderBottom: 1,
          borderColor: "divider",
          display: "flex",
          height: 32,
          justifyContent: "space-between"
        }
      },
      React69.createElement(
        TabList_default,
        {
          sx: { "& button": { fontSize: 12, fontWeight: "normal" } },
          onChange: (event, value) => handleToolsTabTypeChange(value),
          "aria-label": "Query tools active tab"
        },
        React69.createElement(Tab_default, { label: "Preview", value: "preview" })
      ),
      React69.createElement(
        LoadingButton_default,
        {
          variant: "text",
          size: "small",
          loading: isLoading,
          disabled: isLoading,
          onClick: runPreview,
          endIcon: React69.createElement(PlayArrow_default, { "aria-label": "Run preview", onClick: runPreview })
        },
        "Run"
      )
    ), React69.createElement(TabPanel_default2, { value: "preview", disableGutters: true }, React69.createElement(QueryPreview, { isLoading: currentTab.isPreviewLoading, error: preview == null ? void 0 : preview.error }, React69.createElement(ResolvedPreview2, { preview }))))
  )))) : React69.createElement(Alert_default, { severity: "error" }, "An error occurred while rendering this tab. Please refresh and try again.");
}
function getInitialQueryValue2() {
  return {};
}
var dataSource2 = {
  displayName: "Custom",
  QueryEditor: QueryEditor2,
  getInitialQueryValue: getInitialQueryValue2,
  hasDefault: true
};
var client_default2 = dataSource2;
var dataSources = {
  rest: client_default,
  local: client_default2
};
var client_default3 = dataSources;
function refetchIntervalInSeconds(maybeInterval) {
  if (typeof maybeInterval !== "number") {
    return void 0;
  }
  const seconds = Math.floor(maybeInterval / 1e3);
  return seconds > 0 ? seconds : void 0;
}
function QuerySettingsTab({
  draft,
  liveEnabled,
  pageState,
  globalScopeMeta,
  jsBrowserRuntime
}) {
  var _a, _b, _c, _d;
  const appStateApi = useAppStateApi();
  const updateAttribute = React70.useCallback(
    function updateAttribute2(attrName, attrValue) {
      appStateApi.updateQueryDraft((node) => ({
        ...node,
        attributes: {
          ...node.attributes,
          [attrName]: attrValue
        }
      }));
    },
    [appStateApi]
  );
  const handleModeChange = React70.useCallback(
    (event) => {
      if (event.target.value === "mutation" || event.target.value === "query") {
        updateAttribute("mode", event.target.value);
      }
    },
    [updateAttribute]
  );
  const handleEnabledChange = React70.useCallback(
    (newValue) => {
      if (newValue !== null) {
        updateAttribute("enabled", newValue);
      }
    },
    [updateAttribute]
  );
  const handleRefetchIntervalChange = React70.useCallback(
    (event) => {
      const interval = Number(event.target.value);
      if (!Number.isNaN(interval) && interval > 0) {
        updateAttribute("refetchInterval", interval * 1e3);
      }
    },
    [updateAttribute]
  );
  return React70.createElement(
    Box_default2,
    {
      display: "flex",
      flexDirection: "column",
      sx: {
        p: 0.25,
        mt: 1,
        ml: 1,
        mr: 1
      }
    },
    React70.createElement(
      Stack_default,
      {
        display: "grid",
        gridTemplateRows: "1fr 1fr 1fr",
        gridTemplateColumns: "0.45fr 1fr",
        rowGap: 0.5
      },
      React70.createElement(Typography_default, { fontSize: 12, sx: { alignSelf: "center" } }, "Set query mode:"),
      React70.createElement(
        TextField_default,
        {
          select: true,
          label: "mode",
          value: ((_a = draft == null ? void 0 : draft.attributes) == null ? void 0 : _a.mode) ?? "query",
          onChange: handleModeChange,
          sx: {
            [`& .${inputLabelClasses_default.root}`]: { fontSize: 12 },
            [`& .${inputBaseClasses_default.root}`]: { fontSize: 12 }
          }
        },
        React70.createElement(MenuItem_default, { value: "query" }, "Fetch at any time to always be available on the page"),
        React70.createElement(MenuItem_default, { value: "mutation" }, "Only fetch on manual action")
      ),
      ((_b = draft == null ? void 0 : draft.attributes) == null ? void 0 : _b.mode) !== "mutation" ? React70.createElement(React70.Fragment, null, React70.createElement(Typography_default, { fontSize: 12, sx: { alignSelf: "center" } }, "Set refetch interval:"), React70.createElement(
        TextField_default,
        {
          sx: {
            [`& .${inputLabelClasses_default.root}`]: { fontSize: 12 },
            [`& .${inputBaseClasses_default.root}`]: { fontSize: 12 },
            maxWidth: 200
          },
          type: "number",
          label: "Refetch interval",
          value: refetchIntervalInSeconds((_c = draft == null ? void 0 : draft.attributes) == null ? void 0 : _c.refetchInterval) ?? "",
          onChange: handleRefetchIntervalChange,
          slotProps: {
            input: {
              startAdornment: React70.createElement(InputAdornment_default, { position: "start" }, "s")
            }
          }
        }
      ), React70.createElement(Typography_default, { fontSize: 12, sx: { alignSelf: "center" } }, "Set query enabled/disabled:"), React70.createElement(
        BindableEditor,
        {
          liveBinding: liveEnabled,
          globalScope: pageState,
          globalScopeMeta,
          jsRuntime: jsBrowserRuntime,
          label: "Enabled",
          propType: { type: "boolean" },
          value: ((_d = draft == null ? void 0 : draft.attributes) == null ? void 0 : _d.enabled) ?? true,
          onChange: handleEnabledChange,
          sx: { maxWidth: 100 }
        }
      )) : null
    )
  );
}
function QueryEditorPanel({ draft, saved }) {
  var _a, _b, _c, _d, _e2, _f;
  const { dom } = useAppState();
  const projectApi = useProjectApi();
  const connectionId = deref(saved ? (_a = saved == null ? void 0 : saved.attributes) == null ? void 0 : _a.connectionId : (_b = draft == null ? void 0 : draft.attributes) == null ? void 0 : _b.connectionId) ?? null;
  const connection = connectionId ? getMaybeNode(dom, connectionId, "connection") : null;
  const dataSourceId = saved ? (_c = saved == null ? void 0 : saved.attributes) == null ? void 0 : _c.dataSource : (_d = draft == null ? void 0 : draft.attributes) == null ? void 0 : _d.dataSource;
  const dataSource3 = dataSourceId && client_default3[dataSourceId] || null;
  const connectionParams = (_e2 = connection == null ? void 0 : connection.attributes) == null ? void 0 : _e2.params;
  const { pageState, globalScopeMeta } = usePageEditorState();
  const queryEditorContext = React70.useMemo(
    () => dataSourceId ? { dataSourceId, connectionId } : null,
    [dataSourceId, connectionId]
  );
  const jsBrowserRuntime = useBrowserJsRuntime();
  const liveEnabled = useEvaluateLiveBinding({
    jsRuntime: jsBrowserRuntime,
    input: ((_f = draft == null ? void 0 : draft.attributes) == null ? void 0 : _f.enabled) || null,
    globalScope: pageState
  });
  const execPrivate = React70.useCallback(
    (method, args) => {
      (0, import_invariant9.default)(dataSourceId, "dataSourceId must be set");
      return projectApi.methods.dataSourceExecPrivate(dataSourceId, method, args);
    },
    [projectApi, dataSourceId]
  );
  return dataSourceId && dataSource3 && queryEditorContext ? React70.createElement(ConnectionContextProvider, { value: queryEditorContext }, React70.createElement(Box_default2, { sx: { height: "100%", p: 0, overflow: "hidden" } }, React70.createElement(
    dataSource3.QueryEditor,
    {
      connectionParams,
      value: draft,
      globalScope: pageState,
      globalScopeMeta,
      execApi: execPrivate,
      settingsTab: React70.createElement(
        QuerySettingsTab,
        {
          ...{
            draft,
            liveEnabled,
            pageState,
            globalScopeMeta,
            jsBrowserRuntime
          }
        }
      )
    }
  ))) : React70.createElement(Alert_default, { severity: "error" }, 'Datasource "', dataSourceId, '" not found');
}
function isMac() {
  const userAgent = navigator.userAgent;
  return /Mac|iPod|iPhone|iPad/.test(userAgent);
}
function getModifierKey() {
  return isMac() ? "⌘" : React71.createElement("kbd", null, "Ctrl");
}
function SaveShortcutIndicator() {
  return React722.createElement("span", null, getModifierKey(), "+", React722.createElement("kbd", null, "S"));
}
function TabCloseIcon({
  queryIndex,
  unsaved,
  queryId
}) {
  const appStateApi = useAppStateApi();
  const [notHovered, setNotHovered] = React722.useState(true);
  const onClose = React722.useCallback(() => {
    if (queryId === void 0) {
      return;
    }
    appStateApi.closeQueryTab(queryId, queryIndex);
  }, [appStateApi, queryIndex, queryId]);
  const { handleCloseWithUnsavedChanges: handleCloseTab } = useUnsavedChangesConfirm({
    hasUnsavedChanges: unsaved ?? false,
    onClose
  });
  return unsaved && notHovered ? React722.createElement(
    Circle_default,
    {
      "aria-label": `Unsaved changes ${queryIndex + 1}`,
      sx: {
        color: (theme3) => theme3.palette.mode === "dark" ? theme3.palette.primaryDark[300] : theme3.palette.primary.main,
        fontSize: 12
      },
      onMouseEnter: () => {
        setNotHovered(false);
      }
    }
  ) : React722.createElement(
    ClearOutlined_default,
    {
      onMouseLeave: () => {
        setNotHovered(true);
      },
      onClick: (event) => {
        event.stopPropagation();
        handleCloseTab();
      },
      role: "button",
      "aria-label": `Close query tab ${queryIndex + 1}`,
      sx: {
        color: (theme3) => theme3.palette.mode === "dark" ? theme3.palette.primaryDark[400] : theme3.palette.grey[500],
        fontSize: 12,
        padding: "1px",
        "&:hover": {
          color: (theme3) => theme3.palette.mode === "dark" ? theme3.palette.primaryDark[300] : theme3.palette.grey[700],
          backgroundColor: (theme3) => theme3.palette.mode === "dark" ? theme3.palette.primaryDark[700] : theme3.palette.grey[300],
          borderRadius: "4px"
        }
      }
    }
  );
}
function QueryEditor3() {
  var _a, _b, _c, _d, _e2, _f;
  const { currentView, dom } = useAppState();
  const appStateApi = useAppStateApi();
  const state = usePageEditorState();
  const page = getNode(dom, state.nodeId, "page");
  const currentQueryId = React722.useMemo(() => {
    var _a2;
    if (currentView.kind === "page" && ((_a2 = currentView.view) == null ? void 0 : _a2.kind) === "query") {
      return currentView.view.nodeId;
    }
    return "";
  }, [currentView]);
  const currentTabIndex = React722.useMemo(() => {
    var _a2, _b2, _c2;
    if (currentView.kind === "page" && ((_a2 = currentView.view) == null ? void 0 : _a2.kind) === "query") {
      return ((_c2 = (_b2 = currentView.queryPanel) == null ? void 0 : _b2.currentTabIndex) == null ? void 0 : _c2.toString()) || "";
    }
    return "";
  }, [currentView]);
  const handleTabChange = React722.useCallback(
    (event, newValue) => {
      var _a2, _b2, _c2, _d2;
      if (currentView.kind === "page") {
        const tabIndex = Number(newValue);
        const queryId = (_d2 = (_c2 = (_b2 = (_a2 = currentView.queryPanel) == null ? void 0 : _a2.queryTabs) == null ? void 0 : _b2[tabIndex]) == null ? void 0 : _c2.meta) == null ? void 0 : _d2.id;
        if (queryId) {
          appStateApi.setView({
            kind: "page",
            name: page.name,
            view: { kind: "query", nodeId: queryId },
            queryPanel: {
              ...currentView.queryPanel,
              currentTabIndex: tabIndex
            }
          });
        }
      }
    },
    [appStateApi, currentView, page.name]
  );
  const hasUnsavedChanges = React722.useCallback(
    (queryIndex) => {
      var _a2, _b2, _c2;
      if (currentView.kind !== "page" || !currentView.name || !((_a2 = currentView.queryPanel) == null ? void 0 : _a2.queryTabs) || queryIndex === void 0) {
        return false;
      }
      const tab = (_b2 = currentView.queryPanel) == null ? void 0 : _b2.queryTabs[queryIndex];
      const draft = tab == null ? void 0 : tab.draft;
      if (!tab || !((_c2 = tab.meta) == null ? void 0 : _c2.id) || !draft) {
        return false;
      }
      return draft !== tab.saved;
    },
    [currentView]
  );
  const handleSave = React722.useCallback(() => {
    var _a2, _b2, _c2, _d2, _e3;
    if (currentView.kind !== "page" || !currentView.name || !((_a2 = currentView.queryPanel) == null ? void 0 : _a2.queryTabs) || ((_b2 = currentView.queryPanel) == null ? void 0 : _b2.currentTabIndex) === void 0) {
      return;
    }
    const currentTab = (_d2 = currentView.queryPanel) == null ? void 0 : _d2.queryTabs[(_c2 = currentView.queryPanel) == null ? void 0 : _c2.currentTabIndex];
    const currentQueryDraft = currentTab == null ? void 0 : currentTab.draft;
    if (!currentTab || !((_e3 = currentTab.meta) == null ? void 0 : _e3.id) || !currentQueryDraft) {
      return;
    }
    appStateApi.saveQueryDraft(currentQueryDraft);
  }, [currentView, appStateApi]);
  const onClosePanel = React722.useCallback(() => {
    appStateApi.closeQueryPanel();
  }, [appStateApi]);
  const saveDisabled = React722.useMemo(
    () => !hasUnsavedChanges(Number(currentTabIndex)),
    [hasUnsavedChanges, currentTabIndex]
  );
  const hasUnsavedChangesInPanel = React722.useMemo(() => {
    var _a2, _b2;
    if (currentView.kind !== "page" || !((_a2 = currentView.queryPanel) == null ? void 0 : _a2.queryTabs)) {
      return false;
    }
    return (_b2 = currentView.queryPanel) == null ? void 0 : _b2.queryTabs.some((tab) => tab.draft !== tab.saved);
  }, [currentView]);
  const { handleCloseWithUnsavedChanges: handleClosePanel } = useUnsavedChangesConfirm({
    hasUnsavedChanges: hasUnsavedChangesInPanel,
    onClose: onClosePanel
  });
  useShortcut({ key: "s", metaKey: true, disabled: saveDisabled }, handleSave);
  return currentView.kind === "page" && ((_a = currentView.view) == null ? void 0 : _a.kind) === "query" && currentQueryId && ((_b = currentView == null ? void 0 : currentView.queryPanel) == null ? void 0 : _b.queryTabs) ? React722.createElement(
    Stack_default,
    {
      direction: "column",
      sx: { height: "100%", overflow: "hidden", borderBottom: 5, borderColor: "divider" },
      "aria-label": "Query editor",
      role: "tabpanel"
    },
    React722.createElement(TabContext, { value: currentTabIndex }, React722.createElement(
      Stack_default,
      {
        direction: "row",
        justifyContent: "space-between",
        sx: { maxHeight: 36, borderBottom: 1, borderColor: "divider" }
      },
      React722.createElement(TabList_default, { onChange: handleTabChange, "aria-label": "Query editor tabs" }, (_d = (_c = currentView.queryPanel) == null ? void 0 : _c.queryTabs) == null ? void 0 : _d.map((query, index) => {
        var _a2, _b2, _c2, _d2;
        return React722.createElement(
          Tab_default,
          {
            key: index,
            label: React722.createElement(
              Chip_default,
              {
                label: (_a2 = query == null ? void 0 : query.meta) == null ? void 0 : _a2.name,
                size: "small",
                variant: "outlined",
                sx: {
                  color: "inherit",
                  border: 0,
                  ml: -1,
                  "&:hover": { color: "inherit" }
                },
                deleteIcon: React722.createElement(
                  TabCloseIcon,
                  {
                    queryIndex: index,
                    unsaved: hasUnsavedChanges(index),
                    queryId: (_b2 = query == null ? void 0 : query.meta) == null ? void 0 : _b2.id
                  }
                ),
                onDelete: () => {
                }
              }
            ),
            value: index.toString(),
            icon: React722.createElement(
              QueryIcon,
              {
                id: ((_c2 = query == null ? void 0 : query.meta) == null ? void 0 : _c2.dataSource) || "default",
                mode: ((_d2 = query == null ? void 0 : query.meta) == null ? void 0 : _d2.mode) ?? "query",
                sx: { mt: 0.2 }
              }
            ),
            iconPosition: "start"
          }
        );
      })),
      React722.createElement("div", null, React722.createElement(
        LoadingButton_default,
        {
          disabled: saveDisabled,
          onClick: handleSave,
          variant: "contained",
          color: "primary",
          sx: { width: "fit-content", height: 32, my: "auto", mt: 0.2, mr: 2 }
        },
        "Save  ",
        React722.createElement(SaveShortcutIndicator, null)
      ), React722.createElement(IconButton_default, { size: "small", disableRipple: true, onClick: handleClosePanel }, React722.createElement(
        CancelPresentation_default,
        {
          sx: {
            mr: 1,
            alignSelf: "center",
            color: (theme3) => theme3.palette.grey[500],
            transition: (theme3) => theme3.transitions.create("color", {
              duration: theme3.transitions.duration.shortest
            }),
            "&:hover, &:focus": {
              color: (theme3) => theme3.palette.mode === "dark" ? theme3.palette.primaryDark[300] : theme3.palette.primary.main
            },
            fontSize: 16
          }
        }
      )))
    ), (_f = (_e2 = currentView.queryPanel) == null ? void 0 : _e2.queryTabs) == null ? void 0 : _f.map((query, index) => {
      var _a2;
      if (query && query.draft) {
        return React722.createElement(
          TabPanel_default,
          {
            key: index,
            value: index.toString(),
            "aria-label": (_a2 = query.meta) == null ? void 0 : _a2.name,
            sx: {
              p: 0,
              height: "100%",
              overflow: "hidden"
            }
          },
          React722.createElement(React722.Suspense, { fallback: React722.createElement(LinearProgress_default, null) }, React722.createElement(QueryEditorPanel, { draft: query.draft, saved: query.saved }))
        );
      }
      return null;
    }))
  ) : null;
}
var classes6 = {
  renderPanel: "Toolpad_RenderPanel"
};
var PageEditorRoot = styled_default("div")({
  width: "100%",
  height: "100%",
  overflow: "hidden",
  display: "flex",
  flexDirection: "row",
  [`& .${classes6.renderPanel}`]: {
    flex: 1
  }
});
function PageEditorContent({ node }) {
  var _a, _b;
  usePageTitle(`${getPageTitle(node)} | Toolpad Studio editor`);
  const { currentView } = useAppState();
  const showQuery = currentView.kind === "page" && ((_a = currentView.view) == null ? void 0 : _a.kind) === "query" && ((_b = currentView.queryPanel) == null ? void 0 : _b.queryTabs);
  return React73.createElement(PageEditorProvider, { key: node.id, nodeId: node.id }, React73.createElement(resizablePanels_exports.PanelGroup, { autoSaveId: "toolpad/editor-panel-split", direction: "vertical" }, React73.createElement(resizablePanels_exports.Panel, { order: 1, id: "editor" }, React73.createElement(resizablePanels_exports.PanelGroup, { autoSaveId: "editor/component-panel-split", direction: "horizontal" }, React73.createElement(resizablePanels_exports.Panel, { id: "page-editor", defaultSize: 75, minSize: 50, maxSize: 80 }, React73.createElement(PageEditorRoot, null, React73.createElement(ComponentCatalog_default, null), React73.createElement(RenderPanel_default, { className: classes6.renderPanel }))), React73.createElement(PanelResizeHandle2, null), React73.createElement(resizablePanels_exports.Panel, { id: "component-panel", defaultSize: 25, maxSize: 50, minSize: 20 }, React73.createElement(ComponentPanel, null)))), React73.createElement(PanelResizeHandle2, null), showQuery ? React73.createElement(resizablePanels_exports.Panel, { minSize: 10, maxSize: 90, defaultSize: 35, order: 2, id: "query-panel" }, React73.createElement(QueryEditor3, null)) : null));
}
function PageEditor({ name }) {
  const { dom } = useAppState();
  const pageNode = React73.useMemo(() => getPageByName(dom, name), [dom, name]);
  useUndoRedo();
  return pageNode ? React73.createElement(PageEditorContent, { node: pageNode }) : React73.createElement(NotFoundEditor, { message: `Non-existing Page "${name}"` });
}
var SystemDialog = Dialog_default;
var SystemDialogTitle = DialogTitle_default;
var SystemDialogContent = DialogContent_default;
var SystemDialogActions = DialogActions_default;
var SystemDialogCancelButton = React74.forwardRef(
  ({ children = "cancel", ...props2 }, ref) => React74.createElement(Button_default, { ref, color: "inherit", variant: "text", ...props2 }, children)
);
var SystemDialogOkButton = React74.forwardRef(
  ({ children = "ok", ...props2 }, ref) => React74.createElement(LoadingButton_default, { ref, ...props2 }, children)
);
function ConfirmDialog({
  open,
  onClose,
  title,
  children,
  cancelButton = "Cancel",
  okButton = "ok",
  severity,
  loading
}) {
  const handleCancel = React74.useCallback(
    (event) => onClose(false, event),
    [onClose]
  );
  const handleOk = React74.useCallback((event) => onClose(true, event), [onClose]);
  return React74.createElement(SystemDialog, { open, onClose: handleCancel }, React74.createElement(SystemDialogTitle, null, title ?? "Confirm"), React74.createElement(SystemDialogContent, null, children), React74.createElement(SystemDialogActions, null, React74.createElement(SystemDialogCancelButton, { onClick: handleCancel }, cancelButton), React74.createElement(SystemDialogOkButton, { color: severity, loading, onClick: handleOk }, okButton)));
}
function useMenu() {
  const buttonId = React75.useId();
  const menuId = React75.useId();
  const [anchorEl, setAnchorEl] = React75.useState(null);
  const open = Boolean(anchorEl);
  const onMenuClose = React75.useCallback((event) => {
    var _a;
    (_a = event == null ? void 0 : event.stopPropagation) == null ? void 0 : _a.call(event);
    setAnchorEl(null);
  }, []);
  const buttonProps = React75.useMemo(
    () => ({
      id: buttonId,
      "aria-controls": open ? menuId : void 0,
      "aria-haspopup": "true",
      "aria-expanded": open ? "true" : void 0,
      onClick(event) {
        event.stopPropagation();
        setAnchorEl(event.currentTarget);
      }
    }),
    [buttonId, menuId, open]
  );
  const menuProps = React75.useMemo(
    () => ({
      id: menuId,
      anchorEl,
      open,
      onClose: onMenuClose,
      MenuListProps: {
        "aria-labelledby": buttonId
      }
    }),
    [anchorEl, buttonId, menuId, onMenuClose, open]
  );
  return {
    buttonProps,
    menuProps,
    onMenuClose
  };
}
function NodeMenu({
  nodeId,
  renderButton,
  renameLabelText = "Rename",
  deleteLabelText = "Delete",
  duplicateLabelText = "Duplicate",
  onRenameNode,
  onDeleteNode,
  onDuplicateNode
}) {
  const { dom } = useAppState();
  const { menuProps, buttonProps, onMenuClose } = useMenu();
  const [deletedNodeId, setDeletedNodeId] = React76.useState(null);
  const handleDeleteNodeDialogOpen = React76.useCallback(
    (event) => {
      event.stopPropagation();
      setDeletedNodeId(nodeId);
      onMenuClose(event);
    },
    [nodeId, onMenuClose]
  );
  const deletedNode = deletedNodeId && getMaybeNode(dom, deletedNodeId);
  const latestDeletedNode = useLatest_default(deletedNode);
  const isAction = React76.useMemo(() => {
    var _a;
    if ((latestDeletedNode == null ? void 0 : latestDeletedNode.type) === "query" && ((_a = latestDeletedNode == null ? void 0 : latestDeletedNode.attributes) == null ? void 0 : _a.mode) === "mutation") {
      return true;
    }
    return false;
  }, [latestDeletedNode]);
  const handleDeleteNodeDialogClose = React76.useCallback(
    (confirmed, event) => {
      event.stopPropagation();
      setDeletedNodeId(null);
      if (confirmed && deletedNode) {
        onDeleteNode == null ? void 0 : onDeleteNode(deletedNodeId);
      }
    },
    [deletedNode, deletedNodeId, onDeleteNode]
  );
  const handleRenameClick = React76.useCallback(
    (event) => {
      onRenameNode == null ? void 0 : onRenameNode(nodeId);
      onMenuClose(event);
    },
    [nodeId, onRenameNode, onMenuClose]
  );
  const handleDuplicateClick = React76.useCallback(
    (event) => {
      onMenuClose(event);
      onDuplicateNode == null ? void 0 : onDuplicateNode(nodeId);
    },
    [onDuplicateNode, nodeId, onMenuClose]
  );
  return React76.createElement(React76.Fragment, null, renderButton({
    buttonProps,
    menuProps
  }), React76.createElement(
    Menu_default,
    {
      ...menuProps,
      onClick: (event) => {
        var _a;
        event.stopPropagation();
        (_a = menuProps.onClick) == null ? void 0 : _a.call(menuProps, event);
      }
    },
    onRenameNode ? React76.createElement(MenuItem_default, { onClick: handleRenameClick }, React76.createElement(ListItemIcon_default, null, React76.createElement(ModeEdit_default, null)), React76.createElement(ListItemText_default, null, renameLabelText)) : null,
    onDuplicateNode ? React76.createElement(MenuItem_default, { onClick: handleDuplicateClick }, React76.createElement(ListItemIcon_default, null, React76.createElement(ContentCopy_default, null)), React76.createElement(ListItemText_default, null, duplicateLabelText)) : null,
    onDeleteNode ? React76.createElement(MenuItem_default, { onClick: handleDeleteNodeDialogOpen }, React76.createElement(ListItemIcon_default, null, React76.createElement(Delete_default, null)), React76.createElement(ListItemText_default, null, deleteLabelText)) : null
  ), React76.createElement(
    ConfirmDialog,
    {
      open: !!deletedNode,
      severity: "error",
      onClose: handleDeleteNodeDialogClose,
      okButton: "Delete"
    },
    "Delete ",
    isAction ? "action" : "query",
    ' "',
    latestDeletedNode == null ? void 0 : latestDeletedNode.name,
    '"?'
  ));
}
var EditableTreeItemRoot = styled_default(TreeItem, {
  shouldForwardProp: (prop) => prop !== "isEditing"
})(({ theme: theme3, isEditing }) => ({
  paddingLeft: theme3.spacing(0.5),
  "> .MuiTreeItem-content": {
    padding: theme3.spacing(0, 0.5),
    gap: theme3.spacing(0.5),
    backgroundColor: isEditing ? alpha(theme3.palette.primary.main, 0.2) : void 0
  }
}));
var defaultRenderLabel = (children) => children;
function EditableTreeItem({
  labelText = "",
  renderLabel = defaultRenderLabel,
  suggestedNewItemName = "",
  validateItemName,
  isEditing: isExternalEditing = false,
  onEdit,
  onCancel,
  isLoading = false,
  inputProps,
  sx,
  ...rest
}) {
  const inputRef = React77.useRef(null);
  const [itemNameInput, setItemNameInput] = React77.useState(suggestedNewItemName);
  const [isInternalEditing, setIsInternalEditing] = React77.useState(false);
  const isEditing = isExternalEditing || isInternalEditing;
  const newItemValidationResult = React77.useMemo(
    () => validateItemName ? validateItemName(itemNameInput) : { isValid: true },
    [itemNameInput, validateItemName]
  );
  const validationErrorMessage = newItemValidationResult.errorMessage;
  React77.useEffect(() => {
    setItemNameInput(suggestedNewItemName);
  }, [suggestedNewItemName]);
  const handleClick = React77.useCallback(
    (event) => {
      if (event.detail === 2 && onEdit) {
        setIsInternalEditing(true);
      }
    },
    [onEdit]
  );
  const handleCancel = React77.useCallback(() => {
    setItemNameInput(suggestedNewItemName);
    setIsInternalEditing(false);
    if (onCancel) {
      onCancel();
    }
  }, [onCancel, suggestedNewItemName]);
  const handleConfirm = React77.useCallback(async () => {
    if (!itemNameInput || !newItemValidationResult.isValid || isLoading) {
      handleCancel();
      return;
    }
    if (onEdit) {
      await onEdit(itemNameInput);
    }
    setIsInternalEditing(false);
  }, [handleCancel, isLoading, itemNameInput, newItemValidationResult.isValid, onEdit]);
  const handleChange = React77.useCallback((event) => {
    setItemNameInput(event.target.value.replaceAll(/[^a-zA-Z0-9]/g, ""));
  }, []);
  const handleFocus = React77.useCallback((event) => {
    event.target.select();
    event.stopPropagation();
  }, []);
  const handleBlur = React77.useCallback(() => {
    handleConfirm();
  }, [handleConfirm]);
  const handleKeyDown = React77.useCallback(
    (event) => {
      event.stopPropagation();
      if (event.key === "Enter") {
        handleConfirm();
      } else if (event.key === "Escape") {
        handleCancel();
      }
    },
    [handleCancel, handleConfirm]
  );
  const inputErrorPopoverAnchorEl = inputRef.current;
  const labelTextSx = {
    fontSize: 14,
    pt: "4px",
    pb: "4px"
  };
  return React77.createElement(
    EditableTreeItemRoot,
    {
      ...rest,
      onClick: handleClick,
      label: renderLabel(
        isEditing ? React77.createElement(React77.Fragment, null, React77.createElement(
          InputBase_default,
          {
            ...inputProps,
            ref: inputRef,
            value: itemNameInput,
            onChange: handleChange,
            autoFocus: true,
            onFocus: handleFocus,
            onBlur: handleBlur,
            onKeyDown: handleKeyDown,
            fullWidth: true,
            disabled: isLoading,
            endAdornment: isLoading ? React77.createElement(CircularProgress_default, { size: 14 }) : null,
            sx: {
              ...(inputProps == null ? void 0 : inputProps.sx) || {},
              ...labelTextSx,
              padding: 0
            }
          }
        ), inputErrorPopoverAnchorEl ? React77.createElement(
          Popover_default,
          {
            open: !!validationErrorMessage,
            anchorEl: inputErrorPopoverAnchorEl,
            disableAutoFocus: true,
            anchorOrigin: {
              vertical: "bottom",
              horizontal: "left"
            }
          },
          validationErrorMessage ? React77.createElement(Alert_default, { severity: "error", variant: "outlined" }, validationErrorMessage) : null
        ) : null) : React77.createElement(
          Typography_default,
          {
            variant: "body2",
            sx: {
              fontWeight: "inherit",
              flexGrow: 1,
              overflow: "hidden",
              textOverflow: "ellipsis",
              ...labelTextSx
            },
            noWrap: true
          },
          labelText
        )
      ),
      isEditing,
      sx
    }
  );
}
var ExplorerHeaderContainer = styled_default(Stack_default)(({ theme: theme3 }) => ({
  backgroundColor: theme3.palette.background.paper,
  width: "100%",
  height: 36
}));
var ExplorerHeaderTitle = styled_default(Typography_default)(({ theme: theme3 }) => ({
  fontSize: 13,
  flexGrow: 1,
  fontWeight: theme3.typography.fontWeightLight
}));
function ExplorerHeader({
  headerText,
  headerIcon,
  onCreate,
  onSearch,
  createLabelText,
  searchLabelText = "Search",
  hasPersistentSearch = false
}) {
  const [isSearching, setIsSearching] = React78.useState(hasPersistentSearch);
  const [searchTerm, setSearchTerm] = React78.useState("");
  const handleSearchClick = React78.useCallback(() => {
    if (isSearching && searchTerm) {
      setSearchTerm("");
    }
    setIsSearching((previousIsSearching) => !previousIsSearching);
  }, [isSearching, searchTerm]);
  const handleSearchChange = React78.useCallback((event) => {
    setSearchTerm(event.target.value);
  }, []);
  React78.useEffect(() => {
    if (onSearch) {
      onSearch(searchTerm);
    }
  }, [onSearch, searchTerm]);
  return React78.createElement(
    ExplorerHeaderContainer,
    {
      direction: "row",
      alignItems: "center",
      justifyContent: "space-between",
      sx: { pl: isSearching ? 2 : 2.5 }
    },
    isSearching ? React78.createElement(
      TextField_default,
      {
        hiddenLabel: true,
        value: searchTerm,
        onChange: handleSearchChange,
        variant: "standard",
        fullWidth: true,
        size: "small",
        placeholder: `${searchLabelText}…`,
        slotProps: {
          input: {
            startAdornment: hasPersistentSearch ? React78.createElement(InputAdornment_default, { position: "start" }, React78.createElement(Search_default, { fontSize: "small", sx: { mt: "-4px" } })) : null,
            sx: {
              fontSize: 14,
              borderRadius: 0
            }
          }
        }
      }
    ) : React78.createElement(React78.Fragment, null, headerIcon, React78.createElement(
      ExplorerHeaderTitle,
      {
        variant: "body2",
        sx: {
          mx: 0.5,
          my: 0.5
        }
      },
      headerText
    )),
    onSearch && searchLabelText && !hasPersistentSearch ? React78.createElement(Tooltip_default, { title: searchLabelText }, React78.createElement(IconButton_default, { "aria-label": searchLabelText, size: "medium", onClick: handleSearchClick }, React78.createElement(Search_default, { color: isSearching ? "primary" : "inherit" }))) : null,
    onCreate && createLabelText ? React78.createElement(Tooltip_default, { title: createLabelText }, React78.createElement(IconButton_default, { "aria-label": createLabelText, size: "small", onClick: onCreate }, React78.createElement(Add_default, null))) : null
  );
}
var PagesExplorerRoot = styled_default(Stack_default)({
  height: "100%",
  width: "100%"
});
var classes7 = {
  treeItemMenuButton: "Toolpad__PagesExplorerTreeItem",
  treeItemMenuOpen: "Toolpad__PagesExplorerTreeItemMenuOpen"
};
var StyledEditableTreeItem = styled_default(EditableTreeItem)({
  [`& .${classes7.treeItemMenuButton}`]: {
    visibility: "hidden"
  },
  [`
    & .${treeItemClasses.content}:hover .${classes7.treeItemMenuButton},
    & .${classes7.treeItemMenuOpen}
  `]: {
    visibility: "visible"
  }
});
function PagesExplorerTreeItem(props2) {
  const {
    itemId,
    labelIcon,
    labelText,
    title,
    onRenameNode,
    onDeleteNode,
    onDuplicateNode,
    renameLabelText = "Rename",
    deleteLabelText = "Delete",
    duplicateLabelText = "Duplicate",
    toolpadNodeId,
    validateItemName,
    ...other
  } = props2;
  const { value: isEditing, setTrue: startEditing, setFalse: stopEditing } = useBoolean(false);
  const handleRenameConfirm = React79.useCallback(
    (updatedName) => {
      if (onRenameNode) {
        onRenameNode(itemId, updatedName);
        stopEditing();
      }
    },
    [itemId, onRenameNode, stopEditing]
  );
  const validateEditablePageName = React79.useCallback(
    (newName) => {
      if (newName !== labelText && validateItemName) {
        return validateItemName(newName);
      }
      return { isValid: true };
    },
    [labelText, validateItemName]
  );
  return React79.createElement(
    StyledEditableTreeItem,
    {
      itemId,
      labelText,
      renderLabel: (children) => React79.createElement(Tooltip_default, { title, placement: "right", disableInteractive: true }, React79.createElement(Box_default2, { sx: { display: "flex", alignItems: "center" } }, labelIcon, children, toolpadNodeId ? React79.createElement(
        NodeMenu,
        {
          renderButton: ({ buttonProps, menuProps }) => React79.createElement(
            IconButton_default,
            {
              className: clsx_default(classes7.treeItemMenuButton, {
                [classes7.treeItemMenuOpen]: menuProps.open
              }),
              "aria-label": "Open page explorer menu",
              size: "small",
              ...buttonProps
            },
            React79.createElement(MoreVert_default, { fontSize: "inherit" })
          ),
          nodeId: toolpadNodeId,
          renameLabelText,
          deleteLabelText,
          duplicateLabelText,
          onRenameNode: startEditing,
          onDeleteNode,
          onDuplicateNode
        }
      ) : null)),
      suggestedNewItemName: labelText,
      onCancel: stopEditing,
      isEditing,
      ...onRenameNode ? { onEdit: handleRenameConfirm } : {},
      validateItemName: validateEditablePageName,
      ...other
    }
  );
}
function getNodeEditorDomView(node) {
  switch (node.type) {
    case "page":
      return { kind: "page", name: node.name };
    default:
      return void 0;
  }
}
var DEFAULT_NEW_PAGE_NAME = "page";
function PagesExplorer({ className }) {
  const projectApi = useProjectApi();
  const { dom, currentView } = useAppState();
  const appStateApi = useAppStateApi();
  const app = getApp(dom);
  const { pages = [] } = getChildNodes(dom, app);
  const existingNames = React79.useMemo(
    () => getExistingNamesForChildren(dom, getApp(dom), "pages"),
    [dom]
  );
  const [expanded, setExpanded] = useLocalStorageState(
    `editor/${app.id}/pages-explorer-expansion`,
    [":pages"]
  );
  const activePage = currentView.name ? getPageByName(dom, currentView.name) : null;
  const handleToggle = (event, nodeIds) => {
    setExpanded(nodeIds);
  };
  const handleSelect = (event, nodeIds) => {
    if (nodeIds.length <= 0) {
      return;
    }
    const rawNodeId = nodeIds[0];
    if (rawNodeId.startsWith(":")) {
      return;
    }
    const selectedNodeId = rawNodeId;
    const node = getNode(dom, selectedNodeId);
    if (isElement(node)) {
      const page = getPageAncestor(dom, node);
      if (page) {
        appStateApi.setView({ kind: "page", name: page.name });
      }
    }
    if (isPage(node)) {
      appStateApi.setView({ kind: "page", name: node.name });
    }
  };
  const pagesTreeRef = React79.useRef(null);
  const [hasMounted, setHasMounted] = React79.useState(false);
  React79.useEffect(() => {
    setHasMounted(true);
  }, []);
  React79.useEffect(() => {
    const pagesTree = pagesTreeRef.current;
    if (pagesTree && hasMounted) {
      const selectedItem = pagesTree.querySelector(`.${treeItemClasses.selected}`);
      if (selectedItem) {
        scrollIntoViewIfNeeded(selectedItem);
      }
    }
  }, [hasMounted, pages]);
  const {
    value: isCreateNewPageOpen,
    setTrue: handleOpenCreateNewPage,
    setFalse: handleCloseCreateNewPage
  } = useBoolean(false);
  const nextProposedName = React79.useMemo(
    () => proposeName(DEFAULT_NEW_PAGE_NAME, existingNames),
    [existingNames]
  );
  const handleCreateNewCommit = React79.useCallback(
    async (newPageName) => {
      const newNode = createNode(dom, "page", {
        name: newPageName,
        attributes: {
          title: newPageName,
          display: "shell",
          authorization: {
            allowAll: true
          }
        }
      });
      const appNode = getApp(dom);
      appStateApi.update((draft) => addNode(draft, newNode, appNode, "pages"), {
        kind: "page",
        name: newNode.name
      });
      handleCloseCreateNewPage();
    },
    [appStateApi, dom, handleCloseCreateNewPage]
  );
  const validatePageName = React79.useCallback(
    (pageName) => {
      const validationErrorMessage = validateNodeName(pageName, existingNames, "page");
      return {
        isValid: !validationErrorMessage,
        ...validationErrorMessage ? { errorMessage: validationErrorMessage } : {}
      };
    },
    [existingNames]
  );
  const handleDeletePage = React79.useCallback(
    async (nodeId) => {
      const deletedNode = getNode(dom, nodeId);
      let domViewAfterDelete;
      if (nodeId === (activePage == null ? void 0 : activePage.id)) {
        const siblings = getSiblings(dom, deletedNode);
        const firstSiblingOfType = siblings.find((sibling) => sibling.type === deletedNode.type);
        domViewAfterDelete = firstSiblingOfType ? getNodeEditorDomView(firstSiblingOfType) : { kind: "page" };
      }
      await projectApi.methods.deletePage(deletedNode.name);
      appStateApi.update((draft) => removeNode(draft, nodeId), domViewAfterDelete);
    },
    [projectApi, activePage == null ? void 0 : activePage.id, appStateApi, dom]
  );
  const handleRenameNode = React79.useCallback(
    (nodeId, updatedName) => {
      appStateApi.update(
        (draft) => {
          const page = getNode(draft, nodeId, "page");
          return setNodeName(draft, page, updatedName);
        },
        {
          kind: "page",
          name: updatedName
        }
      );
      const oldNameNode = dom.nodes[nodeId];
      if (oldNameNode.type === "page" && updatedName !== oldNameNode.name) {
        setTimeout(async () => {
          await projectApi.methods.deletePage(oldNameNode.name);
        }, 300);
      }
    },
    [appStateApi, dom.nodes, projectApi.methods]
  );
  const handleDuplicateNode = React79.useCallback(
    (nodeId) => {
      const node = getNode(dom, nodeId);
      (0, import_invariant10.default)(
        node.parentId && node.parentProp,
        "Duplication should never be called on nodes that are not placed in the dom"
      );
      const fragment = cloneFragment(dom, nodeId);
      const newNode = getNode(fragment, fragment.root);
      const editorDomView = getNodeEditorDomView(newNode);
      appStateApi.update(
        (draft) => addFragment(draft, fragment, node.parentId, node.parentProp),
        editorDomView || { kind: "page" }
      );
    },
    [appStateApi, dom]
  );
  const alphabeticSortedPages = React79.useMemo(
    () => [...pages].sort(createPropComparator("name", alphabeticComparator)),
    [pages]
  );
  return React79.createElement(PagesExplorerRoot, { "data-testid": "pages-explorer", direction: "column", className }, React79.createElement(
    ExplorerHeader,
    {
      headerText: "Pages",
      onCreate: handleOpenCreateNewPage,
      createLabelText: "Create new page"
    }
  ), React79.createElement(
    SimpleTreeView,
    {
      ref: pagesTreeRef,
      "aria-label": "Pages explorer",
      selectedItems: activePage ? [activePage.id] : [],
      onSelectedItemsChange: handleSelect,
      expandedItems: expanded,
      onExpandedItemsChange: handleToggle,
      multiSelect: true,
      sx: {
        overflow: "auto",
        scrollbarGutter: "stable"
      }
    },
    isCreateNewPageOpen ? React79.createElement(
      EditableTreeItem,
      {
        itemId: "::create::",
        isEditing: true,
        suggestedNewItemName: nextProposedName,
        onEdit: handleCreateNewCommit,
        onCancel: handleCloseCreateNewPage,
        validateItemName: validatePageName
      }
    ) : null,
    alphabeticSortedPages.map((page) => React79.createElement(
      PagesExplorerTreeItem,
      {
        key: page.id,
        itemId: page.id,
        toolpadNodeId: page.id,
        labelText: page.name,
        title: getPageDisplayName(page),
        onRenameNode: handleRenameNode,
        onDuplicateNode: handleDuplicateNode,
        onDeleteNode: handleDeletePage,
        validateItemName: validatePageName
      }
    ))
  ));
}
var classes8 = {
  treeItemMenuButton: "Toolpad__HierarchyListItem",
  treeItemMenuOpen: "Toolpad__HierarchyListItemMenuOpen"
};
var StyledTreeItem = styled_default(EditableTreeItem)({
  [`& .${classes8.treeItemMenuButton}`]: {
    visibility: "hidden"
  },
  [`& .${treeItemClasses.content}:hover .${classes8.treeItemMenuButton}, & .${classes8.treeItemMenuOpen}`]: {
    visibility: "visible"
  }
});
function CustomTreeItem(props2) {
  const domApi = useDomApi();
  const { dom } = useAppState();
  const appStateApi = useAppStateApi();
  const { label, node, ...other } = props2;
  const {
    value: domNodeEditing,
    setTrue: startDomNodeEditing,
    setFalse: stopDomNodeEditing
  } = useBoolean(false);
  const existingNames = React80.useMemo(() => getExistingNamesForNode(dom, node), [dom, node]);
  const validateEditableNodeName = React80.useCallback(
    (newName) => {
      if (newName !== node.name) {
        const validationErrorMessage = validateNodeName(newName, existingNames, node.type);
        return {
          isValid: !validationErrorMessage,
          ...validationErrorMessage ? { errorMessage: validationErrorMessage } : {}
        };
      }
      return { isValid: true };
    },
    [existingNames, node.name, node.type]
  );
  const handleNameSave = React80.useCallback(
    (newName) => {
      domApi.setNodeName(node.id, newName);
      stopDomNodeEditing();
    },
    [domApi, node.id, stopDomNodeEditing]
  );
  const handleNodeDelete = React80.useCallback(
    (nodeId) => {
      domApi.update((draft) => {
        const toRemove = getNode(draft, nodeId);
        if (isElement(toRemove)) {
          draft = removePageLayoutNode(draft, toRemove);
        }
        return draft;
      });
    },
    [domApi]
  );
  const handleNodeDuplicate = React80.useCallback(
    (nodeId) => {
      const currentNode = getNode(dom, nodeId);
      (0, import_invariant11.default)(
        node.parentId && node.parentProp,
        "Duplication should never be called on nodes that are not placed in the dom"
      );
      domApi.update((draft) => {
        draft = duplicateNode(draft, currentNode);
        return draft;
      });
    },
    [dom, domApi, node.parentId, node.parentProp]
  );
  const handleNodeHover = React80.useCallback(
    (event, nodeId) => {
      appStateApi.hoverNode(nodeId);
    },
    [appStateApi]
  );
  const handleNodeBlur = React80.useCallback(() => {
    appStateApi.blurHoverNode();
  }, [appStateApi]);
  return React80.createElement(
    StyledTreeItem,
    {
      key: node.id,
      labelText: node.name,
      renderLabel: (children) => React80.createElement(
        Box_default2,
        {
          sx: { display: "flex", alignItems: "center" },
          onMouseEnter: (event) => {
            handleNodeHover == null ? void 0 : handleNodeHover(event, node.id);
          },
          onMouseLeave: handleNodeBlur
        },
        React80.createElement(
          ComponentIcon,
          {
            id: node.attributes.component,
            kind: "builtIn",
            sx: { marginRight: 1, fontSize: 18, opacity: 0.5 }
          }
        ),
        children,
        node.id ? React80.createElement(
          NodeMenu,
          {
            renderButton: ({ buttonProps, menuProps }) => React80.createElement(
              IconButton_default,
              {
                className: clsx_default(classes8.treeItemMenuButton, {
                  [classes8.treeItemMenuOpen]: menuProps.open
                }),
                "aria-label": "Open hierarchy menu",
                size: "small",
                ...buttonProps
              },
              React80.createElement(MoreVert_default, { fontSize: "inherit" })
            ),
            nodeId: node.id,
            onRenameNode: startDomNodeEditing,
            onDuplicateNode: handleNodeDuplicate,
            onDeleteNode: handleNodeDelete
          }
        ) : null
      ),
      isEditing: domNodeEditing,
      onEdit: handleNameSave,
      suggestedNewItemName: node.name,
      onCancel: stopDomNodeEditing,
      validateItemName: validateEditableNodeName,
      ...other
    }
  );
}
function RecursiveSubTree({ dom, root: root2 }) {
  const { children = [], renderItem = [] } = React80.useMemo(
    () => getChildNodes(dom, root2),
    [dom, root2]
  );
  if (children.length > 0) {
    return React80.createElement(CustomTreeItem, { itemId: root2.id, node: root2 }, children.map((childNode) => React80.createElement(RecursiveSubTree, { key: childNode.id, dom, root: childNode })));
  }
  if (renderItem.length > 0) {
    return React80.createElement(
      CustomTreeItem,
      {
        itemId: root2.id,
        node: root2,
        label: React80.createElement(Typography_default, { variant: "body2" }, root2.name)
      },
      React80.createElement(
        TreeItem,
        {
          itemId: `${root2.id}-renderItem`,
          label: React80.createElement(Typography_default, { variant: "body2" }, "renderItem")
        },
        renderItem.map((childNode) => React80.createElement(RecursiveSubTree, { key: childNode.id, dom, root: childNode }))
      )
    );
  }
  return React80.createElement(CustomTreeItem, { itemId: root2.id, node: root2 });
}
function HierarchyExplorer() {
  const { dom, currentView } = useAppState();
  const appStateApi = useAppStateApi();
  const [expandedDomNodeIds, setExpandedDomNodeIds] = React80.useState([]);
  const currentPageNode = (currentView == null ? void 0 : currentView.name) ? getPageByName(dom, currentView.name) : null;
  const selectedDomNodeId = currentView == null ? void 0 : currentView.selectedNodeId;
  const selectedNodeAncestorIds = React80.useMemo(() => {
    if (!selectedDomNodeId) {
      return [];
    }
    const selectedNode = getMaybeNode(dom, selectedDomNodeId);
    if (selectedNode) {
      return getAncestors(dom, selectedNode).map((node) => node.id);
    }
    return [];
  }, [dom, selectedDomNodeId]);
  const { children: rootChildren = [] } = React80.useMemo(() => {
    if (!currentPageNode) {
      return { children: [] };
    }
    return getChildNodes(dom, currentPageNode);
  }, [dom, currentPageNode]);
  const handleNodeSelect = React80.useCallback(
    (event, itemIds) => {
      if (!itemIds) {
        return;
      }
      appStateApi.selectNode(itemIds);
    },
    [appStateApi]
  );
  const handleNodeFocus = React80.useCallback(
    (event, nodeId) => {
      appStateApi.hoverNode(nodeId);
    },
    [appStateApi]
  );
  const handleNodeToggle = React80.useCallback(
    (event, nodeIds) => {
      setExpandedDomNodeIds(nodeIds);
    },
    [setExpandedDomNodeIds]
  );
  const deleteNode = React80.useCallback(() => {
    if (!selectedDomNodeId) {
      return;
    }
    appStateApi.update(
      (draft) => {
        const toRemove = getMaybeNode(dom, selectedDomNodeId);
        if (toRemove && isElement(toRemove)) {
          draft = removePageLayoutNode(draft, toRemove);
        }
        return draft;
      },
      {
        ...currentView,
        selectedNodeId: null
      }
    );
  }, [selectedDomNodeId, appStateApi, currentView, dom]);
  const handleKeyDown = React80.useCallback(
    (event) => {
      if (event.key === "Backspace") {
        deleteNode();
      }
    },
    [deleteNode]
  );
  const expandedDomNodeIdSet = React80.useMemo(() => {
    return /* @__PURE__ */ new Set([...selectedNodeAncestorIds, ...expandedDomNodeIds]);
  }, [selectedNodeAncestorIds, expandedDomNodeIds]);
  return React80.createElement(React80.Fragment, null, React80.createElement(ExplorerHeader, { headerText: "Page hierarchy" }), React80.createElement(
    SimpleTreeView,
    {
      "aria-label": "Page hierarchy explorer",
      expandedItems: Array.from(expandedDomNodeIdSet),
      selectedItems: selectedDomNodeId,
      onSelectedItemsChange: handleNodeSelect,
      onItemFocus: handleNodeFocus,
      onExpandedItemsChange: handleNodeToggle,
      onKeyDown: handleKeyDown,
      sx: {
        flexGrow: 1,
        maxWidth: 400,
        maxHeight: "85%",
        overflowY: "auto",
        scrollbarGutter: "stable"
      }
    },
    rootChildren.map((childNode) => React80.createElement(RecursiveSubTree, { key: childNode.id, dom, root: childNode }))
  ));
}
function AppExportDialog({ open, onClose, dom }) {
  const dialogTitleId = React81.useId();
  return React81.createElement(Dialog_default, { "aria-labelledby": dialogTitleId, fullWidth: true, maxWidth: "sm", open, onClose }, React81.createElement(DialogTitle_default, { id: dialogTitleId }, "Application DOM"), React81.createElement(DialogContent_default, { sx: { position: "relative", display: "flex", alignItems: "stretch" } }, React81.createElement(JsonView, { sx: { flex: 1 }, copyToClipboard: true, src: dom, expandPaths: [], expandLevel: 5 })), React81.createElement(DialogActions_default, null, React81.createElement(Button_default, { onClick: onClose }, "Close")));
}
var AppExportDialog_default = AppExportDialog;
function AppOptions({ dom }) {
  const { buttonProps, menuProps, onMenuClose } = useMenu();
  const {
    setTrue: handleOpenAppExport,
    setFalse: handleCloseAppExport,
    value: appExportOpen
  } = useBoolean(false);
  const handleAppExportClick = React822.useCallback(() => {
    onMenuClose();
    handleOpenAppExport();
  }, [handleOpenAppExport, onMenuClose]);
  return React822.createElement(React822.Fragment, null, React822.createElement(IconButton_default, { ...buttonProps, "aria-label": "Application menu" }, React822.createElement(MoreVert_default, null)), React822.createElement(Menu_default, { ...menuProps }, React822.createElement(Divider_default, null), dom ? React822.createElement(MenuItem_default, { onClick: handleAppExportClick }, React822.createElement(ListItemIcon_default, null, React822.createElement(Code_default, null)), React822.createElement(ListItemText_default, null, "View DOM")) : null), dom ? React822.createElement(AppExportDialog_default, { open: appExportOpen, onClose: handleCloseAppExport, dom }) : null);
}
var AppOptions_default = AppOptions;
var classes9 = {
  treeItemMenuButton: "Toolpad__QueryListItem",
  treeItemMenuOpen: "Toolpad__QueryListItemMenuOpen"
};
var StyledTreeItem2 = styled_default(EditableTreeItem)({
  [`& .${classes9.treeItemMenuButton}`]: {
    visibility: "hidden"
  },
  [`
  & .${treeItemClasses.content}:hover .${classes9.treeItemMenuButton},
      & .${classes9.treeItemMenuOpen}
    `]: {
    visibility: "visible"
  }
});
function DataTreeItem(props2) {
  const {
    itemId,
    labelText,
    labelTextSx,
    labelIconSx,
    labelIconId,
    onCreate,
    onSelectNode,
    onDeleteNode,
    onDuplicateNode,
    onRenameNode,
    createLabelText,
    deleteLabelText = "Delete",
    duplicateLabelText = "Duplicate",
    renameLabelText = "Rename",
    toolpadNodeId,
    validateItemName,
    ...other
  } = props2;
  const { value: isEditing, setTrue: startEditing, setFalse: stopEditing } = useBoolean(false);
  const handleRenameConfirm = React83.useCallback(
    (updatedName) => {
      if (onRenameNode) {
        onRenameNode(itemId, updatedName);
        stopEditing();
      }
    },
    [itemId, onRenameNode, stopEditing]
  );
  const validateEditableQueryName = React83.useCallback(
    (newName) => {
      if (newName !== labelText && validateItemName) {
        return validateItemName(newName);
      }
      return { isValid: true };
    },
    [labelText, validateItemName]
  );
  const handleClick = React83.useCallback(() => {
    (0, import_invariant12.default)(toolpadNodeId, "DataTreeItem should only be used for nodes with a toolpadNodeId");
    onSelectNode == null ? void 0 : onSelectNode(toolpadNodeId);
  }, [onSelectNode, toolpadNodeId]);
  const queryCreationMode = React83.useMemo(() => {
    if (props2.itemId === ":query") {
      return "query";
    }
    if (props2.itemId === ":mutation") {
      return "mutation";
    }
    return void 0;
  }, [props2.itemId]);
  return React83.createElement(
    StyledTreeItem2,
    {
      itemId,
      labelText,
      renderLabel: (children) => React83.createElement(Box_default2, { sx: { display: "flex", alignItems: "center" }, onClick: handleClick }, React83.createElement(QueryIcon, { id: labelIconId || "query", sx: { fontSize: 24, my: 0, ...labelIconSx } }), children, onCreate ? React83.createElement(
        IconButton_default,
        {
          "aria-label": createLabelText,
          onClick: (event) => {
            onCreate(event, queryCreationMode);
          },
          size: "small"
        },
        React83.createElement(Add_default, { fontSize: "inherit" })
      ) : null, toolpadNodeId ? React83.createElement(
        NodeMenu,
        {
          renderButton: ({ buttonProps, menuProps }) => React83.createElement(
            IconButton_default,
            {
              className: clsx_default(classes9.treeItemMenuButton, {
                [classes9.treeItemMenuOpen]: menuProps.open
              }),
              "aria-label": "Open hierarchy menu",
              size: "small",
              ...buttonProps
            },
            React83.createElement(MoreVert_default, { fontSize: "inherit" })
          ),
          nodeId: toolpadNodeId,
          deleteLabelText,
          duplicateLabelText,
          renameLabelText,
          onRenameNode: startEditing,
          onDeleteNode,
          onDuplicateNode
        }
      ) : null),
      suggestedNewItemName: labelText,
      onCancel: stopEditing,
      isEditing,
      ...onRenameNode ? { onEdit: handleRenameConfirm } : {},
      validateItemName: validateEditableQueryName,
      ...other
    }
  );
}
function CreatePopover({
  anchorEl,
  createPopoverOpen,
  handleCreateNode,
  handleCreateClose,
  createMode
}) {
  return React83.createElement(
    Popover_default,
    {
      open: createPopoverOpen,
      anchorEl,
      onClose: handleCreateClose,
      anchorOrigin: {
        vertical: "bottom",
        horizontal: "left"
      }
    },
    React83.createElement(Paper_default, { sx: { p: 2, maxWidth: 500 } }, React83.createElement(Typography_default, { variant: "body2", sx: { mb: 2, textAlign: "center" } }, createMode === "query" ? React83.createElement(React83.Fragment, null, "Make backend data available as state on the page. Read more in the", " ", React83.createElement(
      Link_default,
      {
        href: "https://mui.com/toolpad/studio/concepts/queries/#queries",
        target: "_blank",
        rel: "noopener"
      },
      "docs."
    )) : React83.createElement(React83.Fragment, null, "Run an action on the page. Read more in the", " ", React83.createElement(
      Link_default,
      {
        href: "https://mui.com/toolpad/studio/concepts/queries/#actions",
        target: "_blank",
        rel: "noopener"
      },
      "docs."
    ))), React83.createElement(Stack_default, { direction: "row", gap: 1, display: "grid", gridTemplateColumns: "1fr 1fr" }, Object.keys(client_default3).map((dataSourceId) => {
      const dataSource3 = client_default3[dataSourceId];
      return React83.createElement(
        Button_default,
        {
          key: dataSourceId,
          sx: { minHeight: 50, minWidth: 150 },
          variant: "outlined",
          onClick: handleCreateNode(dataSourceId)
        },
        React83.createElement(QueryIcon, { id: dataSourceId, sx: { fontSize: 28 } }),
        " ",
        (dataSource3 == null ? void 0 : dataSource3.displayName) || dataSourceId
      );
    })))
  );
}
function Explorer({ nodes, setAnchorEl, nodeName, headerText }) {
  var _a;
  const { dom, currentView } = useAppState();
  const appStateApi = useAppStateApi();
  const currentPageName = currentView.name;
  const handleQuerySelect = React83.useCallback(
    (selectedQueryId) => {
      appStateApi.openQueryTab(selectedQueryId);
    },
    [appStateApi]
  );
  const handleCreateClick = React83.useCallback(
    (event) => {
      event.stopPropagation();
      setAnchorEl(event.currentTarget);
    },
    [setAnchorEl]
  );
  const handleDeleteNode = React83.useCallback(
    (selectedQueryId) => {
      var _a2, _b;
      const selectedQueryTabIndex = (_b = (_a2 = currentView.queryPanel) == null ? void 0 : _a2.queryTabs) == null ? void 0 : _b.findIndex(
        (tab) => {
          var _a3;
          return ((_a3 = tab.meta) == null ? void 0 : _a3.id) === selectedQueryId;
        }
      );
      appStateApi.closeQueryTab(selectedQueryId, selectedQueryTabIndex, true);
    },
    [appStateApi, currentView]
  );
  const existingNames = React83.useMemo(() => {
    if (!currentPageName) {
      return void 0;
    }
    const currentPageNode = getPageByName(dom, currentPageName);
    if (!currentPageNode) {
      return void 0;
    }
    return getExistingNamesForChildren(dom, currentPageNode);
  }, [currentPageName, dom]);
  const handleDuplicateNode = React83.useCallback(
    (nodeId) => {
      const node = getNode(dom, nodeId, "query");
      (0, import_invariant12.default)(
        currentPageName,
        "handleDuplicateNode should only be used for queries, which should always belong to a page"
      );
      const currentPageNode = getPageByName(dom, currentPageName);
      const newName = proposeName(node.name, existingNames);
      const copy = createNode(dom, "query", { ...node, name: newName });
      if (!currentPageNode) {
        return;
      }
      appStateApi.update((draft) => addNode(draft, copy, currentPageNode, "queries"), {
        kind: "page",
        name: currentPageName,
        view: { kind: "query", nodeId: copy.id }
      });
    },
    [dom, currentPageName, existingNames, appStateApi]
  );
  const validateName = React83.useCallback(
    (queryName) => {
      if (!existingNames) {
        return {
          isValid: true
        };
      }
      const validationErrorMessage = validateNodeName(queryName, existingNames, "query");
      return {
        isValid: !validationErrorMessage,
        ...validationErrorMessage ? { errorMessage: validationErrorMessage } : {}
      };
    },
    [existingNames]
  );
  const handleRenameNode = React83.useCallback(
    (nodeId, updatedName) => {
      var _a2, _b;
      const node = getNode(dom, nodeId, "query");
      appStateApi.update((draft) => setNodeName(draft, node, updatedName), {
        ...currentView,
        queryPanel: {
          ...currentView.queryPanel,
          queryTabs: (_b = (_a2 = currentView.queryPanel) == null ? void 0 : _a2.queryTabs) == null ? void 0 : _b.map((tab) => {
            var _a3;
            if (((_a3 = tab == null ? void 0 : tab.meta) == null ? void 0 : _a3.id) === nodeId && tab.draft && tab.saved) {
              const updatedNode = { ...tab.draft, name: updatedName };
              return {
                ...tab,
                meta: {
                  ...tab.meta,
                  name: updatedName
                },
                draft: updatedNode,
                saved: updatedNode
              };
            }
            return tab;
          })
        }
      });
    },
    [dom, appStateApi, currentView]
  );
  return React83.createElement(Stack_default, { "data-testid": `${nodeName}-explorer`, sx: { height: "100%", width: "100%" } }, React83.createElement(
    ExplorerHeader,
    {
      headerIcon: React83.createElement(QueryIcon, { mode: nodeName }),
      headerText,
      onCreate: handleCreateClick,
      createLabelText: `Create new ${nodeName}`
    }
  ), React83.createElement(
    SimpleTreeView,
    {
      "aria-label": `${nodeName} explorer`,
      defaultExpandedItems: [`:queries`],
      selectedItems: currentView.kind === "page" && ((_a = currentView.view) == null ? void 0 : _a.kind) === "query" ? currentView.view.nodeId : "",
      sx: {
        flexGrow: 1,
        maxWidth: 400,
        overflowY: "auto",
        scrollbarGutter: "stable"
      }
    },
    nodes.map((node) => {
      var _a2;
      return React83.createElement(
        DataTreeItem,
        {
          key: node.id,
          itemId: node.id,
          toolpadNodeId: node.id,
          "aria-level": 1,
          "aria-label": node.name,
          labelText: node.name,
          labelTextSx: { fontSize: 13 },
          labelIconId: (_a2 = node.attributes) == null ? void 0 : _a2.dataSource,
          onDuplicateNode: handleDuplicateNode,
          onDeleteNode: handleDeleteNode,
          onSelectNode: handleQuerySelect,
          onRenameNode: handleRenameNode,
          validateItemName: validateName
        }
      );
    })
  ));
}
function QueriesExplorer() {
  const { dom, currentView } = useAppState();
  const appStateApi = useAppStateApi();
  const currentPageName = currentView.name;
  const queryNodes = React83.useMemo(() => {
    if (!currentPageName) {
      return [];
    }
    if (currentPageName) {
      const currentPageNode = getPageByName(dom, currentPageName);
      if (currentPageNode) {
        return getChildNodes(dom, currentPageNode).queries ?? [];
      }
    }
    return [];
  }, [currentPageName, dom]);
  const queries = React83.useMemo(() => {
    return queryNodes.filter(
      (query) => {
        var _a, _b;
        return ((_a = query.attributes) == null ? void 0 : _a.mode) === "query" || !((_b = query.attributes) == null ? void 0 : _b.mode);
      }
    );
  }, [queryNodes]);
  const [anchorEl, setAnchorEl] = React83.useState(null);
  const createPopoverOpen = Boolean(anchorEl);
  const handleCreateClose = () => {
    setAnchorEl(null);
  };
  const handleCreateNode = React83.useCallback(
    (dataSourceId) => () => {
      const dataSource3 = client_default3[dataSourceId];
      (0, import_invariant12.default)(dataSource3, `Selected non-existing dataSource "${dataSourceId}"`);
      (0, import_invariant12.default)(
        currentPageName,
        "handleCreateNode should only be used for queries, which should always belong to a page"
      );
      appStateApi.createQueryTab(dataSource3, dataSourceId, "query");
      setAnchorEl(null);
    },
    [currentPageName, appStateApi]
  );
  return React83.createElement(React83.Fragment, null, React83.createElement(Explorer, { nodes: queries, setAnchorEl, headerText: "Queries", nodeName: "query" }), React83.createElement(
    CreatePopover,
    {
      anchorEl,
      createPopoverOpen,
      handleCreateNode,
      handleCreateClose,
      createMode: "query"
    }
  ));
}
function ActionsExplorer() {
  const { dom, currentView } = useAppState();
  const appStateApi = useAppStateApi();
  const currentPageName = currentView.name;
  const queryNodes = React83.useMemo(() => {
    if (!currentPageName) {
      return [];
    }
    if (currentPageName) {
      const currentPageNode = getPageByName(dom, currentPageName);
      if (currentPageNode) {
        return getChildNodes(dom, currentPageNode).queries ?? [];
      }
    }
    return [];
  }, [currentPageName, dom]);
  const actions = React83.useMemo(() => {
    return queryNodes.filter((query) => {
      var _a;
      return ((_a = query.attributes) == null ? void 0 : _a.mode) === "mutation";
    });
  }, [queryNodes]);
  const [anchorEl, setAnchorEl] = React83.useState(null);
  const createPopoverOpen = Boolean(anchorEl);
  const handleCreateClose = () => {
    setAnchorEl(null);
  };
  const handleCreateNode = React83.useCallback(
    (dataSourceId) => () => {
      const dataSource3 = client_default3[dataSourceId];
      (0, import_invariant12.default)(dataSource3, `Selected non-existing dataSource "${dataSourceId}"`);
      (0, import_invariant12.default)(
        currentPageName,
        "handleCreateNode should only be used for queries, which should always belong to a page"
      );
      appStateApi.createQueryTab(dataSource3, dataSourceId, "mutation");
      setAnchorEl(null);
    },
    [currentPageName, appStateApi]
  );
  return React83.createElement(React83.Fragment, null, React83.createElement(Explorer, { nodes: actions, setAnchorEl, headerText: "Actions", nodeName: "action" }), React83.createElement(
    CreatePopover,
    {
      anchorEl,
      createPopoverOpen,
      handleCreateNode,
      handleCreateClose,
      createMode: "mutation"
    }
  ));
}
var PAGE_PANEL_WIDTH = 250;
var PagePanelRoot = styled_default("div")({
  display: "flex",
  flexDirection: "column",
  width: PAGE_PANEL_WIDTH
});
function PagePanel({ className, sx }) {
  const project = useProject();
  const { dom, currentView } = useAppState();
  const currentPageNode = (currentView == null ? void 0 : currentView.name) ? getPageByName(dom, currentView.name) : null;
  return React84.createElement(PagePanelRoot, { className, sx }, React84.createElement(
    Box_default2,
    {
      sx: {
        pl: 2,
        pr: 1,
        py: 1,
        display: "flex",
        flexDirection: "row",
        justifyContent: "space-between",
        alignItems: "center"
      }
    },
    React84.createElement(Typography_default, { noWrap: true }, project.rootDir.split(/[/\\]/).pop()),
    React84.createElement(AppOptions_default, { dom })
  ), React84.createElement(Divider_default, null), React84.createElement(resizablePanels_exports.PanelGroup, { autoSaveId: "toolpad-page-panel", direction: "vertical" }, React84.createElement(resizablePanels_exports.Panel, { id: "pages-explorer", order: 1, minSize: 10, defaultSize: 25 }, React84.createElement(PagesExplorer, null)), currentPageNode ? React84.createElement(React84.Fragment, null, React84.createElement(PanelResizeHandle2, null), React84.createElement(resizablePanels_exports.Panel, { id: "hierarchy-explorer", order: 2, minSize: 10, defaultSize: 25, maxSize: 90 }, React84.createElement(HierarchyExplorer, null)), React84.createElement(PanelResizeHandle2, null), React84.createElement(resizablePanels_exports.Panel, { id: "queries-explorer", order: 3, minSize: 10, defaultSize: 25, maxSize: 90 }, React84.createElement(QueriesExplorer, null)), React84.createElement(PanelResizeHandle2, null), React84.createElement(resizablePanels_exports.Panel, { id: "actions-explorer", order: 4, minSize: 10, defaultSize: 25, maxSize: 90 }, React84.createElement(ActionsExplorer, null))) : null));
}
var MarkdownEditor = lazyComponent(() => import("./MarkdownEditor-X7TRCJOM-R2JUUUAX.js"), {
  noSsr: true,
  fallback: React85.createElement(Skeleton_default, { variant: "rectangular", height: "100%" })
});
function MarkdownPropEditor({ propType, value, onChange }) {
  const [dialogOpen, setDialogOpen] = React85.useState(false);
  useShortcut({ key: "s", metaKey: true, disabled: !dialogOpen }, () => {
    setDialogOpen(false);
  });
  return React85.createElement(React85.Fragment, null, React85.createElement(PropertyControl, { propType }, React85.createElement(Button_default, { variant: "outlined", color: "inherit", fullWidth: true, onClick: () => setDialogOpen(true) }, "Edit Markdown")), React85.createElement(Dialog_default, { fullWidth: true, open: dialogOpen, onClose: () => setDialogOpen(false) }, React85.createElement(DialogTitle_default, null, "Edit Markdown"), React85.createElement(DialogContent_default, null, React85.createElement(Box_default2, { sx: { height: 200 } }, React85.createElement(MarkdownEditor, { value, onChange: (newValue = "") => onChange(newValue) }))), React85.createElement(DialogActions_default, null, React85.createElement(Button_default, { color: "inherit", variant: "text", onClick: () => setDialogOpen(false) }, "Done"))));
}
var Markdown_default = MarkdownPropEditor;
var PropControlToggleButtonGroup = styled_default(
  ToggleButtonGroup_default,
  {}
)(({ fullWidth }) => ({
  display: "flex",
  [`& .${toggleButtonClasses_default.root}`]: fullWidth ? {
    flex: 1
  } : {}
}));
function ToggleButtonSelect({
  options: options2,
  label,
  value,
  onChange,
  disabled,
  fullWidth
}) {
  const handleChange = React86.useCallback(
    (event, newValue) => {
      onChange == null ? void 0 : onChange(newValue);
    },
    [onChange]
  );
  return React86.createElement(FormControl_default, null, React86.createElement(FormLabel_default, null, label), React86.createElement(
    PropControlToggleButtonGroup,
    {
      color: "primary",
      value,
      exclusive: true,
      onChange: handleChange,
      "aria-label": "Platform",
      disabled,
      fullWidth
    },
    options2 == null ? void 0 : options2.map((option) => {
      const optionValue = typeof option === "string" ? option : option.value;
      const optionLabel = (typeof option === "string" ? option : option.label) || optionValue;
      return React86.createElement(ToggleButton_default, { key: optionValue, value: optionValue }, optionLabel);
    })
  ));
}
var ToggleButtonSelect_default = ToggleButtonSelect;
var COLUMN_TYPES = [
  "string",
  "number",
  "date",
  "dateTime",
  "boolean",
  "link",
  "image",
  "codeComponent"
];
var ALIGNMENTS = ["left", "right", "center"];
function useImmediateTextField(props2) {
  const { value, onChange, error, helperText, required, onBlur, validate } = props2;
  const createInputState = React87.useCallback(
    (rawInput) => {
      const input = String(rawInput);
      let inputError = null;
      if (required && !input) {
        inputError = "Input required";
      } else if (validate) {
        inputError = validate(input);
      }
      return { input, error: inputError };
    },
    [validate, required]
  );
  const [state, setState] = React87.useState(createInputState(value));
  React87.useEffect(() => {
    setState(createInputState(value));
  }, [value, createInputState]);
  return {
    ...props2,
    value: state.input,
    error: !!state.error || error,
    helperText: state.error || helperText,
    required,
    onBlur: (event) => {
      if (state.input !== value) {
        setState(createInputState(value));
      }
      onBlur == null ? void 0 : onBlur(event);
    },
    onChange: (event) => {
      const newState = createInputState(event.target.value);
      setState(newState);
      if (!newState.error) {
        onChange == null ? void 0 : onChange(event);
      }
    }
  };
}
function GridColumnEditor({
  disabled,
  value: editedColumn,
  onChange: handleColumnChange
}) {
  const toolpadComponents = useToolpadComponents();
  const codeComponents = React87.useMemo(() => {
    return Object.values(toolpadComponents).filter(Boolean).filter((definition) => !definition.builtIn);
  }, [toolpadComponents]);
  const fieldInput = useImmediateTextField({
    label: "field",
    disabled,
    required: true,
    value: editedColumn.field,
    onChange: (event) => {
      handleColumnChange({ ...editedColumn, field: event.target.value });
    }
  });
  const appHost = useAppHost();
  const isProPlan = appHost.plan === "pro";
  return React87.createElement(Stack_default, { gap: 1, py: 1 }, React87.createElement(TextField_default, { ...fieldInput }), React87.createElement(
    TextField_default,
    {
      label: "header",
      value: editedColumn.headerName || "",
      disabled,
      onChange: (event) => handleColumnChange({
        ...editedColumn,
        headerName: event.target.value ? event.target.value : void 0
      })
    }
  ), React87.createElement(
    TextField_default,
    {
      select: true,
      fullWidth: true,
      label: "align",
      value: editedColumn.align ?? "",
      disabled,
      onChange: (event) => handleColumnChange({
        ...editedColumn,
        align: event.target.value || void 0
      })
    },
    ALIGNMENTS.map((alignment) => React87.createElement(MenuItem_default, { key: alignment, value: alignment }, alignment))
  ), React87.createElement(
    TextField_default,
    {
      label: "width",
      type: "number",
      value: editedColumn.width,
      disabled,
      onChange: (event) => handleColumnChange({ ...editedColumn, width: Number(event.target.value) })
    }
  ), React87.createElement(
    TextField_default,
    {
      select: true,
      fullWidth: true,
      label: "type",
      value: editedColumn.type ?? "",
      disabled,
      onChange: (event) => handleColumnChange({
        ...editedColumn,
        type: event.target.value,
        numberFormat: void 0
      })
    },
    COLUMN_TYPES.map((type) => React87.createElement(MenuItem_default, { key: type, value: type }, type))
  ), React87.createElement(Box_default2, { sx: { ml: 1, pl: 1, borderLeft: 1, borderColor: "divider" } }, editedColumn.type === "number" ? React87.createElement(
    NumberFormatEditor,
    {
      disabled,
      value: editedColumn.numberFormat,
      onChange: (numberFormat) => handleColumnChange({ ...editedColumn, numberFormat })
    }
  ) : null, editedColumn.type === "date" ? React87.createElement(
    DateFormatEditor,
    {
      disabled,
      disableTimeFormat: true,
      value: editedColumn.dateFormat,
      onChange: (dateFormat) => {
        handleColumnChange({ ...editedColumn, dateFormat });
      }
    }
  ) : null, editedColumn.type === "dateTime" ? React87.createElement(
    DateFormatEditor,
    {
      disabled,
      value: editedColumn.dateTimeFormat,
      onChange: (dateTimeFormat) => {
        handleColumnChange({ ...editedColumn, dateTimeFormat });
      }
    }
  ) : null, editedColumn.type === "codeComponent" ? React87.createElement(
    TextField_default,
    {
      select: true,
      required: true,
      fullWidth: true,
      label: "Custom component",
      value: editedColumn.codeComponent ?? "",
      disabled,
      error: !editedColumn.codeComponent,
      helperText: editedColumn.codeComponent ? void 0 : "Please select a component",
      onChange: (event) => handleColumnChange({
        ...editedColumn,
        codeComponent: event.target.value
      })
    },
    codeComponents.map(({ displayName }) => React87.createElement(MenuItem_default, { key: displayName, value: displayName }, displayName))
  ) : null), React87.createElement(Tooltip_default, { title: "Initial visibility of this column." }, React87.createElement(
    FormControlLabel_default,
    {
      control: React87.createElement(
        Checkbox_default,
        {
          checked: editedColumn.visible ?? true,
          disabled,
          onChange: (event) => handleColumnChange({
            ...editedColumn,
            visible: event.target.checked
          })
        }
      ),
      label: "Visible"
    }
  )), React87.createElement(
    FormControlLabel_default,
    {
      control: React87.createElement(
        Checkbox_default,
        {
          checked: editedColumn.sortable ?? true,
          disabled,
          onChange: (event) => handleColumnChange({
            ...editedColumn,
            sortable: event.target.checked
          })
        }
      ),
      label: "Sortable"
    }
  ), React87.createElement(
    FormControlLabel_default,
    {
      control: React87.createElement(
        Checkbox_default,
        {
          checked: editedColumn.filterable ?? true,
          disabled,
          onChange: (event) => handleColumnChange({
            ...editedColumn,
            filterable: event.target.checked
          })
        }
      ),
      label: "Filterable"
    }
  ), React87.createElement(
    FormControlLabel_default,
    {
      control: React87.createElement(
        Checkbox_default,
        {
          checked: editedColumn.editable ?? true,
          disabled,
          onChange: (event) => handleColumnChange({
            ...editedColumn,
            editable: event.target.checked
          })
        }
      ),
      label: "Editable"
    }
  ), isProPlan ? React87.createElement(React87.Fragment, null, React87.createElement(
    FormControlLabel_default,
    {
      control: React87.createElement(
        Checkbox_default,
        {
          checked: editedColumn.groupable ?? true,
          disabled,
          onChange: (event) => handleColumnChange({
            ...editedColumn,
            groupable: event.target.checked
          })
        }
      ),
      label: "Groupable"
    }
  ), React87.createElement(
    FormControlLabel_default,
    {
      control: React87.createElement(
        Checkbox_default,
        {
          checked: editedColumn.aggregable ?? true,
          disabled,
          onChange: (event) => handleColumnChange({
            ...editedColumn,
            aggregable: event.target.checked
          })
        }
      ),
      label: "Aggregable"
    }
  ), React87.createElement(
    ToggleButtonSelect_default,
    {
      options: ["left", "center", "right"],
      fullWidth: true,
      label: "Pinned",
      value: editedColumn.pin ?? "center",
      onChange: (pin) => handleColumnChange({ ...editedColumn, pin: pin === "center" ? void 0 : pin })
    }
  )) : React87.createElement(Typography_default, { variant: "body2" }, "Grouping/aggregation/pinning", React87.createElement(
    UpgradeChip,
    {
      sx: { ml: 1 },
      url: "https://mui.com/toolpad/studio/components/data-grid/#grouping"
    }
  )));
}
function GridColumnsPropEditor({
  propType,
  label,
  nodeId,
  value = [],
  onChange,
  disabled
}) {
  const { nodeData } = usePageEditorState();
  const [editedIndex, setEditedIndex] = React87.useState(null);
  const editedColumn = typeof editedIndex === "number" ? value[editedIndex] : null;
  const [menuAnchorEl, setMenuAnchorEl] = React87.useState(null);
  const menuOpen = Boolean(menuAnchorEl);
  const handleMenuClick = (event) => {
    setMenuAnchorEl(event.currentTarget);
  };
  const handleClose = () => {
    setMenuAnchorEl(null);
  };
  const gridNodeData = nodeId && nodeData[nodeId];
  const rawRows = gridNodeData && gridNodeData.rawRows;
  const inferredColumns = React87.useMemo(
    () => inferColumns(Array.isArray(rawRows) ? rawRows : []),
    [rawRows]
  );
  const columnSuggestions = React87.useMemo(() => {
    const existingFields = new Set(value.map(({ field }) => field));
    return inferredColumns.filter((column2) => !existingFields.has(column2.field));
  }, [inferredColumns, value]);
  const handleCreateColumn = React87.useCallback(
    (suggestion) => () => {
      const existingFields = new Set(value.map(({ field }) => field));
      const newFieldName = generateUniqueString(suggestion.field, existingFields);
      const newValue = [...value, { ...suggestion, field: newFieldName }];
      onChange(newValue);
      setEditedIndex(newValue.length - 1);
      handleClose();
    },
    [value, onChange]
  );
  const handleColumnItemClick = React87.useCallback(
    (index) => () => {
      setEditedIndex(index);
    },
    []
  );
  const handleColumnChange = React87.useCallback(
    (newValue) => {
      onChange(value.map((column2, i) => i === editedIndex ? newValue : column2));
    },
    [editedIndex, onChange, value]
  );
  const handleColumnDelete = React87.useCallback(
    (deletedIndex) => (event) => {
      event.stopPropagation();
      onChange(value.filter((column2, i) => i !== deletedIndex));
    },
    [onChange, value]
  );
  const handleRecreateColumns = React87.useCallback(() => {
    if (inferredColumns.length > 0) {
      onChange(inferredColumns);
    }
  }, [inferredColumns, onChange]);
  const [anchorEl, setAnchorEl] = React87.useState(null);
  const handlePopoverClick = (event) => {
    setAnchorEl(event.currentTarget);
  };
  const handlePopoverClose = () => {
    setAnchorEl(null);
  };
  const open = Boolean(anchorEl);
  const popoverIdValue = React87.useId();
  const popoverId = open ? popoverIdValue : void 0;
  React87.useEffect(() => {
    if (open) {
      setEditedIndex(null);
    }
  }, [open]);
  return React87.createElement(React87.Fragment, null, React87.createElement(PropertyControl, { propType }, React87.createElement(Button_default, { "aria-describedby": popoverId, onClick: handlePopoverClick }, label)), React87.createElement(
    Popover_default,
    {
      id: popoverId,
      open,
      anchorEl,
      onClose: handlePopoverClose,
      anchorOrigin: {
        vertical: "center",
        horizontal: "left"
      },
      transformOrigin: {
        vertical: "center",
        horizontal: "left"
      }
    },
    React87.createElement(Box_default2, { sx: { minWidth: 300, p: 2 }, "aria-label": "Column editor" }, editedColumn ? React87.createElement(React87.Fragment, null, React87.createElement(IconButton_default, { "aria-label": "Back", onClick: () => setEditedIndex(null) }, React87.createElement(ArrowBack_default, null)), React87.createElement(
      GridColumnEditor,
      {
        value: editedColumn,
        onChange: handleColumnChange,
        disabled
      }
    )) : React87.createElement(React87.Fragment, null, React87.createElement(Tooltip_default, { describeChild: true, title: "Recreate columns" }, React87.createElement("span", null, React87.createElement(
      IconButton_default,
      {
        "aria-label": "Recreate columns",
        onClick: handleRecreateColumns,
        disabled: inferredColumns.length <= 0
      },
      React87.createElement(Refresh_default, null)
    ))), React87.createElement(Tooltip_default, { title: "Add column" }, React87.createElement(IconButton_default, { onClick: handleMenuClick, disabled }, React87.createElement(Add_default, null))), React87.createElement(
      Menu_default,
      {
        id: "new-column-menu",
        anchorEl: menuAnchorEl,
        open: menuOpen,
        onClose: handleClose,
        MenuListProps: {
          "aria-labelledby": "basic-button"
        }
      },
      columnSuggestions.map((suggestion) => React87.createElement(MenuItem_default, { key: suggestion.field, onClick: handleCreateColumn(suggestion) }, suggestion.field)),
      React87.createElement(MenuItem_default, { onClick: handleCreateColumn({ field: "new" }) }, "New column")
    ), React87.createElement(List_default, null, value.map((colDef, i) => {
      return React87.createElement(
        ListItem_default,
        {
          key: colDef.field,
          disableGutters: true,
          onClick: handleColumnItemClick(i),
          secondaryAction: React87.createElement(
            IconButton_default,
            {
              "aria-label": "Remove column",
              edge: "end",
              onClick: handleColumnDelete(i)
            },
            React87.createElement(Delete_default, null)
          )
        },
        React87.createElement(ListItemButton_default, null, React87.createElement(ListItemText_default, { primary: colDef.headerName || colDef.field }))
      );
    }))))
  ));
}
var GridColumns_default = GridColumnsPropEditor;
var PropControlToggleButtonGroup2 = styled_default(ToggleButtonGroup_default)({
  display: "flex",
  [`& .${toggleButtonClasses_default.root}`]: {
    flex: 1
  }
});
function SelectPropEditor2({ label, propType, value, onChange, disabled }) {
  const items = propType.type === "string" ? propType.enum ?? [] : [];
  const handleChange = React88.useCallback(
    (event, newValue) => {
      onChange(newValue || void 0);
    },
    [onChange]
  );
  const enumLabels = propType.type === "string" ? propType.enumLabels ?? {} : {};
  return React88.createElement(PropertyControl, { propType }, React88.createElement(Box_default2, { sx: { my: 0.5 } }, React88.createElement(Typography_default, { variant: "body2" }, label), React88.createElement(
    PropControlToggleButtonGroup2,
    {
      color: "primary",
      value,
      exclusive: true,
      onChange: handleChange,
      "aria-label": "Platform",
      disabled
    },
    items.map((item) => React88.createElement(ToggleButton_default, { key: item, value: item }, enumLabels[item] || item))
  )));
}
var ToggleButtons_default = SelectPropEditor2;
function SelectOptionsPropEditor({
  propType,
  label,
  value = [],
  onChange
}) {
  const [editOptionsDialogOpen, setEditOptionsDialogOpen] = React89.useState(false);
  const [editingIndex, setEditingIndex] = React89.useState(null);
  const [input, setInput] = React89.useState("");
  const editingOption = React89.useMemo(() => {
    if (typeof editingIndex === "number") {
      const option = value[editingIndex];
      if (typeof option === "string") {
        return {
          value: option,
          label: ""
        };
      }
      return option;
    }
    return null;
  }, [editingIndex, value]);
  const handleOptionTextInput = React89.useCallback(
    (event) => {
      if (event.key === "Enter") {
        onChange([...value, input]);
        setInput("");
      }
    },
    [input, onChange, value]
  );
  const handleOptionDelete = React89.useCallback(
    (deletedIndex) => (event) => {
      event.stopPropagation();
      onChange(value.filter((column2, i) => i !== deletedIndex));
    },
    [onChange, value]
  );
  const handleDeleteAll = React89.useCallback(() => {
    onChange([]);
  }, [onChange]);
  const handleOptionItemClick = React89.useCallback(
    (index) => () => {
      setEditingIndex(index);
    },
    []
  );
  const handleOptionChange = React89.useCallback(
    (newOption) => {
      if (typeof newOption === "object") {
        if (!newOption.label) {
          newOption = newOption.value;
        }
      }
      onChange(value.map((option, i) => i === editingIndex ? newOption : option));
    },
    [editingIndex, onChange, value]
  );
  const handleEditOptionsDialogClose = React89.useCallback(() => {
    setEditingIndex(null);
    setEditOptionsDialogOpen(false);
  }, []);
  return React89.createElement(React89.Fragment, null, React89.createElement(PropertyControl, { propType }, React89.createElement(
    Button_default,
    {
      variant: "outlined",
      color: "inherit",
      fullWidth: true,
      onClick: () => {
        setEditOptionsDialogOpen(true);
      }
    },
    label
  )), React89.createElement(
    Dialog_default,
    {
      fullWidth: true,
      open: editOptionsDialogOpen,
      onClose: () => {
        setEditOptionsDialogOpen(false);
      }
    },
    editingOption ? React89.createElement(React89.Fragment, null, React89.createElement(DialogTitle_default, null, React89.createElement(IconButton_default, { "aria-label": "Back", onClick: () => setEditingIndex(null) }, React89.createElement(ArrowBack_default, null)), "Edit option “", editingOption.value, "”"), React89.createElement(DialogContent_default, null, React89.createElement(Stack_default, { gap: 1, py: 1 }, React89.createElement(
      TextField_default,
      {
        label: "Value",
        value: editingOption.value,
        onChange: (event) => {
          handleOptionChange({ ...editingOption, value: event.target.value });
        }
      }
    ), React89.createElement(
      TextField_default,
      {
        label: "Label",
        value: editingOption.label,
        onChange: (event) => {
          handleOptionChange({ ...editingOption, label: event.target.value });
        }
      }
    )))) : React89.createElement(React89.Fragment, null, React89.createElement(DialogTitle_default, null, "Edit options", value.length > 0 ? React89.createElement(
      Button_default,
      {
        "aria-label": "Delete all options",
        variant: "text",
        color: "inherit",
        onClick: handleDeleteAll,
        sx: {
          position: "absolute",
          right: 16,
          top: 16
        }
      },
      "Delete All"
    ) : null), React89.createElement(DialogContent_default, null, value.length > 0 ? React89.createElement(List_default, null, value.map((option, i) => {
      return React89.createElement(
        ListItem_default,
        {
          key: i,
          disableGutters: true,
          onClick: handleOptionItemClick(i),
          secondaryAction: React89.createElement(
            IconButton_default,
            {
              "aria-label": "Delete option",
              edge: "end",
              onClick: handleOptionDelete(i)
            },
            React89.createElement(Delete_default, null)
          )
        },
        React89.createElement(ListItemButton_default, null, React89.createElement(
          ListItemText_default,
          {
            primary: typeof option === "string" ? option : option.value,
            secondary: typeof option === "object" ? `Label: "${option.label}"` : null
          }
        ))
      );
    })) : null, React89.createElement(
      TextField_default,
      {
        fullWidth: true,
        sx: { my: 1 },
        variant: "outlined",
        value: input,
        onChange: (event) => setInput(event.target.value),
        onKeyUp: handleOptionTextInput,
        label: "Add option",
        helperText: React89.createElement("span", null, "Press ", React89.createElement("kbd", null, "Enter"), " or ", React89.createElement("kbd", null, "Return"), " to add")
      }
    ))),
    React89.createElement(DialogActions_default, null, React89.createElement(Button_default, { color: "inherit", variant: "text", onClick: handleEditOptionsDialogClose }, "Close"))
  ));
}
var SelectOptions_default = SelectOptionsPropEditor;
function ColorPickerIconButton({ label, value, onChange }) {
  const [anchorEl, setAnchorEl] = React90.useState(null);
  const handleClick = (event) => {
    setAnchorEl(event.currentTarget);
  };
  const handleClose = () => {
    setAnchorEl(null);
  };
  const open = Boolean(anchorEl);
  const id = React90.useId();
  return React90.createElement(React90.Fragment, null, React90.createElement(IconButton_default, { "aria-label": "select color", edge: "end", onClick: handleClick }, React90.createElement(
    Box_default2,
    {
      sx: {
        background: value,
        width: 24,
        height: 24,
        borderRadius: "50%",
        boxShadow: 1
      }
    }
  )), React90.createElement(
    Popover_default,
    {
      id: open ? id : void 0,
      open,
      anchorEl,
      onClose: handleClose,
      anchorOrigin: {
        vertical: "bottom",
        horizontal: "left"
      }
    },
    React90.createElement(ColorTool_default, { sx: { m: 2 }, label, value, onChange })
  ));
}
function ColorPicker({ label, value, onChange }) {
  return React90.createElement(
    TextField_default,
    {
      label,
      value,
      onChange: (event) => onChange == null ? void 0 : onChange(event.target.value),
      slotProps: {
        input: {
          endAdornment: React90.createElement(InputAdornment_default, { position: "end" }, React90.createElement(ColorPickerIconButton, { value, onChange, label }))
        }
      }
    }
  );
}
var CHART_KIND_OPTIONS = [
  { kind: "line", icon: ShowChart_default },
  { kind: "bar", icon: BarChart_default },
  { kind: "area", icon: LegendToggle_default },
  { kind: "scatter", icon: ScatterPlot_default }
];
function ChartDataPropEditor({
  nodeId,
  propType,
  value = [],
  onChange
}) {
  const { dom } = useAppState();
  const domApi = useDomApi();
  const { pageState, bindings, globalScopeMeta } = usePageEditorState();
  const jsBrowserRuntime = useBrowserJsRuntime();
  const appTheme = React91.useMemo(() => createToolpadAppTheme(dom), [dom]);
  const defaultPalette = blueberryTwilightPalette(appTheme.palette.mode);
  const [dataSeriesEditIndex, setDataSeriesEditIndex] = React91.useState(null);
  const [popoverAnchorElement, setPopoverAnchorElement] = React91.useState(null);
  const handleAddDataSeries = React91.useCallback(() => {
    const newDataSeriesCount = value.length + 1;
    const newDataSeriesLabel = `dataSeries${newDataSeriesCount}`;
    onChange([
      ...value,
      {
        label: newDataSeriesLabel,
        kind: "line",
        data: [],
        color: defaultPalette[(newDataSeriesCount - 1) % defaultPalette.length]
      }
    ]);
  }, [defaultPalette, onChange, value]);
  const previousDataSeriesCountRef = React91.useRef(value.length);
  React91.useEffect(() => {
    if (previousDataSeriesCountRef.current === 0 && value.length === 1) {
      setDataSeriesEditIndex(0);
      setPopoverAnchorElement(document.getElementById("data-series-button-1"));
    }
    previousDataSeriesCountRef.current = value.length;
  }, [value.length]);
  const handleDataSeriesClick = React91.useCallback(
    (index) => (event) => {
      setDataSeriesEditIndex(index);
      setPopoverAnchorElement(event.currentTarget);
    },
    []
  );
  const handleDuplicateDataSeries = React91.useCallback(
    (index) => () => {
      const newDataSeriesCount = value.length + 1;
      onChange([
        ...value.slice(0, index + 1),
        {
          ...value[index],
          color: defaultPalette[(newDataSeriesCount - 1) % defaultPalette.length]
        },
        ...value.slice(index + 1)
      ]);
    },
    [defaultPalette, onChange, value]
  );
  const handleRemoveDataSeries = React91.useCallback(
    (index) => () => {
      onChange(remove(value, index));
    },
    [onChange, value]
  );
  const popoverId = React91.useId();
  const isPopoverOpen = Boolean(popoverAnchorElement);
  const handlePopoverClose = React91.useCallback(() => {
    setPopoverAnchorElement(null);
  }, []);
  const updateDataSeriesProp = React91.useCallback(
    (draft, index, newValue, propName, defaultValue = "") => {
      var _a;
      const draftNode = nodeId ? getMaybeNode(draft, nodeId) : null;
      if (draftNode) {
        const previousData = ((_a = draftNode.props) == null ? void 0 : _a.data) || [];
        return setNodeNamespacedProp(
          draft,
          draftNode,
          "props",
          "data",
          updateArray(
            previousData,
            {
              ...previousData[index],
              [propName]: newValue || defaultValue
            },
            index
          )
        );
      }
      return draft;
    },
    [nodeId]
  );
  const handleDataSeriesDataChange = React91.useCallback(
    (index) => (newValue) => {
      const previousDataSeries = value[index];
      domApi.update((draft) => {
        draft = updateDataSeriesProp(draft, index, newValue, "data", []);
        if (!previousDataSeries.xKey || !previousDataSeries.yKey) {
          const newDataResult = evaluateBindable(jsBrowserRuntime, newValue, pageState).value || [];
          let inferredXKey;
          const keySuggestions = newDataResult.flatMap((dataSeriesPoint) => Object.keys(dataSeriesPoint)).filter((key2, pointIndex, array) => array.indexOf(key2) === pointIndex);
          if (!previousDataSeries.xKey) {
            inferredXKey = keySuggestions.find(
              (key2) => newDataResult.every((dataSeriesPoint) => typeof dataSeriesPoint[key2] === "string")
            ) || keySuggestions[0];
            draft = updateDataSeriesProp(draft, index, inferredXKey, "xKey");
          }
          if (!previousDataSeries.yKey) {
            const xKey = previousDataSeries.xKey || inferredXKey;
            const inferredYKey = xKey && xKey === keySuggestions[0] ? keySuggestions[1] : keySuggestions[0];
            draft = updateDataSeriesProp(draft, index, inferredYKey, "yKey");
          }
        }
        return draft;
      });
    },
    [domApi, jsBrowserRuntime, pageState, updateDataSeriesProp, value]
  );
  const handleDataSeriesTextInputPropChange = React91.useCallback(
    (index, propName) => (event) => {
      const newValue = event.target.value;
      domApi.update((draft) => updateDataSeriesProp(draft, index, newValue, propName));
    },
    [domApi, updateDataSeriesProp]
  );
  const handleDataSeriesAutocompletePropChange = React91.useCallback(
    (index, propName) => (event, newValue) => {
      domApi.update((draft) => updateDataSeriesProp(draft, index, newValue, propName));
    },
    [domApi, updateDataSeriesProp]
  );
  const handleDataSeriesColorChange = React91.useCallback(
    (index) => (newValue) => {
      domApi.update((draft) => updateDataSeriesProp(draft, index, newValue, "color"));
    },
    [domApi, updateDataSeriesProp]
  );
  const dataSeriesKeySuggestions = React91.useMemo(
    () => value.map((dataSeries) => {
      const dataResult = evaluateBindable(jsBrowserRuntime, dataSeries.data, pageState).value || [];
      return Array.isArray(dataResult) ? dataResult.flatMap((dataSeriesPoint) => Object.keys(dataSeriesPoint)).filter((key2, index, array) => array.indexOf(key2) === index) : [];
    }),
    [jsBrowserRuntime, pageState, value]
  );
  const editDataSeries = dataSeriesEditIndex !== null ? value[dataSeriesEditIndex] : null;
  return React91.createElement(React91.Fragment, null, React91.createElement(PropertyControl, { propType }, React91.createElement("div", null, React91.createElement(List_default, { sx: { mb: 1 } }, value.map((dataSeries, index) => {
    const { label } = dataSeries;
    return React91.createElement(ListItem_default, { key: index, disableGutters: true }, React91.createElement(
      ListItemButton_default,
      {
        id: `data-series-button-${index + 1}`,
        onClick: handleDataSeriesClick(index),
        "aria-describedby": popoverId
      },
      React91.createElement(
        ListItemText_default,
        {
          primary: label,
          primaryTypographyProps: {
            style: { overflow: "hidden", textOverflow: "ellipsis", maxWidth: 166 }
          }
        }
      )
    ), React91.createElement(
      IconButton_default,
      {
        "aria-label": "Duplicate data series",
        onClick: handleDuplicateDataSeries(index)
      },
      React91.createElement(ContentCopy_default, null)
    ), React91.createElement(
      IconButton_default,
      {
        "aria-label": "Delete data series",
        onClick: handleRemoveDataSeries(index)
      },
      React91.createElement(Delete_default, null)
    ));
  })), React91.createElement(
    Button_default,
    {
      variant: "outlined",
      startIcon: React91.createElement(Add_default, null),
      fullWidth: true,
      onClick: handleAddDataSeries
    },
    "Add data series"
  ))), React91.createElement(
    Popover_default,
    {
      id: popoverId,
      open: isPopoverOpen,
      anchorEl: popoverAnchorElement,
      onClose: handlePopoverClose,
      anchorOrigin: {
        vertical: "bottom",
        horizontal: "center"
      }
    },
    editDataSeries && dataSeriesEditIndex !== null ? React91.createElement(Box_default2, { sx: { minWidth: 300, p: 2 } }, React91.createElement(Typography_default, { variant: "body1", sx: { mb: 1 } }, editDataSeries.label), React91.createElement(Stack_default, { gap: 1, py: 1 }, React91.createElement(
      TextField_default,
      {
        label: "label",
        value: editDataSeries == null ? void 0 : editDataSeries.label,
        onChange: handleDataSeriesTextInputPropChange(dataSeriesEditIndex, "label")
      }
    ), React91.createElement(
      TextField_default,
      {
        select: true,
        label: "kind",
        value: editDataSeries == null ? void 0 : editDataSeries.kind,
        onChange: handleDataSeriesTextInputPropChange(dataSeriesEditIndex, "kind")
      },
      CHART_KIND_OPTIONS.map((option) => React91.createElement(MenuItem_default, { key: option.kind, value: option.kind }, React91.createElement(Stack_default, { direction: "row", alignItems: "center" }, React91.createElement(option.icon, null), React91.createElement(ListItemText_default, { sx: { ml: 1 } }, option.kind))))
    ), React91.createElement(
      BindableEditor,
      {
        liveBinding: bindings[`${nodeId}.props.data[${dataSeriesEditIndex}].data`],
        globalScope: pageState,
        globalScopeMeta,
        label: "data",
        jsRuntime: jsBrowserRuntime,
        propType: { type: "array" },
        value: (editDataSeries == null ? void 0 : editDataSeries.data) ?? null,
        onChange: handleDataSeriesDataChange(dataSeriesEditIndex)
      }
    ), React91.createElement(
      Autocomplete_default,
      {
        freeSolo: true,
        options: dataSeriesKeySuggestions[dataSeriesEditIndex],
        value: (editDataSeries == null ? void 0 : editDataSeries.xKey) || "",
        onInputChange: handleDataSeriesAutocompletePropChange(dataSeriesEditIndex, "xKey"),
        renderInput: (params) => {
          const keyExists = !(editDataSeries == null ? void 0 : editDataSeries.xKey) || dataSeriesKeySuggestions[dataSeriesEditIndex].includes(editDataSeries.xKey);
          return React91.createElement(
            TextField_default,
            {
              ...params,
              label: "xKey",
              error: !keyExists,
              helperText: keyExists ? "" : "Property not present in data"
            }
          );
        }
      }
    ), React91.createElement(
      Autocomplete_default,
      {
        freeSolo: true,
        options: dataSeriesKeySuggestions[dataSeriesEditIndex],
        value: (editDataSeries == null ? void 0 : editDataSeries.yKey) || "",
        onInputChange: handleDataSeriesAutocompletePropChange(dataSeriesEditIndex, "yKey"),
        renderInput: (params) => {
          const keyExists = !(editDataSeries == null ? void 0 : editDataSeries.yKey) || dataSeriesKeySuggestions[dataSeriesEditIndex].includes(editDataSeries.yKey);
          return React91.createElement(
            TextField_default,
            {
              ...params,
              label: "yKey",
              error: !keyExists,
              helperText: keyExists ? "" : "Property not present in data"
            }
          );
        }
      }
    ), React91.createElement(
      ColorPicker,
      {
        label: "color",
        value: editDataSeries == null ? void 0 : editDataSeries.color,
        onChange: handleDataSeriesColorChange(dataSeriesEditIndex)
      }
    ))) : null
  ));
}
var ChartData_default = ChartDataPropEditor;
function ColumnSelect({ propType, nodeId, ...props2 }) {
  const { bindings } = usePageEditorState();
  const { helperText } = propType;
  const columnsValue = nodeId && bindings[`${nodeId}.props.columns`];
  const definedColumns = columnsValue == null ? void 0 : columnsValue.value;
  const newPropType = React922.useMemo(() => {
    const columnNames = definedColumns == null ? void 0 : definedColumns.map((column2) => column2.field);
    return { type: "string", enum: columnNames, helperText };
  }, [helperText, definedColumns]);
  return React922.createElement(select_default, { nodeId, ...props2, propType: newPropType });
}
var RowIdFieldSelect_default = ColumnSelect;
function HorizontalAlignPropEditor({
  propType,
  label,
  value = "start",
  onChange,
  disabled
}) {
  const handleHorizontalAlign = (event, newHorizontalAlign) => {
    if (newHorizontalAlign) {
      onChange(newHorizontalAlign);
    }
  };
  return React93.createElement(PropertyControl, { propType }, React93.createElement("div", null, label ? React93.createElement(Typography_default, { variant: "body2" }, label, ":") : null, React93.createElement(
    ToggleButtonGroup_default,
    {
      exclusive: true,
      disabled,
      value,
      onChange: handleHorizontalAlign,
      "aria-label": "HorizontalAlign"
    },
    React93.createElement(ToggleButton_default, { value: "start", "aria-label": "start" }, React93.createElement(AlignHorizontalLeft_default, null)),
    React93.createElement(ToggleButton_default, { value: "center", "aria-label": "center" }, React93.createElement(AlignHorizontalCenter_default, null)),
    React93.createElement(ToggleButton_default, { value: "end", "aria-label": "end" }, React93.createElement(AlignHorizontalRight_default, null))
  )));
}
var HorizontalAlign_default = HorizontalAlignPropEditor;
function VerticalAlignPropEditor({
  propType,
  label,
  value = "start",
  onChange,
  disabled
}) {
  const VerticalAlign = (event, newVerticalAlign) => {
    if (newVerticalAlign) {
      onChange(newVerticalAlign);
    }
  };
  return React94.createElement(PropertyControl, { propType }, React94.createElement("div", null, label ? React94.createElement(Typography_default, { variant: "body2" }, label, ":") : null, React94.createElement(
    ToggleButtonGroup_default,
    {
      exclusive: true,
      disabled,
      value,
      onChange: VerticalAlign,
      "aria-label": "VerticalAlign"
    },
    React94.createElement(ToggleButton_default, { value: "start", "aria-label": "start" }, React94.createElement(AlignVerticalTop_default, null)),
    React94.createElement(ToggleButton_default, { value: "center", "aria-label": "center" }, React94.createElement(AlignVerticalCenter_default, null)),
    React94.createElement(ToggleButton_default, { value: "end", "aria-label": "end" }, React94.createElement(AlignVerticalBottom_default, null))
  )));
}
var VerticalAlign_default = VerticalAlignPropEditor;
function NumberFormatPropEditor({
  propType,
  label,
  value,
  onChange,
  disabled
}) {
  return React95.createElement(PropertyControl, { propType }, React95.createElement("span", null, React95.createElement(NumberFormatEditor, { label, disabled, value, onChange })));
}
var NumberFormat_default = NumberFormatPropEditor;
var ListItemRoot = styled_default(ListItem_default)({
  gap: 1
});
var EMPTY_STOPS = [];
function ColorScaleListItem({
  valueLabel,
  value,
  onChange,
  onDelete,
  ...props2
}) {
  return React96.createElement(ListItemRoot, { ...props2 }, valueLabel ? React96.createElement(Typography_default, null, valueLabel) : React96.createElement(React96.Fragment, null, ">", React96.createElement(
    Input_default,
    {
      type: "number",
      value: (value == null ? void 0 : value.value) ?? 0,
      onChange: (event) => onChange == null ? void 0 : onChange({ ...value, value: Number(event.target.value) })
    }
  )), React96.createElement(FlexFill_default, null), React96.createElement(
    ColorPickerIconButton,
    {
      value: value == null ? void 0 : value.color,
      onChange: (newValue) => {
        if (newValue) {
          onChange == null ? void 0 : onChange({ value: 0, ...value, color: newValue });
        }
      }
    }
  ), React96.createElement(
    IconButton_default,
    {
      onClick: onDelete,
      size: "small",
      sx: { visibility: onDelete ? "visible" : "hidden" }
    },
    React96.createElement(Delete_default, { fontSize: "inherit" })
  ));
}
function getOrderedIndices(stops) {
  return stops.map((stop, index) => {
    return { index, value: stop.value };
  }).sort((stop1, stop2) => stop1.value - stop2.value).map(({ index }) => index);
}
function ColorScaleEditor({ value, onChange }) {
  const stops = (value == null ? void 0 : value.stops) ?? EMPTY_STOPS;
  const stopsOrder = React96.useMemo(() => getOrderedIndices(stops), [stops]);
  const handleRemoveStop = (toRemoveIndex) => (event) => {
    event.stopPropagation();
    const newStops = stops.filter((existingStop, index) => index !== toRemoveIndex);
    onChange({
      ...value,
      stops: newStops
    });
  };
  const handleStopChange = (toChangeIndex) => (newValue) => {
    onChange({
      ...value,
      stops: stops.map(
        (existingStop, index) => index === toChangeIndex ? newValue : existingStop
      )
    });
  };
  const handleAddStop = () => {
    const lastStop = stops.length > 0 ? stops[stops.length - 1] : void 0;
    const newStop = lastStop ? { ...lastStop, value: lastStop.value + 10 } : { value: 10 };
    onChange({
      ...value,
      stops: [...stops, newStop]
    });
  };
  return React96.createElement(Stack_default, { spacing: 1, direction: "row" }, React96.createElement(
    Box_default2,
    {
      sx: {
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        gap: 1
      }
    },
    React96.createElement(Box_default2, { sx: { maxHeight: 300, overflow: "auto" } }, React96.createElement(List_default, { sx: { width: 300 } }, React96.createElement(
      ColorScaleListItem,
      {
        valueLabel: "Base color",
        value: (value == null ? void 0 : value.base) ? { value: -Infinity, color: value.base } : void 0,
        onChange: ({ color }) => onChange({ ...value, base: color })
      }
    ), stopsOrder.map((index) => {
      const stop = stops[index];
      return React96.createElement(
        ColorScaleListItem,
        {
          key: index,
          value: stop,
          onChange: handleStopChange(index),
          onDelete: handleRemoveStop(index)
        }
      );
    }))),
    React96.createElement(Button_default, { startIcon: React96.createElement(Add_default, null), onClick: handleAddStop }, "Add Stop")
  ));
}
function ColorScaleControl({ label, propType, value, onChange }) {
  const [anchorEl, setAnchorEl] = React96.useState(null);
  const handlePopoverClick = (event) => {
    setAnchorEl(event.currentTarget);
  };
  const handlePopoverClose = () => {
    setAnchorEl(null);
  };
  const open = Boolean(anchorEl);
  const popoverIdValue = React96.useId();
  const popoverId = open ? popoverIdValue : void 0;
  return React96.createElement(React96.Fragment, null, React96.createElement(PropertyControl, { propType }, React96.createElement(Button_default, { "aria-describedby": popoverId, onClick: handlePopoverClick }, label)), React96.createElement(
    Popover_default,
    {
      id: popoverId,
      open,
      anchorEl,
      onClose: handlePopoverClose,
      anchorOrigin: {
        vertical: "center",
        horizontal: "left"
      },
      transformOrigin: {
        vertical: "center",
        horizontal: "left"
      }
    },
    React96.createElement(Box_default2, { sx: { minWidth: 300, p: 1 } }, React96.createElement(
      ColorScaleEditor,
      {
        value,
        onChange: (newValue) => {
          onChange(newValue);
        }
      }
    ))
  ));
}
var PAGINATION_DOCUMENTATION_URL = "https://mui.com/toolpad/studio/concepts/data-providers/#pagination";
function useFunctionsIntrospectQuery() {
  const projectApi = useProjectApi();
  return projectApi.useQuery("introspect", []);
}
function handleInputFocus2(event) {
  event.target.select();
}
var filter = createFilterOptions();
var classes10 = {
  editButton: "DataProviderSelector_editButton"
};
var DataProviderSelectorRoot = styled_default("div")({
  [`& .${classes10.editButton}`]: {
    visibility: "hidden"
  },
  [`&:hover .${classes10.editButton}, & .${autocompleteClasses_default.focused} .${classes10.editButton}`]: {
    visibility: "visible"
  }
});
function CreateNewDataProviderDialog({
  open,
  onClose,
  onCommit,
  existingNames,
  initialName
}) {
  const projectApi = useProjectApi();
  const [newName, setNewName] = React97.useState(initialName);
  React97.useEffect(() => {
    if (open) {
      setNewName(initialName);
    }
  }, [open, initialName]);
  const [options2, setOptions] = React97.useState({
    paginationMode: "index"
  });
  const createProviderMutation = useMutation({
    mutationKey: [newName, options2],
    mutationFn: () => projectApi.methods.createDataProvider(newName, options2),
    onSuccess: () => {
      onCommit(newName);
      onClose();
    }
  });
  const handleSubmit = (event) => {
    event.preventDefault();
    createProviderMutation.mutate();
  };
  const nameExists = existingNames.has(newName);
  const errorMessage2 = React97.useMemo(() => {
    if (nameExists) {
      return `Provider "${newName}" already exists`;
    }
    if (createProviderMutation.error) {
      return errorFrom(createProviderMutation.error).message;
    }
    return null;
  }, [nameExists, createProviderMutation.error, newName]);
  const paginationModeSelectId = React97.useId();
  return React97.createElement(Dialog_default, { open, onClose }, React97.createElement("form", { onSubmit: handleSubmit }, React97.createElement(DialogTitle_default, null, "Create a new data provider"), React97.createElement(DialogContent_default, null, React97.createElement(DialogContentText_default, null, "To create a new data provider please enter the name here."), React97.createElement(Stack_default, { sx: { gap: 2 } }, React97.createElement(
    TextField_default,
    {
      autoFocus: true,
      margin: "dense",
      fullWidth: true,
      value: newName,
      onChange: (event) => setNewName(event.target.value),
      label: "name",
      type: "text",
      onFocus: handleInputFocus2,
      required: true,
      error: !!errorMessage2,
      helperText: errorMessage2
    }
  ), React97.createElement(FormControl_default, null, React97.createElement(FormLabel_default, { id: paginationModeSelectId }, "Pagination mode"), React97.createElement(
    RadioGroup_default,
    {
      row: true,
      "aria-labelledby": paginationModeSelectId,
      value: options2.paginationMode,
      onChange: (event) => setOptions((existing) => ({
        ...existing,
        paginationMode: event.target.value
      }))
    },
    React97.createElement(FormControlLabel_default, { value: "index", control: React97.createElement(Radio_default, null), label: "Index based" }),
    React97.createElement(FormControlLabel_default, { value: "cursor", control: React97.createElement(Radio_default, null), label: "Cursor based" })
  ), React97.createElement(FormHelperText_default, null, "How is your backend data paginated? By index, or by cursor? Find more about pagination modes in the", " ", React97.createElement("a", { href: PAGINATION_DOCUMENTATION_URL, target: "_blank", rel: "noopener" }, "documentation"), ".")))), React97.createElement(DialogActions_default, null, React97.createElement(Button_default, { onClick: onClose }, "Cancel"), React97.createElement(
    LoadingButton_default,
    {
      type: "submit",
      disabled: !newName || !!errorMessage2,
      loading: createProviderMutation.isPending
    },
    "Create"
  ))));
}
function getProviderNameFromFile(file) {
  return file.name.replace(/\.[^.]+$/, "");
}
function DataProviderSelector({ value, onChange }) {
  const { data: introspection, isLoading, error } = useFunctionsIntrospectQuery();
  const options2 = React97.useMemo(() => {
    return (introspection == null ? void 0 : introspection.files.flatMap(
      (file) => {
        var _a;
        return (_a = file.dataProviders) == null ? void 0 : _a.filter((dataProvider) => dataProvider.name === "default").map((dataProvider) => ({
          kind: "option",
          file,
          dataProvider,
          displayName: getProviderNameFromFile(file)
        }));
      }
    )) ?? [];
  }, [introspection]);
  const [fileName = null, providerName = null] = value ? value.split(":") : [];
  const autocompleteValue = React97.useMemo(() => {
    return options2.find(
      (option) => option.kind === "option" && option.file.name === fileName && option.dataProvider.name === providerName
    ) ?? null;
  }, [fileName, providerName, options2]);
  const errorMessage2 = error ? errorFrom(error).message : void 0;
  const [dialogOpen, setDialogOpen] = React97.useState(false);
  const handleClose = () => {
    setDialogOpen(false);
  };
  const [dialogValue, setDialogValue] = React97.useState("");
  const existingNames = React97.useMemo(
    () => new Set(introspection == null ? void 0 : introspection.files.map((file) => getProviderNameFromFile(file))),
    [introspection]
  );
  const handleCreateNewDataProvider = React97.useCallback((suggestion) => {
    setDialogValue(suggestion);
    setDialogOpen(true);
  }, []);
  return React97.createElement(DataProviderSelectorRoot, null, React97.createElement(
    CreateNewDataProviderDialog,
    {
      open: dialogOpen,
      onClose: handleClose,
      onCommit: (newName) => onChange(`${newName}.ts:default`),
      initialName: dialogValue,
      existingNames
    }
  ), React97.createElement(
    Autocomplete_default,
    {
      options: options2,
      getOptionLabel: (option) => {
        if (typeof option === "string" || option.kind === "create") {
          const inputValue = typeof option === "string" ? option : option.inputValue;
          return inputValue ? `Create data provider "${inputValue}"` : "Create new data provider";
        }
        return option.displayName;
      },
      renderInput: (params) => React97.createElement(
        TextField_default,
        {
          ...params,
          label: "Data Provider",
          placeholder: "Click to create or select a data provider",
          error: !!errorMessage2,
          helperText: errorMessage2,
          slotProps: {
            input: {
              ...params.InputProps,
              endAdornment: React97.createElement(React97.Fragment, null, fileName ? React97.createElement(
                OpenCodeEditorButton,
                {
                  className: classes10.editButton,
                  filePath: fileName,
                  fileType: "resource",
                  iconButton: true
                }
              ) : null, params.InputProps.endAdornment)
            },
            inputLabel: {
              shrink: true
            }
          }
        }
      ),
      filterOptions: (unfilteredOptions, params) => {
        const filtered = filter(unfilteredOptions, params);
        if (!existingNames.has(params.inputValue)) {
          filtered.push({
            kind: "create",
            inputValue: params.inputValue
          });
        }
        return filtered;
      },
      value: autocompleteValue,
      loading: isLoading,
      onChange: (event, newValue) => {
        if (typeof newValue === "string") {
          handleCreateNewDataProvider(
            newValue || generateUniqueString("dataProvider", existingNames)
          );
        } else if (newValue && newValue.kind === "create") {
          handleCreateNewDataProvider(
            newValue.inputValue || generateUniqueString("dataProvider", existingNames)
          );
        } else {
          onChange(newValue ? `${newValue.file.name}:${newValue.dataProvider.name}` : void 0);
        }
      },
      renderOption: (props2, option, state, ownerState) => {
        const icon = option.kind === "create" ? React97.createElement(Add_default, null) : void 0;
        return React97.createElement("li", { ...props2 }, React97.createElement(Box_default2, { sx: { display: "flex", flexDirection: "row", alignItems: "center", gap: 1 } }, icon, ownerState.getOptionLabel(option)));
      },
      selectOnFocus: true,
      clearOnBlur: true,
      freeSolo: true,
      sx: { flex: 1 }
    }
  ));
}
var DataProviderSelector_default = DataProviderSelector;
var PROP_TYPE_CONTROLS = {
  string: string_default,
  boolean: boolean_default,
  number: number_default,
  select: select_default,
  json: json_default,
  markdown: Markdown_default,
  event: event_default,
  GridColumns: GridColumns_default,
  ToggleButtons: ToggleButtons_default,
  SelectOptions: SelectOptions_default,
  ChartData: ChartData_default,
  RowIdFieldSelect: RowIdFieldSelect_default,
  HorizontalAlign: HorizontalAlign_default,
  VerticalAlign: VerticalAlign_default,
  NumberFormat: NumberFormat_default,
  ColorScale: ColorScaleControl,
  DataProviderSelector: DataProviderSelector_default
};
function AppEditorShell({ children }) {
  return React98.createElement(PropControlsContextProvider, { value: PROP_TYPE_CONTROLS }, React98.createElement(
    Box_default2,
    {
      sx: {
        display: "flex",
        flexDirection: "row",
        overflow: "hidden",
        height: "100%"
      }
    },
    React98.createElement(
      PagePanel,
      {
        sx: {
          width: 250,
          borderRight: 1,
          borderColor: "divider"
        }
      }
    ),
    React98.createElement(
      Box_default2,
      {
        sx: {
          flex: 1,
          overflow: "hidden",
          position: "relative"
        }
      },
      children
    )
  ));
}
var DEFAULT_NAME2 = "page";
function CreatePageDialog({ open, onClose, ...props2 }) {
  const { dom } = useAppState();
  const appStateApi = useAppStateApi();
  const existingNames = React99.useMemo(
    () => getExistingNamesForChildren(dom, getApp(dom), "pages"),
    [dom]
  );
  const [name, setName] = React99.useState(proposeName(DEFAULT_NAME2, existingNames));
  const handleReset = useEventCallback_default(
    () => setName(proposeName(DEFAULT_NAME2, existingNames))
  );
  React99.useEffect(() => {
    if (open) {
      handleReset();
    }
  }, [open, handleReset]);
  const inputErrorMsg = useNodeNameValidation(name, existingNames, "page");
  const isNameValid = !inputErrorMsg;
  const isFormValid = isNameValid;
  return React99.createElement(Dialog_default, { open, onClose, ...props2 }, React99.createElement(
    DialogForm,
    {
      autoComplete: "off",
      onSubmit: (event) => {
        (0, import_invariant13.default)(isFormValid, "Invalid form should not be submitted when submit is disabled");
        event.preventDefault();
        const newNode = createNode(dom, "page", {
          name,
          attributes: {
            title: name,
            display: "shell",
            authorization: {
              allowAll: true
            }
          }
        });
        const appNode = getApp(dom);
        appStateApi.update((draft) => addNode(draft, newNode, appNode, "pages"), {
          kind: "page",
          name: newNode.name
        });
        onClose();
      }
    },
    React99.createElement(DialogTitle_default, null, "Create a new Page"),
    React99.createElement(DialogContent_default, null, React99.createElement(
      TextField_default,
      {
        sx: { my: 1 },
        required: true,
        autoFocus: true,
        fullWidth: true,
        label: "name",
        value: name,
        onChange: (event) => setName(event.target.value),
        error: !isNameValid,
        helperText: inputErrorMsg
      }
    )),
    React99.createElement(DialogActions_default, null, React99.createElement(Button_default, { color: "inherit", variant: "text", onClick: onClose }, "Cancel"), React99.createElement(Button_default, { type: "submit", disabled: !isFormValid }, "Create"))
  ));
}
function NoPageFound() {
  const {
    value: createPageDialogOpen,
    setTrue: handleCreatePageDialogOpen,
    setFalse: handleCreatepageDialogClose
  } = useBoolean(false);
  return React100.createElement(
    Grid_default,
    {
      container: true,
      sx: { minHeight: "100%", m: 1 },
      spacing: 1,
      justifyContent: "center",
      alignItems: "center",
      direction: "column"
    },
    React100.createElement(Grid_default, { item: true }, React100.createElement(Typography_default, { variant: "h6" }, "No pages in this app.")),
    React100.createElement(Grid_default, { item: true }, React100.createElement(Button_default, { variant: "outlined", color: "inherit", onClick: handleCreatePageDialogOpen }, "Create new")),
    React100.createElement(CreatePageDialog, { open: !!createPageDialogOpen, onClose: handleCreatepageDialogClose })
  );
}
var classes11 = {
  content: "Toolpad_Content",
  hierarchyPanel: "Toolpad_HierarchyPanel",
  editorPanel: "Toolpad_EditorPanel"
};
var EditorRoot2 = styled_default("div")(({ theme: theme3 }) => ({
  height: 1,
  minHeight: "100%",
  display: "flex",
  flexDirection: "column",
  overflow: "hidden",
  [`& .${classes11.content}`]: {
    flex: 1,
    display: "flex",
    flexDirection: "row",
    overflow: "hidden"
  },
  [`& .${classes11.hierarchyPanel}`]: {
    width: 250,
    borderRight: `1px solid ${theme3.palette.divider}`
  },
  [`& .${classes11.editorPanel}`]: {
    flex: 1,
    overflow: "hidden"
  }
}));
function FileEditor() {
  const { currentView } = useAppState();
  const location = useLocation();
  const navigate = useNavigate();
  React101.useEffect(() => {
    const newPathname = getPathnameFromView(currentView);
    if (newPathname !== location.pathname) {
      navigate({ pathname: newPathname }, { replace: true });
    }
  }, [currentView, location.pathname, navigate]);
  const currentViewContent = React101.useMemo(() => {
    switch (currentView.kind) {
      case "page": {
        if (currentView.name) {
          return React101.createElement(PageEditor, { name: currentView.name });
        }
        return React101.createElement(NoPageFound, null);
      }
      default:
        return React101.createElement(NoPageFound, null);
    }
  }, [currentView.kind, currentView.name]);
  return React101.createElement(AppEditorShell, null, currentViewContent);
}
function Editor2() {
  return React101.createElement(EditorRoot2, null, React101.createElement(FileEditor, null));
}
function usePreferredMode() {
  const prefersDarkMode = useMediaQuery("(prefers-color-scheme: dark)");
  return prefersDarkMode ? "dark" : "light";
}
function useThemeMode() {
  const [themeMode, setThemeMode] = useLocalStorageState(
    "toolpad-palette-mode",
    "system"
  );
  return { themeMode, setThemeMode };
}
function usePaletteMode() {
  const preferredMode = usePreferredMode();
  const { themeMode } = useThemeMode();
  return themeMode === "system" ? preferredMode : themeMode;
}
function ThemeProvider2({ children }) {
  const paletteMode = usePaletteMode();
  const theme3 = React1022.useMemo(() => {
    const brandingDesignTokens = getDesignTokens(paletteMode);
    let nextTheme = createTheme({
      ...brandingDesignTokens,
      palette: {
        ...brandingDesignTokens.palette,
        mode: paletteMode
      }
    });
    nextTheme = deepmerge(nextTheme, getThemedComponents(nextTheme));
    return nextTheme;
  }, [paletteMode]);
  React1022.useMemo(() => {
    let meta = document.querySelector("meta[name='theme-color']");
    if (!meta) {
      meta = document.createElement("meta");
      meta.name = "theme-color";
      document.head.appendChild(meta);
    }
    meta.setAttribute("content", getMetaThemeColor(paletteMode));
    meta.setAttribute("media", `(prefers-color-scheme: ${paletteMode})`);
  }, [paletteMode]);
  return React1022.createElement(ThemeProvider, { theme: theme3 }, React1022.createElement(ScopedCssBaseline_default, { enableColorScheme: true }, children));
}
var REPORT_BUG_URL = "https://github.com/mui/toolpad/issues/new/choose";
var FEATURE_REQUEST_URL = "https://github.com/mui/toolpad/issues";
var SUPPORT_URL = "https://mui.com/toolpad/studio/getting-started/support";
function CliCommandSnippet({ children }) {
  return React103.createElement(
    Box_default2,
    {
      component: "pre",
      sx: {
        p: 1,
        backgroundColor: "background.paper",
        borderRadius: 1,
        border: 1,
        borderColor: "divider"
      }
    },
    children
  );
}
function FeedbackMenuItemLink({ href, children }) {
  return React103.createElement(MenuItem_default, { component: "a", target: "_blank", href }, React103.createElement(ListItemText_default, null, children), React103.createElement(OpenInNew_default, { fontSize: "inherit", sx: { ml: 3, color: "text.secondary" } }));
}
function getUpgradeMessage(packageManager) {
  const pkgName = "@toolpad/studio";
  switch (packageManager) {
    case "yarn":
      return `yarn add ${pkgName}`;
    case "pnpm":
      return `pnpm add ${pkgName}`;
    default:
      return `npm install ${pkgName}`;
  }
}
function UserFeedback() {
  const { buttonProps, menuProps } = useMenu();
  const projectApi = useProjectApi();
  (0, import_invariant14.default)(process.env.TOOLPAD_VERSION, "Missing env var TOOLPAD_VERSION");
  (0, import_invariant14.default)(process.env.TOOLPAD_BUILD, "Missing env var TOOLPAD_BUILD");
  const { data: versionInfo } = projectApi.useQuery("getVersionInfo", [], {
    staleTime: VERSION_CHECK_INTERVAL
  });
  const {
    value: updateDialogOpen,
    setFalse: handleUpdateDialogClose,
    setTrue: handleUpdateDialogOpen
  } = useBoolean(false);
  const updateAvailable = !!(versionInfo == null ? void 0 : versionInfo.updateAvailable);
  return React103.createElement(React103.Fragment, null, React103.createElement(Dialog_default, { open: updateDialogOpen, onClose: handleUpdateDialogClose, maxWidth: "xs" }, React103.createElement(DialogTitle_default, null, "Update Toolpad"), React103.createElement(DialogContent_default, null, React103.createElement(DialogContentText_default, null, "A new Toolpad Studio version is available. To upgrade to the latest version, run:", React103.createElement(CliCommandSnippet, null, getUpgradeMessage((versionInfo == null ? void 0 : versionInfo.packageManager) ?? null)))), React103.createElement(DialogActions_default, null, React103.createElement(Button_default, { onClick: handleUpdateDialogClose, autoFocus: true }, "Close"))), React103.createElement(Tooltip_default, { title: "Help and resources" }, React103.createElement(IconButton_default, { ...buttonProps, color: "primary" }, React103.createElement(HelpOutlined_default, null))), React103.createElement(Menu_default, { ...menuProps }, React103.createElement(FeedbackMenuItemLink, { href: DOCUMENTATION_URL }, "Documentation"), React103.createElement(FeedbackMenuItemLink, { href: REPORT_BUG_URL }, "Report bug"), React103.createElement(FeedbackMenuItemLink, { href: FEATURE_REQUEST_URL }, "Request or upvote feature"), React103.createElement(FeedbackMenuItemLink, { href: SUPPORT_URL }, "Request support"), React103.createElement(Divider_default, null), React103.createElement(
    MenuItem_default,
    {
      disabled: !updateAvailable,
      onClick: handleUpdateDialogOpen,
      sx: { justifyContent: "space-between" }
    },
    "Version ",
    process.env.TOOLPAD_VERSION,
    updateAvailable ? React103.createElement(Chip_default, { size: "small", color: "error", variant: "outlined", label: "Update", clickable: true }) : null
  ), React103.createElement(MenuItem_default, { disabled: true }, "Build ", process.env.TOOLPAD_BUILD)));
}
var UserFeedback_default = UserFeedback;
var options = {
  light: {
    label: "Light",
    value: "light",
    icon: React104.createElement(LightMode_default, null)
  },
  dark: {
    label: "Dark",
    value: "dark",
    icon: React104.createElement(DarkMode_default, null)
  },
  system: {
    label: "System",
    value: "system",
    icon: React104.createElement(SettingsBrightnessOutlined_default, null)
  }
};
function ThemeModeMenu({ mode, onChange }) {
  const { buttonProps, menuProps, onMenuClose } = useMenu();
  return React104.createElement(React104.Fragment, null, React104.createElement(Tooltip_default, { title: "Change theme" }, React104.createElement(IconButton_default, { ...buttonProps, "aria-label": "Change theme", color: "primary" }, options[mode].icon)), React104.createElement(Menu_default, { ...menuProps }, Object.values(options).map((option) => React104.createElement(
    MenuItem_default,
    {
      key: option.value,
      selected: option.value === mode,
      onClick: (event) => {
        onChange(event, option.value);
        onMenuClose();
      }
    },
    React104.createElement(ListItemIcon_default, null, option.icon),
    React104.createElement(ListItemText_default, { primary: option.label })
  ))));
}
var ThemeModeMenu_default = ThemeModeMenu;
function Header({ navigation, actions, status, enableUserFeedback = true }) {
  const theme3 = useTheme();
  const { themeMode, setThemeMode } = useThemeMode();
  const handleThemeModeChange = React105.useCallback(
    (event, mode) => {
      setThemeMode(mode);
    },
    [setThemeMode]
  );
  const productIcon = theme3.palette.mode === "dark" ? productIconDark : productIconLight;
  return React105.createElement(React105.Fragment, null, React105.createElement(
    AppBar_default,
    {
      position: "fixed",
      color: "default",
      elevation: 0,
      sx: { zIndex: theme3.zIndex.drawer + 1, borderBottom: 1, borderColor: "divider" }
    },
    React105.createElement(Toolbar_default, null, React105.createElement(
      Box_default2,
      {
        sx: {
          flex: 1,
          display: "flex",
          flexDirection: "row",
          alignItems: "center",
          justifyContent: "start"
        }
      },
      React105.createElement(Tooltip_default, { title: "Home" }, React105.createElement(
        Link_default,
        {
          color: "inherit",
          "aria-label": "Home",
          href: "/",
          underline: "none",
          sx: { display: "flex", flexDirection: "row", alignItems: "center", gap: 1 }
        },
        React105.createElement("img", { src: productIcon, alt: "Toolpad product icon", width: 25, height: 25 }),
        React105.createElement(
          Box_default2,
          {
            "data-testid": "brand",
            sx: {
              color: "primary.main",
              lineHeight: "21px",
              fontSize: "16px",
              fontWeight: 700,
              letterSpacing: 0,
              fontFamily: theme3.typography.fontFamily
            }
          },
          "Toolpad Studio"
        )
      )),
      React105.createElement(Chip_default, { sx: { ml: 1 }, label: "Beta", size: "small", color: "grey" }),
      navigation
    ), React105.createElement(
      Box_default2,
      {
        sx: {
          flex: 1,
          display: "flex",
          flexDirection: "row",
          alignItems: "center",
          justifyContent: "center"
        }
      },
      actions
    ), React105.createElement(
      Box_default2,
      {
        sx: {
          flex: 1,
          display: "flex",
          flexDirection: "row",
          alignItems: "center",
          justifyContent: "end",
          gap: 2
        }
      },
      status,
      React105.createElement(ThemeModeMenu_default, { mode: themeMode, onChange: handleThemeModeChange }),
      enableUserFeedback ? React105.createElement(UserFeedback_default, null) : null
    ))
  ), React105.createElement(Toolbar_default, null));
}
var Header_default = Header;
var DRAWER_WIDTH = 44;
var Drawer = styled_default(Drawer_default)({
  width: DRAWER_WIDTH,
  "& .MuiDrawer-paper": {
    overflow: "hidden",
    width: DRAWER_WIDTH
  }
});
var navigationOptions = [
  {
    name: "Pages",
    path: "/app/pages",
    icon: Article_default
  },
  {
    name: "Functions",
    path: "/app/functions",
    icon: Functions_default
  }
];
function ToolpadNavigation() {
  const location = useLocation();
  return React106.createElement(Drawer, { variant: "permanent", anchor: "left", open: true }, React106.createElement(Toolbar_default, { variant: "dense" }), React106.createElement(List_default, { component: "nav", sx: { pt: 1 } }, navigationOptions.map(({ name, path, icon }) => {
    const OptionIcon = icon;
    const isSelected = !!matchPath(`${path}/*`, location.pathname);
    return React106.createElement(ListItem_default, { key: name, sx: { pt: 0.5, pb: 0.5, pl: 0, pr: 0 } }, React106.createElement(Link, { to: path, style: { textDecoration: "none", color: "inherit" } }, React106.createElement(
      Stack_default,
      {
        flex: 1,
        direction: "column",
        alignItems: "center",
        sx: { width: DRAWER_WIDTH - 1 }
      },
      React106.createElement(Tooltip_default, { title: name, placement: "right" }, React106.createElement(IconButton_default, null, React106.createElement(OptionIcon, { color: isSelected ? "primary" : "action", fontSize: "medium" })))
    )));
  })));
}
var ToolpadShellRoot = styled_default("div")({
  height: "100vh",
  display: "flex",
  flexDirection: "column"
});
var ViewPort = styled_default("div")({
  flex: 1,
  width: "100%",
  overflow: "auto",
  position: "relative"
});
function ToolpadShell({ children, ...props2 }) {
  return React107.createElement(ToolpadShellRoot, null, React107.createElement(Header_default, { ...props2 }), React107.createElement(Stack_default, { direction: "row", sx: { flex: 1 } }, FEATURE_FLAG_GLOBAL_FUNCTIONS ? React107.createElement(ToolpadNavigation, null) : null, React107.createElement(ViewPort, null, children)));
}
var fileTreeItemClasses = generateUtilityClasses("FileTreeItem", ["actionButton", "handlerItem"]);
var FileTreeItemRoot = styled_default(EditableTreeItem)(({ theme: theme3 }) => ({
  [`& .${treeItemClasses.label}`]: {
    display: "flex",
    flexDirection: "row",
    alignItems: "center",
    [`&:hover .${fileTreeItemClasses.actionButton}`]: {
      visibility: "visible"
    }
  },
  [`& .${treeItemClasses.groupTransition}`]: {
    borderLeft: `1px solid ${alpha(theme3.palette.text.primary, 0.2)}`,
    position: "relative",
    left: "-2px"
  },
  [`& .${fileTreeItemClasses.actionButton}`]: {
    visibility: "hidden"
  },
  [`& .${fileTreeItemClasses.handlerItem} .${treeItemClasses.label}`]: {
    fontFamily: theme3.typography.fontFamilyCode,
    fontSize: 14,
    padding: 4,
    display: "inline-block",
    overflow: "hidden",
    textOverflow: "ellipsis"
  }
}));
function HandlerFileTreeItem({
  file,
  itemId,
  validateItemName,
  onRename,
  ...other
}) {
  const { value: isEditing, setFalse: stopEditing } = useBoolean(false);
  const labelText = file.name;
  const validateEditableFileName = React108.useCallback(
    (newName) => {
      if (newName !== labelText && validateItemName) {
        return validateItemName(newName);
      }
      return { isValid: true };
    },
    [labelText, validateItemName]
  );
  return React108.createElement(
    FileTreeItemRoot,
    {
      key: file.name,
      itemId,
      labelText,
      renderLabel: (children) => React108.createElement(React108.Fragment, null, React108.createElement(Javascript_default, { fontSize: "large" }), children, React108.createElement(FlexFill_default, null), React108.createElement(
        OpenCodeEditorButton,
        {
          className: fileTreeItemClasses.actionButton,
          iconButton: true,
          filePath: file.name,
          fileType: "resource"
        }
      )),
      isEditing,
      suggestedNewItemName: labelText,
      onCancel: stopEditing,
      validateItemName: validateEditableFileName,
      ...other
    },
    file.handlers.map((handler) => {
      return React108.createElement(
        TreeItem,
        {
          className: fileTreeItemClasses.handlerItem,
          key: handler.name,
          itemId: serializeFunctionId({ file: file.name, handler: handler.name }),
          label: handler.name
        }
      );
    })
  );
}
function FunctionsEditor() {
  var _a, _b;
  usePageTitle(`Functions | Toolpad Studio editor`);
  const theme3 = useTheme();
  const projectApi = useProjectApi();
  const [selectedHandler, setSelectedHandler] = React108.useState(null);
  const { file: selectedFile = void 0, handler: selectedFunction = void 0 } = selectedHandler ? parseLegacyFunctionId(selectedHandler) : {};
  const selectedNodeId = selectedFile ? serializeFunctionId({
    file: selectedFile,
    handler: selectedFunction
  }) : null;
  const [expanded, setExpanded] = React108.useState(selectedFile ? [selectedFile] : []);
  const [latestCreatedHandler, setLatestCreatedHandler] = React108.useState(null);
  const execPrivate = React108.useCallback(
    (method, args) => {
      return projectApi.methods.dataSourceExecPrivate("local", method, args);
    },
    [projectApi.methods]
  );
  const introspection = useQuery({
    queryKey: ["introspection"],
    queryFn: () => execPrivate("introspection", []),
    retry: false
  });
  const handleSelectFunction = React108.useCallback(
    (_event, itemId) => {
      if (!itemId) {
        return;
      }
      const parsed = parseFunctionId(itemId);
      if (parsed.handler) {
        setSelectedHandler(itemId);
      }
    },
    [setSelectedHandler]
  );
  const handlerTreeRef = React108.useRef(null);
  React108.useEffect(() => {
    var _a2, _b2;
    (_b2 = (_a2 = handlerTreeRef.current) == null ? void 0 : _a2.querySelector(`.${treeItemClasses.selected}`)) == null ? void 0 : _b2.scrollIntoView();
  }, []);
  const [newHandlerLoading, setNewHandlerLoading] = React108.useState(false);
  const [hasMounted, setHasMounted] = React108.useState(false);
  React108.useEffect(() => {
    setHasMounted(true);
  }, []);
  React108.useEffect(() => {
    const handlerTree = handlerTreeRef.current;
    if (handlerTree && hasMounted) {
      const selectedItem = handlerTree.querySelector(`.${treeItemClasses.selected}`);
      if (selectedItem) {
        scrollIntoViewIfNeeded(selectedItem);
      }
    }
  }, [hasMounted, introspection.data]);
  const {
    value: isCreateNewHandlerOpen,
    setTrue: handleOpenCreateNewHandler,
    setFalse: handleCloseCreateNewHandler
  } = useBoolean(false);
  const existingFileNames = React108.useMemo(
    () => {
      var _a2;
      return new Set(
        ((_a2 = introspection.data) == null ? void 0 : _a2.files.flatMap((file) => [
          file.name,
          `${file.name.substring(0, file.name.lastIndexOf("."))}`
        ])) ?? []
      );
    },
    [introspection]
  );
  const validateFileName = React108.useCallback(
    (fileName) => {
      const alreadyExists = existingFileNames.has(fileName);
      return {
        isValid: !alreadyExists,
        ...alreadyExists ? { errorMessage: "File already exists" } : {}
      };
    },
    [existingFileNames]
  );
  const nextProposedName = React108.useMemo(
    () => proposeName("myfunctions", existingFileNames),
    [existingFileNames]
  );
  const handleCreateNewCommit = React108.useCallback(
    async (newFileName) => {
      const fileName = ensureSuffix(newFileName, ".ts");
      setNewHandlerLoading(true);
      try {
        await execPrivate("createNew", [fileName]);
        await introspection.refetch();
      } catch (error) {
        window.alert(errorFrom(error).message);
      } finally {
        setNewHandlerLoading(false);
        setLatestCreatedHandler(fileName);
      }
      const newNodeId = serializeFunctionId({ file: fileName, handler: "default" });
      setSelectedHandler(newNodeId);
      setExpanded([fileName]);
      handleCloseCreateNewHandler();
    },
    [execPrivate, handleCloseCreateNewHandler, introspection]
  );
  const handleSnackbarClose = React108.useCallback(() => {
    setLatestCreatedHandler(null);
  }, []);
  const [searchTerm, setSearchTerm] = React108.useState("");
  const handleSearch = React108.useCallback((newSearchTerm) => {
    setSearchTerm(newSearchTerm);
  }, []);
  const handleFileRename = React108.useCallback(async () => {
    try {
      await introspection.refetch();
    } catch (error) {
      window.alert(errorFrom(error).message);
    }
  }, [introspection]);
  const functionFiles = React108.useMemo(() => {
    var _a2, _b2;
    const regex = new RegExp(searchTerm.split("").join(".*"), "i");
    return (((_b2 = (_a2 = introspection.data) == null ? void 0 : _a2.files) == null ? void 0 : _b2.filter((file) => searchTerm ? regex.test(file.name) : true)) || []).filter((file) => file.handlers.length > 0);
  }, [(_a = introspection.data) == null ? void 0 : _a.files, searchTerm]);
  return React108.createElement(React108.Fragment, null, React108.createElement(Box_default2, { sx: { height: "calc(100vh - 48px)" } }, React108.createElement(resizablePanels_exports.PanelGroup, { direction: "horizontal" }, React108.createElement(resizablePanels_exports.Panel, { defaultSize: 16, minSize: 16 }, React108.createElement(
    Stack_default,
    {
      direction: "column",
      sx: {
        height: "100%",
        position: "relative"
      }
    },
    React108.createElement(
      ExplorerHeader,
      {
        headerText: "Functions",
        createLabelText: "Create new function file",
        onCreate: handleOpenCreateNewHandler,
        onSearch: handleSearch,
        hasPersistentSearch: true
      }
    ),
    React108.createElement(
      SimpleTreeView,
      {
        ref: handlerTreeRef,
        selectedItems: selectedNodeId,
        onSelectedItemsChange: handleSelectFunction,
        expandedItems: expanded,
        onExpandedItemsChange: (_event, itemIds) => setExpanded(itemIds),
        sx: {
          px: 1,
          overflow: "auto",
          scrollbarGutter: "stable"
        }
      },
      isCreateNewHandlerOpen ? React108.createElement(
        EditableTreeItem,
        {
          itemId: "::create::",
          isEditing: true,
          suggestedNewItemName: nextProposedName,
          onEdit: handleCreateNewCommit,
          onCancel: handleCloseCreateNewHandler,
          validateItemName: validateFileName,
          isLoading: newHandlerLoading,
          renderLabel: (children) => React108.createElement(Box_default2, { sx: { display: "flex", alignItems: "center" } }, React108.createElement(Javascript_default, { fontSize: "large" }), children)
        }
      ) : null,
      functionFiles.map((file) => React108.createElement(
        HandlerFileTreeItem,
        {
          key: file.name,
          itemId: serializeFunctionId({ file: file.name }),
          file,
          validateItemName: validateFileName,
          onRename: handleFileRename
        }
      )),
      ((_b = introspection.data) == null ? void 0 : _b.files.length) === 0 ? React108.createElement(Stack_default, { alignItems: "center", sx: { mt: 2 } }, React108.createElement(Typography_default, { variant: "body1", fontSize: 14 }, "You don't have any functions yet…"), React108.createElement(
        Button_default,
        {
          onClick: handleOpenCreateNewHandler,
          variant: "outlined",
          startIcon: React108.createElement(Add_default, null),
          size: "medium",
          sx: { mt: 1 }
        },
        "Create function file"
      )) : null,
      introspection.isLoading ? React108.createElement(React108.Fragment, null, React108.createElement(TreeItem, { disabled: true, itemId: "loading-1", label: React108.createElement(Skeleton_default, null) }), React108.createElement(TreeItem, { disabled: true, itemId: "loading-2", label: React108.createElement(Skeleton_default, null) }), React108.createElement(TreeItem, { disabled: true, itemId: "loading-3", label: React108.createElement(Skeleton_default, null) })) : null
    ),
    introspection.error ? React108.createElement(
      Box_default2,
      {
        sx: {
          position: "absolute",
          inset: "0 0 0 0",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          color: theme3.palette.error.main
        }
      },
      errorFrom(introspection.error).message
    ) : null
  )), React108.createElement(PanelResizeHandle2, null), React108.createElement(resizablePanels_exports.Panel, null, selectedHandler && selectedFile && selectedFunction ? React108.createElement(Toolbar_default, { sx: { borderBottom: `1px solid ${theme3.palette.divider}` } }, React108.createElement(
    Stack_default,
    {
      direction: "row",
      alignItems: "center",
      justifyContent: "space-between",
      sx: { width: "100%", p: 1 }
    },
    React108.createElement(Stack_default, { direction: "row", alignItems: "center" }, React108.createElement(Javascript_default, { fontSize: "large" }), React108.createElement(Typography_default, { variant: "subtitle1", fontSize: 14 }, selectedFile, "  ›  ", React108.createElement("span", { style: { fontFamily: theme3.typography.fontFamilyCode } }, selectedFunction))),
    React108.createElement(Stack_default, { direction: "row", alignItems: "center", gap: 1 }, React108.createElement(
      OpenCodeEditorButton,
      {
        className: fileTreeItemClasses.actionButton,
        filePath: selectedFile,
        fileType: "resource",
        actionText: "Edit",
        variant: "outlined"
      }
    ), React108.createElement(Button_default, { variant: "contained", size: "medium", startIcon: React108.createElement(PlayArrow_default, null) }, "Preview"))
  )) : React108.createElement(
    Box_default2,
    {
      sx: {
        height: "100%",
        display: "flex",
        alignItems: "center",
        justifyContent: "center"
      }
    },
    React108.createElement(Stack_default, { alignItems: "center", sx: { px: 4 } }, React108.createElement(Typography_default, { variant: "body1", textAlign: "center", fontSize: 14 }, React108.createElement("strong", null, "Custom Functions"), " allow you to run your own JavaScript code, directly from your file system."), React108.createElement(
      Link_default,
      {
        href: "https://mui.com/toolpad/studio/concepts/custom-functions",
        target: "_blank",
        rel: "noopener",
        textAlign: "center",
        sx: { mt: 1 },
        fontSize: 14
      },
      "Read more about Custom Functions"
    ))
  )))), React108.createElement(Portal_default, null, latestCreatedHandler ? React108.createElement(
    Snackbar_default,
    {
      open: !!latestCreatedHandler,
      onClose: handleSnackbarClose,
      message: `Function "${latestCreatedHandler}" created`,
      anchorOrigin: { vertical: "bottom", horizontal: "right" },
      autoHideDuration: 6e3,
      action: React108.createElement(React108.Fragment, null, React108.createElement(
        OpenCodeEditorButton,
        {
          className: fileTreeItemClasses.actionButton,
          filePath: latestCreatedHandler,
          fileType: "resource"
        }
      ), React108.createElement(
        IconButton_default,
        {
          size: "small",
          "aria-label": "close",
          color: "inherit",
          onClick: handleSnackbarClose
        },
        React108.createElement(Close_default, { fontSize: "small" })
      ))
    }
  ) : null));
}
function AzureIcon({ size = 18, color = "currentColor" }) {
  return React109.createElement("svg", { viewBox: "0 0 59.242 47.271", width: size, height: size, xmlns: "http://www.w3.org/2000/svg" }, React109.createElement(
    "path",
    {
      d: "m32.368 0-17.468 15.145-14.9 26.75h13.437zm2.323 3.543-7.454 21.008 14.291 17.956-27.728 4.764h45.442z",
      fill: color
    }
  ));
}
var AUTH_PROVIDER_OPTIONS = /* @__PURE__ */ new Map([
  ["github", { name: "GitHub", icon: React110.createElement(GitHub_default, { fontSize: "small" }), hasRoles: false }],
  ["google", { name: "Google", icon: React110.createElement(Google_default, { fontSize: "small" }), hasRoles: false }],
  [
    "azure-ad",
    {
      name: "Azure AD",
      icon: React110.createElement(AzureIcon, null),
      hasRoles: true
    }
  ]
]);
function AppAuthenticationEditor() {
  const { dom } = useAppState();
  const appState = useAppStateApi();
  const plan = getPlan(dom);
  const isPaidPlan = plan !== void 0 && plan !== "free";
  const handleAuthProvidersChange = React110.useCallback(
    (event) => {
      const {
        target: { value: providers }
      } = event;
      appState.update((draft) => {
        var _a;
        const app = getApp(draft);
        draft = setNodeNamespacedProp(draft, app, "attributes", "authentication", {
          ...(_a = app.attributes) == null ? void 0 : _a.authentication,
          providers: (typeof providers === "string" ? providers.split(",") : providers).map(
            (provider) => ({ provider })
          )
        });
        return draft;
      });
    },
    [appState]
  );
  const handleRestrictedDomainsChange = React110.useCallback(
    (index) => (event) => {
      const {
        target: { value: domain }
      } = event;
      appState.update((draft) => {
        var _a, _b, _c;
        const app = getApp(draft);
        draft = setNodeNamespacedProp(draft, app, "attributes", "authentication", {
          ...(_a = app.attributes) == null ? void 0 : _a.authentication,
          restrictedDomains: updateArray(
            ((_c = (_b = app.attributes) == null ? void 0 : _b.authentication) == null ? void 0 : _c.restrictedDomains) ?? [],
            domain,
            index
          ).filter((restrictedDomain) => restrictedDomain !== "")
        });
        return draft;
      });
    },
    [appState]
  );
  const appNode = getApp(dom);
  const { authentication } = appNode.attributes;
  const authProviders = React110.useMemo(
    () => (authentication == null ? void 0 : authentication.providers) ?? [],
    [authentication == null ? void 0 : authentication.providers]
  ).map((providerConfig) => providerConfig.provider);
  const restrictedDomains = (authentication == null ? void 0 : authentication.restrictedDomains) ?? [];
  return React110.createElement(Stack_default, { direction: "column" }, React110.createElement(Typography_default, { variant: "subtitle1", mb: 1 }, "Providers"), React110.createElement(FormControl_default, null, React110.createElement(InputLabel_default, { id: "auth-providers-label" }, "Authentication providers"), React110.createElement(
    Select_default,
    {
      labelId: "auth-providers-label",
      label: "Authentication providers",
      id: "auth-providers",
      multiple: true,
      value: authProviders,
      onChange: handleAuthProvidersChange,
      fullWidth: true,
      renderValue: (selected) => selected.filter((selectedValue) => AUTH_PROVIDER_OPTIONS.has(selectedValue)).map((selectedValue) => {
        var _a;
        return ((_a = AUTH_PROVIDER_OPTIONS.get(selectedValue)) == null ? void 0 : _a.name) ?? "";
      }).join(", ")
    },
    [...AUTH_PROVIDER_OPTIONS].map(([value, { name, icon, hasRoles }]) => React110.createElement(MenuItem_default, { key: value, value, disabled: hasRoles && !isPaidPlan }, React110.createElement(Stack_default, { direction: "row", alignItems: "center" }, React110.createElement(Checkbox_default, { checked: authProviders.indexOf(value) > -1 }), icon, React110.createElement(Typography_default, { mx: 1 }, name), hasRoles && !isPaidPlan ? React110.createElement(UpgradeAlert, { type: "warning", message: `${name} requires a paid plan.` }) : null)))
  ), React110.createElement(FormHelperText_default, { id: "auth-providers-helper-text" }, "If set, only authenticated users can use the app.")), React110.createElement(Alert_default, { severity: "info", sx: { mt: 1 } }, "Certain environment variables must be set for authentication providers to work.", " ", React110.createElement(Link_default, { href: "https://mui.com/toolpad/studio/concepts/authentication", target: "_blank" }, "Learn how to set up authentication"), "."), React110.createElement(Typography_default, { variant: "subtitle1", mt: 2 }, "Required email domains"), React110.createElement(Typography_default, { variant: "body2", mt: 1 }, "If set, authenticated user emails must be in one of the domains below."), [...restrictedDomains, ""].map((domain, index) => React110.createElement(
    TextField_default,
    {
      key: index,
      value: domain,
      onChange: handleRestrictedDomainsChange(index),
      placeholder: "example.com"
    }
  )), React110.createElement("div", { style: { position: "absolute", bottom: 0 } }, !isPaidPlan ? React110.createElement(
    UpgradeAlert,
    {
      type: "info",
      message: "Using authentication with a few specific providers (Azure AD) requires a paid plan.",
      action: true
    }
  ) : React110.createElement(
    UpgradeAlert,
    {
      type: "warning",
      message: "You are using features that are not covered by our MIT License. You will have to buy a license to use them in production."
    }
  )));
}
function RolesToolbar({ addNewRoleDisabled, onAddNewRole }) {
  (0, import_invariant15.default)(typeof addNewRoleDisabled === "boolean", "addNewRoleDisabled is required in slotProps");
  (0, import_invariant15.default)(typeof onAddNewRole === "function", "onAddNewRole is required in slotProps");
  return React110.createElement(GridToolbarContainer, null, React110.createElement(
    Button_default,
    {
      color: "primary",
      startIcon: React110.createElement(Add_default, null),
      onClick: onAddNewRole,
      disabled: addNewRoleDisabled
    },
    "Add role"
  ));
}
function AppRolesEditor({ onRowUpdateError }) {
  const { dom } = useAppState();
  const appState = useAppStateApi();
  const [draftRow, setDraftRow] = React110.useState(null);
  const addRole = React110.useCallback(
    (role) => {
      appState.update((draft) => {
        var _a, _b, _c;
        const app = getApp(draft);
        draft = setNodeNamespacedProp(draft, app, "attributes", "authorization", {
          ...(_a = app.attributes) == null ? void 0 : _a.authorization,
          roles: [...((_c = (_b = app.attributes) == null ? void 0 : _b.authorization) == null ? void 0 : _c.roles) ?? [], role]
        });
        return draft;
      });
    },
    [appState]
  );
  const updateRole = React110.useCallback(
    (name, values) => {
      appState.update((draft) => {
        var _a, _b, _c;
        const app = getApp(draft);
        draft = setNodeNamespacedProp(draft, app, "attributes", "authorization", {
          ...(_a = app.attributes) == null ? void 0 : _a.authorization,
          roles: (((_c = (_b = app.attributes) == null ? void 0 : _b.authorization) == null ? void 0 : _c.roles) ?? []).map((role) => {
            if (role.name === name) {
              return {
                ...role,
                ...values
              };
            }
            return role;
          })
        });
        return draft;
      });
    },
    [appState]
  );
  const deleteRole = React110.useCallback(
    (name) => {
      appState.update((draft) => {
        var _a, _b, _c;
        const app = getApp(draft);
        draft = setNodeNamespacedProp(draft, app, "attributes", "authorization", {
          ...(_a = app.attributes) == null ? void 0 : _a.authorization,
          roles: (((_c = (_b = app.attributes) == null ? void 0 : _b.authorization) == null ? void 0 : _c.roles) ?? []).filter((role) => role.name !== name)
        });
        return draft;
      });
    },
    [appState]
  );
  const rolesRows = React110.useMemo(() => {
    const appNode = getApp(dom);
    const authorization = appNode.attributes.authorization;
    const roles = authorization == null ? void 0 : authorization.roles;
    const { pages = [] } = getChildNodes(dom, appNode);
    const existingRows = (roles == null ? void 0 : roles.map((role) => ({
      ...role,
      id: role.name,
      pages: pages.filter((page) => {
        var _a, _b;
        return (_b = (_a = page.attributes.authorization) == null ? void 0 : _a.allowedRoles) == null ? void 0 : _b.includes(role.name);
      }).map((page) => page.name)
    }))) ?? [];
    return [...existingRows, ...draftRow ? [draftRow] : []];
  }, [dom, draftRow]);
  const rolesColumns = React110.useMemo(() => {
    return [
      {
        field: "name",
        headerName: "Name",
        editable: true,
        flex: 0.4
      },
      {
        field: "description",
        headerName: "Description",
        editable: true,
        flex: 1
      },
      {
        field: "pages",
        headerName: "Pages",
        type: "number",
        renderCell: ({ value }) => {
          const previewLength = 3;
          const preview = `${value.slice(0, previewLength).join(", ")}${value.length > previewLength ? "..." : ""}`;
          return React110.createElement(Tooltip_default, { title: preview }, React110.createElement("span", null, value.length));
        }
      },
      {
        field: "actions",
        type: "actions",
        headerName: "",
        width: 50,
        cellClassName: "actions",
        getActions: ({ row }) => {
          const isBlockedByPages = row.pages.length > 0;
          const deleteButton = React110.createElement(
            GridActionsCellItem,
            {
              key: "delete",
              disabled: isBlockedByPages || row.isNew,
              icon: React110.createElement(Delete_default, null),
              label: "Delete",
              onClick: () => deleteRole(row.name),
              color: "inherit"
            }
          );
          return [
            isBlockedByPages ? React110.createElement(
              Tooltip_default,
              {
                key: "delete",
                title: "This role can't be deleted because it is still associated with existing pages."
              },
              React110.createElement("span", null, deleteButton)
            ) : deleteButton
          ];
        }
      }
    ];
  }, [deleteRole]);
  const [rowModesModel, setRowModesModel] = React110.useState({});
  const handleRowModesModelChange = (newRowModesModel) => {
    setRowModesModel(newRowModesModel);
  };
  const processRowUpdate = (newRow, oldRow) => {
    setDraftRow(null);
    if (!newRow.name) {
      throw new Error(`Invalid row`);
    }
    const exists = rolesRows.some((row) => row.id !== newRow.id && row.name === newRow.name);
    if (exists) {
      throw new Error(`Role "${newRow.name}" already exists`);
    }
    if (oldRow.isNew) {
      addRole({
        name: newRow.name,
        description: newRow.description
      });
    } else {
      updateRole(newRow.name, {
        description: newRow.description
      });
    }
    return {
      ...newRow,
      id: newRow.name,
      pages: [],
      isNew: false
    };
  };
  const handleAddNewRole = React110.useCallback(() => {
    const draftRowId = `<draft_row>-${Math.random()}`;
    setDraftRow({ id: draftRowId, name: "", description: "", pages: [], isNew: true });
    setRowModesModel((oldModel) => ({
      ...oldModel,
      [draftRowId]: { mode: GridRowModes.Edit, fieldToFocus: "name" }
    }));
  }, []);
  return (
    // eslint-disable-next-line jsx-a11y/no-static-element-interactions
    React110.createElement(
      "div",
      {
        style: { height: 350, width: "100%" },
        onKeyDown: (event) => {
          if (Object.keys(rowModesModel).length > 0) {
            event.stopPropagation();
          }
        }
      },
      React110.createElement(
        DataGrid,
        {
          rows: rolesRows,
          columns: rolesColumns,
          hideFooter: true,
          editMode: "row",
          rowModesModel,
          onRowModesModelChange: handleRowModesModelChange,
          processRowUpdate,
          onProcessRowUpdateError: onRowUpdateError,
          isCellEditable: (params) => {
            if (params.field === "name") {
              return !!params.row.isNew;
            }
            return true;
          },
          slots: {
            toolbar: RolesToolbar
          },
          slotProps: {
            toolbar: {
              onAddNewRole: handleAddNewRole,
              addNewRoleDisabled: !!draftRow
            }
          },
          autoHeight: true
        }
      )
    )
  );
}
function AppRoleMappingsEditor({
  roleEnabledActiveAuthProviderOptions,
  onRowUpdateError
}) {
  var _a;
  const { dom } = useAppState();
  const appState = useAppStateApi();
  const [activeAuthProvider, setAuthProvider] = React110.useState(
    ((_a = roleEnabledActiveAuthProviderOptions[0]) == null ? void 0 : _a[0]) ?? null
  );
  const handleAuthProviderChange = React110.useCallback(
    (event) => {
      const { value: provider } = event.target;
      setAuthProvider(provider);
    },
    []
  );
  const updateRoleMapping = React110.useCallback(
    (role, providerRoles) => {
      if (!activeAuthProvider) {
        return;
      }
      appState.update((draft) => {
        var _a2, _b, _c, _d, _e2, _f;
        const app = getApp(draft);
        const activeAuthProviderConfig = (_c = (_b = (_a2 = app.attributes) == null ? void 0 : _a2.authentication) == null ? void 0 : _b.providers) == null ? void 0 : _c.find(
          (providerConfig) => providerConfig.provider === activeAuthProvider
        );
        draft = setNodeNamespacedProp(draft, app, "attributes", "authentication", {
          ...(_d = app.attributes) == null ? void 0 : _d.authentication,
          providers: [
            ...(((_f = (_e2 = app.attributes) == null ? void 0 : _e2.authentication) == null ? void 0 : _f.providers) ?? []).filter(
              (providerConfig) => providerConfig.provider !== activeAuthProvider
            ),
            {
              ...activeAuthProviderConfig,
              provider: activeAuthProvider,
              roles: [
                ...((activeAuthProviderConfig == null ? void 0 : activeAuthProviderConfig.roles) ?? []).filter(
                  (roleMapping) => roleMapping.target !== role
                ),
                {
                  source: (providerRoles || role).split(",").map((updatedRole) => updatedRole.trim()),
                  target: role
                }
              ]
            }
          ]
        });
        return draft;
      });
    },
    [activeAuthProvider, appState]
  );
  const roleMappingsRows = React110.useMemo(() => {
    var _a2, _b;
    if (!activeAuthProvider) {
      return [];
    }
    const appNode = getApp(dom);
    const authorization = appNode.attributes.authorization;
    const roles = (authorization == null ? void 0 : authorization.roles) ?? [];
    const authentication = appNode.attributes.authentication;
    const roleMappings = activeAuthProvider ? ((_b = (_a2 = authentication == null ? void 0 : authentication.providers) == null ? void 0 : _a2.find(
      (providerConfig) => providerConfig.provider === activeAuthProvider
    )) == null ? void 0 : _b.roles) ?? [] : [];
    const existingRows = (roles == null ? void 0 : roles.map((role) => {
      const targetRoleMapping = roleMappings.find(
        (roleMapping) => roleMapping.target === role.name
      );
      return {
        id: role.name,
        role: role.name,
        providerRoles: targetRoleMapping ? targetRoleMapping.source.join(", ") : role.name
      };
    })) ?? [];
    return existingRows;
  }, [activeAuthProvider, dom]);
  const roleMappingsColumns = React110.useMemo(() => {
    return [
      {
        field: "role",
        headerName: "Role",
        editable: false,
        flex: 0.4
      },
      {
        field: "providerRoles",
        headerName: "Provider roles",
        editable: true,
        flex: 1
      }
    ];
  }, []);
  const [rowModesModel, setRowModesModel] = React110.useState({});
  const handleRowModesModelChange = (newRowModesModel) => {
    setRowModesModel(newRowModesModel);
  };
  const processRowUpdate = (newRow) => {
    updateRoleMapping(newRow.id, newRow.providerRoles);
    return { ...newRow, providerRoles: newRow.providerRoles || newRow.role };
  };
  return React110.createElement(React110.Fragment, null, React110.createElement(
    TextField_default,
    {
      label: "Authentication provider",
      id: "auth-provider",
      value: activeAuthProvider ?? void 0,
      onChange: handleAuthProviderChange,
      fullWidth: true,
      select: true,
      sx: { mt: 2 }
    },
    roleEnabledActiveAuthProviderOptions.map(([value, { name }]) => React110.createElement(MenuItem_default, { key: value, value }, name))
  ), React110.createElement(
    "div",
    {
      style: { height: 350, width: "100%" },
      onKeyDown: (event) => {
        if (Object.keys(rowModesModel).length > 0) {
          event.stopPropagation();
        }
      }
    },
    React110.createElement(
      DataGrid,
      {
        rows: roleMappingsRows,
        columns: roleMappingsColumns,
        hideFooter: true,
        editMode: "row",
        rowModesModel,
        onRowModesModelChange: handleRowModesModelChange,
        processRowUpdate,
        onProcessRowUpdateError: onRowUpdateError,
        autoHeight: true,
        localeText: {
          noRowsLabel: activeAuthProvider ? "No roles defined" : "No provider selected"
        }
      }
    )
  ));
}
function AppAuthorizationDialog({ open, onClose }) {
  const { dom } = useAppState();
  const plan = getPlan(dom);
  const isPaidPlan = plan !== void 0 && plan !== "free";
  const [activeTab, setActiveTab] = React110.useState(
    "authentication"
  );
  const handleActiveTabChange = React110.useCallback((event, newTab) => {
    setActiveTab(newTab);
  }, []);
  const [errorSnackbarMessage, setErrorSnackbarMessage] = React110.useState("");
  const handleRowUpdateError = React110.useCallback((error) => {
    setErrorSnackbarMessage(error.message);
  }, []);
  const handleErrorSnackbarClose = React110.useCallback(() => {
    setErrorSnackbarMessage("");
  }, []);
  const roleEnabledActiveAuthProviderOptions = React110.useMemo(() => {
    var _a;
    const appNode = getApp(dom);
    const authProviders = (((_a = appNode.attributes.authentication) == null ? void 0 : _a.providers) ?? []).filter((providerConfig) => AUTH_PROVIDER_OPTIONS.has(providerConfig.provider)).map((providerConfig) => providerConfig.provider);
    return [...AUTH_PROVIDER_OPTIONS].filter(
      ([optionKey, { hasRoles }]) => hasRoles && authProviders.includes(optionKey)
    );
  }, [dom]);
  return React110.createElement(React110.Fragment, null, React110.createElement(Dialog_default, { open, onClose, fullWidth: true, maxWidth: "md" }, React110.createElement(DialogTitle_default, null, "Authorization"), React110.createElement(TabContext, { value: activeTab }, React110.createElement(Box_default2, { sx: { borderBottom: 1, borderColor: "divider" } }, React110.createElement(
    TabList_default,
    {
      onChange: handleActiveTabChange,
      "aria-label": "Authorization configuration options"
    },
    React110.createElement(Tab_default, { label: "Authentication", value: "authentication", sx: { px: 2 } }),
    React110.createElement(Tab_default, { label: "Roles", value: "roles", sx: { px: 2 } }),
    roleEnabledActiveAuthProviderOptions.length > 0 ? React110.createElement(Tab_default, { label: "Role mappings", value: "roleMappings", sx: { px: 2 } }) : null
  )), React110.createElement(DialogContent_default, { sx: { minHeight: 480, position: "relative" } }, React110.createElement(TabPanel_default2, { disableGutters: true, value: "authentication" }, React110.createElement(AppAuthenticationEditor, null)), React110.createElement(React110.Fragment, null, React110.createElement(TabPanel_default2, { disableGutters: true, value: "roles" }, isPaidPlan ? React110.createElement(React110.Fragment, null, React110.createElement(Typography_default, { variant: "body2" }, "Define the roles for your application. You can configure your pages to be accessible to specific roles only."), React110.createElement(AppRolesEditor, { onRowUpdateError: handleRowUpdateError })) : React110.createElement(
    UpgradeAlert,
    {
      type: "info",
      message: "Role based access control requires a paid plan."
    }
  )), React110.createElement(TabPanel_default2, { disableGutters: true, value: "roleMappings" }, isPaidPlan ? React110.createElement(React110.Fragment, null, React110.createElement(Typography_default, { variant: "body2" }, "Define mappings from authentication provider roles to Toolpad Studio roles."), React110.createElement(
    AppRoleMappingsEditor,
    {
      onRowUpdateError: handleRowUpdateError,
      roleEnabledActiveAuthProviderOptions
    }
  )) : React110.createElement(UpgradeAlert, { type: "info", message: "Role mapping requires a paid plan." }))))), React110.createElement(DialogActions_default, null, React110.createElement(Button_default, { color: "inherit", variant: "text", onClick: onClose }, "Close"))), React110.createElement(
    Snackbar_default,
    {
      open: !!errorSnackbarMessage,
      autoHideDuration: 6e3,
      onClose: handleErrorSnackbarClose
    },
    errorSnackbarMessage ? React110.createElement(Alert_default, { onClose: handleErrorSnackbarClose, severity: "error" }, errorSnackbarMessage) : void 0
  ));
}
var Centered = styled_default("div")({
  height: "100%",
  width: "100%",
  display: "flex",
  justifyContent: "center",
  alignItems: "center"
});
function FullPageLoader() {
  return React111.createElement(Centered, null, React111.createElement(CircularProgress_default, null));
}
function FullPageError({ error }) {
  return React111.createElement(Centered, { sx: { p: 4 } }, React111.createElement(ErrorAlert, { sx: { width: "100%" }, error }));
}
function ErrorFallback({ error }) {
  return React111.createElement(FullPageError, { error });
}
function renderAppSaveState(appState) {
  if (appState.saveDomError) {
    return React111.createElement(Tooltip_default, { title: "Error while saving" }, React111.createElement(SyncProblem_default, { color: "primary" }));
  }
  const isSaving = appState.unsavedDomChanges > 0;
  if (isSaving) {
    return React111.createElement(Tooltip_default, { title: "Saving changes…" }, React111.createElement(Sync_default, { color: "primary" }));
  }
  return React111.createElement(Tooltip_default, { title: "All changes saved!" }, React111.createElement(CloudDone_default, { color: "primary" }));
}
function EditorShell({ children }) {
  const appState = useAppStateContext();
  const location = useLocation();
  const previewPath = React111.useMemo(() => {
    const currentView = getViewFromPathname(location.pathname);
    if (!currentView) {
      return null;
    }
    const currentPageName = (currentView == null ? void 0 : currentView.kind) === "page" ? currentView.name : null;
    return currentPageName ? `${appState.appUrl}/pages/${currentPageName}` : appState.appUrl;
  }, [appState.appUrl, location.pathname]);
  const {
    value: authorizationDialogOpen,
    setTrue: handleAuthorizationDialogOpen,
    setFalse: handleAuthorizationDialogClose
  } = useBoolean(false);
  return React111.createElement(
    ToolpadShell,
    {
      navigation: React111.createElement(Stack_default, { sx: { ml: 3 } }, React111.createElement(Button_default, { onClick: handleAuthorizationDialogOpen }, "Authorization")),
      actions: previewPath ? React111.createElement(Stack_default, { direction: "row", gap: 1, alignItems: "center" }, React111.createElement(
        Button_default,
        {
          variant: "outlined",
          endIcon: React111.createElement(OpenInNew_default, null),
          color: "primary",
          component: "a",
          href: previewPath,
          target: "_blank"
        },
        "Preview"
      )) : null,
      status: renderAppSaveState(appState)
    },
    children,
    React111.createElement(
      AppAuthorizationDialog,
      {
        open: authorizationDialogOpen,
        onClose: handleAuthorizationDialogClose
      }
    )
  );
}
var queryClient2 = new QueryClient({
  defaultOptions: {
    queries: {
      networkMode: "always"
    },
    mutations: {
      networkMode: "always"
    }
  }
});
function ToolpadEditorRoutes({ appUrl }) {
  return React111.createElement(ThemeProvider2, null, React111.createElement(CssBaseline_default, null), React111.createElement(Box_default2, { sx: { height: "1px", minHeight: "100vh" } }, React111.createElement(ErrorBoundary, { fallbackRender: ErrorFallback }, React111.createElement(React111.Suspense, { fallback: React111.createElement(FullPageLoader, null) }, React111.createElement(QueryClientProvider, { client: queryClient2 }, React111.createElement(ProjectProvider, { url: appUrl, fallback: React111.createElement(FullPageLoader, null) }, React111.createElement(AppProvider, { appUrl }, React111.createElement(EditorShell, null, React111.createElement(Routes, null, FEATURE_FLAG_GLOBAL_FUNCTIONS ? React111.createElement(Route, { path: "/app/functions", element: React111.createElement(FunctionsEditor, null) }) : null, React111.createElement(Route, { path: "*", element: React111.createElement(Editor2, null) }))))))))));
}
function ToolpadEditor({ basename, state }) {
  return React111.createElement(BrowserRouter, { basename }, React111.createElement(Routes, null, React111.createElement(Route, { path: "/editor/*", element: React111.createElement(ToolpadEditorRoutes, { appUrl: basename }) }), React111.createElement(Route, { path: "/*", element: React111.createElement(ToolpadAppRoutes, { basename, state }) })));
}
var editor_default = ToolpadEditor;
export {
  editor_default as default
};
/*! Bundled license information:

es7-shim/es7-shim.js:
  (*!
   * https://github.com/es-shims/es7-shim
   * @license es7-shim Copyright 2014 by contributors, MIT License
   * see https://github.com/es-shims/es7-shim/blob/master/LICENSE
   *)

@mui/x-tree-view/index.js:
  (**
   * @mui/x-tree-view v7.21.0
   *
   * @license MIT
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=@toolpad_studio_editor.js.map
