import {
  __export
} from "./chunk-7LSNTUAC.js";

// node_modules/perf-cascade/lib/helpers/misc.js
function parseUrl(url) {
  const pattern = RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?");
  const matches = url.match(pattern) || [];
  return {
    authority: matches[4],
    fragment: matches[9],
    path: matches[5],
    query: matches[7],
    scheme: matches[2]
  };
}
function contains(arr, item) {
  return arr.some((x) => x === item);
}
function findIndex(arr, predicate) {
  let i = 0;
  if (!arr || arr.length < 1) {
    return void 0;
  }
  const len = arr.length;
  while (i < len) {
    if (predicate(arr[i], i)) {
      return i;
    }
    i++;
  }
  return void 0;
}
function find(arr, predicate) {
  const index = findIndex(arr, predicate);
  if (index === void 0) {
    return void 0;
  }
  return arr[index];
}
function resourceUrlFormatter(url, maxLength) {
  if (url.length < maxLength) {
    return url.replace(/https?:\/\//, "");
  }
  const matches = parseUrl(url);
  if ((matches.authority + matches.path).length < maxLength) {
    return matches.authority + matches.path;
  }
  const maxAuthLength = Math.floor(maxLength / 2) - 3;
  const maxPathLength = Math.floor(maxLength / 2) - 5;
  const p = matches.path.split("/");
  if (matches.authority.length > maxAuthLength) {
    return matches.authority.substr(0, maxAuthLength) + "..." + p[p.length - 1].substr(-maxPathLength);
  }
  return matches.authority + "..." + p[p.length - 1].substr(-maxPathLength);
}
function roundNumber(num, decimals = 2) {
  return Math.round(num * Math.pow(10, decimals)) / Math.pow(10, decimals);
}
function isInStatusCodeRange(status, lowerBound, upperBound) {
  return status >= lowerBound && status <= upperBound;
}
var cssClassRegEx = /[^a-z-]/g;
function toCssClass(seed) {
  return seed.toLowerCase().replace(cssClassRegEx, "");
}
function pluralize(word, count) {
  return word + (count > 1 ? "s" : "");
}
function isTabUp(evt) {
  return evt.which === 9 && evt.shiftKey;
}
function isTabDown(evt) {
  return evt.which === 9 && !evt.shiftKey;
}

// node_modules/perf-cascade/lib/helpers/parse.js
function parseAndFormat(input, parseFn, formatFn = toString) {
  if (input === void 0) {
    return void 0;
  }
  const parsed = parseFn(input);
  if (parsed === void 0) {
    return void 0;
  }
  return formatFn(parsed);
}
function toString(source) {
  if (source["toString"] && typeof source["toString"] === "function") {
    return source.toString();
  } else {
    throw TypeError(`Can't convert type ${typeof source} to string`);
  }
}
function parseNonEmpty(input) {
  return input.trim().length > 0 ? input : void 0;
}
function parseDate(input) {
  const date = new Date(input);
  if (isNaN(date.getTime())) {
    return void 0;
  }
  return date;
}
function parseNonNegative(input) {
  if (input === void 0 || input === null) {
    return void 0;
  }
  const filter = (n) => n >= 0;
  return parseToNumber(input, filter);
}
function parsePositive(input) {
  if (input === void 0 || input === null) {
    return void 0;
  }
  const filter = (n) => n > 0;
  return parseToNumber(input, filter);
}
function parseToNumber(input, filterFn) {
  const filter = (n) => filterFn(n) ? n : void 0;
  if (typeof input === "string") {
    const n = parseInt(input, 10);
    if (!isFinite(n)) {
      return void 0;
    }
    return filter(n);
  }
  return filter(input);
}
function formatMilliseconds(millis) {
  return millis !== void 0 ? `${roundNumber(millis, 3)} ms` : void 0;
}
var secondsPerMinute = 60;
var secondsPerHour = 60 * secondsPerMinute;
var secondsPerDay = 24 * secondsPerHour;
function formatSeconds(seconds) {
  if (seconds === void 0) {
    return void 0;
  }
  const raw = `${roundNumber(seconds, 3)} s`;
  if (seconds > secondsPerDay) {
    return `${raw} (~${roundNumber(seconds / secondsPerDay, 0)} days)`;
  }
  if (seconds > secondsPerHour) {
    return `${raw} (~${roundNumber(seconds / secondsPerHour, 0)} hours)`;
  }
  if (seconds > secondsPerMinute) {
    return `${raw} (~${roundNumber(seconds / secondsPerMinute, 0)} minutes)`;
  }
  return raw;
}
function formatDateLocalized(date) {
  return date !== void 0 ? `${date.toUTCString()}<br/>(local time: ${date.toLocaleString()})` : void 0;
}
var bytesPerKB = 1024;
var bytesPerMB = 1024 * bytesPerKB;
function formatBytes(bytes) {
  if (bytes === void 0) {
    return "";
  }
  const raw = `${bytes} bytes`;
  if (bytes >= bytesPerMB) {
    return `${raw} (~${roundNumber(bytes / bytesPerMB, 1)} MB)`;
  }
  if (bytes >= bytesPerKB) {
    return `${raw} (~${roundNumber(bytes / bytesPerKB, 0)} kB)`;
  }
  return raw;
}
var htmlCharMap = {
  '"': "&quot",
  "&": "&amp",
  "'": "&#039",
  "<": "&lt",
  ">": "&gt"
};
var htmlChars = new RegExp(Object.keys(htmlCharMap).join("|"), "g");
function escapeHtml(unsafe = "") {
  if (unsafe === null || unsafe === void 0) {
    return "";
  }
  if (typeof unsafe !== "string") {
    if (typeof unsafe["toString"] === "function") {
      unsafe = unsafe.toString();
    } else {
      throw TypeError("Invalid parameter");
    }
  }
  return unsafe.replace(htmlChars, (match) => {
    return htmlCharMap[match];
  });
}
var unSafeUrlChars = new RegExp("[^-A-Za-z0-9+&@#/%?=~_|!:,.;()]", "g");
function sanitizeUrlForLink(unsafeUrl) {
  const cleaned = unsafeUrl.replace(unSafeUrlChars, "_");
  if (cleaned.indexOf("http://") === 0 || cleaned.indexOf("https://") === 0) {
    return cleaned;
  }
  console.warn("skipped link, due to potentially unsafe url", unsafeUrl);
  return "";
}
var requestTypeTypeRegEx = new RegExp("[^a-zA-Z0-9]", "g");
function sanitizeAlphaNumeric(unsafe) {
  return unsafe.toString().replace(requestTypeTypeRegEx, "");
}
function toInt(input) {
  if (typeof input === "number") {
    return input;
  } else if (typeof input === "string") {
    return parseInt(input, 10);
  } else {
    return void 0;
  }
}
function validateOptions(options) {
  const validateInt = (name) => {
    const val = toInt(options[name]);
    if (val === void 0) {
      throw TypeError(`option "${name}" needs to be a number`);
    }
    options[name] = val;
  };
  const ensureBoolean = (name) => {
    options[name] = !!options[name];
  };
  validateInt("leftColumnWidth");
  validateInt("rowHeight");
  validateInt("selectedPage");
  ensureBoolean("showAlignmentHelpers");
  ensureBoolean("showIndicatorIcons");
  ensureBoolean("showMimeTypeIcon");
  return options;
}

// node_modules/perf-cascade/lib/legend/legend.js
function makeLegend() {
  const ulNode = document.createElement("ul");
  ulNode.className = "resource-legend";
  ulNode.innerHTML = `
        <li class="legend-blocked" title="Time spent in a queue waiting for a network connection.">Blocked</li>
        <li class="legend-dns" title="DNS resolution time.">DNS</li>
        <li class="legend-connect" title="Time required to create TCP connection.">Connect</li>
        <li class="legend-ssl" title="Time required for SSL/TLS negotiation.">SSL (TLS)</li>
        <li class="legend-send" title="Time required to send HTTP request to the server.">Send</li>
        <li class="legend-wait" title="Waiting for a response from the server.">Wait</li>
        <li class="legend-receive"
        title="Time required to read entire response from the server (or cache).">Receive</li>`;
  return ulNode;
}

// node_modules/perf-cascade/lib/helpers/dom.js
function addClass(el, className) {
  const classList = el.classList;
  if (classList) {
    className.split(" ").forEach((c) => classList.add(c));
  } else {
    el.setAttribute("class", el.getAttribute("class") + " " + className);
  }
  return el;
}
function removeClass(el, className) {
  const classList = el.classList;
  if (classList) {
    classList.remove(className);
  } else {
    el.setAttribute("class", (el.getAttribute("class") || "").replace(new RegExp("(\\s|^)" + className + "(\\s|$)", "g"), "$2"));
  }
  return el;
}
function getParentByClassName(base, className) {
  if (typeof base.closest === "function") {
    return base.closest(`.${className}`);
  }
  while (base) {
    if (base.classList.contains(className)) {
      return base;
    }
    base = base.parentElement;
  }
  return null;
}
function removeChildren(el) {
  while (el.hasChildNodes()) {
    el.removeChild(el.lastChild);
  }
  return el;
}
function getLastItemOfNodeList(list) {
  if (!list || list.length === 0) {
    return void 0;
  }
  return list.item(list.length - 1);
}
function forEachNodeList(els, fn) {
  Array.prototype.forEach.call(els, fn);
}
function safeSetStyle(el, property, value) {
  if (property in el.style) {
    el.style[property] = value;
  } else {
    console.warn(new Error(`Trying to set non-existing style ${property} = ${value} on a <${el.tagName.toLowerCase()}>.`));
  }
}
function safeSetAttribute(el, name, value) {
  if (!(name in el)) {
    console.warn(new Error(`Trying to set non-existing attribute ${name} = ${value} on a <${el.tagName.toLowerCase()}>.`));
  }
  el.setAttributeNS("", name, value);
}
function safeSetStyles(el, css2) {
  Object.keys(css2).forEach((property) => {
    safeSetStyle(el, property, css2[property].toString());
  });
}
function safeSetAttributes(el, attributes) {
  Object.keys(attributes).forEach((name) => {
    safeSetAttribute(el, name, attributes[name].toString());
  });
}
function makeHtmlEl() {
  const html2 = document.createElement("html");
  html2.setAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns", "http://www.w3.org/2000/xmlns/");
  return html2;
}
function makeBodyEl(css2 = {}, innerHTML = "") {
  const body = document.createElement("body");
  body.setAttribute("xmlns", "http://www.w3.org/1999/xhtml");
  safeSetStyles(body, css2);
  body.innerHTML = innerHTML;
  return body;
}

// node_modules/perf-cascade/lib/paging/paging.js
var Paging = class {
  constructor(doc, selectedPageIndex = 0) {
    this.doc = doc;
    this.selectedPageIndex = selectedPageIndex;
    this.onPageUpdateCbs = [];
    if (selectedPageIndex >= this.doc.pages.length) {
      this.selectedPageIndex = this.doc.pages.length - 1;
    }
  }
  /**
   * Returns number of pages
   * @returns number - number of pages in current doc
   */
  getPageCount() {
    return this.doc.pages.length;
  }
  /**
   * Returns selected pages
   * @returns WaterfallData - currently selected page
   */
  getSelectedPage() {
    return this.doc.pages[this.selectedPageIndex];
  }
  /**
   * Returns index of currently selected page
   * @returns number - index of current page (0 based)
   */
  getSelectedPageIndex() {
    return this.selectedPageIndex;
  }
  /**
   * Update which pageIndex is currently update.
   * Published `onPageUpdate`
   * @param  {number} pageIndex
   */
  setSelectedPageIndex(pageIndex) {
    if (this.selectedPageIndex === pageIndex) {
      return;
    }
    if (pageIndex < 0 || pageIndex >= this.getPageCount()) {
      throw new Error("Page does not exist - Invalid pageIndex selected");
    }
    this.selectedPageIndex = pageIndex;
    const selectedPage = this.doc.pages[this.selectedPageIndex];
    this.onPageUpdateCbs.forEach((cb) => {
      cb(this.selectedPageIndex, selectedPage);
    });
  }
  /**
   * Register subscriber callbacks to be called when the pageindex updates
   * @param  {OnPagingCb} cb
   * @returns number - index of the callback
   */
  onPageUpdate(cb) {
    if (this.getPageCount() > 1) {
      return this.onPageUpdateCbs.push(cb);
    }
    return void 0;
  }
  /**
   * hooks up select box with paging options
   * @param  {HTMLSelectElement} selectbox
   */
  initPagingSelectBox(selectbox) {
    const self = this;
    if (this.getPageCount() <= 1) {
      selectbox.style.display = "none";
      return;
    }
    removeChildren(selectbox);
    this.doc.pages.forEach((p, i) => {
      const option = new Option(p.title, i.toString(), false, i === this.selectedPageIndex);
      selectbox.add(option);
    });
    selectbox.style.display = "block";
    selectbox.addEventListener("change", (evt) => {
      const val = parseInt(evt.target.value, 10);
      self.setSelectedPageIndex(val);
    });
  }
};

// node_modules/perf-cascade/lib/helpers/har.js
var matchHeaderPartialFn = (lowercaseName) => {
  return (header) => header.name.toLowerCase() === lowercaseName;
};
function hasHeader(headers, headerName) {
  const headerFilter = matchHeaderPartialFn(headerName.toLowerCase());
  return headers.some(headerFilter);
}
var browserHasFind = !!Array.prototype["find"];
function getHeader(headers, headerName) {
  const headerFilter = matchHeaderPartialFn(headerName.toLowerCase());
  let firstItem;
  if (browserHasFind) {
    firstItem = headers["find"](headerFilter);
  } else {
    firstItem = headers.map(headerFilter).pop();
  }
  return firstItem ? firstItem.value : void 0;
}
function getHeaders(headers, headerName) {
  const headerFilter = matchHeaderPartialFn(headerName.toLowerCase());
  return headers.filter(headerFilter).map((h) => [headerName, h.value]);
}

// node_modules/perf-cascade/lib/transformers/har-heuristics.js
function isCompressible(entry, requestType) {
  const minCompressionSize = 1e3;
  if (entry.response.bodySize < minCompressionSize) {
    return false;
  }
  if (contains(["html", "css", "javascript", "svg", "plain"], requestType)) {
    return true;
  }
  const mime = entry.response.content.mimeType;
  const compressableMimes = [
    "application/vnd.ms-fontobject",
    "application/x-font-opentype",
    "application/x-font-truetype",
    "application/x-font-ttf",
    "application/xml",
    "font/eot",
    "font/opentype",
    "font/otf",
    "image/vnd.microsoft.icon"
  ];
  if (contains(["text"], mime.split("/")[0]) || contains(compressableMimes, mime.split(";")[0])) {
    return true;
  }
  return false;
}
function hasCacheIssue(entry) {
  if (!entry.request.method || entry.request.method.toLowerCase() !== "get") {
    return false;
  }
  if (entry.response.status === 204 || !isInStatusCodeRange(entry.response.status, 200, 299)) {
    return false;
  }
  const headers = entry.response.headers;
  return !(hasHeader(headers, "Cache-Control") || hasHeader(headers, "Expires"));
}
function hasCompressionIssue(entry, requestType) {
  const headers = entry.response.headers;
  return !hasHeader(headers, "Content-Encoding") && isCompressible(entry, requestType);
}
function isSecure(entry) {
  return entry.request.url.indexOf("https://") === 0;
}
function isInitialRedirect(entry, index) {
  return index === 0 && !!entry.response.redirectURL;
}
function isPush(entry) {
  if (entry._was_pushed === void 0 || entry._was_pushed === null) {
    return false;
  }
  return toInt(entry._was_pushed) === 1;
}
function documentIsSecure(data) {
  const rootDocument = data.filter((e) => !e.response.redirectURL)[0];
  if (rootDocument === void 0) {
    return data.length > 0 ? isSecure(data[0]) : false;
  }
  return isSecure(rootDocument);
}
function collectIndicators(entry, index, docIsTLS, requestType) {
  const output = [];
  if (isPush(entry)) {
    output.push({
      description: "Response was pushed by the server using HTTP2 push.",
      displayType: "inline",
      icon: "push",
      id: "push",
      title: "Response was pushed by the server",
      type: "info"
    });
  }
  if (docIsTLS && !(isSecure(entry) || isInitialRedirect(entry, index))) {
    output.push({
      description: "Insecure request, it should use HTTPS.",
      displayType: "icon",
      id: "noTls",
      title: "Insecure Connection",
      type: "error"
    });
  }
  if (hasCacheIssue(entry)) {
    output.push({
      description: "The response is not allow to be cached on the client. Consider setting 'Cache-Control' headers.",
      displayType: "icon",
      id: "noCache",
      title: "Response not cached",
      type: "error"
    });
  }
  if (hasCompressionIssue(entry, requestType)) {
    output.push({
      description: "The response is not compressed. Consider enabling HTTP compression on your server.",
      displayType: "icon",
      id: "noGzip",
      title: "no gzip",
      type: "error"
    });
  }
  if (!entry.response.content.mimeType && isInStatusCodeRange(entry.response.status, 200, 299) && entry.response.status !== 204) {
    output.push({
      description: "Response doesn't contain a 'Content-Type' header.",
      displayType: "icon",
      id: "warning",
      title: "No MIME Type defined",
      type: "warning"
    });
  }
  return output;
}

// node_modules/perf-cascade/lib/waterfall/row/svg-indicators.js
function makeIcon(type, title) {
  return { type, title, width: 20 };
}
function getIndicatorIcons(entry) {
  const indicators = entry.responseDetails.indicators.filter((i) => i.displayType === "icon");
  if (indicators.length === 0) {
    return [];
  }
  const combinedTitle = [];
  let icon = "";
  const errors = indicators.filter((i) => i.type === "error");
  const warnings = indicators.filter((i) => i.type === "warning");
  const info = indicators.filter((i) => i.type !== "error" && i.type !== "warning");
  if (errors.length > 0) {
    combinedTitle.push(pluralize("Error", errors.length) + ":\n " + errors.map((e) => e.title).join("\n"));
    icon = "error";
  }
  if (warnings.length > 0) {
    combinedTitle.push(pluralize("Warning", warnings.length) + ":\n" + warnings.map((w) => w.title).join("\n"));
    icon = icon || "warning";
  }
  if (info.length > 0) {
    combinedTitle.push(`Info:
${info.map((i) => i.title).join("\n")}`);
    if (!icon && info.length === 1) {
      icon = info[0].icon || info[0].type;
    } else {
      icon = icon || "info";
    }
  }
  return [makeIcon(icon, combinedTitle.join("\n"))];
}

// node_modules/perf-cascade/lib/transformers/helpers.js
var escapeHtmlLight = (str) => escapeHtml(str).replace("&ltbr/&gt", "<br/>");
function makeDefinitionList(dlKeyValues, addClass2 = false) {
  const makeClass = (key) => {
    if (!addClass2) {
      return "";
    }
    const className = toCssClass(key) || "no-colour";
    return `class="${className}"`;
  };
  return dlKeyValues.map((tuple) => `
      <dt ${makeClass(tuple[0])}>${escapeHtmlLight(tuple[0])}</dt>
      <dd>${escapeHtmlLight(tuple[1])}</dd>
    `).join("");
}
function mimeToRequestType(mimeType) {
  if (mimeType === void 0) {
    return "other";
  }
  const types = mimeType.split("/");
  let part2 = types[1];
  if (part2 !== void 0) {
    part2 = part2.indexOf(";") > -1 ? part2.split(";")[0] : part2;
  }
  switch (types[0]) {
    case "image": {
      if (part2 === "svg+xml") {
        return "svg";
      }
      return "image";
    }
    case "font":
      return "font";
    case "video":
      return "video";
    case "audio":
      return "audio";
    default:
      break;
  }
  switch (part2) {
    case "xml":
    case "html":
      return "html";
    case "plain":
      return "plain";
    case "css":
      return "css";
    case "vnd.ms-fontobject":
    case "font-woff":
    case "font-woff2":
    case "x-font-truetype":
    case "x-font-opentype":
    case "x-font-woff":
      return "font";
    case "javascript":
    case "x-javascript":
    case "script":
    case "json":
      return "javascript";
    case "x-shockwave-flash":
      return "flash";
    default:
      return "other";
  }
}
function createWaterfallEntry(url, start, end, segments = [], responseDetails, tabs) {
  const total = typeof start !== "number" || typeof end !== "number" ? NaN : end - start;
  return {
    end,
    responseDetails,
    segments,
    start,
    tabs,
    total,
    url
  };
}
function createWaterfallEntryTiming(type, start, end, chunks) {
  const total = typeof start !== "number" || typeof end !== "number" ? NaN : end - start;
  const typeClean = sanitizeAlphaNumeric(type);
  return {
    end,
    start,
    total,
    type: typeClean,
    chunks
  };
}
function makeRowCssClasses(status, renderBlockingStatus, largestContentfulPaintStatus) {
  const classes = ["row-item"];
  if (isInStatusCodeRange(status, 500, 599)) {
    classes.push("status5xx");
  } else if (isInStatusCodeRange(status, 400, 499)) {
    classes.push("status4xx");
  } else if (status !== 304 && isInStatusCodeRange(status, 300, 399)) {
    classes.push("status3xx");
  } else if (status === 0 || status === void 0) {
    classes.push("status0");
  }
  if (largestContentfulPaintStatus === true) {
    classes.push("largestContentfulPaint");
  }
  if (renderBlockingStatus === "potentially_blocking") {
    classes.push("potentiallyRenderBlocking");
  } else if (renderBlockingStatus === "blocking" || renderBlockingStatus === "in_body_parser_blocking") {
    classes.push("renderBlocking");
  }
  return classes.join(" ");
}
function makeMimeTypeIcon(status, statusText, requestType, redirectURL = "") {
  if (!!redirectURL) {
    const url = encodeURI(redirectURL.split("?")[0] || "");
    return makeIcon("err3xx", `${status} response status: Redirect to ${escapeHtml(url)}...`);
  } else if (isInStatusCodeRange(status, 400, 499)) {
    return makeIcon("err4xx", `${status} response status: ${escapeHtml(statusText)}`);
  } else if (isInStatusCodeRange(status, 500, 599)) {
    return makeIcon("err5xx", `${status} response status: ${escapeHtml(statusText)}`);
  } else if (status === 204) {
    return makeIcon("plain", "No content");
  } else {
    return makeIcon(sanitizeAlphaNumeric(requestType), escapeHtml(requestType));
  }
}
var flattenKvTuple = (nestedKvPairs) => {
  const returnKv = [];
  nestedKvPairs.forEach((maybeKv) => {
    if (maybeKv === void 0 || maybeKv.length === 0) {
      return;
    }
    if (Array.isArray(maybeKv[0])) {
      returnKv.push(...maybeKv);
      return;
    }
    returnKv.push(maybeKv);
  });
  return returnKv;
};

// node_modules/perf-cascade/lib/transformers/extract-details-keys.js
var byteSizeProperty = (title, input) => {
  return [title, parseAndFormat(input, parsePositive, formatBytes)];
};
var countProperty = (title, input) => {
  return [title, parseAndFormat(input, parsePositive)];
};
var notEmpty = (kv) => {
  return kv.length > 1 && kv[1] !== void 0 && kv[1] !== "";
};
function parseGeneralDetails(entry, startRelative, requestID) {
  return [
    ["Request Number", `#${requestID}`],
    ["Started", new Date(entry.startedDateTime).toLocaleString() + (startRelative > 0 ? " (" + formatMilliseconds(startRelative) + " after page request started)" : "")],
    ["Duration", formatMilliseconds(entry.time)],
    ["Error/Status Code", entry.response.status + " " + entry.response.statusText],
    ["Server IPAddress", entry.serverIPAddress],
    ["Connection", entry.connection],
    ["Browser Priority", entry._priority || entry._initialPriority],
    ["Was pushed", parseAndFormat(entry._was_pushed, parsePositive, () => "yes")],
    ["Initiator (Loaded by)", entry._initiator],
    ["Initiator Line", entry._initiator_line],
    ["Initiator Type", entry._initiator_type],
    ["Host", getHeader(entry.request.headers, "Host")],
    ["IP", entry._ip_addr],
    ["Client Port", parseAndFormat(entry._client_port, parsePositive)],
    ["Expires", entry._expires],
    ["Cache Time", parseAndFormat(entry._cache_time, parsePositive, formatSeconds)],
    ["CDN Provider", entry._cdn_provider],
    ["Render blocking", entry._renderBlocking],
    ["Is Largest Contentful Paint", entry._isLCP ? "yes" : void 0],
    byteSizeProperty("ObjectSize", entry._objectSize),
    byteSizeProperty("Bytes In (downloaded)", entry._bytesIn),
    byteSizeProperty("Bytes Out (uploaded)", entry._bytesOut),
    byteSizeProperty("JPEG Scan Count", entry._jpeg_scan_count),
    byteSizeProperty("Gzip Total", entry._gzip_total),
    byteSizeProperty("Gzip Save", entry._gzip_save),
    byteSizeProperty("Minify Total", entry._minify_total),
    byteSizeProperty("Minify Save", entry._minify_save),
    byteSizeProperty("Image Total", entry._image_total),
    byteSizeProperty("Image Save", entry._image_save)
  ].filter(notEmpty);
}
function parseRequestDetails(harEntry) {
  const request = harEntry.request;
  const stringHeader = (name) => getHeaders(request.headers, name);
  return flattenKvTuple([
    ["Method", request.method],
    ["HTTP Version", request.httpVersion],
    byteSizeProperty("Bytes Out (uploaded)", harEntry._bytesOut),
    byteSizeProperty("Headers Size", request.headersSize),
    byteSizeProperty("Body Size", request.bodySize),
    ["Comment", parseAndFormat(request.comment, parseNonEmpty)],
    stringHeader("User-Agent"),
    stringHeader("Host"),
    stringHeader("Connection"),
    stringHeader("Accept"),
    stringHeader("Accept-Encoding"),
    stringHeader("Expect"),
    stringHeader("Forwarded"),
    stringHeader("If-Modified-Since"),
    stringHeader("If-Range"),
    stringHeader("If-Unmodified-Since"),
    countProperty("Querystring parameters count", request.queryString.length),
    countProperty("Cookies count", request.cookies.length)
  ]).filter(notEmpty);
}
function parseResponseDetails(entry) {
  const response = entry.response;
  const content = response.content;
  const headers = response.headers;
  const stringHeader = (title, name = title) => {
    return getHeaders(headers, name);
  };
  const dateHeader = (name) => {
    const header = getHeader(headers, name);
    return [name, parseAndFormat(header, parseDate, formatDateLocalized)];
  };
  const contentLength = getHeader(headers, "Content-Length");
  let contentSize;
  if (content.size && content.size !== -1 && contentLength !== content.size.toString()) {
    contentSize = content.size;
  }
  let contentType = getHeader(headers, "Content-Type");
  if (entry._contentType && entry._contentType !== contentType) {
    contentType = contentType + " | " + entry._contentType;
  }
  return flattenKvTuple([
    ["Status", response.status + " " + response.statusText],
    ["HTTP Version", response.httpVersion],
    byteSizeProperty("Bytes In (downloaded)", entry._bytesIn),
    byteSizeProperty("Headers Size", response.headersSize),
    byteSizeProperty("Body Size", response.bodySize),
    ["Content-Type", contentType],
    stringHeader("Cache-Control"),
    stringHeader("Content-Encoding"),
    dateHeader("Expires"),
    dateHeader("Last-Modified"),
    stringHeader("Pragma"),
    byteSizeProperty("Content-Length", contentLength),
    byteSizeProperty("Content Size", contentSize),
    byteSizeProperty("Content Compression", content.compression),
    stringHeader("Connection"),
    stringHeader("ETag"),
    stringHeader("Accept-Patch"),
    ["Age", parseAndFormat(getHeader(headers, "Age"), parseNonNegative, formatSeconds)],
    stringHeader("Allow"),
    stringHeader("Content-Disposition"),
    stringHeader("Location"),
    stringHeader("Strict-Transport-Security"),
    stringHeader("Trailer (for chunked transfer coding)", "Trailer"),
    stringHeader("Transfer-Encoding"),
    stringHeader("Upgrade"),
    stringHeader("Vary"),
    stringHeader("Timing-Allow-Origin"),
    ["Redirect URL", parseAndFormat(response.redirectURL, parseNonEmpty)],
    ["Comment", parseAndFormat(response.comment, parseNonEmpty)]
  ]).filter(notEmpty);
}
function parseTimings(entry, start, end) {
  const timings = entry.timings;
  const optionalTiming = (timing) => parseAndFormat(timing, parseNonNegative, formatMilliseconds);
  const total = typeof start !== "number" || typeof end !== "number" ? void 0 : end - start;
  let connectVal = optionalTiming(timings.connect);
  if (timings.ssl && timings.ssl > 0 && timings.connect) {
    connectVal = `${connectVal} (without TLS: ${optionalTiming(timings.connect - timings.ssl)})`;
  }
  return [
    ["Total", formatMilliseconds(total)],
    ["Blocked", optionalTiming(timings.blocked)],
    ["DNS", optionalTiming(timings.dns)],
    ["Connect", connectVal],
    ["SSL (TLS)", optionalTiming(timings.ssl)],
    ["Send", formatMilliseconds(timings.send)],
    ["Wait", formatMilliseconds(timings.wait)],
    ["Receive", formatMilliseconds(timings.receive)]
  ].filter(notEmpty);
}
function getKeys(entry, requestID, startRelative, endRelative) {
  const requestHeaders = entry.request.headers;
  const responseHeaders = entry.response.headers;
  const headerToKvTuple = (header) => [header.name, header.value];
  return {
    general: parseGeneralDetails(entry, startRelative, requestID),
    request: parseRequestDetails(entry),
    requestHeaders: requestHeaders.map(headerToKvTuple).filter(notEmpty),
    response: parseResponseDetails(entry),
    responseHeaders: responseHeaders.map(headerToKvTuple).filter(notEmpty),
    timings: parseTimings(entry, startRelative, endRelative)
  };
}

// node_modules/perf-cascade/lib/transformers/har-tabs.js
var escapedNewLineRegex = /\\n/g;
var newLineRegex = /\n/g;
var escapedTabRegex = /\\t/g;
function makeTabs(entry, requestID, requestType, startRelative, endRelative, indicators) {
  const tabs = [];
  const tabsData = getKeys(entry, requestID, startRelative, endRelative);
  tabs.push(makeGeneralTab(tabsData.general, indicators));
  tabs.push(makeRequestTab(tabsData.request, tabsData.requestHeaders));
  tabs.push(makeResponseTab(tabsData.response, tabsData.responseHeaders));
  tabs.push(makeWaterfallEntryTab("Timings", makeDefinitionList(tabsData.timings, true)));
  tabs.push(makeRawData(entry));
  if (requestType === "image") {
    tabs.push(makeImgTab(entry));
  }
  if (entry.response.content && entry.response.content.mimeType && entry.response.content.mimeType.indexOf("text/") === 0 && entry.response.content.text) {
    tabs.push(makeContentTab(entry));
  }
  return tabs.filter((t) => t !== void 0);
}
function makeWaterfallEntryTab(title, content, tabClass = "") {
  return {
    content,
    tabClass,
    title
  };
}
function makeLazyWaterfallEntryTab(title, renderContent, tabClass = "") {
  return {
    renderContent,
    tabClass,
    title
  };
}
function makeGeneralTab(generalData, indicators) {
  const mainContent = makeDefinitionList(generalData);
  if (indicators.length === 0) {
    return makeWaterfallEntryTab("General", mainContent);
  }
  const general = `<h2>General</h2>
<dl>${mainContent}<dl>`;
  let content = "";
  const errors = indicators.filter((i) => i.type === "error").map((i) => [i.title, i.description]);
  const warnings = indicators.filter((i) => i.type === "warning").map((i) => [i.title, i.description]);
  const info = indicators.filter((i) => i.type !== "error" && i.type !== "warning").map((i) => [i.title, i.description]);
  if (errors.length > 0) {
    content += `<h2 class="no-border">${pluralize("Error", errors.length)}</h2>
    <dl>${makeDefinitionList(errors)}</dl>`;
  }
  if (warnings.length > 0) {
    content += `<h2 class="no-border">${pluralize("Warning", warnings.length)}</h2>
    <dl>${makeDefinitionList(warnings)}</dl>`;
  }
  if (info.length > 0) {
    content += `<h2 class="no-border">Info</h2>
    <dl>${makeDefinitionList(info)}</dl>`;
  }
  return makeWaterfallEntryTab("General", content + general);
}
function makeRequestTab(request, requestHeaders) {
  const content = `<dl>
      ${makeDefinitionList(request)}
    </dl>
    <h2>All Request Headers</h2>
    <dl>
      ${makeDefinitionList(requestHeaders)}
    </dl>`;
  return makeWaterfallEntryTab("Request", content);
}
function makeResponseTab(response, responseHeaders) {
  const content = `<dl>
      ${makeDefinitionList(response)}
    </dl>
    <h2>All Response Headers</h2>
    <dl>
      ${makeDefinitionList(responseHeaders)}
    </dl>`;
  return makeWaterfallEntryTab("Response", content);
}
function makeContentTab(entry) {
  const escapedText = entry.response.content.text || "";
  const unescapedText = escapedText.replace(escapedNewLineRegex, "\n").replace(escapedTabRegex, "	");
  const newLines = escapedText.match(newLineRegex);
  const lineCount = newLines ? newLines.length : 1;
  return makeLazyWaterfallEntryTab(
    `Content (${lineCount} Line${lineCount > 1 ? "s" : ""})`,
    // class `copy-tab-data` needed to catch bubbled up click event in `details-overlay/html-details-body.ts`
    () => `
    <button class="copy-tab-data">Copy Content to Clipboard</button>
    <pre><code>${escapeHtml(unescapedText)}</code></pre>
    `,
    "content rendered-data"
  );
}
function makeRawData(entry) {
  return makeLazyWaterfallEntryTab("Raw Data", () => {
    return `
      <button class="copy-tab-data">Copy Raw Data to Clipboard</button>
      <pre><code>${escapeHtml(JSON.stringify(entry, null, 2))}</code></pre>
      `;
  }, "raw-data rendered-data");
}
function makeImgTab(entry) {
  return makeLazyWaterfallEntryTab("Preview", (detailsHeight) => `<img class="preview" style="max-height:${detailsHeight - 100}px"
    data-src="${sanitizeUrlForLink(entry.request.url)}" />`);
}

// node_modules/perf-cascade/lib/transformers/har.js
function transformDoc(harData, options) {
  const data = harData["log"] !== void 0 ? harData["log"] : harData;
  const pages = getPages(data);
  return {
    pages: pages.map((_page, i) => transformPage(data, i, options))
  };
}
function toWaterFallEntry(entry, index, startRelative, isTLS) {
  startRelative = Math.round(startRelative);
  const endRelative = Math.round(toInt(entry._all_end) || startRelative + entry.time);
  const requestType = mimeToRequestType(entry.response.content.mimeType);
  const indicators = collectIndicators(entry, index, isTLS, requestType);
  const responseDetails = createResponseDetails(entry, indicators);
  return createWaterfallEntry(entry.request.url, startRelative, endRelative, buildDetailTimingBlocks(startRelative, entry), responseDetails, makeTabs(entry, index + 1, requestType, startRelative, endRelative, indicators));
}
var getPages = (data) => {
  if (data.pages && data.pages.length > 0) {
    return data.pages;
  }
  const statedTime = data.entries.reduce((earliest, curr) => {
    const currDate = Date.parse(curr.startedDateTime);
    const earliestDate = Date.parse(earliest);
    return earliestDate < currDate ? earliest : curr.startedDateTime;
  }, data.entries[0].startedDateTime);
  return [{
    id: "",
    pageTimings: {},
    startedDateTime: statedTime,
    title: "n/a"
  }];
};
function transformPage(harData, pageIndex = 0, options) {
  const data = harData["log"] !== void 0 ? harData["log"] : harData;
  const pages = getPages(data);
  const currPage = pages[pageIndex];
  if (!currPage.startedDateTime) {
    throw new TypeError(`Invalid HAR document: "log.pages[${pageIndex}].startedDateTime" is not set`);
  }
  const pageStartTime = new Date(currPage.startedDateTime).getTime();
  const pageTimings = currPage.pageTimings;
  let doneTime = 0;
  const isTLS = documentIsSecure(data.entries);
  const entries = data.entries.filter((entry) => {
    if (entry.request.url.indexOf("data:") === 0 || entry.request.url.indexOf("javascript:") === 0) {
      return false;
    }
    if (pages.length === 1 && currPage.id === "") {
      return true;
    }
    return entry.pageref === currPage.id;
  }).map((entry, index) => {
    const startRelative = new Date(entry.startedDateTime).getTime() - pageStartTime;
    if (!isNaN(startRelative)) {
      doneTime = Math.max(doneTime, startRelative + entry.time);
    } else {
      console.warn(`Entry has no valid 'startedDateTime' time`, entry.request.url, entry);
    }
    return toWaterFallEntry(entry, index, startRelative, isTLS);
  });
  const marks = getMarks(pageTimings, currPage, options);
  marks.forEach((mark) => {
    if (mark.startTime > doneTime) {
      doneTime = mark.startTime;
    }
  });
  if (options.fixedLengthMs) {
    doneTime = options.fixedLengthMs;
  }
  doneTime += 100;
  return {
    docIsTLS: isTLS,
    durationMs: doneTime,
    entries,
    marks,
    title: currPage.title
  };
}
var getMarks = (pageTimings, currPage, options) => {
  if (pageTimings === void 0) {
    return [];
  }
  const sortFn = (a, b) => a.startTime - b.startTime;
  const marks = Object.keys(pageTimings).filter((k) => typeof pageTimings[k] === "number" && pageTimings[k] >= 0).map((k) => ({
    name: `${escapeHtml(k.replace(/^[_]/, ""))} (${roundNumber(pageTimings[k], 0)} ms)`,
    startTime: pageTimings[k]
  }));
  if (!options.showUserTiming) {
    return marks.sort(sortFn);
  }
  return getUserTimings(currPage, options).concat(marks).sort(sortFn);
};
var getUserTimings = (currPage, options) => {
  const baseFilter = options.showUserTimingEndMarker ? (k) => k.indexOf("_userTime.") === 0 : (k) => k.indexOf("_userTime.") === 0 && k.indexOf("_userTime.endTimer-") !== 0;
  let filterFn = baseFilter;
  if (Array.isArray(options.showUserTiming)) {
    const findTimings = options.showUserTiming;
    filterFn = (k) => baseFilter(k) && findTimings.indexOf(k.replace(/^_userTime\./, "")) >= 0;
  }
  const findName = /^_userTime\.((?:startTimer-)?(.+))$/;
  const extractUserTiming = (k) => {
    let name;
    let fullName;
    let duration;
    [, fullName, name] = findName.exec(k) || [, void 0, void 0];
    fullName = escapeHtml(fullName);
    name = escapeHtml(name);
    if (fullName !== name && currPage[`_userTime.endTimer-${name}`]) {
      duration = currPage[`_userTime.endTimer-${name}`] - currPage[k];
      return {
        duration,
        name: `${options.showUserTimingEndMarker ? fullName : name} (${currPage[k]} - ${currPage[k] + duration} ms)`,
        startTime: currPage[k]
        // x: currPage[k],
      };
    }
    return {
      name: fullName,
      startTime: currPage[k]
    };
  };
  return Object.keys(currPage).filter(filterFn).map(extractUserTiming);
};
var buildDetailTimingBlocks = (startRelative, harEntry) => {
  const t = harEntry.timings;
  const chunks = harEntry._chunks || [];
  const types = ["blocked", "dns", "connect", "send", "wait", "receive"];
  return types.reduce((collect, key) => {
    const time = getTimePair(key, harEntry, collect, startRelative);
    if (time.end && time.start >= time.end) {
      return collect;
    }
    if (key === "connect" && t.ssl && t.ssl !== -1) {
      const sslStart = parseInt(`${harEntry[`_ssl_start`]}`, 10) || time.start;
      const sslEnd = parseInt(`${harEntry[`_ssl_end`]}`, 10) || time.start + t.ssl;
      const connectStart = !!parseInt(`${harEntry[`_ssl_start`]}`, 10) ? time.start : sslEnd;
      return collect.concat([createWaterfallEntryTiming("ssl", Math.round(sslStart), Math.round(sslEnd))]).concat([createWaterfallEntryTiming(key, Math.round(connectStart), Math.round(time.end))]);
    }
    if (key === "receive" && chunks && chunks.length > 0) {
      return collect.concat([createWaterfallEntryTiming(key, Math.round(time.start), Math.round(time.end), chunks)]);
    }
    return collect.concat([createWaterfallEntryTiming(key, Math.round(time.start), Math.round(time.end))]);
  }, []);
};
var getTimePair = (key, harEntry, collect, startRelative) => {
  let wptKey;
  switch (key) {
    case "wait":
      wptKey = "ttfb";
      break;
    case "receive":
      wptKey = "download";
      break;
    default:
      wptKey = key;
  }
  const preciseStart = parseInt(`${harEntry[`_${wptKey}_start`]}`, 10);
  const preciseEnd = parseInt(`${harEntry[`_${wptKey}_end`]}`, 10);
  const start = isNaN(preciseStart) ? collect.length > 0 ? collect[collect.length - 1].end : startRelative : preciseStart;
  const end = isNaN(preciseEnd) ? start + (harEntry.timings[key] ?? 0) : preciseEnd;
  return {
    end: Math.round(end),
    start: Math.round(start)
  };
};
var createResponseDetails = (entry, indicators) => {
  const requestType = mimeToRequestType(entry.response.content.mimeType);
  const statusClean = toInt(entry.response.status) || 0;
  const renderBlockingStatus = entry._renderBlocking || "";
  const largestContentfulPaintStatus = entry._isLCP || false;
  return {
    icon: makeMimeTypeIcon(statusClean, entry.response.statusText, requestType, entry.response.redirectURL),
    indicators,
    requestType,
    rowClass: makeRowCssClasses(statusClean, renderBlockingStatus, largestContentfulPaintStatus),
    statusCode: statusClean
  };
};

// node_modules/perf-cascade/lib/helpers/svg.js
var svgNamespaceUri = "http://www.w3.org/2000/svg";
function newElement(tagName, { attributes = {}, css: css2 = {}, text = "", className = "" } = {}) {
  const element = document.createElementNS(svgNamespaceUri, tagName);
  if (className) {
    addClass(element, className);
  }
  if (text) {
    element.textContent = text;
  }
  safeSetStyles(element, css2);
  safeSetAttributes(element, attributes);
  return element;
}
function newSvg(className, attributes, css2 = {}) {
  return newElement("svg", { className, attributes, css: css2 });
}
function newG(className, attributes = {}, css2 = {}) {
  return newElement("g", { className, attributes, css: css2 });
}
function newClipPath(id) {
  const attributes = { id };
  return newElement("clipPath", { attributes });
}
function newForeignObject(attributes, className = "", css2 = {}) {
  return newElement("foreignObject", { attributes, className, css: css2 });
}
function newA(className) {
  return newElement("a", { className });
}
function newRect(attributes, className = "", css2 = {}) {
  return newElement("rect", { attributes, className, css: css2 });
}
function newLine(attributes, className = "") {
  return newElement("line", { className, attributes });
}
function newTitle(text) {
  const title = document.createElementNS(svgNamespaceUri, "title");
  title.setAttribute("text", text);
  return title;
}
function newTextEl(text, attributes = {}, css2 = {}) {
  return newElement("text", { text, attributes, css: css2 });
}
function newPath(d) {
  const path = document.createElementNS(svgNamespaceUri, "path");
  path.setAttribute("d", d);
  return path;
}
var getTestSVGEl = /* @__PURE__ */ (() => {
  let svgTestEl;
  let removeSvgTestElTimeout;
  return () => {
    if (svgTestEl === void 0) {
      const attributes = {
        className: "water-fall-chart temp",
        width: "9999px"
      };
      const css2 = {
        "left": "0px",
        "position": "absolute",
        "top": "0px",
        "visibility": "hidden",
        "z-index": "99999"
      };
      svgTestEl = newSvg("water-fall-chart temp", attributes, css2);
    }
    if (svgTestEl.parentElement === void 0) {
      window.document.body.appendChild(svgTestEl);
    }
    clearTimeout(removeSvgTestElTimeout);
    removeSvgTestElTimeout = setTimeout(() => {
      svgTestEl.parentNode.removeChild(svgTestEl);
    }, 500);
    return svgTestEl;
  };
})();
function getNodeTextWidth(textNode, skipClone = false) {
  if ((textNode.textContent || "").length === 0) {
    return 0;
  }
  const tmp = getTestSVGEl();
  let tmpTextNode;
  let shadow;
  if (skipClone) {
    shadow = textNode.style.textShadow;
    tmpTextNode = textNode;
  } else {
    tmpTextNode = textNode.cloneNode(true);
    tmpTextNode.setAttribute("x", "0");
    tmpTextNode.setAttribute("y", "0");
  }
  tmpTextNode.style.textShadow = "0";
  tmp.appendChild(tmpTextNode);
  window.document.body.appendChild(tmp);
  const width = tmpTextNode.getComputedTextLength();
  if (skipClone && shadow !== void 0) {
    textNode.style.textShadow = shadow;
  }
  return width;
}

// node_modules/perf-cascade/lib/transformers/styling-converters.js
function requestTypeToCssClass(requestType) {
  return "block-" + requestType;
}
function timingTypeToCssClass(timingType) {
  return "block-" + timingType;
}

// node_modules/perf-cascade/lib/waterfall/details-overlay/html-details-body.js
function createDetailsBody(requestID, detailsHeight, entry) {
  const html2 = makeHtmlEl();
  const body = makeBodyEl();
  const tabMenu = entry.tabs.map((t) => {
    return `<li><button class="tab-button">${t.title}</button></li>`;
  }).join("\n");
  const tabBody = entry.tabs.map((t) => {
    let cssClasses = "tab";
    if (t.tabClass) {
      cssClasses += ` ${t.tabClass}`;
    }
    let content = "";
    if (t.content) {
      content = t.content;
    } else if (typeof t.renderContent === "function") {
      content = t.renderContent(detailsHeight);
      t.content = content;
    } else {
      throw TypeError("Invalid Details Tab");
    }
    return `<div class="tab ${cssClasses}">${content}</div>`;
  }).join("\n");
  body.innerHTML = `
    <div class="wrapper">
      <header class="type-${entry.responseDetails.requestType}">
        <h3><strong>#${requestID}</strong> <a href="${sanitizeUrlForLink(entry.url)}">
          ${escapeHtml(entry.url)}
        </a></h3>
        <nav class="tab-nav">
          <ul>
            ${tabMenu}
          </ul>
        </nav>
      </header>
      ${tabBody}
    </div>
    `;
  html2.appendChild(body);
  return html2;
}

// node_modules/perf-cascade/lib/waterfall/details-overlay/svg-details-overlay.js
function createCloseButtonSvg(y) {
  const closeBtn = newA("info-overlay-close-btn");
  closeBtn.appendChild(newRect({
    height: 23,
    width: 23,
    x: "100%",
    y
  }));
  closeBtn.appendChild(newTextEl("✕", {
    dx: 7,
    dy: 16,
    x: "100%",
    y
  }));
  closeBtn.appendChild(newTitle("Close Overlay"));
  return closeBtn;
}
function createHolder(y, detailsHeight) {
  const holder = newG("info-overlay-holder");
  const bg = newRect({
    height: detailsHeight,
    rx: 2,
    ry: 2,
    width: "100%",
    x: "0",
    y
  }, "info-overlay-bg");
  holder.appendChild(bg);
  return holder;
}
var onTabDataCopyClick = (event) => {
  const btn = event.target;
  if (btn.tagName.toLowerCase() === "button" && btn.classList.contains("copy-tab-data")) {
    const el = document.createElement("textarea");
    el.value = btn.nextElementSibling ? btn.nextElementSibling.innerText : "";
    document.body.appendChild(el);
    el.select();
    el.setSelectionRange(0, 99999);
    document.execCommand("copy");
    document.body.removeChild(el);
  }
};
function createRowInfoOverlay(overlay, y, detailsHeight) {
  const requestID = overlay.index + 1;
  const holder = createHolder(y, detailsHeight);
  const foreignObject = newForeignObject({
    height: detailsHeight,
    width: "100%",
    x: "0",
    y
  });
  const body = createDetailsBody(requestID, detailsHeight, overlay.entry);
  const closeBtn = createCloseButtonSvg(y);
  closeBtn.addEventListener("click", () => {
    overlay.onClose(overlay.index);
    body.removeEventListener("click", onTabDataCopyClick);
  });
  body.addEventListener("click", onTabDataCopyClick);
  const getButtons = () => body.getElementsByClassName("tab-button");
  const getTabs = () => body.getElementsByClassName("tab");
  const setTabStatus = (tabIndex) => {
    overlay.openTabIndex = tabIndex;
    forEachNodeList(getTabs(), (tab, j) => {
      tab.style.display = tabIndex === j ? "block" : "none";
      getButtons().item(j).classList.toggle("active", tabIndex === j);
    });
  };
  forEachNodeList(getButtons(), (btn, tabIndex) => {
    btn.addEventListener("click", () => setTabStatus(tabIndex));
  });
  setTabStatus(overlay.openTabIndex);
  foreignObject.appendChild(body);
  holder.appendChild(foreignObject);
  holder.appendChild(closeBtn);
  return holder;
}

// node_modules/perf-cascade/lib/waterfall/details-overlay/overlay-manager.js
var OverlayManager = class _OverlayManager {
  constructor(context) {
    this.context = context;
    this.openOverlays = [];
    this.realignRow = (rowItem, offset) => {
      rowItem.setAttribute("transform", `translate(0, ${offset})`);
    };
  }
  /** all open overlays height combined */
  getCombinedOverlayHeight() {
    return this.openOverlays.reduce((pre, curr) => pre + (curr.height || 0), 0);
  }
  /**
   * Opens an overlay - rerenders others internaly
   */
  openOverlay(index, y, detailsHeight, entry, rowItems) {
    if (this.openOverlays.some((o) => o.index === index)) {
      return;
    }
    const self = this;
    const newOverlay = {
      defaultY: y,
      entry,
      index,
      onClose: () => {
        self.closeOverlay(index, detailsHeight, rowItems);
      },
      openTabIndex: 0
    };
    this.openOverlays.push(newOverlay);
    this.openOverlays = this.openOverlays.sort((a, b) => a.index > b.index ? 1 : -1);
    this.renderOverlays(detailsHeight, rowItems);
    this.context.pubSub.publishToOverlayChanges({
      changedIndex: index,
      combinedOverlayHeight: self.getCombinedOverlayHeight(),
      type: "open"
    });
  }
  /**
   * Toggles an overlay - rerenders others
   */
  toggleOverlay(index, y, detailsHeight, entry, rowItems) {
    if (this.openOverlays.some((o) => o.index === index)) {
      this.closeOverlay(index, detailsHeight, rowItems);
    } else {
      this.openOverlay(index, y, detailsHeight, entry, rowItems);
    }
  }
  /**
   * closes on overlay - rerenders others internally
   */
  closeOverlay(index, detailsHeight, rowItems) {
    const self = this;
    this.openOverlays.splice(this.openOverlays.reduce((prev, curr, i) => {
      return curr.index === index ? i : prev;
    }, -1), 1);
    this.renderOverlays(detailsHeight, rowItems);
    this.context.pubSub.publishToOverlayChanges({
      changedIndex: index,
      combinedOverlayHeight: self.getCombinedOverlayHeight(),
      type: "closed"
    });
  }
  /**
   * Renders / Adjusts Overlays
   *
   * @summary this is to re-set the "y" position since there is a bug in chrome with
   * tranform of an SVG and positioning/scoll of a foreignObjects
   * @param  {number} detailsHeight
   * @param  {SVGAElement[]} rowItems
   */
  renderOverlays(detailsHeight, rowItems) {
    let currY = 0;
    const updateHeight = (overlay, y, currHeight) => {
      currY += currHeight;
      overlay.actualY = y;
      overlay.height = currHeight;
    };
    const addNewOverlay = (overlayHolder, overlay) => {
      const y = overlay.defaultY + currY;
      const infoOverlay = createRowInfoOverlay(overlay, y, detailsHeight);
      const previewImg = infoOverlay.querySelector("img.preview");
      if (previewImg && !previewImg.src) {
        previewImg.setAttribute("src", (previewImg.attributes.getNamedItem("data-src") || { value: "" }).value);
      }
      infoOverlay.querySelector("a").addEventListener("keydown", _OverlayManager.firstElKeypress);
      getLastItemOfNodeList(infoOverlay.querySelectorAll("button")).addEventListener("keydown", _OverlayManager.lastElKeypress);
      overlayHolder.appendChild(infoOverlay);
      updateHeight(overlay, y, infoOverlay.getBoundingClientRect().height);
    };
    const updateRow = (rowItem, index) => {
      const overlay = find(this.openOverlays, (o) => o.index === index);
      const nextRowItem = rowItem.nextElementSibling;
      const overlayEl = nextRowItem.firstElementChild;
      this.realignRow(rowItem, currY);
      if (overlay === void 0) {
        if (overlayEl && nextRowItem !== null) {
          nextRowItem.querySelector("a").removeEventListener("keydown", _OverlayManager.firstElKeypress);
          getLastItemOfNodeList(nextRowItem.querySelectorAll("button")).removeEventListener("keydown", _OverlayManager.lastElKeypress);
          removeChildren(nextRowItem);
        }
        return;
      }
      if (overlayEl && overlay.actualY !== void 0) {
        const bg = overlayEl.querySelector(".info-overlay-bg");
        const fo = overlayEl.querySelector("foreignObject");
        const btnRect = overlayEl.querySelector(".info-overlay-close-btn rect");
        const btnText = overlayEl.querySelector(".info-overlay-close-btn text");
        updateHeight(overlay, overlay.defaultY + currY, overlay.height);
        bg.setAttribute("y", overlay.actualY.toString());
        fo.setAttribute("y", overlay.actualY.toString());
        btnText.setAttribute("y", overlay.actualY.toString());
        btnRect.setAttribute("y", overlay.actualY.toString());
        return;
      }
      addNewOverlay(rowItem.nextElementSibling, overlay);
    };
    rowItems.forEach(updateRow);
  }
};
OverlayManager.showFullName = (el) => {
  var _a;
  (_a = el.getElementsByClassName("row-fixed").item(0)) == null ? void 0 : _a.dispatchEvent(new MouseEvent("mouseenter"));
};
OverlayManager.firstElKeypress = (evt) => {
  if (isTabUp(evt)) {
    const par = getParentByClassName(evt.target, "row-overlay-holder");
    if (par && par.previousElementSibling) {
      OverlayManager.showFullName(par.previousElementSibling);
    }
  }
};
OverlayManager.lastElKeypress = (evt) => {
  if (isTabDown(evt)) {
    const par = getParentByClassName(evt.target, "row-overlay-holder");
    if (par && par.nextElementSibling) {
      OverlayManager.showFullName(par.nextElementSibling);
    }
  }
};
var overlay_manager_default = OverlayManager;

// node_modules/perf-cascade/lib/waterfall/details-overlay/pub-sub.js
var PubSub = class {
  constructor() {
    this.subscribers = [];
  }
  /** Call `fn` whenever a new change is publisched on OverlayChanges channel */
  subscribeToOverlayChanges(fn) {
    this.subscribers.push(fn);
  }
  /**
   * Call `fn` whenever a new change for `index` are publisched
   * on OverlayChanges channel
   */
  subscribeToSpecificOverlayChanges(index, fn) {
    this.subscribers.push((evt) => {
      if (evt.changedIndex === index) {
        fn(evt);
      }
    });
  }
  /** Publish a change on OverlayChanges channel  */
  publishToOverlayChanges(change) {
    this.subscribers.forEach((fn) => fn(change));
  }
};

// node_modules/perf-cascade/lib/helpers/icons.js
var icons_exports = {};
__export(icons_exports, {
  audio: () => audio,
  css: () => css,
  err3xx: () => err3xx,
  err4xx: () => err4xx,
  err5xx: () => err5xx,
  error: () => error,
  flash: () => flash,
  font: () => font,
  html: () => html,
  image: () => image,
  javascript: () => javascript,
  noTls: () => noTls,
  other: () => other,
  plain: () => plain,
  svg: () => svg,
  video: () => video,
  warning: () => warning
});
var wrapSvgIcon = (x, y, title, className, scale, svgEl) => {
  const holder = newSvg("", {
    x,
    y
  });
  const el = newG(`icon ${className}`, {
    transform: `scale(${scale})`
  });
  el.appendChild(svgEl);
  el.appendChild(newTitle(title));
  holder.appendChild(el);
  return holder;
};
var noTlsIconLazy;
function noTls(x, y, title, scale = 1) {
  if (noTlsIconLazy === void 0) {
    const d = `M18 6.216v2.77q0 .28-.206.486-.205.206-.486.206h-.693q-.28 0-.486-.206-.21-.205-.21
  -.487v-2.77q0-1.145-.81-1.957-.813-.81-1.96-.81-1.146 0-1.957.81-.81.812-.81 1.958v2.077h1.037q.434
  0 .737.303.302.303.302.736v6.23q0 .433-.305.736t-.737.303H1.038q-.433 0-.736-.3Q0 15.996 0
  15.56V9.33q0-.433.303-.736t.735-.303h7.27V6.218q0-2 1.422-3.423 1.423-1.423 3.424-1.423 2
  0 3.424 1.424Q18 4.214 18 6.216`;
    noTlsIconLazy = newPath(d);
  }
  return wrapSvgIcon(x, y, title, "icon-no-tls", scale, noTlsIconLazy.cloneNode(false));
}
var err3xxIconLazy;
function err3xx(x, y, title, scale = 1) {
  if (err3xxIconLazy === void 0) {
    const d = `M17 2.333V7q0 .27-.198.47-.198.197-.47.197h-4.665q-.438 0-.615-.417-.177-.406.146-.72l1.437-1.436Q11.095
  3.667 9 3.667q-1.083 0-2.068.422-.984.42-1.703 1.14-.72.715-1.14 1.7-.426.984-.426 2.07 0 1.08.422 2.065.42.984
  1.14 1.703.718.72 1.702 1.14.984.422 2.067.422 1.24 0 2.344-.54 1.104-.543 1.864-1.533.073-.105.24-.126.146 0
  .26.095l1.427 1.436q.095.084.1.214.006.13-.08.234-1.133 1.376-2.75 2.13Q10.793 17 9 17q-1.625
  0-3.104-.635-1.48-.636-2.552-1.71-1.073-1.072-1.71-2.55Q1 10.625 1 9t.635-3.104q.636-1.48 1.71-2.552
  1.072-1.073 2.55-1.71Q7.375 1 9 1q1.53 0 2.964.578 1.432.578 2.546
  1.63l1.355-1.343q.302-.323.73-.146.405.173.405.61z`;
    err3xxIconLazy = newPath(d);
  }
  return wrapSvgIcon(x, y, title, "icon-redirect", scale, err3xxIconLazy.cloneNode(false));
}
function err4xx(x, y, title, scale = 1) {
  return warning(x, y, title, scale);
}
function err5xx(x, y, title, scale = 1) {
  return warning(x, y, title, scale);
}
var plainIconLazy;
function plain(x, y, title, scale = 1) {
  if (plainIconLazy === void 0) {
    const d = `M15.247 4.393q.25.25.43.678.177.43.177.79v10.287q0
  .357-.25.607t-.607.25h-12q-.357 0-.607-.25t-.25-.606V1.858q0-.358.25-.608T2.997 1h8q.357 0
  .786.18.428.177.678.427zm-3.964-2.18V5.57h3.357q-.09-.256-.196-.364L11.65 2.41q-.108-.106-.367
  -.196zm3.428 13.644V6.714H11q-.357 0-.607-.25t-.25-.607V2.143h-6.86v13.714H14.71zM5.57
  8.143q0-.125.08-.205.08-.08.204-.08h6.286q.125 0 .205.08.08.08.08.205v.57q0 .126-.08.207-.08.08
  -.205.08H5.854q-.125 0-.205-.08-.08-.08-.08-.206v-.57zm6.57 2q.125 0 .205.08.08.08.08.206V11q0
  .125-.08.205-.08.08-.205.08H5.854q-.125 0-.205-.08-.08-.08-.08-.205v-.57q0-.126.08-.207.08-.08.2
  -.08h6.286zm0 2.286q.125 0 .205.08.08.08.08.2v.572q0 .125-.08.205-.08.08-.205.08H5.854q-.125 0-.205
  -.08-.08-.08-.08-.205v-.572q0-.124.08-.204.08-.08.2-.08h6.286z`;
    plainIconLazy = newPath(d);
  }
  return wrapSvgIcon(x, y, title, "icon-plain", scale, plainIconLazy.cloneNode(false));
}
var otherIconLazy;
function other(x, y, title, scale = 1) {
  if (otherIconLazy === void 0) {
    const d = `M10.8 13.5v3q0 .2-.15.35-.15.15-.35.15h-3q-.2 0-.35-.15-.15-.15-.15-.35v-3q0-.2.15-.35.15
  -.15.35-.15h3q.2 0 .35.15.15.15.15.35zM14.75 6q0 .675-.193 1.262-.193.588-.437.957-.244.365
  -.688.74-.443.375-.718.543-.275.17-.763.444-.51.286-.852.81-.344.526-.344.84 0 .21-.15.405-.15.194
  -.35.194h-3q-.186 0-.318-.23-.13-.234-.13-.47v-.564q0-1.037.812-1.956.812-.917 1.787-1.355.74-.336
  1.05-.7.314-.362.314-.95 0-.524-.583-.924-.58-.4-1.343-.4-.814 0-1.35.362-.44.312-1.34 1.437-.16.2
  -.386.2-.15 0-.313-.1L3.4 4.987q-.16-.124-.193-.312-.03-.188.07-.35Q5.277 1 9.077 1q1 0 2.01.387
  1.01.388 1.825 1.038.812.65 1.325 1.594.51.94.51 1.98z`;
    otherIconLazy = newPath(d);
  }
  return wrapSvgIcon(x, y, title, "icon-other", scale, otherIconLazy.cloneNode(false));
}
var javascriptIconLazy;
function javascript(x, y, title, scale = 1) {
  if (javascriptIconLazy === void 0) {
    const d = `M13.516 2.9c-2.766 0-4.463 1.522-4.463 3.536 0 1.733 1.295 2.82 3.256 3.52
  1.413.49 1.973.926 1.973 1.644 0 .787-.647 1.296-1.873 1.296-1.137 0-2.26-.368-2.96-.736l-.54
  2.19c.665.367 1.996.734 3.344.734 3.238 0 4.744-1.68 4.744-3.658
  0-1.68-.966-2.767-3.05-3.537-1.54-.6-2.186-.93-2.186-1.68 0-.6.56-1.14 1.714-1.14
  1.137 0 1.996.33 2.45.56l.596-2.138c-.7-.332-1.663-.596-3.01-.596zm-9.032.192v7.44c0
  1.822-.702 2.33-1.822 2.33-.525 0-.997-.09-1.365-.212L1 14.805c.525.175 1.33.28 1.96.28
  2.574 0 4.185-1.173 4.185-4.534V3.097h-2.66z`;
    javascriptIconLazy = newPath(d);
  }
  return wrapSvgIcon(x, y, title, "icon-js", scale, javascriptIconLazy.cloneNode(false));
}
var imageIconLazy;
function image(x, y, title, scale = 1) {
  if (imageIconLazy === void 0) {
    const d = `M6 6q0 .75-.525 1.275Q4.95 7.8 4.2 7.8q-.75 0-1.275-.525Q2.4 6.75 2.4
  6q0-.75.525-1.275Q3.45 4.2 4.2 4.2q.75 0 1.275.525Q6 5.25 6 6zm9.6 3.6v4.2H2.4V12l3-3
  1.5 1.5 4.8-4.8zm.9-6.6h-15q-.122 0-.21.09-.09.088-.09.21v11.4q0
  .122.09.21.088.09.21.09h15q.122 0 .21-.09.09-.088.09-.21V3.3q0-.122-.09-.21Q16.623
  3 16.5 3zm1.5.3v11.4q0 .62-.44 1.06-.44.44-1.06.44h-15q-.62 0-1.06-.44Q0 15.32 0
  14.7V3.3q0-.62.44-1.06.44-.44 1.06-.44h15q.62 0 1.06.44.44.44.44 1.06z`;
    imageIconLazy = newPath(d);
  }
  return wrapSvgIcon(x, y, title, "icon-image", scale, imageIconLazy.cloneNode(false));
}
function svg(x, y, title, scale = 1) {
  return image(x, y, title, scale);
}
var htmlIconLazy;
function html(x, y, title, scale = 1) {
  if (htmlIconLazy === void 0) {
    const d = `M5.626 13.31l-.492.492q-.098.098-.226.098t-.226-.098L.098 9.22Q0 9.12 0
  8.99q0-.127.098-.226L4.682 4.18q.098-.097.226-.097t.226.098l.492.49q.1.1.1.23t-.1.23L1.76
  8.99l3.866 3.866q.1.098.1.226t-.1.226zM11.44 2.815l-3.67
  12.7q-.04.127-.152.19-.113.065-.23.026l-.61-.162q-.13-.04-.193-.152-.064-.112-.024-.24l3.67-12.698q.04
  -.128.157-.192.113-.064.23-.025l.61.167q.13.04.193.152.063.113.023.24zM17.9
  9.22l-4.582 4.58q-.098.098-.226.098t-.226-.098l-.492-.492q-.1-.098-.1-.226t.1-.226L16.24
  8.99l-3.867-3.865q-.1-.098-.1-.226t.1-.23l.492-.49q.098-.1.226-.1t.23.1l4.58 4.583q.1.1.1.226 0 .13-.1.23z`;
    htmlIconLazy = newPath(d);
  }
  return wrapSvgIcon(x, y, title, "icon-html", scale, htmlIconLazy.cloneNode(false));
}
var cssIconLazy;
function css(x, y, title, scale = 1) {
  if (cssIconLazy === void 0) {
    const d = `M15.436.99q.625 0 1.095.416.47.415.47 1.04 0 .564-.4 1.35-2.97 5.624-4.16 6.724-.865.814
  -1.946.814-1.127 0-1.935-.827-.81-.827-.81-1.962 0-1.144.822-1.895l5.705-5.175Q14.8.99
  15.435.99zM7.31 10.232q.35.68.953 1.162.603.483 1.345.68l.01.634q.035 1.904-1.16 3.102-1.192
  1.198-3.114 1.198-1.1 0-1.948-.416-.85-.415-1.364-1.14-.514-.723-.773-1.635Q1 12.905 1
  11.85l.366.268q.304.224.555.398.25.175.53.327.277.15.41.15.368 0 .493-.33.224-.59.515-1.005.29
  -.415.62-.68.332-.263.788-.424.455-.16.92-.228.465-.066 1.118-.094z`;
    cssIconLazy = newPath(d);
  }
  return wrapSvgIcon(x, y, title, "icon-css", scale, cssIconLazy.cloneNode(false));
}
var warningIconLazy;
function warning(x, y, title, scale = 1) {
  if (warningIconLazy === void 0) {
    const d = `M6 6q0 .75-.525 1.275Q4.95 7.8 4.2 7.8q-.75 0-1.275-.525Q2.4 6.75 2.4
  6q0-.75.525-1.275Q3.45 4.2 4.2 4.2q.75 0 1.275.525Q6 5.25 6 6zm9.6 3.6v4.2H2.4V12l3-3
  1.5 1.5 4.8-4.8zm.9-6.6h-15q-.122 0-.21.09-.09.088-.09.21v11.4q0
  .122.09.21.088.09.21.09h15q.122 0 .21-.09.09-.088.09-.21V3.3q0-.122-.09-.21Q16.623
  3 16.5 3zm1.5.3v11.4q0 .62-.44 1.06-.44.44-1.06.44h-15q-.62 0-1.06-.44Q0 15.32 0
  14.7V3.3q0-.62.44-1.06.44-.44 1.06-.44h15q.62 0 1.06.44.44.44.44 1.06z`;
    warningIconLazy = newPath(d);
  }
  return wrapSvgIcon(x, y, title, "icon-warning", scale, warningIconLazy.cloneNode(false));
}
var errorIconLazy;
function error(x, y, title, scale = 1) {
  if (errorIconLazy === void 0) {
    const d = `M9 1q2.177 0 4.016 1.073 1.838 1.073 2.91 2.91Q17 6.823 17 9q0 2.177-1.073 4.016-1.073
  1.838-2.91 2.91Q11.177 17 9 17q-2.177 0-4.016-1.073-1.838-1.073-2.91-2.91Q1 11.177 1 9q0-2.177 1.073-4.016
  1.073-1.838 2.91-2.91Q6.823 1 9 1zm1.333 12.99v-1.98q0-.145-.093-.244-.094-.1-.23-.1h-2q-.135 0-.24.105
  -.103.106-.103.24v1.98q0 .136.104.24.106.104.24.104h2q.137 0 .23-.1.094-.098.094-.243zm-.02-3.584l.187
  -6.468q0-.125-.104-.188-.104-.084-.25-.084H7.854q-.146 0-.25.084-.104.062-.104.188l.177 6.468q0
  .104.104.183.106.076.25.076h1.93q.146 0 .245-.078.1-.08.11-.184z`;
    errorIconLazy = newPath(d);
  }
  return wrapSvgIcon(x, y, title, "icon-no-gzip", scale, errorIconLazy.cloneNode(false));
}
var fontIconLazy;
function font(x, y, title, scale = 1) {
  if (fontIconLazy === void 0) {
    const d = `M7.97 5.754L6.338 10.08q.317 0 1.312.02.994.02 1.542.02.183 0 .548-.02-.836-2.432-1.77
  -4.345zM1 16.38l.02-.76q.22-.068.538-.12.317-.053.548-.102.23-.048.476-.14.245-.09.428-.278.182
  -.187.298-.485l2.28-5.923 2.69-6.962H9.51q.077.135.105.202l1.972 4.615q.317.75 1.02 2.476.7 1.726
  1.095 2.64.144.327.558 1.39.413 1.062.692 1.62.192.432.336.547.183.145.847.284.663.14.807.197.058.37.058.55
  0 .04-.005.13t-.005.128q-.605 0-1.827-.076-1.22-.08-1.836-.08-.73 0-2.067.07-1.337.067-1.712.076 0-.412.04
  -.75l1.258-.27q.01 0 .12-.022l.15-.033q.038-.01.14-.044.1-.034.143-.06l.1-.08q.06-.048.082-.106.024-.056.024
  -.133 0-.152-.298-.926t-.693-1.71q-.392-.93-.402-.96l-4.325-.02q-.25.56-.734 1.88-.487 1.32-.487 1.56 0
  .213.136.362.134.15.418.235.285.087.467.13.185.044.55.08.366.04.395.04.01.183.01.558 0 .087-.02.26-.558
  0-1.678-.095-1.12-.098-1.678-.098-.08 0-.26.04-.18.037-.208.037-.77.136-1.808.136Z`;
    fontIconLazy = newPath(d);
  }
  return wrapSvgIcon(x, y, title, "icon-font", scale, fontIconLazy.cloneNode(false));
}
var flashIconLazy;
function flash(x, y, title, scale = 1) {
  if (flashIconLazy === void 0) {
    const d = `M13.724 4.738q.195.216.076.476L7.96 17.73q-.142.27-.456.27-.043 0-.15-.022-.185-.054-.277
  -.205-.092-.15-.05-.325l2.132-8.74L4.765 9.8q-.044.01-.13.01-.195 0-.336-.118-.193-.162-.14-.422L6.337.346q.043
  -.15.173-.25Q6.64 0 6.81 0h3.548q.206 0 .346.135.14.135.14.32 0 .086-.053.194L8.94 5.654l4.285
  -1.06q.086-.02.13-.02.205 0 .367.16z`;
    flashIconLazy = newPath(d);
  }
  return wrapSvgIcon(x, y, title, "icon-flash", scale, flashIconLazy.cloneNode(false));
}
var videoIconLazy;
function video(x, y, title, scale = 1) {
  if (videoIconLazy === void 0) {
    const d = `M17 4.107v9.714q0 .38-.348.53-.116.05-.223.05-.25 0-.41-.17l-3.6-3.6v1.48q0 1.067-.757 1.82-.754.756
  -1.817.756H3.57q-1.06 0-1.816-.753Q1 13.17 1 12.106V5.82q0-1.06.754-1.816.755-.754 1.817-.754h6.29q1.07 0
  1.82.754.76.755.76 1.817V7.3l3.597-3.59q.16-.17.4-.17.107 0 .22.045.35.153.35.528z`;
    videoIconLazy = newPath(d);
  }
  return wrapSvgIcon(x, y, title, "icon-video", scale, videoIconLazy.cloneNode(false));
}
var audioIconLazy;
function audio(x, y, title, scale = 1) {
  if (audioIconLazy === void 0) {
    const d = `M8.385 3.756v10.46q0 .252-.183.434-.183.183-.433.183t-.44-.183l-3.2-3.202H1.61q-.25
  0-.43-.183-.18-.182-.18-.432V7.14q0-.25.182-.432.182-.183.432-.183h2.52l3.202-3.202q.182-.183.432
  -.183t.43.183q.182.183.182.433zm3.692 5.23q0 .73-.41 1.36-.407.63-1.08.9-.097.048-.24.048-.25 0
  -.434-.178-.182-.177-.182-.437 0-.21.12-.35.12-.14.28-.24.16-.1.33-.22.166-.12.28-.34.117-.22.117
  -.55 0-.33-.115-.55-.115-.224-.28-.344-.163-.12-.326-.22-.165-.1-.28-.24-.116-.14-.116-.34 0-.26.183
  -.44t.43-.176q.146 0 .24.048.676.26 1.08.894.41.636.41 1.367zm2.46 0q0 1.472-.816 2.717t-2.16 1.813q
  -.12.048-.24.048-.26 0-.44-.183-.18-.18-.18-.43 0-.37.378-.56.54-.28.73-.42.713-.52 1.11-1.302.4
  -.783.4-1.667 0-.886-.4-1.67-.4-.783-1.11-1.303-.192-.145-.73-.424-.376-.192-.376-.567 0-.25.183
  -.434.183-.18.433-.18.123 0 .25.047 1.344.567 2.16 1.812.82 1.244.82 2.716zm2.463 0q0 2.212
  -1.22 4.063-1.222 1.85-3.25 2.72-.126.05-.25.05-.25 0-.434-.19-.183-.183-.183-.433 0-.346.375
  -.568.068-.04.217-.1.15-.064.216-.1.45-.244.79-.494 1.19-.875 1.85-2.183.67-1.306.67-2.777 0
  -1.47-.663-2.78-.664-1.304-1.846-2.18-.346-.25-.79-.49-.065-.035-.214-.1-.15-.06-.22-.1
  -.375-.22-.375-.57 0-.25.183-.43.183-.182.433-.182.123 0 .25.047 2.027.876 3.25 2.727Q17 6.775 17 8.99Z`;
    audioIconLazy = newPath(d);
  }
  return wrapSvgIcon(x, y, title, "icon-audio", scale, audioIconLazy.cloneNode(false));
}

// node_modules/perf-cascade/lib/waterfall/row/svg-tooltip.js
var translateYRegEx = /(?:translate)\(.+[, ]+(.+)\)/;
var tooltipMaxWidth = 200;
var getTranslateY = (str = "") => {
  str = str === null ? "" : str;
  const res = translateYRegEx.exec(str);
  if (res && res.length >= 2) {
    return parseInt(res[1], 10);
  }
  return 0;
};
var onHoverInShowTooltip = (base, rectData, foreignEl) => {
  const innerDiv = foreignEl.querySelector(".tooltip-payload");
  const row = getParentByClassName(base, "row-item");
  const yTransformOffsest = getTranslateY(row.getAttribute("transform"));
  const yInt = parseInt(base.getAttribute("y") || "", 10);
  const x = base.getAttribute("x") || "";
  const xPercInt = parseFloat(x);
  let offsetY = 50;
  const rowWidthPx = base.width.baseVal.value || base.getBoundingClientRect().width;
  const pxPerPerc = rowWidthPx / (rectData.width / rectData.unit);
  const percPerPx = rectData.width / rectData.unit / rowWidthPx;
  const isLeftOfRow = xPercInt > 50 && (95 - xPercInt) * pxPerPerc < tooltipMaxWidth;
  innerDiv.innerHTML = rectData.label || "";
  addClass(innerDiv, "no-anim");
  foreignEl.style.display = "block";
  innerDiv.style.opacity = "0.01";
  const initialHeight = innerDiv.clientHeight + 5;
  if (yInt + yTransformOffsest - initialHeight > 0) {
    offsetY = yTransformOffsest - initialHeight;
  } else {
    offsetY = yTransformOffsest + rectData.height + 10;
  }
  if (isLeftOfRow) {
    const newLeft = xPercInt - (innerDiv.clientWidth + 5) * percPerPx;
    let leftOffset = parseInt(foreignEl.querySelector("body").style.left || "", 10);
    const ratio = 1 / (1 / 100 * (100 - leftOffset));
    leftOffset = ratio * leftOffset;
    if (newLeft > -leftOffset) {
      innerDiv.style.left = `${newLeft}%`;
    } else {
      innerDiv.style.left = `${-leftOffset}%`;
    }
  } else {
    innerDiv.style.left = x;
  }
  foreignEl.setAttribute("y", `${yInt + offsetY}`);
  foreignEl.setAttribute("height", initialHeight.toString());
  removeClass(innerDiv, "no-anim");
  innerDiv.style.opacity = "1";
  const diff = innerDiv.clientHeight + 5 - initialHeight;
  if (diff !== 0) {
    foreignEl.setAttribute("height", (initialHeight + diff).toString());
    foreignEl.setAttribute("y", `${yInt + offsetY - diff}`);
  }
};
var onHoverOutShowTooltip = (base) => {
  const holder = getParentByClassName(base, "water-fall-chart");
  const foreignEl = holder.querySelector(".tooltip");
  const innerDiv = foreignEl.querySelector(".tooltip-payload");
  foreignEl.style.display = "none";
  foreignEl.setAttribute("height", "250");
  innerDiv.style.opacity = "0";
};
var makeTooltip = (options) => {
  const leftColOffsetPerc = options.leftColumnWidth;
  const holder = newSvg("tooltip-holder", {
    width: "100%",
    x: "0",
    y: "0"
  });
  const foreignEl = newForeignObject({
    width: `100%`,
    x: "0",
    y: `${leftColOffsetPerc}%`
  }, "tooltip", {
    display: "none"
  });
  const html2 = makeHtmlEl();
  const body = makeBodyEl({
    left: `${leftColOffsetPerc}%`,
    width: `${100 - leftColOffsetPerc}%`
  }, `<div class="tooltip-payload" style="max-width: ${tooltipMaxWidth}px; opacity: 0;"></div>`);
  html2.appendChild(body);
  foreignEl.appendChild(html2);
  holder.appendChild(foreignEl);
  return holder;
};

// node_modules/perf-cascade/lib/waterfall/row/svg-row-subcomponents.js
function makeBlock(rectData, className) {
  const holder = newG("");
  const blockHeight = rectData.height - 1;
  const rectX = roundNumber(rectData.x / rectData.unit) + "%";
  const rect = newRect({
    height: blockHeight,
    width: roundNumber(rectData.width / rectData.unit) + "%",
    x: rectX,
    y: rectData.y
  }, className);
  holder.appendChild(rect);
  if (rectData.label) {
    let showDelayTimeOut;
    let foreignElLazy;
    rect.addEventListener("mouseenter", () => {
      if (!foreignElLazy) {
        foreignElLazy = getParentByClassName(rect, "water-fall-chart").querySelector(".tooltip");
      }
      showDelayTimeOut = setTimeout(() => {
        showDelayTimeOut = null;
        onHoverInShowTooltip(rect, rectData, foreignElLazy);
      }, 100);
    });
    rect.addEventListener("mouseleave", () => {
      if (showDelayTimeOut) {
        clearTimeout(showDelayTimeOut);
      } else {
        onHoverOutShowTooltip(rect);
      }
    });
  }
  if (rectData.showOverlay && rectData.hideOverlay) {
    rect.addEventListener("mouseenter", rectData.showOverlay(rectData));
    rect.addEventListener("mouseleave", rectData.hideOverlay(rectData));
  }
  return holder;
}
function makeChunkBlock(chunkData, rectData, className) {
  const holder = newG("");
  const blockHeight = rectData.height - 1;
  const rectX = roundNumber(chunkData.ts / rectData.unit) + "%";
  const rect = newRect({
    height: blockHeight,
    width: "1px",
    x: rectX,
    y: rectData.y
  }, className, {
    pointerEvents: "none"
  });
  holder.appendChild(rect);
  return holder;
}
function segmentToRectData(segment, rectData) {
  const total = !isNaN(segment.total) ? `<br/>total: ${Math.round(segment.total)}ms` : "";
  return {
    cssClass: timingTypeToCssClass(segment.type),
    height: rectData.height - 6,
    hideOverlay: rectData.hideOverlay,
    label: `<strong>${segment.type}</strong><br/>${Math.round(segment.start)}ms - ${Math.round(segment.end)}ms${total}`,
    showOverlay: rectData.showOverlay,
    unit: rectData.unit,
    width: segment.total,
    x: segment.start || 1e-3,
    y: rectData.y
  };
}
function createTimingLabel(rectData, timeTotal, firstX) {
  const minWidth = 500;
  const spacingPerc = 5 / minWidth * 100;
  const y = rectData.y + rectData.height / 1.5;
  const totalLabel = `${Math.round(timeTotal)} ms`;
  let percStart = (rectData.x + rectData.width) / rectData.unit + spacingPerc;
  let txtEl = newTextEl(totalLabel, { x: `${roundNumber(percStart)}%`, y });
  const roughTxtWidth = totalLabel.length * 8;
  if (percStart + roughTxtWidth / minWidth * 100 > 100) {
    percStart = firstX / rectData.unit - spacingPerc;
    txtEl = newTextEl(totalLabel, { x: `${roundNumber(percStart)}%`, y }, { textAnchor: "end" });
  }
  return txtEl;
}
function createPushIndicator(rectData) {
  const y = rectData.y + rectData.height / 1.5;
  const x = `${roundNumber(rectData.x / rectData.unit)}%`;
  const el = newG("http2-inidicator-holder");
  el.appendChild(newTextEl("→", {
    transform: `translate(-5)`,
    x,
    y
  }, {
    "fillOpacity": "0.6",
    "text-anchor": "end"
  }));
  el.appendChild(newTitle("http2 Push"));
  return el;
}
function createRect(rectData, entry) {
  const segments = entry.segments;
  const rect = makeBlock(rectData, `time-block ${rectData.cssClass}`);
  const rectHolder = newG("rect-holder");
  let firstX = rectData.x;
  rectHolder.appendChild(rect);
  if (segments && segments.length > 0) {
    segments.forEach((segment) => {
      if (!isNaN(segment.total) && segment.total > 0 && typeof segment.start === "number") {
        const childRectData = segmentToRectData(segment, rectData);
        const childRect = makeBlock(childRectData, `segment ${childRectData.cssClass}`);
        firstX = Math.min(firstX, childRectData.x);
        if (segment.type === "receive" && segment.chunks && segment.chunks.length > 0) {
          segment.chunks.forEach((chunk) => {
            const chunkRect = makeChunkBlock(chunk, childRectData, `${childRectData.cssClass}-chunk`);
            childRect.appendChild(chunkRect);
          });
        }
        rectHolder.appendChild(childRect);
      }
    });
    if (find(entry.responseDetails.indicators, (indicator) => indicator.id === "push")) {
      rectHolder.appendChild(createPushIndicator(rectData));
    }
    rectHolder.appendChild(createTimingLabel(rectData, entry.total, firstX));
  }
  return rectHolder;
}
function createRequestNumberLabel(x, y, requestNumber, height, width) {
  y += Math.round(height / 2) + 5;
  x += width;
  return newTextEl(requestNumber, { x, y }, { "text-anchor": "end" });
}
function createRequestLabelClipped(x, y, name, height) {
  const blockLabel = createRequestLabel(x, y, name, height);
  blockLabel.style.clipPath = `url(#titleClipPath)`;
  return blockLabel;
}
function createRequestLabelFull(x, y, name, height) {
  const blockLabel = createRequestLabel(x, y, name, height);
  const labelHolder = newG("full-label", {}, {
    clipPath: `url(#titleFullClipPath)`
  });
  labelHolder.appendChild(newRect({
    height: height - 4,
    rx: 5,
    ry: 5,
    // for initial load performance use 500px as base width
    // it's updated one by one on hover
    width: 500,
    x: x - 3,
    y: y + 3
  }, "label-full-bg"));
  labelHolder.appendChild(blockLabel);
  return labelHolder;
}
function createRequestLabel(x, y, name, height) {
  const blockName = resourceUrlFormatter(name, 125);
  y = y + Math.round(height / 2) + 5;
  const blockLabel = newTextEl(blockName, { x, y });
  blockLabel.appendChild(newTitle(name));
  blockLabel.style.opacity = name.match(/js.map$/) ? "0.5" : "1";
  return blockLabel;
}
var supportsAnimationFrame = typeof window.requestAnimationFrame === "function" && typeof window.cancelAnimationFrame === "function";
function appendRequestLabels(rowFixed, requestNumberLabel, shortLabel, fullLabel) {
  const labelFullBg = fullLabel.getElementsByTagName("rect")[0];
  const fullLabelText = fullLabel.getElementsByTagName("text")[0];
  fullLabel.style.display = "none";
  fullLabel.style.visibility = "hidden";
  rowFixed.appendChild(requestNumberLabel);
  rowFixed.appendChild(shortLabel);
  rowFixed.appendChild(fullLabel);
  let isAdjusted = false;
  let updateAnimFrame;
  rowFixed.addEventListener("mouseenter", () => {
    fullLabel.style.display = "block";
    shortLabel.style.display = "none";
    fullLabel.style.visibility = "visible";
    const update = () => {
      const newWidth = fullLabelText.getComputedTextLength() + 10;
      labelFullBg.setAttribute("width", newWidth.toString());
      isAdjusted = true;
      updateAnimFrame = void 0;
    };
    if (!isAdjusted) {
      if (supportsAnimationFrame) {
        updateAnimFrame = window.requestAnimationFrame(update);
      } else {
        update();
      }
    }
  });
  rowFixed.addEventListener("mouseleave", () => {
    shortLabel.style.display = "block";
    fullLabel.style.display = "none";
    fullLabel.style.visibility = "hidden";
    if (supportsAnimationFrame && updateAnimFrame !== void 0) {
      cancelAnimationFrame(updateAnimFrame);
    }
  });
}
function createBgStripe(y, height, isEven) {
  const className = isEven ? "even" : "odd";
  return newRect({
    height,
    width: "100%",
    x: 0,
    y
  }, className);
}
function createNameRowBg(y, rowHeight) {
  const rowFixed = newG("row row-fixed");
  rowFixed.appendChild(newRect({
    height: rowHeight,
    width: "100%",
    x: "0",
    y
  }, "", {
    opacity: 0
  }));
  return rowFixed;
}
function createRowBg(y, rowHeight) {
  const rowFixed = newG("row row-flex");
  rowFixed.appendChild(newRect({
    height: rowHeight,
    width: "100%",
    x: "0",
    y
  }, "", {
    opacity: 0
  }));
  return rowFixed;
}

// node_modules/perf-cascade/lib/waterfall/row/svg-row.js
var clipPathElProto = newClipPath("titleClipPath");
clipPathElProto.appendChild(newRect({
  height: "100%",
  width: "100%"
}));
var clipPathElFullProto = newClipPath("titleFullClipPath");
clipPathElFullProto.appendChild(newRect({
  height: "100%",
  width: "100%"
}));
var ROW_LEFT_MARGIN = 3;
function createRow(context, index, maxIconsWidth, maxNumberWidth, rectData, entry, onDetailsOverlayShow) {
  const y = rectData.y;
  const rowHeight = rectData.height;
  const leftColumnWidth = context.options.leftColumnWidth;
  const rowItem = newA(entry.responseDetails.rowClass || "");
  rowItem.setAttribute("tabindex", "0");
  rowItem.setAttribute("xlink:href", "javascript:void(0)");
  const leftFixedHolder = newSvg("left-fixed-holder", {
    width: `${leftColumnWidth}%`,
    x: "0"
  });
  const flexScaleHolder = newSvg("flex-scale-waterfall", {
    width: `${100 - leftColumnWidth}%`,
    x: `${leftColumnWidth}%`
  });
  const rect = createRect(rectData, entry);
  const rowName = createNameRowBg(y, rowHeight);
  const rowBar = createRowBg(y, rowHeight);
  const bgStripe = createBgStripe(y, rowHeight, index % 2 === 0);
  let x = ROW_LEFT_MARGIN + maxIconsWidth;
  if (context.options.showMimeTypeIcon) {
    const icon = entry.responseDetails.icon;
    x -= icon.width;
    rowName.appendChild(icons_exports[icon.type](x, y + 3, icon.title));
  }
  if (context.options.showIndicatorIcons) {
    getIndicatorIcons(entry).forEach((icon) => {
      x -= icon.width;
      rowName.appendChild(icons_exports[icon.type](x, y + 3, icon.title));
    });
  }
  x = ROW_LEFT_MARGIN + maxIconsWidth;
  const requestNumber = `${index + 1}`;
  const requestNumberLabel = createRequestNumberLabel(x, y, requestNumber, rowHeight, maxNumberWidth);
  x += maxNumberWidth + 4;
  const shortLabel = createRequestLabelClipped(x, y, resourceUrlFormatter(entry.url, 40), rowHeight);
  const fullLabel = createRequestLabelFull(x, y, entry.url, rowHeight);
  rowBar.appendChild(rect);
  appendRequestLabels(rowName, requestNumberLabel, shortLabel, fullLabel);
  context.pubSub.subscribeToSpecificOverlayChanges(index, (change) => {
    hasOpenOverlay = change.type === "open";
  });
  if (index > 0) {
    context.pubSub.subscribeToSpecificOverlayChanges(index - 1, (change) => {
      hasPrevOpenOverlay = change.type === "open";
    });
  }
  let hasOpenOverlay;
  let hasPrevOpenOverlay;
  rowItem.addEventListener("click", (evt) => {
    evt.preventDefault();
    onDetailsOverlayShow(evt);
  });
  rowItem.addEventListener("keydown", (evt) => {
    const e = evt;
    if (e.which === 32 || e.which === 13) {
      e.preventDefault();
      return onDetailsOverlayShow(e);
    }
    if (isTabUp(e) && !hasPrevOpenOverlay && index > 0) {
      if (rowItem.previousSibling && rowItem.previousSibling.previousSibling && rowItem.previousSibling.previousSibling.lastChild && rowItem.previousSibling.previousSibling.lastChild.lastChild) {
        rowItem.previousSibling.previousSibling.lastChild.lastChild.dispatchEvent(new MouseEvent("mouseenter"));
      }
      return;
    }
    if (isTabDown(e) && !hasOpenOverlay) {
      if (rowItem.nextSibling && rowItem.nextSibling.nextSibling && rowItem.nextSibling.nextSibling.lastChild && rowItem.nextSibling.nextSibling.lastChild.lastChild) {
        rowItem.nextSibling.nextSibling.lastChild.lastChild.dispatchEvent(new MouseEvent("mouseenter"));
      }
      return;
    }
  });
  rowItem.addEventListener("focusout", () => {
    rowName.dispatchEvent(new MouseEvent("mouseleave"));
  });
  flexScaleHolder.appendChild(rowBar);
  leftFixedHolder.appendChild(clipPathElProto.cloneNode(true));
  leftFixedHolder.appendChild(rowName);
  rowItem.appendChild(clipPathElFullProto.cloneNode(true));
  rowItem.appendChild(bgStripe);
  rowItem.appendChild(flexScaleHolder);
  rowItem.appendChild(leftFixedHolder);
  return rowItem;
}

// node_modules/perf-cascade/lib/waterfall/sub-components/svg-alignment-helper.js
function createAlignmentLines(diagramHeight) {
  return {
    endline: newLine({
      x1: "0",
      x2: "0",
      y1: "0",
      y2: diagramHeight
    }, "line-end"),
    startline: newLine({
      x1: "0",
      x2: "0",
      y1: "0",
      y2: diagramHeight
    }, "line-start")
  };
}
function makeHoverEvtListeners(hoverEl) {
  return {
    onMouseEnterPartial() {
      return (evt) => {
        const targetRect = evt.target;
        addClass(targetRect, "active");
        const xPosEnd = targetRect.x.baseVal.valueInSpecifiedUnits + targetRect.width.baseVal.valueInSpecifiedUnits + "%";
        const xPosStart = targetRect.x.baseVal.valueInSpecifiedUnits + "%";
        hoverEl.endline.x1.baseVal.valueAsString = xPosEnd;
        hoverEl.endline.x2.baseVal.valueAsString = xPosEnd;
        hoverEl.startline.x1.baseVal.valueAsString = xPosStart;
        hoverEl.startline.x2.baseVal.valueAsString = xPosStart;
        addClass(hoverEl.endline, "active");
        addClass(hoverEl.startline, "active");
      };
    },
    onMouseLeavePartial() {
      return (evt) => {
        const targetRect = evt.target;
        removeClass(targetRect, "active");
        removeClass(hoverEl.endline, "active");
        removeClass(hoverEl.startline, "active");
      };
    }
  };
}

// node_modules/perf-cascade/lib/waterfall/sub-components/svg-general-components.js
var appendSecond = (context, timeHolder, secsTotal, sec, addLabel = false) => {
  const diagramHeight = context.diagramHeight;
  const secPerc = 100 / secsTotal;
  let lineLabel;
  let lineClass = "sub-second-line";
  let x;
  if (addLabel) {
    const showTextBefore = sec > secsTotal - 0.2;
    lineClass = "second-line";
    x = roundNumber(secPerc * sec) + 0.5 + "%";
    const css2 = {};
    if (showTextBefore) {
      x = roundNumber(secPerc * sec) - 0.5 + "%";
      css2["text-anchor"] = "end";
    }
    lineLabel = newTextEl(sec + "s", { x, y: diagramHeight }, css2);
  }
  x = roundNumber(secPerc * sec) + "%";
  const lineEl = newLine({
    x1: x,
    x2: x,
    y1: 0,
    y2: diagramHeight
  }, lineClass);
  context.pubSub.subscribeToOverlayChanges((change) => {
    const offset = change.combinedOverlayHeight;
    const scale = (diagramHeight + offset) / diagramHeight;
    lineEl.setAttribute("transform", `scale(1, ${scale})`);
    if (addLabel) {
      lineLabel.setAttribute("transform", `translate(0, ${offset})`);
    }
  });
  timeHolder.appendChild(lineEl);
  if (addLabel) {
    timeHolder.appendChild(lineLabel);
  }
};
function createTimeScale(context, durationMs) {
  const timeHolder = newG("time-scale full-width");
  const secInMs = 1e3;
  const stepsInASec = 5;
  const showSubSteps = durationMs < 20 * secInMs;
  const subStepMs = showSubSteps ? Math.ceil(durationMs / (10 * secInMs)) * (secInMs / stepsInASec) : secInMs;
  const subStep = Number(1000n / BigInt(subStepMs));
  const secs = durationMs / secInMs;
  const steps = Math.floor(durationMs / subStepMs);
  for (let i = 0; i <= steps; i++) {
    const isMarkerStep = i % subStep === 0;
    const secValue = i / subStep;
    appendSecond(context, timeHolder, secs, secValue, isMarkerStep);
  }
  return timeHolder;
}

// node_modules/perf-cascade/lib/waterfall/sub-components/svg-marks.js
function createMarks(context, marks) {
  const diagramHeight = context.diagramHeight;
  const marksHolder = newG("marker-holder", {
    transform: "scale(1, 1)"
  });
  marks.forEach((mark, i) => {
    const x = roundNumber(mark.startTime / context.unit);
    const markHolder = newG("mark-holder type-" + mark.name.toLowerCase().replace(/([0-9]+[ ]?ms)|\W/g, ""));
    const lineHolder = newG("line-holder");
    const lineLabelHolder = newG("line-label-holder");
    const lineLabel = newTextEl(mark.name, { x: `${x}%`, y: diagramHeight + 25 });
    lineLabel.setAttribute("writing-mode", "tb");
    let lineRect;
    mark.x = x;
    const line = newLine({
      x1: x + "%",
      x2: x + "%",
      y1: 0,
      y2: diagramHeight
    });
    const previousMark = marks[i - 1];
    const nextMark = marks[i + 1];
    const minDistance = 2.5;
    const isCloseToPerviousMark = (previousMark == null ? void 0 : previousMark.x) !== void 0 && mark.x - previousMark.x < minDistance;
    const nextX = roundNumber(((nextMark == null ? void 0 : nextMark.startTime) || 0) / context.unit);
    if (nextX && nextX - mark.x < minDistance && nextX + minDistance >= 100 && !isCloseToPerviousMark) {
      lineLabel.setAttribute("x", `${nextX - minDistance}%`);
      mark.x = nextX - minDistance;
    } else if ((previousMark == null ? void 0 : previousMark.x) !== void 0 && isCloseToPerviousMark) {
      lineLabel.setAttribute("x", `${previousMark.x + minDistance}%`);
      mark.x = previousMark.x + minDistance;
    }
    const lineConnection = newLine({
      x1: x + "%",
      x2: mark.x + "%",
      y1: diagramHeight,
      y2: diagramHeight + 23
    });
    lineHolder.appendChild(line);
    lineHolder.appendChild(lineConnection);
    if (mark.duration) {
      lineRect = createLineRect(context, mark);
      lineHolder.appendChild(lineRect);
    }
    context.pubSub.subscribeToOverlayChanges((change) => {
      const offset = change.combinedOverlayHeight;
      const scale = (diagramHeight + offset) / diagramHeight;
      line.setAttribute("transform", `scale(1, ${scale})`);
      lineLabelHolder.setAttribute("transform", `translate(0, ${offset})`);
      lineConnection.setAttribute("transform", `translate(0, ${offset})`);
      if (lineRect) {
        lineRect.setAttribute("transform", `translate(0, ${offset})`);
      }
    });
    let isHoverActive = false;
    let isClickActive = false;
    const onLabelMouseEnter = () => {
      if (!isHoverActive) {
        markHolder.parentNode.appendChild(markHolder);
        isHoverActive = true;
        if (typeof window.requestAnimationFrame === "function") {
          window.requestAnimationFrame(() => addClass(lineHolder, "active"));
        } else {
          addClass(lineHolder, "active");
        }
      }
    };
    const onLabelMouseLeave = () => {
      isHoverActive = false;
      if (!isClickActive) {
        removeClass(lineHolder, "active");
      }
    };
    const onLabelClick = () => {
      if (isClickActive) {
        isHoverActive = false;
        removeClass(lineHolder, "active");
      } else if (!isHoverActive) {
        addClass(lineHolder, "active");
      } else {
        isHoverActive = false;
      }
      isClickActive = !isClickActive;
    };
    lineLabel.addEventListener("mouseenter", onLabelMouseEnter);
    lineLabel.addEventListener("mouseleave", onLabelMouseLeave);
    lineLabel.addEventListener("click", onLabelClick);
    lineLabelHolder.appendChild(lineLabel);
    markHolder.appendChild(newTitle(mark.name));
    markHolder.appendChild(lineHolder);
    markHolder.appendChild(lineLabelHolder);
    marksHolder.appendChild(markHolder);
  });
  return marksHolder;
}
function createLineRect(context, entry) {
  const holder = newG(`line-mark-holder line-marker-${toCssClass(entry.name)}`);
  holder.appendChild(newTitle(entry.name.replace(/^startTimer-/, "")));
  holder.appendChild(newRect({
    height: context.diagramHeight,
    width: (entry.duration || 1) / context.unit + "%",
    x: (entry.startTime || 1e-3) / context.unit + "%",
    y: 0
  }, "line-mark"));
  return holder;
}

// node_modules/perf-cascade/lib/waterfall/svg-chart.js
function getWidestDigitString(n) {
  const numDigits = Math.floor(Math.log(n) / Math.LN10) + 1;
  let s = "";
  for (let i = 0; i < numDigits; i++) {
    s += "0";
  }
  return s;
}
function getSvgHeight(marks, diagramHeight) {
  const maxMarkTextLength = marks.reduce((currMax, currValue) => {
    const attributes = { x: 0, y: 0 };
    return Math.max(currMax, getNodeTextWidth(newTextEl(currValue.name, attributes), true));
  }, 0);
  return Math.floor(diagramHeight + maxMarkTextLength + 35);
}
function createContext(data, options, entriesToShow) {
  const unit = data.durationMs / 100;
  const diagramHeight = (entriesToShow.length + 1) * options.rowHeight;
  const context = {
    diagramHeight,
    options,
    pubSub: new PubSub(),
    unit
  };
  return {
    ...context,
    overlayManager: new overlay_manager_default(context)
  };
}
function createWaterfallSvg(data, options) {
  const entriesToShow = data.entries.filter((entry) => typeof entry.start === "number" && typeof entry.total === "number").sort((a, b) => (a.start || 0) - (b.start || 0));
  const overlayHolder = newG("overlays");
  const rowHolder = newG("rows-holder");
  const context = createContext(data, options, entriesToShow);
  const chartHolderHeight = getSvgHeight(data.marks, context.diagramHeight);
  const timeLineHolder = newSvg("water-fall-chart", {
    height: chartHolderHeight
  });
  const scaleAndMarksHolder = newSvg("scale-and-marks-holder", {
    width: `${100 - options.leftColumnWidth}%`,
    x: `${options.leftColumnWidth}%`
  });
  let hoverOverlayHolder;
  let mouseListeners;
  if (options.showAlignmentHelpers) {
    hoverOverlayHolder = newG("hover-overlays");
    const hoverEl = createAlignmentLines(context.diagramHeight);
    hoverOverlayHolder.appendChild(hoverEl.startline);
    hoverOverlayHolder.appendChild(hoverEl.endline);
    mouseListeners = makeHoverEvtListeners(hoverEl);
  }
  scaleAndMarksHolder.appendChild(createTimeScale(context, data.durationMs));
  scaleAndMarksHolder.appendChild(createMarks(context, data.marks));
  const perIconWidth = entriesToShow[0].responseDetails.icon.width;
  let maxIcons = 0;
  if (options.showMimeTypeIcon) {
    maxIcons += 1;
  }
  if (options.showIndicatorIcons) {
    const iconsPerBlock = entriesToShow.map((entry) => entry.responseDetails.indicators.filter((i) => i.displayType === "icon").length > 0 ? 1 : 0);
    maxIcons += Math.max.apply(null, iconsPerBlock);
  }
  const maxIconsWidth = maxIcons * perIconWidth;
  const widestRequestNumber = getWidestDigitString(entriesToShow.length);
  const maxNumberWidth = getNodeTextWidth(newTextEl(`${widestRequestNumber}`), true);
  const rowItems = [];
  function getChartHeight() {
    return chartHolderHeight + context.overlayManager.getCombinedOverlayHeight();
  }
  context.pubSub.subscribeToOverlayChanges(() => {
    const newHeight = getChartHeight();
    timeLineHolder.classList.toggle("closing", newHeight < timeLineHolder.clientHeight);
    timeLineHolder.style.height = `${newHeight}px`;
  });
  function renderRow(entry, i) {
    const entryWidth = entry.total || 1;
    const y = options.rowHeight * i;
    const x = entry.start || 1e-3;
    const detailsHeight = 450;
    const rectData = {
      cssClass: requestTypeToCssClass(entry.responseDetails.requestType),
      height: options.rowHeight,
      hideOverlay: options.showAlignmentHelpers ? mouseListeners.onMouseLeavePartial : void 0,
      label: `<strong>${entry.url}</strong><br/>${Math.round(entry.start)}ms - ${Math.round(entry.end)}ms<br/>total: ${isNaN(entry.total) ? "n/a " : Math.round(entry.total)}ms`,
      showOverlay: options.showAlignmentHelpers ? mouseListeners.onMouseEnterPartial : void 0,
      unit: context.unit,
      width: entryWidth,
      x,
      y
    };
    const showDetailsOverlay = () => {
      context.overlayManager.toggleOverlay(i, y + options.rowHeight, detailsHeight, entry, rowItems);
    };
    const rowItem = createRow(context, i, maxIconsWidth, maxNumberWidth, rectData, entry, showDetailsOverlay);
    rowItems.push(rowItem);
    rowHolder.appendChild(rowItem);
    rowHolder.appendChild(newG("row-overlay-holder"));
  }
  entriesToShow.forEach(renderRow);
  if (options.showAlignmentHelpers && hoverOverlayHolder !== void 0) {
    scaleAndMarksHolder.appendChild(hoverOverlayHolder);
  }
  timeLineHolder.appendChild(scaleAndMarksHolder);
  timeLineHolder.appendChild(rowHolder);
  timeLineHolder.appendChild(overlayHolder);
  timeLineHolder.appendChild(makeTooltip(options));
  return timeLineHolder;
}

// node_modules/perf-cascade/lib/main.js
var defaultChartOptions = {
  leftColumnWidth: 25,
  legendHolder: void 0,
  onParsed: void 0,
  pageSelector: void 0,
  rowHeight: 23,
  selectedPage: 0,
  showAlignmentHelpers: true,
  showIndicatorIcons: true,
  showMimeTypeIcon: true
};
var defaultHarTransformerOptions = {
  showUserTiming: false,
  showUserTimingEndMarker: false
};
function makeLegend2() {
  return makeLegend();
}
function PerfCascade(waterfallDocsData, chartOptions = {}) {
  if (chartOptions["leftColumnWith"] !== void 0) {
    console.warn("Depreciation Warning: The option 'leftColumnWith' has been fixed to 'leftColumnWidth', please update your code as this will get deprecated in the future");
    chartOptions.leftColumnWidth = chartOptions["leftColumnWith"];
  }
  const options = validateOptions({ ...defaultChartOptions, ...chartOptions });
  const paging = new Paging(waterfallDocsData, options.selectedPage);
  let doc = createWaterfallSvg(paging.getSelectedPage(), options);
  paging.onPageUpdate((_pageIndex, pageDoc) => {
    const el = doc.parentElement;
    const newDoc = createWaterfallSvg(pageDoc, options);
    el.replaceChild(newDoc, doc);
    doc = newDoc;
  });
  if (options.pageSelector) {
    paging.initPagingSelectBox(options.pageSelector);
  }
  if (options.legendHolder) {
    options.legendHolder.innerHTML = "";
    options.legendHolder.appendChild(makeLegend());
  }
  return doc;
}
function fromHar(harData, options = {}) {
  const harTransformerOptions = {
    ...defaultHarTransformerOptions,
    ...options
  };
  const data = transformDoc(harData, harTransformerOptions);
  if (typeof options.onParsed === "function") {
    options.onParsed(data);
  }
  return PerfCascade(data, options);
}

// node_modules/perf-cascade/lib/file-reader.js
var getConfiguredZipJs = () => {
  const zip = window["zip"] || {};
  zip.useWebWorkers = false;
  return zip;
};
function readFile(file, fileName, callback, onProgress) {
  if (!file) {
    return callback(new Error("Failed to load HAR file"));
  }
  function parseJson(rawData) {
    try {
      const harData = JSON.parse(rawData);
      callback(null, harData.log);
    } catch (e) {
      callback(e);
    }
  }
  const extension = (fileName.match(/\.[0-9a-z]+$/i) || [])[0];
  const zip = getConfiguredZipJs();
  if ([".zhar", ".zip"].indexOf(extension) !== -1) {
    zip.createReader(new zip.BlobReader(file), (zipReader) => {
      zipReader.getEntries((x) => {
        x[0].getData(new zip.TextWriter(), (txt) => {
          parseJson(txt);
          zipReader.close();
        }, onProgress);
      });
    });
  } else {
    const reader = new FileReader();
    reader.addEventListener("load", (e) => {
      parseJson(e.target.result);
    });
    reader.readAsText(file);
  }
}

export {
  makeLegend2 as makeLegend,
  fromHar,
  readFile
};
//# sourceMappingURL=chunk-NJUHM74N.js.map
