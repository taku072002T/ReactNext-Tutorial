// src/server/appBuilderWorker.ts
import invariant5 from "invariant";

// src/server/toolpadAppBuilder.ts
import * as path2 from "path";
import * as url from "node:url";
import * as fs from "fs";
import react from "@vitejs/plugin-react";
import { indent } from "@toolpad/utils/strings";
import * as appDom from "@toolpad/studio-runtime/appDom";

// src/constants.ts
var INITIAL_STATE_WINDOW_PROPERTY = "__initialToolpadState__";
var UPGRADE_URL = "https://mui.com/toolpad/studio/getting-started/roadmap/#paid-plan";
var VERSION_CHECK_INTERVAL = 1e3 * 60 * 10;

// src/server/viteVirtualPlugin.ts
import { posix as path } from "path";
import { transformWithEsbuild } from "vite";
var API_PROPERTY = Symbol("virtual-fs-api");
function virtualFsPlugin(initialFiles, userIdentifier) {
  const prefix = `virtual:${userIdentifier}:`;
  const resolvedPrefix = `\0${prefix}`;
  const transformExtensions = /* @__PURE__ */ new Set([".js", ".jsx", ".ts", ".tsx"]);
  const resolveExtensions = /* @__PURE__ */ new Set([".js", ".jsx", ".ts", ".tsx", ".json"]);
  let serverInstance;
  let files = initialFiles;
  return {
    name: "virtual-fs",
    enforce: "pre",
    configureServer(server) {
      serverInstance = server;
    },
    resolveId(id, importer) {
      if (id.startsWith(prefix)) {
        const entryPath = id.slice(prefix.length);
        if (files.has(entryPath)) {
          return `${resolvedPrefix}${entryPath}`;
        }
        for (const extension of resolveExtensions) {
          const entryPathWithExtension = `${entryPath}${extension}`;
          if (files.has(entryPathWithExtension)) {
            return `${resolvedPrefix}${entryPathWithExtension}`;
          }
        }
      } else if (importer?.startsWith(resolvedPrefix)) {
        const importerPath = importer.slice(resolvedPrefix.length);
        const fullPath = path.resolve(path.dirname(importerPath), id);
        return this.resolve(`${prefix}${fullPath}`, importer);
      }
      return null;
    },
    async load(id) {
      if (id.startsWith(resolvedPrefix)) {
        const virtualPath = id.slice(resolvedPrefix.length);
        const content = files.get(virtualPath);
        return content;
      }
      return null;
    },
    async transform(code, id) {
      if (id.startsWith(resolvedPrefix)) {
        const virtualPath = id.slice(resolvedPrefix.length);
        if (transformExtensions.has(path.extname(virtualPath))) {
          return transformWithEsbuild(code, virtualPath);
        }
      }
      return null;
    },
    [API_PROPERTY]: {
      async replaceFiles(newFiles) {
        const filesToInvalidate = [];
        for (const [virtualPath, content] of files) {
          if (!newFiles.has(virtualPath) || newFiles.get(virtualPath) !== content) {
            filesToInvalidate.push(virtualPath);
          }
        }
        files = newFiles;
        if (serverInstance) {
          for (const virtualPath of filesToInvalidate) {
            const resolvedId = `${resolvedPrefix}${virtualPath}`;
            const mod = serverInstance.moduleGraph.getModuleById(resolvedId);
            if (mod) {
              serverInstance.reloadModule(mod);
            }
          }
        } else {
          console.warn("Server instance not found, cannot invalidate files");
        }
      }
    }
  };
}
function replaceFiles(plugin, newFiles) {
  return plugin[API_PROPERTY].replaceFiles(newFiles);
}

// src/runtime/constants.ts
var FONTS_URL = "https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap";

// src/server/toolpadAppBuilder.ts
var currentDirectory = url.fileURLToPath(new URL(".", import.meta.url));
var pkgJsonContent = fs.readFileSync(path2.resolve(currentDirectory, "../../package.json"), {
  encoding: "utf-8"
});
var pkgJson = JSON.parse(pkgJsonContent);
var TOOLPAD_BUILD = process.env.GIT_SHA1?.slice(0, 7) || "dev";
var MAIN_ENTRY = "/main.tsx";
var EDITOR_ENTRY = "/editor.tsx";
function getHtmlContent(entry) {
  return `
    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Toolpad</title>
        <link rel="preload" href="${FONTS_URL}" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="${FONTS_URL}"></noscript>
      </head>
      <body>
        <div id="root"></div>
    
        <!-- __TOOLPAD_SCRIPTS__ -->

        <script type="module" src=${JSON.stringify(entry)}></script>
      </body>
    </html>
  `;
}
function getAppHtmlContent() {
  return getHtmlContent(MAIN_ENTRY);
}
function getEditorHtmlContent() {
  return getHtmlContent(EDITOR_ENTRY);
}
function toolpadStudioVitePlugin() {
  return {
    name: "toolpad-studio",
    async resolveId(id) {
      if (id.endsWith(".html")) {
        return id;
      }
      return null;
    },
    async load(id) {
      if (id.endsWith("index.html")) {
        return getAppHtmlContent();
      }
      if (id.endsWith("editor.html")) {
        return getEditorHtmlContent();
      }
      return null;
    }
  };
}
async function createViteConfig({
  toolpadDevMode,
  outDir,
  root,
  dev,
  base,
  customServer,
  plugins = [],
  getComponents,
  loadDom,
  getPagesManifest
}) {
  const mode = dev ? "development" : "production";
  const initialDom = await loadDom();
  const plan = appDom.getPlan(initialDom);
  const getEntryPoint = (target) => {
    const isEditor = target === "editor";
    const componentsId = "virtual:toolpad-files:components.tsx";
    return `
import { init, setComponents } from '@toolpad/studio/entrypoint';
import components from ${JSON.stringify(componentsId)};
${isEditor ? `import ToolpadEditor from '@toolpad/studio/editor'` : ""}

${isEditor ? `
      // importing monaco to get around module ordering issues in esbuild
      import 'monaco-editor';

      window.MonacoEnvironment = {
        getWorker: async (_, label) => {
          // { type: 'module' } is supported in firefox but behind feature flag:
          // you have to enable it manually via about:config and set dom.workers.modules.enabled to true.
          if (label === 'typescript') {
            const { default: TsWorker } = await import('monaco-editor/esm/vs/language/typescript/ts.worker?worker');
            return new TsWorker();
          }
          if (label === 'json') {
            const { default: JsonWorker } = await import('monaco-editor/esm/vs/language/json/json.worker?worker');
            return new JsonWorker();
          }
          if (label === 'html') {
            const { default: HtmlWorker } = await import('monaco-editor/esm/vs/language/html/html.worker?worker');
            return new HtmlWorker();
          }
          if (label === 'css') {
            const { default: CssWorker } = await import('monaco-editor/esm/vs/language/css/css.worker?worker');
            return new CssWorker();
          }
          if (label === 'editorWorkerService') {
            const { default: EditorWorker } = await import('monaco-editor/esm/vs/editor/editor.worker?worker');
            return new EditorWorker();
          }
          throw new Error(\`Failed to resolve worker with label "\${label}"\`);
        },
      } as monaco.Environment;
      ` : ""}

const initialState = window[${JSON.stringify(INITIAL_STATE_WINDOW_PROPERTY)}];

setComponents(components);

init({
  ${isEditor ? `ToolpadApp: ToolpadEditor,` : ""}
  base: ${JSON.stringify(base)},
  initialState,
})

if (import.meta.hot) {
  // TODO: investigate why this doesn't work, see https://github.com/vitejs/vite/issues/12912
  import.meta.hot.accept(
    [${JSON.stringify(componentsId)}],
    (newComponents) => {
    if (newComponents) {
      console.log('hot updating Toolpad Studio components')
      setComponents(
        newComponents ?? components,
      );
    }
  });
}
`;
  };
  const createComponentsFile = async () => {
    const components = await getComponents();
    const imports = components.map(
      ({ name }) => `import ${name} from 'toolpad-user-project:./components/${name}';`
    );
    const defaultExportProperties = components.map(
      ({ name }) => `${JSON.stringify(`codeComponent.${name}`)}: ${name}`
    );
    const code = `
      ${imports.join("\n")}

      export default {
        ${indent(defaultExportProperties.join(",\n"), 2)}
      };
    `;
    return {
      code,
      map: null
    };
  };
  const virtualFiles = /* @__PURE__ */ new Map([
    ["main.tsx", getEntryPoint("prod")],
    ["editor.tsx", getEntryPoint("editor")],
    ["components.tsx", await createComponentsFile()],
    ["pages-manifest.json", JSON.stringify(await getPagesManifest(), null, 2)]
  ]);
  const virtualToolpadFiles = virtualFsPlugin(virtualFiles, "toolpad-files");
  return {
    reloadComponents: async () => {
      const newFiles = new Map(virtualFiles);
      newFiles.set("components.tsx", await createComponentsFile());
      replaceFiles(virtualToolpadFiles, newFiles);
    },
    viteConfig: {
      configFile: false,
      mode,
      build: {
        outDir,
        emptyOutDir: true,
        chunkSizeWarningLimit: Infinity,
        rollupOptions: {
          input: {
            index: path2.resolve(currentDirectory, "./index.html"),
            ...dev ? { editor: path2.resolve(currentDirectory, "./editor.html") } : {}
          },
          onwarn(warning, warn) {
            if (warning.code === "MODULE_LEVEL_DIRECTIVE") {
              return;
            }
            warn(warning);
          }
        }
      },
      envFile: false,
      resolve: {
        dedupe: ["@mui/material", "@emotion/react", "@emotion/styled", "@tanstack/react-query"],
        alias: [
          {
            // FIXME(https://github.com/mui/material-ui/issues/35233)
            find: /^@mui\/icons-material\/(?!esm\/)([^/]*)/,
            replacement: "@mui/icons-material/esm/$1"
          },
          {
            find: /^toolpad-user-project:(.*)$/,
            replacement: `${root}/$1`
          },
          {
            find: MAIN_ENTRY,
            replacement: "virtual:toolpad-files:main.tsx"
          },
          {
            find: "@toolpad/studio",
            replacement: toolpadDevMode ? (
              // load source
              path2.resolve(currentDirectory, "../../src/exports")
            ) : (
              // load compiled
              path2.resolve(currentDirectory, "../exports")
            )
          },
          ...dev ? [
            {
              find: EDITOR_ENTRY,
              replacement: "virtual:toolpad-files:editor.tsx"
            },
            {
              find: "vm",
              replacement: "vm-browserify"
            }
          ] : []
        ]
      },
      optimizeDeps: {
        include: [
          ...dev ? [
            "perf-cascade",
            "monaco-editor",
            "monaco-editor/esm/vs/basic-languages/javascript/javascript",
            "monaco-editor/esm/vs/basic-languages/typescript/typescript",
            "monaco-editor/esm/vs/basic-languages/markdown/markdown"
          ] : ["@toolpad/studio/entrypoint", "@toolpad/studio/editor"]
        ]
      },
      appType: "custom",
      logLevel: "info",
      root: currentDirectory,
      plugins: [toolpadStudioVitePlugin(), virtualToolpadFiles, react(), ...plugins],
      base,
      define: {
        "process.env.NODE_ENV": `'${mode}'`,
        "process.env.BASE_URL": `'${base}'`,
        "process.env.TOOLPAD_CUSTOM_SERVER": `'${JSON.stringify(customServer)}'`,
        "process.env.TOOLPAD_VERSION": JSON.stringify(pkgJson.version),
        "process.env.TOOLPAD_BUILD": JSON.stringify(TOOLPAD_BUILD),
        "process.env.TOOLPAD_PLAN": JSON.stringify(plan)
      }
    }
  };
}
async function buildApp({
  root,
  base,
  getComponents,
  getPagesManifest,
  loadDom,
  outDir
}) {
  const { viteConfig } = await createViteConfig({
    toolpadDevMode: false,
    dev: false,
    root,
    base,
    outDir,
    getComponents,
    getPagesManifest,
    loadDom
  });
  const vite = await import("vite");
  await vite.build(viteConfig);
}

// src/server/localMode.ts
import * as path8 from "path";
import * as fs5 from "fs/promises";
import { isMainThread } from "worker_threads";
import * as yaml from "yaml";
import invariant4 from "invariant";
import openEditor from "open-editor";
import chalk3 from "chalk";
import { fromZodError as fromZodError2 } from "zod-validation-error";
import { glob as glob2 } from "glob";
import * as chokidar3 from "chokidar";
import { debounce, throttle } from "lodash-es";
import { Emitter } from "@toolpad/utils/events";
import { guessTitle, isValidJsIdentifier } from "@toolpad/utils/strings";
import { errorFrom as errorFrom7 } from "@toolpad/utils/errors";
import { filterValues, hasOwnProperty, mapValues } from "@toolpad/utils/collections";
import { execa } from "execa";
import {
  writeFileRecursive as writeFileRecursive2,
  readMaybeFile,
  readMaybeDir,
  updateYamlFile,
  fileExists as fileExists3,
  readJsonFile as readJsonFile2
} from "@toolpad/utils/fs";
import { z as z3 } from "zod";
import * as appDom3 from "@toolpad/studio-runtime/appDom";

// src/utils/insecureHash.ts
function insecureHash(str) {
  let h = 0;
  for (let i = 0; i < str.length; i += 1) {
    h = Math.imul(31, h) + str.charCodeAt(i) | 0;
  }
  return h;
}

// src/server/schema.ts
import { z } from "zod";
var API_VERSION = "v1";
function toolpadObjectSchema(kind, spec) {
  return z.object({
    apiVersion: z.literal("v1").describe(
      `Defines the version of this object. Used in determining compatibility between Toolpad Studio "${kind}" objects.`
    ),
    kind: z.literal(kind).describe(`Describes the nature of this Toolpad Studio "${kind}" object.`),
    spec: spec.optional().describe(`Defines the shape of this "${kind}" object`)
  });
}
var literalSchema = z.union([z.string(), z.number(), z.boolean(), z.null()]);
function nameValuePairSchema(valueType) {
  return z.object({
    name: z.string().describe("The name"),
    value: valueType.describe(valueType.description ?? "The value")
  }).describe("A name/value pair.");
}
var jsExpressionBindingSchema = z.object({
  $$jsExpression: z.string().describe("The expression to be evaluated.")
}).describe("A binding that evaluates an expression and returns the result.");
var envBindingSchema = z.object({
  $$env: z.string().describe("The name of an environment variable.")
}).describe("An environment variable.");
function bindableSchema(valueType) {
  return z.union([valueType, jsExpressionBindingSchema, envBindingSchema]);
}
var jsExpressionActionSchema = z.object({
  $$jsExpressionAction: z.string().describe("The code to be executed.")
}).describe("A javascript expression to be executed when this action is triggered.");
var navigationActionSchema = z.object({
  $$navigationAction: z.object({
    page: z.string().describe("The page that is being navigated to"),
    parameters: z.record(bindableSchema(z.any())).describe("Parameters to pass when navigating to this page")
  })
}).describe(
  "A navigation from one page to another, optionally passing parameters to the next page."
);
var fetchModeSchema = z.union([
  z.literal("query").describe("Fetch automatically when the page opens"),
  z.literal("mutation").describe("Fetch on manual action only")
]);
var nameStringValuePairSchema = nameValuePairSchema(z.string()).describe(
  "a name/value pair with a string value."
);
var rawBodySchema = z.object({
  kind: z.literal("raw"),
  content: bindableSchema(z.string()),
  contentType: z.string()
});
var bindableNameStringValueSchema = nameValuePairSchema(bindableSchema(z.string())).describe(
  "A name/value pair where the value is dynamically bindable to strings."
);
var urlEncodedBodySchema = z.object({
  kind: z.literal("urlEncoded"),
  content: z.array(bindableNameStringValueSchema)
});
var fetchBodySchema = z.discriminatedUnion("kind", [rawBodySchema, urlEncodedBodySchema]);
var rawResponseTypeSchema = z.object({
  kind: z.literal("raw")
}).describe("Don't interpret this body at all.");
var jsonResponseTypeSchema = z.object({
  kind: z.literal("json")
}).describe("Interpret the fetch response as JSON");
var csvResponseTypeSchema = z.object({
  kind: z.literal("csv"),
  headers: z.boolean().describe("First row contains headers")
}).describe("Interpret the fetch response as CSV");
var xmlResponseTypeSchema = z.object({
  kind: z.literal("xml")
}).describe("Interpret the fetch response as XML");
var responseTypeSchema = z.discriminatedUnion("kind", [
  rawResponseTypeSchema,
  jsonResponseTypeSchema,
  csvResponseTypeSchema,
  xmlResponseTypeSchema
]).describe("Describes how a the fetch response is to be interpreted.");
var fetchQueryConfigSchema = z.object({
  kind: z.literal("rest").describe("Designates this object as a fetch query."),
  url: bindableSchema(z.string()).optional().describe("The URL of the request"),
  method: z.string().optional().describe("The request method."),
  headers: z.array(bindableNameStringValueSchema).optional().describe("Extra request headers."),
  searchParams: z.array(bindableNameStringValueSchema).optional().describe("Extra url query parameters."),
  body: fetchBodySchema.optional().describe("The request body."),
  transformEnabled: z.boolean().optional().describe("Run a custom transformer on the response."),
  transform: z.string().optional().describe("The custom transformer to run when enabled."),
  response: responseTypeSchema.optional().describe("How to parse the response.")
});
var localQueryConfigSchema = z.object({
  kind: z.literal("local").describe("Designates this object as a local function query."),
  function: z.string().optional().describe("The function to be executed on the backend by this query.")
});
var queryConfigSchema = z.discriminatedUnion("kind", [
  fetchQueryConfigSchema,
  localQueryConfigSchema
]);
var querySchema = z.object({
  name: z.string().describe("A name for the query"),
  enabled: bindableSchema(z.boolean()).optional().describe(
    "Activates or deactivates the query. When deactivated the data won't be loaded when the page opens."
  ),
  parameters: z.array(nameValuePairSchema(bindableSchema(z.any()))).optional().describe("Parameters to pass to this query."),
  mode: fetchModeSchema.optional().describe("How to fetch this query."),
  query: queryConfigSchema.optional().describe("Query definition"),
  transform: z.string().optional().describe("Transformation to run on the response"),
  transformEnabled: z.boolean().optional().describe("Enable the transformation"),
  refetchInterval: z.number().optional().describe("Interval to rerun this query at"),
  cacheTime: z.number().optional().describe("Time to cache before refetching")
});
var elementSchema;
var templateSchema = z.object({
  $$template: z.lazy(() => z.array(elementSchema)).describe("The subtree, that describes the UI to be rendered by the template.")
}).describe("Describes a fragment of Toolpad Studio elements, to be used as a template.");
var baseElementSchema = z.object({
  component: z.string().describe("The component that this element was based on."),
  name: z.string().describe("a name for this component, which is used to reference it inside bindings."),
  layout: z.object({
    horizontalAlign: z.string().optional().describe("Lays out the element along the horizontal axis."),
    verticalAlign: z.string().optional().describe("Lays out the element along the vertical axis."),
    columnSize: z.number().optional().describe("The width this element takes up, expressed in terms of columns on the page."),
    height: z.number().optional().describe("The height this element takes up, in pixels.")
  }).optional().describe("Layout properties for this element.")
});
var bindablePropSchema = z.lazy(
  () => z.union([
    ...literalSchema.options,
    z.array(bindablePropSchema),
    z.record(
      z.string().refine((key) => !key.startsWith("$$")),
      bindablePropSchema
    ),
    jsExpressionBindingSchema,
    envBindingSchema,
    jsExpressionActionSchema,
    navigationActionSchema,
    templateSchema
  ])
);
elementSchema = baseElementSchema.extend({
  children: z.lazy(() => z.array(elementSchema).optional()).describe("The children of this element."),
  props: z.lazy(() => z.record(bindablePropSchema).optional()).describe("The properties to configure this instance of the component.")
}).describe("The instance of a component. Used to build user interfaces in pages.");
var applicationSchema = toolpadObjectSchema(
  "application",
  z.object({
    plan: z.enum(["free", "pro"]).optional().describe("The plan for this application."),
    authentication: z.object({
      providers: z.array(
        z.object({
          provider: z.enum(["github", "google", "azure-ad", "credentials"]).describe("Unique identifier for this authentication provider."),
          roles: z.array(
            z.object({
              source: z.array(z.string()).describe("Authentication provider roles to be mapped from."),
              target: z.string().describe("Toolpad Studio role to be mapped to.")
            })
          ).optional().describe("Role mapping definition for this authentication provider.")
        })
      ).optional().describe("Authentication providers to use."),
      restrictedDomains: z.array(z.string()).optional().describe("Valid email patterns for the authenticated user.")
    }).optional().describe("Authentication configuration for this application."),
    authorization: z.object({
      roles: z.array(
        z.union([
          z.string(),
          z.object({
            name: z.string().describe("The name of the role."),
            description: z.string().optional().describe("A description of the role.")
          })
        ])
      ).optional().describe("Available roles for this application. These can be assigned to users.")
    }).optional().describe("Authorization configuration for this application.")
  })
);
var pageSchema = toolpadObjectSchema(
  "page",
  z.object({
    displayName: z.string().optional().describe("Page name to display in the UI."),
    id: z.string().optional().describe("Serves as a canonical id of the page. Deprecated: use an alias instead."),
    alias: z.array(z.string()).optional().describe("Page name aliases."),
    title: z.string().optional().describe("Title for this page."),
    parameters: z.array(nameStringValuePairSchema).optional().describe("Parameters for the page. These can be set inside of the url query string."),
    queries: z.array(querySchema).optional().describe("Queries that are used by the page. These will load data when the page opens."),
    content: z.array(elementSchema).optional().describe("The content of the page. This defines the UI."),
    authorization: z.object({
      allowAll: z.boolean().optional().describe("Allow all users to access this page."),
      allowedRoles: z.array(z.string()).optional().describe("Roles that are allowed to access this page.")
    }).optional().describe("Authorization configuration for this page."),
    display: z.union([
      z.literal("standalone").describe("Hide the Toolpad Studio chrome and just display the content of the page"),
      z.literal("shell").describe("Show Toolpad Studio header and navigation.")
    ]).optional().describe(
      "Display mode of the page. This can also be set at runtime with the toolpad-display query parameter"
    ),
    maxWidth: z.union([
      z.literal("xs"),
      z.literal("sm"),
      z.literal("md"),
      z.literal("lg"),
      z.literal("xl"),
      z.literal("none")
    ]).optional().describe("Top level element of the page.")
  })
);
var simplePaletteColorOptionsSchema = z.object({
  main: z.string(),
  light: z.string().optional(),
  dark: z.string().optional(),
  contrastText: z.string().optional()
});
var themeOptionsSchema = z.object({
  // TODO: expand to full MUI theme object
  palette: z.object({
    mode: z.union([z.literal("light"), z.literal("dark")]).optional(),
    primary: simplePaletteColorOptionsSchema.optional(),
    secondary: simplePaletteColorOptionsSchema.optional()
  }).passthrough().optional()
}).passthrough();
var themeSchema = toolpadObjectSchema(
  "theme",
  z.object({
    options: themeOptionsSchema.optional().describe("The ThemeOptions object that gets fed into MUI's createTheme function.")
  })
);

// src/utils/prettier.ts
import prettier from "prettier";
import parserBabel from "prettier/parser-babel";
var DEFAULT_OPTIONS = {
  parser: "babel-ts",
  plugins: [parserBabel]
};
async function resolvePrettierConfig(filePath) {
  const config2 = await prettier.resolveConfig(filePath);
  return config2;
}
async function format(code, filePath) {
  const readConfig2 = await resolvePrettierConfig(filePath);
  return prettier.format(code, {
    ...readConfig2,
    ...DEFAULT_OPTIONS
  });
}

// src/server/EnvManager.ts
import * as path3 from "path";
import * as chokidar from "chokidar";
import * as dotenv from "dotenv";
import chalk from "chalk";
import { truncate } from "@toolpad/utils/strings";
function getEnvFilePath() {
  return path3.resolve(process.cwd(), ".env");
}
var EnvManager = class {
  project;
  originalEnv = { ...process.env };
  values = {};
  watcher;
  constructor(project) {
    this.project = project;
  }
  async start() {
    this.loadEnvFile();
    if (this.project.options.dev) {
      this.initWatcher();
    }
  }
  // eslint-disable-next-line class-methods-use-this
  async build() {
  }
  async dispose() {
    await this.watcher?.close();
  }
  resetEnv() {
    Object.keys(process.env).forEach((key) => {
      delete process.env[key];
    });
    Object.assign(process.env, this.originalEnv);
  }
  loadEnvFile() {
    const envFilePath = getEnvFilePath();
    this.resetEnv();
    const { parsed = {} } = dotenv.config({ path: envFilePath, override: true });
    this.values = parsed;
    console.log(
      `${chalk.blue("info")}  - loaded env file "${envFilePath}" with keys ${truncate(
        Object.keys(parsed).join(", "),
        1e3
      )}`
    );
  }
  initWatcher() {
    if (!this.project.options.dev) {
      return;
    }
    this.watcher = chokidar.watch([getEnvFilePath()], {
      usePolling: true,
      ignoreInitial: true
    });
    const handleChange = async () => {
      this.loadEnvFile();
      this.project.events.emit("envChanged", {});
    };
    this.watcher.on("add", handleChange);
    this.watcher.on("unlink", handleChange);
    this.watcher.on("change", handleChange);
  }
  async getDeclaredKeys() {
    return Object.keys(this.values);
  }
  // eslint-disable-next-line class-methods-use-this
  getEnv() {
    return process.env;
  }
};

// src/server/FunctionsManager.ts
import * as path5 from "path";
import * as fs3 from "fs/promises";
import * as esbuild from "esbuild";
import { ensureSuffix, indent as indent2 } from "@toolpad/utils/strings";
import * as chokidar2 from "chokidar";
import chalk2 from "chalk";
import { glob } from "glob";
import { writeFileRecursive, fileExists, readJsonFile } from "@toolpad/utils/fs";
import Piscina from "piscina";
import { errorFrom } from "@toolpad/utils/errors";
import * as url3 from "node:url";
import invariant from "invariant";

// src/server/functionsRuntime.ts
import * as path4 from "path";
import * as url2 from "url";
import * as fs2 from "fs/promises";
import { TOOLPAD_DATA_PROVIDER_MARKER } from "@toolpad/studio-runtime/server";
import * as z2 from "zod";
import { fromZodError } from "zod-validation-error";
import * as crypto from "crypto";
async function loadExports(filePath) {
  const importFileUrl = url2.pathToFileURL(path4.resolve(filePath));
  const content = await fs2.readFile(importFileUrl, "utf-8");
  const hash = crypto.createHash("md5").update(content).digest("hex");
  importFileUrl.searchParams.set("hash", hash);
  const exports = await import(
    /* webpackIgnore: true */
    importFileUrl.href
  );
  return new Map(Object.entries(exports));
}
var dataProviderSchema = z2.object({
  paginationMode: z2.enum(["index", "cursor"]).optional().default("index"),
  getRecords: z2.function(z2.tuple([z2.any()]), z2.any()),
  deleteRecord: z2.function(z2.tuple([z2.any()]), z2.any()).optional(),
  updateRecord: z2.function(z2.tuple([z2.any(), z2.any()]), z2.any()).optional(),
  createRecord: z2.function(z2.tuple([z2.any()]), z2.any()).optional(),
  [TOOLPAD_DATA_PROVIDER_MARKER]: z2.literal(true)
});
async function loadDataProvider(filePath, name) {
  const exports = await loadExports(filePath);
  const dataProviderExport = exports.get(name);
  if (!dataProviderExport || typeof dataProviderExport !== "object") {
    throw new Error(`DataProvider "${name}" not found`);
  }
  const parsed = dataProviderSchema.safeParse(dataProviderExport);
  if (parsed.success) {
    return parsed.data;
  }
  throw fromZodError(parsed.error);
}
async function execute(filePath, name, parameters) {
  const exports = await loadExports(filePath);
  const fn = exports.get(name);
  if (typeof fn !== "function") {
    throw new Error(`Function "${name}" not found`);
  }
  const result = await fn(...parameters);
  return result;
}

// src/server/functionsShared.ts
import ts from "typescript";
var compilerOptions = {
  noEmit: true,
  target: ts.ScriptTarget.ESNext,
  lib: ["lib.esnext.d.ts"],
  types: ["node"],
  // NOTE: strictNullChecks is essential for the type extraction to work properly. When we decide
  // to support user-defined tsconfig.json, we must make sure this option is enabled.
  strictNullChecks: true,
  module: ts.ModuleKind.CommonJS,
  moduleResolution: ts.ModuleResolutionKind.Bundler,
  esModuleInterop: true,
  allowSyntheticDefaultImports: true
};

// src/server/FunctionsManager.ts
var currentDirectory2 = url3.fileURLToPath(new URL(".", String(import.meta.url)));
async function createDefaultFunction(filePath) {
  const result = await format(
    `
    /**
     * Toolpad Studio handlers file.
     */

    export default async function handler (message: string) {
      return \`Hello \${message}\`;
    }
  `,
    filePath
  );
  return result;
}
async function createDefaultDataProvider(filePath, options) {
  const result = await format(
    `
    /**
     * Toolpad data provider file.
     * See: https://mui.com/toolpad/studio/concepts/data-providers/
     */

    import { createDataProvider } from '@toolpad/studio/server';

    export default createDataProvider({
      ${options.paginationMode === "cursor" ? 'paginationMode: "cursor",' : ""}
      async getRecords({ paginationModel: ${options.paginationMode === "cursor" ? "{ cursor, pageSize }" : "{ start, pageSize }"} }) {
        return {
          records: [],
          ${options.paginationMode === "cursor" ? "cursor: null," : ""}
        };
      }
    })
  `,
    filePath
  );
  return result;
}
function formatCodeFrame(location) {
  const lineNumberCharacters = Math.ceil(Math.log10(location.line));
  return [
    `${location.file}:${location.line}:${location.column}:`,
    `  ${location.line} \u2502 ${location.lineText}`,
    `  ${" ".repeat(lineNumberCharacters)} \u2575 ${" ".repeat(
      Math.max(location.lineText.length - 1, 0)
    )}^`
  ].join("\n");
}
function formatError(esbuildError) {
  let messageText = esbuildError.text;
  if (esbuildError.location) {
    const formattedLocation = indent2(formatCodeFrame(esbuildError.location), 2);
    messageText = [messageText, formattedLocation].join("\n");
  }
  return new Error(messageText);
}
var FunctionsManager = class {
  project;
  buildErrors = [];
  extractedTypes;
  extractTypesWorker;
  buildCtx;
  constructor(project) {
    this.project = project;
  }
  getResourcesFolder() {
    return path5.join(this.project.getRoot(), "./resources");
  }
  getFunctionsFile() {
    return path5.join(this.getResourcesFolder(), "./functions.ts");
  }
  async getFunctionFilePath(fileName) {
    const resourcesFolder = this.getResourcesFolder();
    return path5.join(resourcesFolder, fileName);
  }
  getFunctionResourcesPattern() {
    return path5.join(this.getResourcesFolder(), "*.ts");
  }
  async migrateLegacy() {
    const legacyQueriesFile = path5.resolve(this.project.getRoot(), "queries.ts");
    if (await fileExists(legacyQueriesFile)) {
      const functionsFile = this.getFunctionsFile();
      await fs3.mkdir(path5.dirname(functionsFile), { recursive: true });
      await fs3.rename(legacyQueriesFile, functionsFile);
    }
  }
  async getFunctionFiles() {
    const paths = await glob(this.getFunctionResourcesPattern(), { windowsPathsNoEscape: true });
    return paths.map((fullPath) => path5.relative(this.project.getRoot(), fullPath));
  }
  getBuildErrorsForFile(entryPoint) {
    return this.buildErrors.filter((error) => error.location?.file === entryPoint);
  }
  getFunctionsOutputFolder() {
    return path5.resolve(this.project.getOutputFolder(), "functions");
  }
  getIntrospectJsonPath() {
    return path5.resolve(this.getFunctionsOutputFolder(), "introspect.json");
  }
  async extractTypes() {
    if (!this.extractTypesWorker) {
      this.extractTypesWorker = new Piscina({
        filename: path5.resolve(currentDirectory2, "../cli/functionsTypesWorker.mjs")
      });
    }
    const extractedTypes = this.extractTypesWorker.run({ resourcesFolder: this.getResourcesFolder() }, {}).catch((error) => ({
      error,
      files: []
    }));
    return extractedTypes;
  }
  async createEsbuildContext() {
    const root = this.project.getRoot();
    const onFunctionBuildStart = async () => {
      this.extractedTypes = void 0;
    };
    const onFunctionsBuildEnd = async (args) => {
      console.log(
        `${chalk2.green("ready")} - built functions.ts: ${args.errors.length} error(s), ${args.warnings.length} warning(s)`
      );
      this.buildErrors = args.errors;
      this.project.events.emit("functionsChanged", {});
    };
    const toolpadStudioPlugin = {
      name: "toolpad-studio",
      setup(build) {
        build.onStart(onFunctionBuildStart);
        build.onEnd(onFunctionsBuildEnd);
      }
    };
    const entryPoints = await this.getFunctionFiles();
    return esbuild.context({
      absWorkingDir: root,
      entryPoints,
      plugins: [toolpadStudioPlugin],
      write: true,
      bundle: true,
      metafile: true,
      outdir: this.getFunctionsOutputFolder(),
      outExtension: { ".js": ".mjs" },
      platform: "node",
      format: "esm",
      packages: "external",
      target: "es2022",
      tsconfigRaw: JSON.stringify({ compilerOptions }),
      loader: {
        ".txt": "text",
        ".sql": "text"
      }
    });
  }
  async startWatchingFunctionFiles() {
    const resourcesWatcher = chokidar2.watch([this.getFunctionResourcesPattern()], {
      ignoreInitial: true
    });
    const reinitializeWatcher = async () => {
      await this.buildCtx?.dispose();
      this.buildCtx = await this.createEsbuildContext();
      await this.buildCtx.watch();
    };
    reinitializeWatcher();
    resourcesWatcher.on("add", reinitializeWatcher);
    resourcesWatcher.on("unlink", reinitializeWatcher);
  }
  async start() {
    if (this.project.options.dev) {
      await this.migrateLegacy();
      await this.startWatchingFunctionFiles();
    }
  }
  async build() {
    const ctx = await this.createEsbuildContext();
    await ctx.rebuild();
    await ctx.dispose();
    const types = await this.extractTypes();
    if (types.error) {
      throw errorFrom(types.error);
    }
    await fs3.mkdir(this.getFunctionsOutputFolder(), { recursive: true });
    await fs3.writeFile(this.getIntrospectJsonPath(), JSON.stringify(types, null, 2), "utf-8");
  }
  async disposeBuildcontext() {
    this.buildCtx?.dispose();
    this.buildCtx = void 0;
  }
  async dispose() {
    await Promise.all([this.disposeBuildcontext(), this.extractTypesWorker?.destroy()]);
  }
  async getBuiltOutputFilePath(fileName) {
    const resourcesFolder = this.getResourcesFolder();
    const fullPath = path5.resolve(resourcesFolder, fileName);
    const entryPoint = path5.relative(this.project.getRoot(), fullPath);
    const buildErrors = this.getBuildErrorsForFile(entryPoint);
    if (buildErrors.length > 0) {
      throw formatError(buildErrors[0]);
    }
    const outputFilePath = path5.resolve(
      this.getFunctionsOutputFolder(),
      `${path5.basename(fileName, ".ts")}.mjs`
    );
    return outputFilePath;
  }
  async exec(fileName, name, parameters) {
    const extractedTypes = await this.introspect();
    if (extractedTypes.error) {
      throw errorFrom(extractedTypes.error);
    }
    const file = extractedTypes.files.find((fileEntry) => fileEntry.name === fileName);
    const handler = file?.handlers.find((handlerEntry) => handlerEntry.name === name);
    if (!handler) {
      throw new Error(`No function found with the name "${name}"`);
    }
    const executeParams = handler.isCreateFunction ? [{ parameters }] : handler.parameters.map(([parameterName]) => parameters[parameterName]);
    return this.execFunction(fileName, name, executeParams);
  }
  async execFunction(fileName, name, parameters) {
    const outputFilePath = await this.getBuiltOutputFilePath(fileName);
    const data = await execute(outputFilePath, name, parameters);
    return { data };
  }
  async introspect() {
    if (!this.extractedTypes) {
      if (this.project.options.dev) {
        this.extractedTypes = this.extractTypes();
      } else {
        this.extractedTypes = readJsonFile(
          this.getIntrospectJsonPath()
        );
      }
    }
    return this.extractedTypes;
  }
  async createFunctionFile(name) {
    const filePath = path5.resolve(this.getResourcesFolder(), ensureSuffix(name, ".ts"));
    const content = await createDefaultFunction(filePath);
    if (await fileExists(filePath)) {
      throw new Error(`"${name}" already exists`);
    }
    await writeFileRecursive(filePath, content, { encoding: "utf-8" });
    this.extractedTypes = void 0;
  }
  async createDataProviderFile(name, options) {
    const filePath = path5.resolve(this.getResourcesFolder(), ensureSuffix(name, ".ts"));
    const content = await createDefaultDataProvider(filePath, options);
    if (await fileExists(filePath)) {
      throw new Error(`"${name}" already exists`);
    }
    await writeFileRecursive(filePath, content, { encoding: "utf-8" });
    this.extractedTypes = void 0;
  }
  async introspectDataProvider(fileName, exportName = "default") {
    const fullPath = await this.getBuiltOutputFilePath(fileName);
    const dataProvider = await loadDataProvider(fullPath, exportName);
    return {
      paginationMode: dataProvider.paginationMode,
      hasDeleteRecord: !!dataProvider.deleteRecord,
      hasUpdateRecord: !!dataProvider.updateRecord,
      hasCreateRecord: !!dataProvider.createRecord
    };
  }
  async getDataProviderRecords(fileName, exportName, params) {
    const fullPath = await this.getBuiltOutputFilePath(fileName);
    const dataProvider = await loadDataProvider(fullPath, exportName);
    return dataProvider.getRecords(params);
  }
  async deleteDataProviderRecord(fileName, exportName, id) {
    const fullPath = await this.getBuiltOutputFilePath(fileName);
    const dataProvider = await loadDataProvider(fullPath, exportName);
    invariant(dataProvider.deleteRecord, "DataProvider does not support deleteRecord");
    return dataProvider.deleteRecord(id);
  }
  async updateDataProviderRecord(fileName, exportName, id, values) {
    const fullPath = await this.getBuiltOutputFilePath(fileName);
    const dataProvider = await loadDataProvider(fullPath, exportName);
    invariant(dataProvider.updateRecord, "DataProvider does not support updateRecord");
    return dataProvider.updateRecord(id, values);
  }
  async createDataProviderRecord(fileName, exportName, values) {
    const fullPath = await this.getBuiltOutputFilePath(fileName);
    const dataProvider = await loadDataProvider(fullPath, exportName);
    invariant(dataProvider.createRecord, "DataProvider does not support createRecord");
    return dataProvider.createRecord(values);
  }
};

// src/server/versionInfo.ts
import * as path6 from "path";
import latestVersion from "latest-version";
import * as semver from "semver";
import { fileExists as fileExists2 } from "@toolpad/utils/fs";

// package.json
var package_default = {
  name: "@toolpad/studio",
  version: "0.8.1",
  license: "MIT",
  bin: {
    "toolpad-studio": "./cli.mjs"
  },
  scripts: {
    build: 'concurrently "pnpm:build:*"',
    dev: 'concurrently "pnpm:dev:*"',
    cli: "./cli.mjs",
    lint: "prettier --check .",
    fix: "prettier --write .",
    "build:cli": "tsup",
    "dev:cli": "tsup --watch",
    "check-types": "tsup && tsc --noEmit",
    test: "vitest run"
  },
  keywords: [
    "react",
    "mui",
    "toolpad",
    "internal tools",
    "crud",
    "low code",
    "admin",
    "dashboard"
  ],
  repository: {
    type: "git",
    url: "git+https://github.com/mui/toolpad.git",
    directory: "packages/toolpad-studio"
  },
  bugs: {
    url: "https://github.com/mui/toolpad/issues"
  },
  homepage: "https://mui.com/toolpad/",
  files: [
    "public",
    "scripts",
    "dist",
    "cli.mjs",
    "browser",
    "server",
    "runtime"
  ],
  exports: {
    "./package.json": "./package.json",
    ".": {
      types: "./dist/exports/index.d.ts",
      import: "./dist/exports/index.mjs"
    },
    "./*": {
      types: "./dist/exports/*.d.ts",
      import: "./dist/exports/*.mjs"
    }
  },
  dependencies: {
    "@auth/core": "0.37.0",
    "@emotion/cache": "11.13.1",
    "@emotion/react": "11.13.3",
    "@emotion/server": "11.11.0",
    "@emotion/styled": "11.13.0",
    "@googleapis/drive": "8.14.0",
    "@googleapis/sheets": "9.3.1",
    "@mui/icons-material": "6.1.4",
    "@mui/lab": "6.0.0-beta.12",
    "@mui/material": "6.1.4",
    "@mui/system": "6.1.4",
    "@mui/types": "7.2.18",
    "@mui/utils": "6.1.4",
    "@mui/x-charts": "7.21.0",
    "@mui/x-data-grid": "7.21.0",
    "@mui/x-data-grid-premium": "7.21.0",
    "@mui/x-date-pickers": "7.21.0",
    "@mui/x-date-pickers-pro": "7.21.0",
    "@mui/x-tree-view": "7.21.0",
    "@tanstack/react-query": "5.59.13",
    "@tanstack/react-query-devtools": "5.59.13",
    "@toolpad/core": "workspace:*",
    "@toolpad/studio-components": "workspace:*",
    "@toolpad/studio-runtime": "workspace:*",
    "@toolpad/utils": "workspace:*",
    "@types/cors": "2.8.17",
    "@types/json-schema": "7.0.15",
    "@types/node": "^20.16.11",
    "@types/react-dev-utils": "9.0.15",
    "@vitejs/plugin-react": "4.3.2",
    "@webcontainer/env": "1.1.1",
    "abort-controller": "3.0.0",
    "basic-auth": "2.0.1",
    chalk: "5.3.0",
    chokidar: "3.6.0",
    clsx: "2.1.1",
    compression: "^1.7.4",
    concurrently: "9.0.1",
    cors: "2.8.5",
    csstype: "3.1.3",
    dayjs: "1.11.13",
    dotenv: "16.4.5",
    esbuild: "0.24.0",
    execa: "9.4.0",
    express: "4.21.1",
    "find-up": "7.0.0",
    "fractional-indexing": "3.2.0",
    "get-port": "7.1.0",
    glob: "10.4.5",
    "google-auth-library": "9.14.2",
    "http-proxy-middleware": "3.0.3",
    invariant: "2.2.4",
    "json-to-ts": "2.1.0",
    json5: "2.2.3",
    "latest-version": "9.0.0",
    "lodash-es": "4.17.21",
    "markdown-to-jsx": "7.5.0",
    mime: "4.0.4",
    "monaco-editor": "0.52.0",
    mysql2: "3.11.3",
    nanoid: "5.0.7",
    "node-fetch": "2.7.0",
    "node-fetch-har": "1.0.1",
    "open-editor": "5.0.0",
    "path-to-regexp": "6.3.0",
    "perf-cascade": "3.0.3",
    pg: "8.13.0",
    piscina: "4.7.0",
    prettier: "3.3.3",
    "pretty-bytes": "6.1.1",
    react: "18.3.1",
    "react-dev-utils": "12.0.1",
    "react-dom": "18.3.1",
    "react-error-boundary": "4.0.13",
    "react-hook-form": "7.53.0",
    "react-inspector": "6.0.2",
    "react-is": "18.3.1",
    "react-resizable-panels": "2.1.4",
    "react-router-dom": "6.26.2",
    semver: "7.6.3",
    "serialize-javascript": "6.0.2",
    superjson: "2.0.0",
    typescript: "5.5.4",
    vite: "5.4.8",
    "vm-browserify": "1.1.2",
    "whatwg-url": "14.0.0",
    ws: "8.18.0",
    yaml: "2.5.1",
    "yaml-diff-patch": "2.0.0",
    yargs: "17.7.2",
    zod: "3.23.8",
    "zod-validation-error": "3.4.0"
  },
  devDependencies: {
    "@types/babel__code-frame": "7.0.6",
    "@types/compression": "^1.7.5",
    "@types/express": "5.0.0",
    "@types/express-serve-static-core": "5.0.0",
    "@types/formidable": "3.4.5",
    "@types/glob": "8.1.0",
    "@types/har-format": "1.2.16",
    "@types/invariant": "2.2.37",
    "@types/lodash-es": "4.17.12",
    "@types/node-fetch": "2.6.11",
    "@types/pg": "8.11.10",
    "@types/react": "18.3.11",
    "@types/react-dom": "18.3.1",
    "@types/react-is": "18.3.0",
    "@types/semver": "7.5.8",
    "@types/serialize-javascript": "5.0.4",
    "@types/whatwg-url": "11.0.5",
    "@types/ws": "8.5.12",
    "@types/yargs": "17.0.33",
    ajv: "8.17.1",
    eslint: "8.57.1",
    "eslint-config-prettier": "9.1.0",
    "eslint-plugin-import": "2.31.0",
    formidable: "3.5.1",
    "react-transition-group": "4.4.5",
    webpack: "5.95.0"
  },
  typings: "./index.d.ts",
  publishConfig: {
    access: "public"
  },
  engines: {
    node: ">=18"
  }
};

// src/server/versionInfo.ts
async function detectPackageManager(root) {
  const [hasYarnLock, hasPackageLock, hasPnpmLock] = await Promise.all([
    fileExists2(path6.resolve(root, "./yarn.lock")),
    fileExists2(path6.resolve(root, "./package-lock.lock")),
    fileExists2(path6.resolve(root, "./pnpm-lock.lock"))
  ]);
  if (hasYarnLock) {
    return "yarn";
  }
  if (hasPnpmLock) {
    return "pnpm";
  }
  if (hasPackageLock) {
    return "npm";
  }
  return null;
}
async function checkVersion(root) {
  const pkgName = "@toolpad/studio";
  const [latest, packageManager] = await Promise.all([
    latestVersion(pkgName),
    detectPackageManager(root)
  ]);
  const current = package_default.version;
  const updateAvailable = semver.compare(latest, current) > 0;
  return { current, latest, updateAvailable, packageManager };
}

// src/server/DataManager.ts
import { withContext, createServerContext } from "@toolpad/studio-runtime/serverRuntime";
import { createServerJsRuntime as createServerJsRuntime2 } from "@toolpad/studio-runtime/jsServerRuntime";
import express from "express";
import cors from "cors";
import invariant3 from "invariant";
import { errorFrom as errorFrom6, serializeError as serializeError3 } from "@toolpad/utils/errors";
import * as appDom2 from "@toolpad/studio-runtime/appDom";

// src/toolpadDataSources/postgres/server.ts
import pg from "pg";
import { errorFrom as errorFrom3 } from "@toolpad/utils/errors";

// src/toolpadDataSources/sql/server.ts
import { serializeError, errorFrom as errorFrom2 } from "@toolpad/utils/errors";
function createSqlServerDatasource({
  execSql: execSql3,
  testConnection: testConnection3
}) {
  return {
    exec: async (connection, query, params) => {
      const { data, error } = await execSql3(connection, query, params);
      return { data, error };
    },
    execPrivate: async (connection, query) => {
      switch (query.kind) {
        case "debugExec":
          return execSql3(connection, query.query, query.params);
        case "connectionStatus": {
          let connectionStatus;
          try {
            await testConnection3(query.params);
            connectionStatus = { status: "success" };
            return { data: connectionStatus };
          } catch (rawError) {
            const serializedError = serializeError(errorFrom2(rawError));
            connectionStatus = {
              status: "error",
              error: serializedError.message
            };
            return { data: connectionStatus, error: serializedError };
          }
        }
        default:
          throw new Error(`Unknown query "${query.kind}"`);
      }
    },
    api: {}
  };
}

// src/toolpadDataSources/postgres/server.ts
var { Client } = pg;
function parseQuery(sql, params) {
  const substitutions = new Map(params.map(([name], i) => [name.toLowerCase(), i + 1]));
  const sqlWithNamedVars = sql.replaceAll(/\$([a-zA-Z][a-zA-Z0-9]*)/g, (match2, varName) => {
    const index = substitutions.get(varName.toLowerCase());
    if (typeof index === "number") {
      return `$${index}`;
    }
    return match2;
  });
  return {
    text: sqlWithNamedVars,
    values: params.map(([, value]) => value)
  };
}
function parseErrorMessage(msg, params) {
  const substitutions = new Map(params.map(([name], i) => [i + 1, name]));
  const msgWithNamedVars = msg.replaceAll(/\$(\d+)/g, (match2, index) => {
    const varName = substitutions.get(Number(index));
    if (typeof varName === "string") {
      return `$${varName}(${match2})`;
    }
    return match2;
  });
  return msgWithNamedVars;
}
async function execSql(connection, postgresQuery, params) {
  if (!connection?.password) {
    throw new Error(`Password required`);
  }
  const client = new Client({ ...connection });
  const paramEntries = Object.entries(params);
  try {
    await client.connect();
    const pgQuery = parseQuery(postgresQuery.sql, paramEntries);
    const res = await client.query(pgQuery);
    return {
      data: res.rows,
      info: res.command !== "SELECT" ? `OK ${res.command}, ${res.rowCount} ${res.rowCount === 1 ? "row" : "rows"} affected` : void 0
    };
  } catch (rawError) {
    const error = errorFrom3(rawError);
    error.message = parseErrorMessage(error.message, paramEntries);
    throw error;
  } finally {
    await client.end();
  }
}
var testConnection = async (connection) => {
  const client = new Client({ ...connection });
  await client.connect();
  await client.query("SELECT * FROM version();");
};
var server_default = createSqlServerDatasource({
  execSql,
  testConnection
});

// src/toolpadDataSources/mysql/server.ts
import { createConnection } from "mysql2/promise";
import { errorFrom as errorFrom4 } from "@toolpad/utils/errors";
function prepareQuery(sql, params) {
  const substitutions = [];
  const sqlWithVarsReplaced = sql.replaceAll(
    // eslint-disable-next-line no-useless-escape
    /(?<==|<|<=|>|>=|<>)[ ]*(([\$\w\d]*\b)|([']+[\w ]+['][ ]*))|(;)/g,
    (match2) => {
      const trimmedMatch = match2.trim().replaceAll(/[']+/g, "");
      if (trimmedMatch[0] === "$") {
        const varName = trimmedMatch.slice(1);
        if (typeof params[varName] !== "undefined") {
          substitutions.push(params[varName]);
        }
        return "?";
      }
      if (trimmedMatch === ";") {
        return "";
      }
      substitutions.push(trimmedMatch);
      return "?";
    }
  );
  return {
    sql: sqlWithVarsReplaced,
    substitutions
  };
}
async function execSql2(connection, query, params) {
  const mysqlConnection = await createConnection({ ...connection });
  try {
    const { sql, substitutions } = prepareQuery(query.sql, params);
    const [result] = await mysqlConnection.execute(sql, substitutions);
    let rows = [];
    let info;
    if (Array.isArray(result)) {
      rows = result;
    } else {
      info = result.info || result.message;
    }
    return {
      data: rows,
      info
    };
  } catch (rawError) {
    const error = errorFrom4(rawError);
    throw error;
  } finally {
    await mysqlConnection.end();
  }
}
async function testConnection2(connection) {
  const mysqlConnection = await createConnection({ ...connection });
  mysqlConnection.execute("SELECT 1");
}
var server_default2 = createSqlServerDatasource({
  execSql: execSql2,
  testConnection: testConnection2
});

// src/toolpadDataSources/rest/server.ts
import fetch, { Headers } from "node-fetch";
import { createServerJsRuntime } from "@toolpad/studio-runtime/jsServerRuntime";
import { errorFrom as errorFrom5, serializeError as serializeError2 } from "@toolpad/utils/errors";
import { evaluateBindable } from "@toolpad/studio-runtime/jsRuntime";
import { removePrefix } from "@toolpad/utils/strings";

// src/server/har.ts
import { withHar as withHarOriginal } from "node-fetch-har";
import { Request } from "node-fetch";

// src/utils/har.ts
function createHarLog() {
  return {
    log: {
      version: "0.0",
      creator: {
        name: "Toolpad",
        version: process.env.TOOLPAD_VERSION || ""
      },
      entries: []
    }
  };
}

// src/server/har.ts
var withHarInstrumentation = function withHar(fetchFn, options) {
  const withHarFetch = withHarOriginal(fetchFn, options);
  const patchedFetch = (...args) => {
    const req = new Request(...args);
    const input = req.url;
    return withHarFetch(input, {
      agent: req.agent,
      body: req.body,
      compress: req.compress,
      follow: req.follow,
      headers: req.headers,
      method: req.method,
      redirect: req.redirect
    });
  };
  return patchedFetch;
};

// src/toolpadDataSources/applyTransform.ts
async function applyTransform(jsRuntime, transform, data) {
  const transformFn = `(data) => {${transform}}`;
  const { error, value } = jsRuntime.evaluateExpression(
    `(${transformFn})(${JSON.stringify(data)})`,
    {}
  );
  if (error) {
    throw error;
  }
  return value;
}

// src/toolpadDataSources/rest/shared.ts
import { ensureSuffix as ensureSuffix2 } from "@toolpad/utils/strings";
var HTTP_NO_BODY = /* @__PURE__ */ new Set(["GET", "HEAD"]);
function getAuthenticationHeaders(auth) {
  if (!auth) {
    return [];
  }
  switch (auth.type) {
    case "basic":
      return [
        [
          "Authorization",
          `Basic ${Buffer.from(`${auth.user}:${auth.password}`, "utf-8").toString("base64")}`
        ]
      ];
    case "bearerToken":
      return [["Authorization", `Bearer ${auth.token}`]];
    case "apiKey":
      return [[auth.header, auth.key]];
    default:
      throw new Error(`Unsupported authentication type "${auth.type}"`);
  }
}
function parseBaseUrl(baseUrl) {
  const parsedBase = new URL(baseUrl);
  parsedBase.pathname = ensureSuffix2(parsedBase.pathname, "/");
  parsedBase.search = "";
  parsedBase.hash = "";
  return parsedBase;
}

// src/toolpadDataSources/rest/server.ts
function resolveBindable(jsRuntime, bindable, scope) {
  const { value, error } = evaluateBindable(jsRuntime, bindable, scope);
  if (error) {
    throw error;
  }
  return value;
}
function resolveBindableEntries(jsRuntime, entries, scope) {
  return entries.map(([key, value]) => [key, resolveBindable(jsRuntime, value, scope)]);
}
function resolveBindables(jsRuntime, obj, scope) {
  return Object.fromEntries(
    resolveBindableEntries(jsRuntime, Object.entries(obj), scope)
  );
}
function parseQueryUrl(queryUrl, baseUrl) {
  if (baseUrl) {
    const parsedBase = parseBaseUrl(baseUrl);
    return new URL(parsedBase.href + removePrefix(queryUrl, "/"));
  }
  return new URL(queryUrl);
}
function resolveRawBody(jsRuntime, body, scope) {
  const { content, contentType } = resolveBindables(
    jsRuntime,
    {
      contentType: body.contentType,
      content: body.content
    },
    scope
  );
  return {
    kind: "raw",
    contentType,
    content: String(content)
  };
}
function resolveUrlEncodedBody(jsRuntime, body, scope) {
  return {
    kind: "urlEncoded",
    content: resolveBindableEntries(jsRuntime, body.content, scope)
  };
}
function resolveBody(jsRuntime, body, scope) {
  switch (body.kind) {
    case "raw":
      return resolveRawBody(jsRuntime, body, scope);
    case "urlEncoded":
      return resolveUrlEncodedBody(jsRuntime, body, scope);
    default:
      throw new Error(`Missing case for "${body.kind}"`);
  }
}
async function readData(res, fetchQuery) {
  if (!fetchQuery.response || fetchQuery.response?.kind === "json") {
    return res.json();
  }
  if (fetchQuery.response?.kind === "raw") {
    return res.text();
  }
  throw new Error(`Unsupported response type "${fetchQuery.response.kind}"`);
}
async function execBase(project, connection, fetchQuery, params) {
  const har = createHarLog();
  const instrumentedFetch = withHarInstrumentation(fetch, { har });
  const jsRuntime = createServerJsRuntime(process.env);
  const resolvedParams = resolveBindableEntries(jsRuntime, Object.entries(params), {});
  const queryScope = {
    // @TODO: remove deprecated query after v1
    query: params,
    parameters: Object.fromEntries(resolvedParams)
  };
  const urlvalue = fetchQuery.url ?? "";
  const resolvedUrl = resolveBindable(jsRuntime, urlvalue, queryScope);
  const resolvedSearchParams = resolveBindableEntries(
    jsRuntime,
    fetchQuery.searchParams || [],
    queryScope
  );
  const resolvedHeaders = resolveBindableEntries(jsRuntime, fetchQuery.headers || [], queryScope);
  const queryUrl = parseQueryUrl(resolvedUrl, connection?.baseUrl);
  resolvedSearchParams.forEach(([key, value]) => queryUrl.searchParams.append(key, value));
  const headers = new Headers([
    ...connection ? getAuthenticationHeaders(connection.authentication) : [],
    ...connection?.headers || []
  ]);
  resolvedHeaders.forEach(([key, value]) => headers.append(key, value));
  const method = fetchQuery.method || "GET";
  const requestInit = { method, headers };
  if (!HTTP_NO_BODY.has(method) && fetchQuery.body) {
    const resolvedBody = resolveBody(jsRuntime, fetchQuery.body, queryScope);
    switch (resolvedBody.kind) {
      case "raw": {
        headers.set("content-type", resolvedBody.contentType);
        requestInit.body = resolvedBody.content;
        break;
      }
      case "urlEncoded": {
        headers.set("content-type", "application/x-www-form-urlencoded");
        requestInit.body = new URLSearchParams(resolvedBody.content).toString();
        break;
      }
      default:
        throw new Error(`Missing case for "${resolvedBody.kind}"`);
    }
  }
  let error;
  let untransformedData;
  let data;
  try {
    const res = await instrumentedFetch(queryUrl.href, requestInit);
    if (!res.ok) {
      throw new Error(`HTTP ${res.status} (${res.statusText}) while fetching "${res.url}"`);
    }
    untransformedData = await readData(res, fetchQuery);
    data = untransformedData;
    if (fetchQuery.transformEnabled && fetchQuery.transform) {
      data = await applyTransform(jsRuntime, fetchQuery.transform, untransformedData);
    }
  } catch (rawError) {
    error = serializeError2(errorFrom5(rawError));
  }
  return { data, untransformedData, error, har };
}
function createDatasource(project) {
  return {
    async exec(connection, fetchQuery, params) {
      const { data, error } = await execBase(project, connection, fetchQuery, params);
      return { data, error };
    },
    async execPrivate(connection, query) {
      switch (query.kind) {
        case "introspection": {
          return {
            env: process.env,
            declaredEnvKeys: await project.envManager.getDeclaredKeys()
          };
        }
        case "debugExec":
          return execBase(project, connection, query.query, query.params);
        default:
          throw new Error(`Unknown private query "${query.kind}"`);
      }
    },
    api: {}
  };
}

// src/toolpadDataSources/googleSheets/server.ts
import { drive_v3 } from "@googleapis/drive";
import { sheets_v4 } from "@googleapis/sheets";
import { OAuth2Client } from "google-auth-library";
import { match } from "path-to-regexp";
import { asArray } from "@toolpad/utils/collections";
import invariant2 from "invariant";

// src/server/config.ts
function readConfig() {
  if (typeof window !== "undefined") {
    throw new Error(`Server-side config can't be loaded on the client side`);
  }
  const encryptionKeys = process.env.TOOLPAD_ENCRYPTION_KEYS?.split(/\s+/).filter(Boolean) ?? [];
  let basicAuthConfig = {};
  if (process.env.TOOLPAD_BASIC_AUTH_USER && process.env.TOOLPAD_BASIC_AUTH_PASSWORD) {
    basicAuthConfig = {
      basicAuthUser: process.env.TOOLPAD_BASIC_AUTH_USER,
      basicAuthPassword: process.env.TOOLPAD_BASIC_AUTH_PASSWORD
    };
  } else if (process.env.TOOLPAD_BASIC_AUTH_USER) {
    throw new Error(
      `Basic Auth user configured without password. Please provide the TOOLPAD_BASIC_AUTH_PASSWORD environment variable.`
    );
  }
  return {
    ...basicAuthConfig,
    databaseUrl: process.env.TOOLPAD_DATABASE_URL,
    googleSheetsClientId: process.env.TOOLPAD_DATASOURCE_GOOGLESHEETS_CLIENT_ID,
    googleSheetsClientSecret: process.env.TOOLPAD_DATASOURCE_GOOGLESHEETS_CLIENT_SECRET,
    encryptionKeys
  };
}
var config_default = readConfig();

// src/toolpadDataSources/googleSheets/server.ts
function createOAuthClient() {
  const externalUrl = process.env.TOOLPAD_EDITOR_EXTERNAL_URL;
  invariant2(externalUrl, "Missing TOOLPAD_EDITOR_EXTERNAL_URL");
  if (!config_default.googleSheetsClientId) {
    throw new Error('Google Sheets: Missing client ID "TOOLPAD_DATASOURCE_GOOGLESHEETS_CLIENT_ID"');
  }
  if (!config_default.googleSheetsClientSecret) {
    throw new Error(
      'Google Sheets: Missing client secret "TOOLPAD_DATASOURCE_GOOGLESHEETS_CLIENT_SECRET"'
    );
  }
  return new OAuth2Client(
    config_default.googleSheetsClientId,
    config_default.googleSheetsClientSecret,
    new URL("/api/dataSources/googleSheets/auth/callback", externalUrl).href
  );
}
function createDriveClient(client) {
  if (!client) {
    throw new Error("Malformed Google Sheets datasource client");
  }
  return new drive_v3.Drive({
    auth: client
  });
}
function createSheetsClient(client) {
  if (!client) {
    throw new Error("Malformed Google Sheets datasource client");
  }
  return new sheets_v4.Sheets({
    auth: client
  });
}
function createDatasource2() {
  const exec = async (connection, query) => {
    const client = createOAuthClient();
    if (connection) {
      client.setCredentials(connection);
    }
    const sheets = createSheetsClient(client);
    const { spreadsheetId, sheetName, ranges, headerRow } = query;
    if (spreadsheetId && sheetName) {
      const response = await sheets.spreadsheets.values.get({
        spreadsheetId,
        range: `${sheetName}!${ranges}`
      });
      if (response.status === 200) {
        const { values } = response.data;
        if (values && values.length > 0) {
          let data = values;
          if (headerRow) {
            const firstRow = values.shift() ?? [];
            data = values.map((row) => {
              const rowObject = {};
              row.forEach((elem, cellIndex) => {
                if (firstRow[cellIndex]) {
                  rowObject[firstRow[cellIndex]] = elem;
                }
              });
              return rowObject;
            });
          }
          return { data };
        }
        return { data: [] };
      }
      throw new Error(
        `${response.status}: ${response.statusText} Failed to fetch "${JSON.stringify(query)}"`
      );
    }
    throw new Error(`No sheet selected`);
  };
  const execPrivate = async (connection, query) => {
    const client = createOAuthClient();
    if (connection) {
      client.setCredentials(connection);
    }
    if (query.type === "FILE_GET") {
      const driveClient = createDriveClient(client);
      const { spreadsheetId } = query;
      if (spreadsheetId) {
        const response = await driveClient.files.get({
          fileId: spreadsheetId
        });
        if (response.status === 200) {
          return response.data;
        }
        throw new Error(
          `${response?.status}: ${response.statusText} Failed to fetch "${JSON.stringify(query)}"`
        );
      }
      throw new Error(`Google Sheets: Missing spreadsheetId in query`);
    }
    if (query.type === "FILES_LIST") {
      const driveClient = createDriveClient(client);
      const { spreadsheetQuery, pageToken } = query;
      let queryString = "mimeType='application/vnd.google-apps.spreadsheet'";
      if (spreadsheetQuery) {
        const escapedSpreadsheetQuery = spreadsheetQuery.replace(/\\|'/g, "\\$&");
        queryString = `name contains '${escapedSpreadsheetQuery}' and ${queryString}`;
      }
      const response = await driveClient.files.list({
        q: queryString,
        pageToken
      });
      if (response.status === 200) {
        return response.data;
      }
      throw new Error(
        `${response?.status}: ${response.statusText} Failed to fetch "${JSON.stringify(query)}"`
      );
    }
    if (query.type === "FETCH_SPREADSHEET") {
      const sheetsClient = createSheetsClient(client);
      const { spreadsheetId } = query;
      if (spreadsheetId) {
        const response = await sheetsClient.spreadsheets.get({
          spreadsheetId,
          includeGridData: false
        });
        if (response.status === 200) {
          return response.data;
        }
        throw new Error(
          `${response?.status}: ${response.statusText} Failed to fetch "${JSON.stringify(query)}"`
        );
      }
      throw new Error(`Google Sheets: Missing spreadsheetId in query`);
    }
    if (query.type === "CONNECTION_STATUS") {
      const driveClient = createDriveClient(client);
      const response = await driveClient.about.get({ fields: "user" });
      if (response.status === 200) {
        return response.data.user;
      }
      return null;
    }
    if (query.type === "DEBUG_EXEC") {
      return exec(connection, query.query);
    }
    throw new Error(`Google Sheets: Unrecognized private query "${JSON.stringify(query)}"`);
  };
  return {
    exec,
    execPrivate,
    api: {},
    createHandler: () => {
      return async (api, req, res) => {
        const client = createOAuthClient();
        try {
          const pathname = `/${asArray(req.query.path).map((segment = "") => encodeURIComponent(String(segment))).join("/")}`;
          const matchAuthLogin = match("/auth/login", { decode: decodeURIComponent });
          const matchAuthCallback = match("/auth/callback", { decode: decodeURIComponent });
          const [state] = asArray(req.query.state);
          if (typeof state !== "string") {
            return res.status(400).send(`Missing query parameter "state"`);
          }
          const { connectionId } = JSON.parse(decodeURIComponent(state));
          const savedConnection = await api.getConnectionParams(connectionId);
          if (savedConnection) {
            client.setCredentials(savedConnection);
          }
          if (matchAuthLogin(pathname)) {
            return res.redirect(
              client.generateAuthUrl({
                access_type: "offline",
                scope: [
                  "https://www.googleapis.com/auth/spreadsheets.readonly",
                  "https://www.googleapis.com/auth/drive.readonly"
                ],
                state,
                include_granted_scopes: true,
                prompt: "consent"
              })
            );
          }
          if (matchAuthCallback(pathname)) {
            const [oAuthError] = asArray(req.query.error);
            if (oAuthError) {
              throw new Error(String(oAuthError));
            }
            const [code] = asArray(req.query.code);
            if (typeof code !== "string") {
              return res.status(400).send(`Missing query parameter "code"`);
            }
            const { tokens, res: getTokenResponse } = await client.getToken(code);
            if (!tokens) {
              throw new Error(`${getTokenResponse?.status}: ${getTokenResponse?.statusText}`);
            }
            if (tokens) {
              client.setCredentials(tokens);
              await api.setConnectionParams(connectionId, client.credentials);
            }
            return res.redirect(`/_toolpad/app/connections/${encodeURIComponent(connectionId)}`);
          }
          return res.status(404).send("No handler exists for given path");
        } catch (error) {
          if (error instanceof Error) {
            console.error(error.message);
            return res.status(500).send(error.message);
          }
          return res.status(500).send(error);
        }
      };
    }
  };
}

// src/toolpadDataSources/local/shared.tsx
function parseLegacyFunctionId(id) {
  if (!id) {
    return { file: "functions.ts" };
  }
  const [file, handler] = id.split("#");
  return handler ? { file, handler } : { file: "functions.ts", handler: file };
}

// src/toolpadDataSources/local/server.ts
function createDatasource3(project) {
  const exec = async (connection, fetchQuery, parameters) => {
    if (!fetchQuery.function) {
      throw new Error("Missing function name");
    }
    const parsed = parseLegacyFunctionId(fetchQuery.function);
    if (!parsed.handler) {
      throw new Error("Missing function name");
    }
    const { data, error } = await project.functionsManager.exec(
      parsed.file,
      parsed.handler,
      parameters
    );
    return { data, error };
  };
  return {
    exec,
    api: {
      async introspection() {
        return project.functionsManager.introspect();
      },
      async debugExec(query, params) {
        return exec(null, query, params);
      },
      async createNew(fileName) {
        return project.functionsManager.createFunctionFile(fileName);
      }
    }
  };
}

// src/toolpadDataSources/server.ts
var dataSources = {
  rest: createDatasource,
  postgres: server_default,
  googleSheets: createDatasource2,
  mysql: server_default2,
  local: createDatasource3
};
var server_default3 = dataSources;

// src/utils/express.ts
function asyncHandler(handler) {
  return (req, res, next) => {
    Promise.resolve(handler(req, res, next)).catch(next);
  };
}

// src/server/DataManager.ts
function withSerializedError(withError) {
  const { error, ...withoutError } = withError;
  return withError.error ? { ...withoutError, error: serializeError3(errorFrom6(error)) } : withoutError;
}
var DataManager = class {
  project;
  dataSources;
  constructor(project) {
    this.project = project;
  }
  getDataSources() {
    if (!this.dataSources) {
      this.dataSources = new Map(
        Object.entries(server_default3).map(([key, value]) => [
          key,
          typeof value === "function" ? value(this.project) : value
        ])
      );
    }
    return this.dataSources;
  }
  async getConnectionParams(connectionId) {
    const dom = await this.project.loadDom();
    const node = appDom2.getNode(
      dom,
      connectionId,
      "connection"
    );
    return node.attributes.params.$$secret;
  }
  async setConnectionParams(connectionId, params) {
    let dom = await this.project.loadDom();
    const existing = appDom2.getNode(dom, connectionId, "connection");
    dom = appDom2.setNodeNamespacedProp(
      dom,
      existing,
      "attributes",
      "params",
      appDom2.createSecret(params)
    );
    await this.project.saveDom(dom);
  }
  async execDataNodeQuery(dataNode, params) {
    const dataSources2 = this.getDataSources();
    const dataSource = dataNode.attributes.dataSource ? dataSources2.get(dataNode.attributes.dataSource) : void 0;
    if (!dataSource) {
      throw new Error(
        `Unknown datasource "${dataNode.attributes.dataSource}" for query "${dataNode.id}"`
      );
    }
    let result = await dataSource.exec(null, dataNode.attributes.query, params);
    if (appDom2.isQuery(dataNode)) {
      const transformEnabled = dataNode.attributes.transformEnabled;
      const transform = dataNode.attributes.transform;
      if (transformEnabled && transform) {
        const jsServerRuntime = await createServerJsRuntime2(process.env);
        result = {
          data: await applyTransform(jsServerRuntime, transform, result.data)
        };
      }
    }
    return result;
  }
  async execQuery(pageName, queryName, params) {
    const dom = await this.project.loadDom();
    const page = appDom2.getPageByName(dom, pageName);
    if (!page) {
      throw new Error(`Unknown page "${pageName}"`);
    }
    const dataNode = appDom2.getQueryByName(dom, page, queryName);
    if (!dataNode) {
      throw new Error(`Unknown query "${queryName}"`);
    }
    if (!appDom2.isQuery(dataNode)) {
      throw new Error(`Invalid node type for data request`);
    }
    try {
      const result = await this.execDataNodeQuery(dataNode, params);
      return withSerializedError(result);
    } catch (error) {
      return withSerializedError({ error });
    }
  }
  async dataSourceFetchPrivate(dataSourceId, connectionId, query) {
    const dataSources2 = this.getDataSources();
    const dataSource = dataSources2.get(dataSourceId);
    if (!dataSource) {
      throw new Error(`Unknown dataSource "${dataSourceId}"`);
    }
    if (!dataSource.execPrivate) {
      throw new Error(`No execPrivate available on datasource "${dataSourceId}"`);
    }
    return dataSource.execPrivate(null, query);
  }
  async dataSourceExecPrivate(dataSourceId, method, args) {
    const dataSources2 = this.getDataSources();
    const dataSource = dataSources2.get(dataSourceId);
    if (!dataSource) {
      throw new Error(`Unknown dataSource "${dataSourceId}"`);
    }
    if (!dataSource.api) {
      throw new Error(`No api available on datasource "${dataSourceId}"`);
    }
    return dataSource.api[method](...args);
  }
  createDataHandler() {
    const router = express.Router();
    router.use(
      cors({
        methods: ["GET", "HEAD", "PUT", "PATCH", "POST", "DELETE"],
        // TODO: make this configurable
        origin: "*"
      })
    );
    router.post(
      "/:pageName/:queryName",
      express.json(),
      asyncHandler(async (req, res) => {
        const { pageName, queryName } = req.params;
        invariant3(typeof pageName === "string", "pageName url param required");
        invariant3(typeof queryName === "string", "queryName url variable required");
        const ctx = await createServerContext(req, res);
        const result = await withContext(ctx, async () => {
          return this.execQuery(pageName, queryName, req.body);
        });
        res.json(result);
      })
    );
    return router;
  }
  createDataSourcesHandler() {
    const dataSources2 = this.getDataSources();
    const router = express.Router();
    const handlerMap = /* @__PURE__ */ new Map();
    Object.keys(server_default3).forEach((dataSourceId) => {
      const handler = dataSources2.get(dataSourceId)?.createHandler?.();
      if (handler) {
        invariant3(
          typeof handler === "function",
          `Received a "${typeof handler}" instead of a "function" for the "${dataSourceId}" handler`
        );
        handlerMap.set(dataSourceId, handler);
      }
    });
    router.get(
      "/:dataSource/*",
      asyncHandler(async (req, res) => {
        const dataSource = req.params.dataSource;
        if (!dataSource) {
          throw new Error(`Missing path parameter "dataSource"`);
        }
        const handler = handlerMap.get(dataSource);
        if (typeof handler === "function") {
          return handler(this, req, res);
        }
        return res.status(404).json({ message: "No handler found" });
      })
    );
    return router;
  }
};

// src/runtime/toolpadComponents/index.tsx
var PAGE_ROW_COMPONENT_ID = "PageRow";
var PAGE_COLUMN_COMPONENT_ID = "PageColumn";

// src/packageInfo.ts
import * as path7 from "path";
import * as url4 from "node:url";
import * as fs4 from "fs";
var currentDirectory3 = url4.fileURLToPath(new URL(".", String(import.meta.url)));
var pkgJsonContent2 = fs4.readFileSync(path7.resolve(currentDirectory3, "../../package.json"), {
  encoding: "utf-8"
});
var pkgJson2 = JSON.parse(pkgJsonContent2);
var packageInfo_default = {
  version: pkgJson2.version,
  build: process.env.GIT_SHA1?.slice(0, 7) || "dev"
};

// src/server/localMode.ts
invariant4(
  isMainThread,
  "localMode should be used only in the main thread. Use message passing to get data from the main thread."
);
function getThemeFile(root) {
  return path8.join(root, "./theme.yml");
}
function getApplicationFile(root) {
  return path8.join(root, "./application.yml");
}
function getComponentsFolder(root) {
  return path8.join(root, "./components");
}
function getPagesFolder(root) {
  return path8.join(root, "./pages");
}
function getPageFolder(root, name) {
  const pagesFolder = getPagesFolder(root);
  const pageFolder = path8.resolve(pagesFolder, name);
  return pageFolder;
}
function getPageFile(root, name) {
  const pageFolder = getPageFolder(root, name);
  const pageFileName = path8.resolve(pageFolder, "page.yml");
  return pageFileName;
}
function getComponentFilePath(componentsFolder, componentName) {
  return path8.join(componentsFolder, `${componentName}.tsx`);
}
function getOutputFolder(root) {
  return path8.join(root, ".generated");
}
function getAppOutputFolder(root) {
  return path8.join(getOutputFolder(root), "app");
}
async function loadPagesFromFiles(root) {
  const pagesFolder = getPagesFolder(root);
  const entries = await readMaybeDir(pagesFolder);
  const resultEntries = await Promise.all(
    entries.map(async (entry) => {
      if (entry.isDirectory()) {
        const pageName = entry.name;
        const pageDirEntries = new Set(await fs5.readdir(path8.resolve(pagesFolder, pageName)));
        if (pageDirEntries.has("page.yml")) {
          const ymlFilePath = path8.resolve(pagesFolder, pageName, "./page.yml");
          const ymlContent = await readMaybeFile(ymlFilePath);
          if (ymlContent) {
            let parsedFile;
            try {
              parsedFile = yaml.parse(ymlContent);
            } catch (rawError) {
              const error = errorFrom7(rawError);
              console.error(
                `${chalk3.red("error")} - Failed to read page ${chalk3.cyan(pageName)}. ${error.message}`
              );
              return null;
            }
            const result = pageSchema.safeParse(parsedFile);
            if (result.success) {
              return [pageName, result.data];
            }
            console.error(
              `${chalk3.red("error")} - Failed to read page ${chalk3.cyan(pageName)}. ${fromZodError2(
                result.error
              )}`
            );
          }
        }
      }
      return null;
    })
  );
  return Object.fromEntries(resultEntries.filter(Boolean));
}
async function loadObjectFromFile(filePath, schema) {
  const content = await readMaybeFile(filePath);
  if (content) {
    const parsedFile = yaml.parse(content);
    const result = schema.safeParse(parsedFile);
    if (result.success) {
      return result.data;
    }
    console.error(
      `${chalk3.red("error")} - Failed to read theme ${chalk3.cyan(filePath)}. ${fromZodError2(
        result.error
      )}`
    );
    return null;
  }
  return null;
}
async function loadThemeFromFile(root) {
  const themeFilePath = getThemeFile(root);
  return loadObjectFromFile(themeFilePath, themeSchema);
}
async function loadApplicationFromFile(root) {
  const applicationFilePath = getApplicationFile(root);
  return loadObjectFromFile(applicationFilePath, applicationSchema);
}
async function createDefaultCodeComponent(name, filePath) {
  const componentId = name.replace(/\s/g, "");
  const propTypeId = `${componentId}Props`;
  const result = await format(
    `
  import * as React from 'react';
  import { createComponent } from '@toolpad/studio/browser';
  
  export interface ${propTypeId} {
    msg: string;
  }
  
  function ${componentId}({ msg }: ${propTypeId}) {
    return (
      <div>{msg}</div>
    );
  }

  export default createComponent(${componentId}, {
    argTypes: {
      msg: {
        type: "string",
        default: "Hello world!"
      },
    },
  });    
`,
    filePath
  );
  return result;
}
var Lock = class {
  pending = null;
  async use(doWork) {
    try {
      this.pending = Promise.resolve(this.pending).then(() => doWork());
      return await this.pending;
    } finally {
      this.pending = null;
    }
  }
};
var buildInfoSchema = z3.object({
  timestamp: z3.number(),
  base: z3.string().optional()
});
var DEFAULT_GENERATED_GITIGNORE_FILE_CONTENT = ".generated\n";
async function initGitignore(root) {
  const generatedGitignorePath = path8.resolve(root, ".gitignore");
  if (!await fileExists3(generatedGitignorePath)) {
    console.log(`${chalk3.blue("info")}  - Initializing .gitignore file`);
    await writeFileRecursive2(generatedGitignorePath, DEFAULT_GENERATED_GITIGNORE_FILE_CONTENT, {
      encoding: "utf-8"
    });
  }
}
function mergeThemeIntoAppDom(dom, themeFile) {
  const themeFileSpec = themeFile.spec;
  const app = appDom3.getApp(dom);
  dom = appDom3.addNode(
    dom,
    appDom3.createNode(dom, "theme", {
      theme: themeFileSpec?.options,
      attributes: {}
    }),
    app,
    "themes"
  );
  return dom;
}
function mergeApplicationIntoDom(dom, applicationFile) {
  const applicationFileSpec = applicationFile.spec;
  const app = appDom3.getApp(dom);
  dom = appDom3.setNodeNamespacedProp(dom, app, "attributes", "plan", applicationFileSpec?.plan);
  dom = appDom3.setNodeNamespacedProp(dom, app, "attributes", "authentication", {
    ...applicationFileSpec?.authentication
  });
  dom = appDom3.setNodeNamespacedProp(dom, app, "attributes", "authorization", {
    ...applicationFileSpec?.authorization,
    roles: applicationFileSpec?.authorization?.roles?.map(
      (role) => typeof role === "string" ? { name: role } : role
    )
  });
  return dom;
}
function stringOnly(maybeString) {
  return typeof maybeString === "string" ? maybeString : void 0;
}
function expandChildren(children, dom) {
  return children.sort((child1, child2) => {
    invariant4(child1.parentIndex && child2.parentIndex, "Nodes are not children of another node");
    return appDom3.compareFractionalIndex(child1.parentIndex, child2.parentIndex);
  }).map((child) => expandFromDom(child, dom));
}
function undefinedWhenEmpty(obj) {
  if (!obj || Object.values(obj).every((property) => property === void 0)) {
    return void 0;
  }
  return obj;
}
function createPageFileQueryFromDomQuery(dataSource, query) {
  switch (dataSource) {
    case "rest": {
      if (!query) {
        return { kind: "rest" };
      }
      query = query;
      let body;
      if (query.body) {
        switch (query.body.kind) {
          case "raw": {
            body = {
              kind: "raw",
              content: query.body.content,
              contentType: query.body.contentType
            };
            break;
          }
          case "urlEncoded": {
            body = {
              kind: "urlEncoded",
              content: query.body.content.map(([name, value]) => ({
                name,
                value
              }))
            };
            break;
          }
          default:
            throw new Error(`Unrecognized body kind "${query.body.kind}"`);
        }
      }
      let response;
      if (query.response) {
        switch (query.response.kind) {
          case "csv": {
            response = { kind: "csv", headers: query.response.headers };
            break;
          }
          case "json": {
            response = { kind: "json" };
            break;
          }
          case "xml": {
            response = { kind: "xml" };
            break;
          }
          case "raw": {
            response = { kind: "raw" };
            break;
          }
          default:
            throw new Error(`Unrecognized response kind "${query.response.kind}"`);
        }
      }
      return {
        kind: "rest",
        url: query.url,
        searchParams: query.searchParams?.map(([name, value]) => ({
          name,
          value
        })),
        headers: query.headers.map(([name, value]) => ({
          name,
          value
        })),
        body,
        method: query.method,
        response,
        transform: query.transform,
        transformEnabled: query.transformEnabled
      };
    }
    case "local":
      if (!query) {
        return { kind: "local" };
      }
      query = query;
      return {
        function: query.function,
        kind: "local"
      };
    default:
      throw new Error(`Unsupported dataSource "${dataSource}"`);
  }
}
function expandFromDom(node, dom) {
  if (appDom3.isPage(node)) {
    const children = appDom3.getChildNodes(dom, node);
    return {
      apiVersion: API_VERSION,
      kind: "page",
      spec: {
        displayName: node.attributes.displayName,
        alias: node.attributes.alias,
        title: node.attributes.title,
        parameters: undefinedWhenEmpty(
          node.attributes.parameters?.map(([name, value]) => ({ name, value })) ?? []
        ),
        content: undefinedWhenEmpty(expandChildren(children.children || [], dom)),
        queries: undefinedWhenEmpty(expandChildren(children.queries || [], dom)),
        display: node.attributes.display,
        maxWidth: node.attributes.maxWidth,
        authorization: node.attributes.authorization
      }
    };
  }
  if (appDom3.isQuery(node)) {
    return {
      name: node.name,
      enabled: node.attributes.enabled,
      mode: node.attributes.mode,
      query: node.attributes.dataSource ? createPageFileQueryFromDomQuery(
        node.attributes.dataSource,
        node.attributes.query
      ) : void 0,
      parameters: undefinedWhenEmpty(node.params?.map(([name, value]) => ({ name, value }))),
      cacheTime: node.attributes.cacheTime,
      refetchInterval: node.attributes.refetchInterval,
      transform: node.attributes.transform,
      transformEnabled: node.attributes.transformEnabled
    };
  }
  if (appDom3.isElement(node)) {
    const { children, ...templates } = appDom3.getChildNodes(dom, node);
    const templateProps = mapValues(
      templates,
      (subtree) => subtree ? {
        $$template: expandChildren(subtree, dom)
      } : void 0
    );
    return {
      component: node.attributes.component,
      name: node.name,
      layout: undefinedWhenEmpty({
        columnSize: node.layout?.columnSize,
        height: node.layout?.height,
        horizontalAlign: stringOnly(node.layout?.horizontalAlign),
        verticalAlign: stringOnly(node.layout?.verticalAlign)
      }),
      props: undefinedWhenEmpty({ ...node.props, ...templateProps }),
      children: undefinedWhenEmpty(expandChildren(children || [], dom))
    };
  }
  throw new Error(`Unsupported node type "${node.type}"`);
}
function isTemplate(bindableProp) {
  return !!(bindableProp && typeof bindableProp === "object" && hasOwnProperty(bindableProp, "$$template"));
}
function mergeElementIntoDom(dom, parent, parentProp, elm) {
  const plainProps = filterValues(elm.props ?? {}, (prop) => !isTemplate(prop));
  const templateProps = filterValues(elm.props ?? {}, isTemplate);
  const elmNode = appDom3.createElement(dom, elm.component, plainProps, elm.layout ?? {}, elm.name);
  dom = appDom3.addNode(dom, elmNode, parent, parentProp);
  if (elm.children) {
    for (const child of elm.children) {
      dom = mergeElementIntoDom(dom, elmNode, "children", child);
    }
  }
  for (const [propName, templateProp] of Object.entries(templateProps)) {
    for (const child of templateProp.$$template) {
      dom = mergeElementIntoDom(dom, elmNode, propName, child);
    }
  }
  return dom;
}
function createDomQueryFromPageFileQuery(query) {
  switch (query.kind) {
    case "local":
      return {
        function: query.function
      };
    case "rest": {
      let body;
      if (query.body) {
        switch (query.body.kind) {
          case "raw": {
            body = {
              kind: "raw",
              content: query.body.content,
              contentType: query.body.contentType
            };
            break;
          }
          case "urlEncoded": {
            body = {
              kind: "urlEncoded",
              content: query.body.content.map(({ name, value }) => [
                name,
                value
              ])
            };
            break;
          }
          default:
            throw new Error(`Unrecognized body kind "${query.body.kind}"`);
        }
      }
      let response;
      if (query.response) {
        switch (query.response.kind) {
          case "csv": {
            response = { kind: "csv", headers: query.response.headers };
            break;
          }
          case "json": {
            response = { kind: "json" };
            break;
          }
          case "xml": {
            response = { kind: "xml" };
            break;
          }
          case "raw": {
            response = { kind: "raw" };
            break;
          }
          default:
            throw new Error(`Unrecognized response kind "${query.response.kind}"`);
        }
      }
      return {
        url: query.url || void 0,
        headers: query.headers?.map(({ name, value }) => [name, value]) || [],
        method: query.method || "GET",
        browser: false,
        transform: query.transform,
        transformEnabled: query.transformEnabled,
        searchParams: query.searchParams?.map(({ name, value }) => [name, value]) || [],
        body,
        response
      };
    }
    default:
      throw new Error(`Unrecognized query kind "${query.kind}"`);
  }
}
function createPageDomFromPageFile(pageName, pageFile) {
  const pageFileSpec = pageFile.spec ?? {};
  let fragment = appDom3.createFragment("page", {
    name: pageName,
    attributes: {
      displayName: pageFileSpec.displayName,
      // Convert deprecated id to alias
      alias: pageFileSpec.id ? [pageFileSpec.id] : pageFileSpec.alias,
      title: pageFileSpec.title,
      parameters: pageFileSpec.parameters?.map(({ name, value }) => [name, value]) || [],
      display: pageFileSpec.display || void 0,
      maxWidth: pageFileSpec.maxWidth || void 0,
      authorization: pageFileSpec.authorization || void 0
    }
  });
  const pageNode = appDom3.getRoot(fragment);
  appDom3.assertIsPage(pageNode);
  if (pageFileSpec.queries) {
    for (const query of pageFileSpec.queries) {
      if (query.query) {
        const queryNode = appDom3.createNode(fragment, "query", {
          name: query.name,
          attributes: {
            connectionId: null,
            dataSource: typeof query.query?.kind === "string" ? query.query.kind : void 0,
            query: createDomQueryFromPageFileQuery(query.query),
            cacheTime: typeof query.cacheTime === "number" ? query.cacheTime : void 0,
            enabled: query.enabled ?? void 0,
            mode: typeof query.mode === "string" ? query.mode : void 0,
            transform: typeof query.transform === "string" ? query.transform : void 0,
            refetchInterval: typeof query.refetchInterval === "number" ? query.refetchInterval : void 0,
            transformEnabled: query.transformEnabled ?? void 0
          },
          params: query.parameters?.map(
            ({ name, value }) => [name, value]
          )
        });
        fragment = appDom3.addNode(fragment, queryNode, pageNode, "queries");
      }
    }
  }
  if (pageFileSpec.content) {
    for (const child of pageFileSpec.content) {
      fragment = mergeElementIntoDom(fragment, pageNode, "children", child);
    }
  }
  return fragment;
}
function mergePageIntoDom(dom, pageName, pageFile) {
  const appRoot = appDom3.getRoot(dom);
  const pageFragment = createPageDomFromPageFile(pageName, pageFile);
  const newPageNode = appDom3.getRoot(pageFragment);
  if (appDom3.getMaybeNode(dom, newPageNode.id)) {
    dom = appDom3.removeNode(dom, newPageNode.id);
  }
  dom = appDom3.addFragment(dom, pageFragment, appRoot.id, "pages");
  return dom;
}
function optimizePageElement(element, isPageChild = false) {
  if (isPageChild && element.component === PAGE_COLUMN_COMPONENT_ID) {
    return (element.children || []).flatMap((child) => optimizePageElement(child, true));
  }
  const isLayoutElement = (possibleLayoutElement) => possibleLayoutElement.component === PAGE_ROW_COMPONENT_ID || possibleLayoutElement.component === PAGE_COLUMN_COMPONENT_ID;
  if (isLayoutElement(element) && element.children?.length === 1) {
    const onlyChild = element.children[0];
    if (!isLayoutElement(onlyChild)) {
      return optimizePageElement({
        ...onlyChild,
        layout: {
          ...onlyChild.layout,
          columnSize: 1
        }
      });
    }
  }
  return {
    ...element,
    children: element.children && element.children.flatMap((child) => optimizePageElement(child))
  };
}
function optimizePage(page) {
  return {
    ...page,
    spec: {
      ...page.spec,
      content: page.spec?.content?.flatMap((element) => optimizePageElement(element, true))
    }
  };
}
function mergePagesIntoDom(dom, pages) {
  for (const [name, page] of Object.entries(pages)) {
    dom = mergePageIntoDom(dom, name, optimizePage(page));
  }
  return dom;
}
function extractPagesFromDom(dom) {
  const rootNode = appDom3.getApp(dom);
  const { pages: pageNodes = [] } = appDom3.getChildNodes(dom, rootNode);
  const pages = {};
  for (const pageNode of pageNodes) {
    pages[pageNode.name] = expandFromDom(pageNode, dom);
    dom = appDom3.removeNode(dom, pageNode.id);
  }
  return { pages, dom };
}
function extractThemeFromDom(dom) {
  const rootNode = appDom3.getApp(dom);
  const { themes: themeNodes = [] } = appDom3.getChildNodes(dom, rootNode);
  if (themeNodes.length > 0) {
    return {
      apiVersion: API_VERSION,
      kind: "theme",
      spec: {
        options: themeNodes[0].theme
      }
    };
  }
  return null;
}
function extractApplicationFromDom(dom) {
  const rootNode = appDom3.getApp(dom);
  return {
    apiVersion: API_VERSION,
    kind: "application",
    spec: {
      plan: rootNode.attributes.plan,
      authentication: rootNode.attributes.authentication,
      authorization: rootNode.attributes.authorization
    }
  };
}
function getSchemaUrl(obj) {
  return `https://raw.githubusercontent.com/mui/toolpad/v${packageInfo_default.version}/docs/schemas/v1/definitions.json#properties/${obj}`;
}
async function writePagesToFiles(root, pages) {
  await Promise.all(
    Object.entries(pages).map(async ([name, page]) => {
      const pageFileName = getPageFile(root, name);
      await updateYamlFile(pageFileName, optimizePage(page), {
        schemaUrl: getSchemaUrl("Page")
      });
    })
  );
}
async function writeThemeFile(root, theme) {
  const themeFilePath = getThemeFile(root);
  if (theme) {
    await updateYamlFile(themeFilePath, theme, {
      schemaUrl: getSchemaUrl("Theme")
    });
  } else {
    await fs5.rm(themeFilePath, { recursive: true, force: true });
  }
}
async function writeApplicationFile(root, application) {
  const applicationFilePath = getApplicationFile(root);
  if (application) {
    await updateYamlFile(applicationFilePath, application, {
      schemaUrl: getSchemaUrl("Application")
    });
  } else {
    await fs5.rm(applicationFilePath, { recursive: true, force: true });
  }
}
async function writeDomToDisk(root, dom) {
  const { pages: pagesContent } = extractPagesFromDom(dom);
  await Promise.all([
    writePagesToFiles(root, pagesContent),
    writeThemeFile(root, extractThemeFromDom(dom)),
    writeApplicationFile(root, extractApplicationFromDom(dom))
  ]);
}
async function findSupportedEditor() {
  if (process.env.EDITOR) {
    return void 0;
  }
  try {
    await execa("code", ["-v"]);
    return "code";
  } catch (err) {
    return void 0;
  }
}
async function readProjectFolder(root) {
  const [pagesContent, theme, application] = await Promise.all([
    loadPagesFromFiles(root),
    loadThemeFromFile(root),
    loadApplicationFromFile(root)
  ]);
  return {
    application,
    pages: pagesContent,
    theme
  };
}
async function writeProjectFolder(root, folder) {
  await Promise.all([
    writePagesToFiles(root, folder.pages),
    writeThemeFile(root, folder.theme),
    writeApplicationFile(root, folder.application)
  ]);
}
function projectFolderToAppDom(projectFolder) {
  let dom = appDom3.createDom();
  dom = mergePagesIntoDom(dom, projectFolder.pages);
  if (projectFolder.theme) {
    dom = mergeThemeIntoAppDom(dom, projectFolder.theme);
  }
  if (projectFolder.application) {
    dom = mergeApplicationIntoDom(dom, projectFolder.application);
  }
  return dom;
}
async function loadProjectFolder(root) {
  return readProjectFolder(root);
}
async function loadDomFromDisk(root) {
  const projectFolder = await loadProjectFolder(root);
  return projectFolderToAppDom(projectFolder);
}
function getDomFilePatterns(root) {
  return [
    path8.resolve(root, "./pages/*/page.yml"),
    path8.resolve(root, "./theme.yml"),
    path8.resolve(root, "./application.yml")
  ];
}
async function calculateDomFingerprint(root) {
  const files = await glob2(getDomFilePatterns(root), { windowsPathsNoEscape: true });
  const mtimes = await Promise.all(
    files.sort().map(async (file) => {
      const stats = await fs5.stat(file);
      return [file, stats.mtimeMs];
    })
  );
  return insecureHash(JSON.stringify(mtimes));
}
function findEnvBindings(obj) {
  if (Array.isArray(obj)) {
    return obj.flatMap((item) => findEnvBindings(item));
  }
  if (obj && typeof obj === "object") {
    try {
      return [envBindingSchema.parse(obj)];
    } catch {
      return Object.values(obj).flatMap((value) => findEnvBindings(value));
    }
  }
  return [];
}
function getRequiredEnvVars(dom) {
  const allVars = Object.values(dom.nodes).flatMap((node) => findEnvBindings(node)).map((binding) => binding.$$env);
  return new Set(allVars);
}
var PRO_AUTH_PROVIDERS = ["azure-ad"];
function detectPaidFeatures(application) {
  if (!application.spec || !application.spec.authorization) {
    return null;
  }
  const hasRoles = Boolean(application?.spec?.authorization?.roles);
  const hasProAuthProvider = application?.spec?.authentication?.providers?.some(
    (elems) => PRO_AUTH_PROVIDERS.includes(elems.provider)
  );
  const paidFeatures = [
    hasRoles ? { id: "roles", label: "Role-based access control" } : void 0,
    hasProAuthProvider ? { id: "pro-auth-provider", label: "Some of your active authentication providers" } : void 0
  ].filter(Boolean);
  return paidFeatures.length > 0 ? paidFeatures : null;
}
var ToolpadProject = class {
  root;
  events = new Emitter();
  domAndFingerprint = null;
  domAndFingerprintLock = new Lock();
  options;
  envManager;
  functionsManager;
  dataManager;
  alertedMissingVars = /* @__PURE__ */ new Set();
  lastVersionCheck = 0;
  pendingVersionCheck;
  componentsManifestPromise;
  pagesManifestPromise;
  constructor(root, options) {
    invariant4(
      // eslint-disable-next-line no-underscore-dangle
      !global.__toolpadProjects?.has(root),
      `A project is already running for "${root}"`
    );
    global.__toolpadProjects ??= /* @__PURE__ */ new Set();
    global.__toolpadProjects.add(root);
    this.root = root;
    this.options = options;
    this.envManager = new EnvManager(this);
    this.functionsManager = new FunctionsManager(this);
    this.dataManager = new DataManager(this);
    const invalidateQueries = throttle(
      () => {
        this.events.emit("queriesInvalidated", {});
      },
      250,
      {
        leading: false
      }
    );
    this.events.on("functionsChanged", invalidateQueries);
    this.events.on("envChanged", invalidateQueries);
  }
  initWatcher() {
    if (!this.options.dev) {
      return;
    }
    const updateDomFromExternal = debounce(() => {
      this.domAndFingerprintLock.use(async () => {
        const [, fingerprint] = await this.loadDomAndFingerprint();
        const newFingerprint = await calculateDomFingerprint(this.root);
        if (fingerprint !== newFingerprint) {
          console.log(`${chalk3.magenta("event")} - Project changed on disk, updating...`);
          this.domAndFingerprint = await Promise.all([
            loadDomFromDisk(this.root),
            calculateDomFingerprint(this.root)
          ]);
          this.events.emit("change", {});
          this.events.emit("externalChange", {});
        }
      });
    }, 100);
    const watchOptions = {
      // This is needed to correctly pick up page folder renames
      // Remove this once https://github.com/paulmillr/chokidar/issues/1285 gets resolved
      usePolling: true
    };
    chokidar3.watch(getDomFilePatterns(this.root), watchOptions).on("all", () => {
      updateDomFromExternal();
    });
    const handleComponentFileChange = async () => {
      const oldManifest = await this.componentsManifestPromise;
      this.componentsManifestPromise = this.buildComponentsManifest();
      const newManifest = await this.componentsManifestPromise;
      if (JSON.stringify(oldManifest) !== JSON.stringify(newManifest)) {
        this.events.emit("componentsListChanged", {});
      }
    };
    chokidar3.watch(
      [path8.resolve(this.root, "./components"), path8.resolve(this.root, "./components/*.*")],
      watchOptions
    ).on("add", handleComponentFileChange).on("addDir", handleComponentFileChange).on("unlink", handleComponentFileChange).on("unlinkDir", handleComponentFileChange);
    const handlePageFileChange = async () => {
      const oldManifest = await this.pagesManifestPromise;
      this.pagesManifestPromise = buildPagesManifest(this.root);
      const newManifest = await this.pagesManifestPromise;
      if (JSON.stringify(oldManifest) !== JSON.stringify(newManifest)) {
        this.events.emit("pagesManifestChanged", {});
      }
    };
    chokidar3.watch(
      [path8.resolve(this.root, "./pages"), path8.resolve(this.root, "./pages/*/page.*")],
      watchOptions
    ).on("add", handlePageFileChange).on("addDir", handlePageFileChange).on("unlink", handlePageFileChange).on("unlinkDir", handlePageFileChange);
  }
  async loadDomAndFingerprint() {
    if (!this.domAndFingerprint) {
      this.domAndFingerprint = Promise.all([
        loadDomFromDisk(this.root),
        calculateDomFingerprint(this.root)
      ]);
    }
    return this.domAndFingerprint;
  }
  getRoot() {
    return this.root;
  }
  getOutputFolder() {
    return getOutputFolder(this.getRoot());
  }
  getAppOutputFolder() {
    return getAppOutputFolder(this.getRoot());
  }
  getBuildInfoFile() {
    return path8.resolve(this.getOutputFolder(), "buildInfo.json");
  }
  alertOnMissingVariablesInDom(dom) {
    const requiredVars = getRequiredEnvVars(dom);
    const missingVars = Array.from(requiredVars).filter(
      (key) => typeof process.env[key] === "undefined"
    );
    const toAlert = missingVars.filter((key) => !this.alertedMissingVars.has(key));
    if (toAlert.length > 0) {
      const firstThree = toAlert.slice(0, 3);
      const restCount = toAlert.length - firstThree.length;
      const missingListMsg = firstThree.map((varName) => chalk3.cyan(varName)).join(", ");
      const restMsg = restCount > 0 ? ` and ${restCount} more` : "";
      console.log(
        `${chalk3.yellow(
          "warn"
        )}  - Missing required environment variable(s): ${missingListMsg}${restMsg}.`
      );
    }
    this.alertedMissingVars = new Set(missingVars);
  }
  async checkPlan() {
    const [dom] = await this.loadDomAndFingerprint();
    const application = extractApplicationFromDom(dom);
    if (!application || !application.spec) {
      return;
    }
    if (!application.spec.plan || application.spec.plan === "free") {
      const paidFeatures = detectPaidFeatures(application);
      if (paidFeatures) {
        throw new Error(
          `You are using ${chalk3.bgBlue(paidFeatures.map((feature) => feature.label))} which ${paidFeatures.length > 1 ? "are paid features" : "is a paid feature"}. To continue using Toolpad, upgrade your plan or remove this feature. Learn more at ${chalk3.cyan(UPGRADE_URL)}.`
        );
      }
    } else {
      console.log(
        `${chalk3.yellow(
          "warn"
        )}  - You are using features that ${chalk3.bold("are not covered under our MIT License")}. You will have to buy a license to use them in production.`
      );
    }
  }
  async start() {
    if (this.options.dev) {
      await this.resetBuildInfo();
      await this.initWatcher();
    } else {
      const buildInfo = await this.getBuildInfo();
      if (!buildInfo) {
        throw new Error(`No production build found. Please run "toolpad-studio build" first.`);
      }
      if (buildInfo.base !== this.options.base) {
        throw new Error(
          `Production build found for base "${buildInfo.base}" but running the app with "${this.options.base}". Please run "toolpad-studio build" with the correct --base option.`
        );
      }
    }
    await Promise.all([this.envManager.start(), this.functionsManager.start()]);
  }
  async build() {
    await Promise.all([this.envManager.build(), this.functionsManager.build()]);
  }
  async dispose() {
    await Promise.all([this.envManager.dispose(), this.functionsManager.dispose()]);
    global.__toolpadProjects?.delete(this.root);
  }
  async loadDom() {
    const [dom] = await this.loadDomAndFingerprint();
    this.alertOnMissingVariablesInDom(dom);
    return dom;
  }
  async buildComponentsManifest() {
    const componentsFolder = getComponentsFolder(this.getRoot());
    const entries = await glob2(["*.tsx"], { cwd: componentsFolder });
    const result = entries.map((fileName) => {
      const componentName = fileName.replace(/\.tsx$/, "");
      if (isValidJsIdentifier(componentName)) {
        const filePath = path8.resolve(componentsFolder, fileName);
        return { name: componentName, path: filePath };
      }
      console.log(`Invalid component name: ${componentName}`);
      return null;
    });
    return result.filter(Boolean);
  }
  async getComponentsManifest() {
    if (!this.componentsManifestPromise) {
      this.componentsManifestPromise = this.buildComponentsManifest();
    }
    return this.componentsManifestPromise;
  }
  async writeDomToDisk(newDom) {
    if (!this.options.dev) {
      throw new Error(`Writing to disk is only possible in Toolpad Studio dev mode.`);
    }
    await writeDomToDisk(this.root, newDom);
    const newFingerprint = await calculateDomFingerprint(this.root);
    this.domAndFingerprint = [newDom, newFingerprint];
    this.events.emit("change", { fingerprint: newFingerprint });
  }
  async init() {
    const projectFolder = await readProjectFolder(this.root);
    if (Object.keys(projectFolder.pages).length <= 0) {
      projectFolder.pages.page = {
        apiVersion: API_VERSION,
        kind: "page",
        spec: {
          id: appDom3.createId(),
          title: "Default page"
        }
      };
      await writeProjectFolder(this.root, projectFolder);
    }
    await initGitignore(this.root);
  }
  async saveDom(newDom) {
    await this.domAndFingerprintLock.use(async () => {
      return this.writeDomToDisk(newDom);
    });
  }
  async applyDomDiff(domDiff) {
    await this.domAndFingerprintLock.use(async () => {
      const dom = await this.loadDom();
      const newDom = appDom3.applyDiff(dom, domDiff);
      return this.writeDomToDisk(newDom);
    });
  }
  async openCodeEditor(fileName, fileType) {
    const supportedEditor = await findSupportedEditor();
    const root = this.getRoot();
    let resolvedPath = fileName;
    if (fileType === "resource") {
      resolvedPath = await this.functionsManager.getFunctionFilePath(fileName);
    }
    if (fileType === "component") {
      const componentsFolder = getComponentsFolder(root);
      resolvedPath = getComponentFilePath(componentsFolder, fileName);
    }
    const fullResolvedPath = path8.resolve(root, resolvedPath);
    await openEditor([fullResolvedPath, root], {
      editor: supportedEditor
    });
  }
  async getVersionInfo() {
    const now = Date.now();
    if (!this.pendingVersionCheck || this.lastVersionCheck + VERSION_CHECK_INTERVAL <= now) {
      this.lastVersionCheck = now;
      this.pendingVersionCheck = checkVersion(this.root);
    }
    return this.pendingVersionCheck;
  }
  async createComponent(name) {
    const componentsFolder = getComponentsFolder(this.root);
    const filePath = getComponentFilePath(componentsFolder, name);
    const content = await createDefaultCodeComponent(name, filePath);
    await writeFileRecursive2(filePath, content, { encoding: "utf-8" });
  }
  async createDataProvider(name, options) {
    return this.functionsManager.createDataProviderFile(name, options);
  }
  async deletePage(name) {
    const pageFolder = getPageFolder(this.root, name);
    await fs5.rm(pageFolder, { force: true, recursive: true });
  }
  async getPrettierConfig() {
    const root = this.getRoot();
    const config2 = await resolvePrettierConfig(root);
    return config2;
  }
  async writeBuildInfo() {
    await writeFileRecursive2(
      this.getBuildInfoFile(),
      JSON.stringify({
        timestamp: Date.now(),
        base: this.options.base
      }),
      { encoding: "utf-8" }
    );
  }
  async resetBuildInfo() {
    await fs5.rm(this.getBuildInfoFile(), { force: true, recursive: true });
  }
  async getBuildInfo() {
    try {
      const content = await readJsonFile2(this.getBuildInfoFile());
      return buildInfoSchema.parse(content);
    } catch {
      return null;
    }
  }
  async getPagesManifest() {
    if (!this.pagesManifestPromise) {
      this.pagesManifestPromise = buildPagesManifest(this.root);
    }
    return this.pagesManifestPromise;
  }
};
function resolveProjectDir(dir) {
  const projectDir = path8.resolve(process.cwd(), dir);
  return projectDir;
}
async function initProject({ dir: dirInput, ...config2 }) {
  const dir = resolveProjectDir(dirInput);
  const resolvedConfig = {
    toolpadDevMode: false,
    dev: false,
    base: "/prod",
    customServer: false,
    ...config2
  };
  const project = new ToolpadProject(dir, resolvedConfig);
  await project.init();
  return project;
}
var basePagesManifestEntrySchema = z3.object({
  slug: z3.string(),
  title: z3.string(),
  legacy: z3.boolean().optional()
});
var pagesManifestEntrySchema = basePagesManifestEntrySchema.extend(
  {
    children: z3.array(z3.lazy(() => pagesManifestEntrySchema))
  }
);
var pagesManifestSchema = z3.object({
  pages: z3.array(pagesManifestEntrySchema)
});
async function buildPagesManifest(root) {
  const pagesFolder = getPagesFolder(root);
  const pageDirs = await readMaybeDir(pagesFolder);
  const pages = (await Promise.all(
    pageDirs.map(async (page) => {
      if (page.isDirectory()) {
        const pagePath = path8.resolve(pagesFolder, page.name);
        const title = guessTitle(page.name);
        const extensions = [".tsx", ".jsx"];
        for (const extension of extensions) {
          const pageFilePath2 = path8.resolve(pagePath, `page${extension}`);
          const stat3 = await fs5.stat(pageFilePath2).catch(() => null);
          if (stat3?.isFile()) {
            return [
              {
                slug: page.name,
                title,
                children: []
              }
            ];
          }
        }
        const pageFilePath = path8.resolve(pagePath, "page.yml");
        const stat2 = await fs5.stat(pageFilePath).catch(() => null);
        if (stat2?.isFile()) {
          return [
            {
              slug: page.name,
              title,
              legacy: true,
              children: []
            }
          ];
        }
      }
      return [];
    })
  )).flat();
  pages.sort((page1, page2) => page1.title.localeCompare(page2.title));
  return { pages };
}

// src/server/appBuilderWorker.ts
async function main() {
  invariant5(
    process.env.NODE_ENV === "production",
    "The app builder must be run with NODE_ENV=production"
  );
  invariant5(!!process.env.TOOLPAD_PROJECT_DIR, "A project root must be defined");
  invariant5(!!process.env.TOOLPAD_BASE, "A base path must be defined");
  const base = process.env.TOOLPAD_BASE;
  const project = await initProject({
    dev: false,
    dir: process.env.TOOLPAD_PROJECT_DIR,
    base
  });
  await project.build();
  await buildApp({
    root: project.getRoot(),
    base,
    getComponents: () => project.getComponentsManifest(),
    getPagesManifest: () => project.getPagesManifest(),
    outDir: project.getAppOutputFolder(),
    loadDom: () => project.loadDom()
  });
  await project.writeBuildInfo();
  await project.dispose();
}
main().catch((err) => {
  console.error(err);
  process.exit(1);
});
//# sourceMappingURL=appBuilderWorker.mjs.map