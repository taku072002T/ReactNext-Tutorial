// src/server/appServerWorker.ts
import { parentPort, workerData } from "worker_threads";
import invariant from "invariant";
import { createRpcClient } from "@toolpad/utils/workerRpc";

// src/server/toolpadAppBuilder.ts
import * as path2 from "path";
import * as url from "node:url";
import * as fs from "fs";
import react from "@vitejs/plugin-react";
import { indent } from "@toolpad/utils/strings";
import * as appDom from "@toolpad/studio-runtime/appDom";

// src/constants.ts
var INITIAL_STATE_WINDOW_PROPERTY = "__initialToolpadState__";
var VERSION_CHECK_INTERVAL = 1e3 * 60 * 10;

// src/server/viteVirtualPlugin.ts
import { posix as path } from "path";
import { transformWithEsbuild } from "vite";
var API_PROPERTY = Symbol("virtual-fs-api");
function virtualFsPlugin(initialFiles, userIdentifier) {
  const prefix = `virtual:${userIdentifier}:`;
  const resolvedPrefix = `\0${prefix}`;
  const transformExtensions = /* @__PURE__ */ new Set([".js", ".jsx", ".ts", ".tsx"]);
  const resolveExtensions = /* @__PURE__ */ new Set([".js", ".jsx", ".ts", ".tsx", ".json"]);
  let serverInstance;
  let files = initialFiles;
  return {
    name: "virtual-fs",
    enforce: "pre",
    configureServer(server) {
      serverInstance = server;
    },
    resolveId(id, importer) {
      if (id.startsWith(prefix)) {
        const entryPath = id.slice(prefix.length);
        if (files.has(entryPath)) {
          return `${resolvedPrefix}${entryPath}`;
        }
        for (const extension of resolveExtensions) {
          const entryPathWithExtension = `${entryPath}${extension}`;
          if (files.has(entryPathWithExtension)) {
            return `${resolvedPrefix}${entryPathWithExtension}`;
          }
        }
      } else if (importer?.startsWith(resolvedPrefix)) {
        const importerPath = importer.slice(resolvedPrefix.length);
        const fullPath = path.resolve(path.dirname(importerPath), id);
        return this.resolve(`${prefix}${fullPath}`, importer);
      }
      return null;
    },
    async load(id) {
      if (id.startsWith(resolvedPrefix)) {
        const virtualPath = id.slice(resolvedPrefix.length);
        const content = files.get(virtualPath);
        return content;
      }
      return null;
    },
    async transform(code, id) {
      if (id.startsWith(resolvedPrefix)) {
        const virtualPath = id.slice(resolvedPrefix.length);
        if (transformExtensions.has(path.extname(virtualPath))) {
          return transformWithEsbuild(code, virtualPath);
        }
      }
      return null;
    },
    [API_PROPERTY]: {
      async replaceFiles(newFiles) {
        const filesToInvalidate = [];
        for (const [virtualPath, content] of files) {
          if (!newFiles.has(virtualPath) || newFiles.get(virtualPath) !== content) {
            filesToInvalidate.push(virtualPath);
          }
        }
        files = newFiles;
        if (serverInstance) {
          for (const virtualPath of filesToInvalidate) {
            const resolvedId = `${resolvedPrefix}${virtualPath}`;
            const mod = serverInstance.moduleGraph.getModuleById(resolvedId);
            if (mod) {
              serverInstance.reloadModule(mod);
            }
          }
        } else {
          console.warn("Server instance not found, cannot invalidate files");
        }
      }
    }
  };
}
function replaceFiles(plugin, newFiles) {
  return plugin[API_PROPERTY].replaceFiles(newFiles);
}

// src/runtime/constants.ts
var FONTS_URL = "https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap";

// src/server/toolpadAppBuilder.ts
var currentDirectory = url.fileURLToPath(new URL(".", import.meta.url));
var pkgJsonContent = fs.readFileSync(path2.resolve(currentDirectory, "../../package.json"), {
  encoding: "utf-8"
});
var pkgJson = JSON.parse(pkgJsonContent);
var TOOLPAD_BUILD = process.env.GIT_SHA1?.slice(0, 7) || "dev";
var MAIN_ENTRY = "/main.tsx";
var EDITOR_ENTRY = "/editor.tsx";
function getHtmlContent(entry) {
  return `
    <!DOCTYPE html>
    <html lang="en">
      <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Toolpad</title>
        <link rel="preload" href="${FONTS_URL}" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="${FONTS_URL}"></noscript>
      </head>
      <body>
        <div id="root"></div>
    
        <!-- __TOOLPAD_SCRIPTS__ -->

        <script type="module" src=${JSON.stringify(entry)}></script>
      </body>
    </html>
  `;
}
function getAppHtmlContent() {
  return getHtmlContent(MAIN_ENTRY);
}
function getEditorHtmlContent() {
  return getHtmlContent(EDITOR_ENTRY);
}
function toolpadStudioVitePlugin() {
  return {
    name: "toolpad-studio",
    async resolveId(id) {
      if (id.endsWith(".html")) {
        return id;
      }
      return null;
    },
    async load(id) {
      if (id.endsWith("index.html")) {
        return getAppHtmlContent();
      }
      if (id.endsWith("editor.html")) {
        return getEditorHtmlContent();
      }
      return null;
    }
  };
}
async function createViteConfig({
  toolpadDevMode,
  outDir,
  root,
  dev,
  base,
  customServer,
  plugins = [],
  getComponents: getComponents2,
  loadDom: loadDom2,
  getPagesManifest: getPagesManifest2
}) {
  const mode = dev ? "development" : "production";
  const initialDom = await loadDom2();
  const plan = appDom.getPlan(initialDom);
  const getEntryPoint = (target) => {
    const isEditor = target === "editor";
    const componentsId = "virtual:toolpad-files:components.tsx";
    return `
import { init, setComponents } from '@toolpad/studio/entrypoint';
import components from ${JSON.stringify(componentsId)};
${isEditor ? `import ToolpadEditor from '@toolpad/studio/editor'` : ""}

${isEditor ? `
      // importing monaco to get around module ordering issues in esbuild
      import 'monaco-editor';

      window.MonacoEnvironment = {
        getWorker: async (_, label) => {
          // { type: 'module' } is supported in firefox but behind feature flag:
          // you have to enable it manually via about:config and set dom.workers.modules.enabled to true.
          if (label === 'typescript') {
            const { default: TsWorker } = await import('monaco-editor/esm/vs/language/typescript/ts.worker?worker');
            return new TsWorker();
          }
          if (label === 'json') {
            const { default: JsonWorker } = await import('monaco-editor/esm/vs/language/json/json.worker?worker');
            return new JsonWorker();
          }
          if (label === 'html') {
            const { default: HtmlWorker } = await import('monaco-editor/esm/vs/language/html/html.worker?worker');
            return new HtmlWorker();
          }
          if (label === 'css') {
            const { default: CssWorker } = await import('monaco-editor/esm/vs/language/css/css.worker?worker');
            return new CssWorker();
          }
          if (label === 'editorWorkerService') {
            const { default: EditorWorker } = await import('monaco-editor/esm/vs/editor/editor.worker?worker');
            return new EditorWorker();
          }
          throw new Error(\`Failed to resolve worker with label "\${label}"\`);
        },
      } as monaco.Environment;
      ` : ""}

const initialState = window[${JSON.stringify(INITIAL_STATE_WINDOW_PROPERTY)}];

setComponents(components);

init({
  ${isEditor ? `ToolpadApp: ToolpadEditor,` : ""}
  base: ${JSON.stringify(base)},
  initialState,
})

if (import.meta.hot) {
  // TODO: investigate why this doesn't work, see https://github.com/vitejs/vite/issues/12912
  import.meta.hot.accept(
    [${JSON.stringify(componentsId)}],
    (newComponents) => {
    if (newComponents) {
      console.log('hot updating Toolpad Studio components')
      setComponents(
        newComponents ?? components,
      );
    }
  });
}
`;
  };
  const createComponentsFile = async () => {
    const components = await getComponents2();
    const imports = components.map(
      ({ name }) => `import ${name} from 'toolpad-user-project:./components/${name}';`
    );
    const defaultExportProperties = components.map(
      ({ name }) => `${JSON.stringify(`codeComponent.${name}`)}: ${name}`
    );
    const code = `
      ${imports.join("\n")}

      export default {
        ${indent(defaultExportProperties.join(",\n"), 2)}
      };
    `;
    return {
      code,
      map: null
    };
  };
  const virtualFiles = /* @__PURE__ */ new Map([
    ["main.tsx", getEntryPoint("prod")],
    ["editor.tsx", getEntryPoint("editor")],
    ["components.tsx", await createComponentsFile()],
    ["pages-manifest.json", JSON.stringify(await getPagesManifest2(), null, 2)]
  ]);
  const virtualToolpadFiles = virtualFsPlugin(virtualFiles, "toolpad-files");
  return {
    reloadComponents: async () => {
      const newFiles = new Map(virtualFiles);
      newFiles.set("components.tsx", await createComponentsFile());
      replaceFiles(virtualToolpadFiles, newFiles);
    },
    viteConfig: {
      configFile: false,
      mode,
      build: {
        outDir,
        emptyOutDir: true,
        chunkSizeWarningLimit: Infinity,
        rollupOptions: {
          input: {
            index: path2.resolve(currentDirectory, "./index.html"),
            ...dev ? { editor: path2.resolve(currentDirectory, "./editor.html") } : {}
          },
          onwarn(warning, warn) {
            if (warning.code === "MODULE_LEVEL_DIRECTIVE") {
              return;
            }
            warn(warning);
          }
        }
      },
      envFile: false,
      resolve: {
        dedupe: ["@mui/material", "@emotion/react", "@emotion/styled", "@tanstack/react-query"],
        alias: [
          {
            // FIXME(https://github.com/mui/material-ui/issues/35233)
            find: /^@mui\/icons-material\/(?!esm\/)([^/]*)/,
            replacement: "@mui/icons-material/esm/$1"
          },
          {
            find: /^toolpad-user-project:(.*)$/,
            replacement: `${root}/$1`
          },
          {
            find: MAIN_ENTRY,
            replacement: "virtual:toolpad-files:main.tsx"
          },
          {
            find: "@toolpad/studio",
            replacement: toolpadDevMode ? (
              // load source
              path2.resolve(currentDirectory, "../../src/exports")
            ) : (
              // load compiled
              path2.resolve(currentDirectory, "../exports")
            )
          },
          ...dev ? [
            {
              find: EDITOR_ENTRY,
              replacement: "virtual:toolpad-files:editor.tsx"
            },
            {
              find: "vm",
              replacement: "vm-browserify"
            }
          ] : []
        ]
      },
      optimizeDeps: {
        include: [
          ...dev ? [
            "perf-cascade",
            "monaco-editor",
            "monaco-editor/esm/vs/basic-languages/javascript/javascript",
            "monaco-editor/esm/vs/basic-languages/typescript/typescript",
            "monaco-editor/esm/vs/basic-languages/markdown/markdown"
          ] : ["@toolpad/studio/entrypoint", "@toolpad/studio/editor"]
        ]
      },
      appType: "custom",
      logLevel: "info",
      root: currentDirectory,
      plugins: [toolpadStudioVitePlugin(), virtualToolpadFiles, react(), ...plugins],
      base,
      define: {
        "process.env.NODE_ENV": `'${mode}'`,
        "process.env.BASE_URL": `'${base}'`,
        "process.env.TOOLPAD_CUSTOM_SERVER": `'${JSON.stringify(customServer)}'`,
        "process.env.TOOLPAD_VERSION": JSON.stringify(pkgJson.version),
        "process.env.TOOLPAD_BUILD": JSON.stringify(TOOLPAD_BUILD),
        "process.env.TOOLPAD_PLAN": JSON.stringify(plan)
      }
    }
  };
}

// src/runtime/createRuntimeState.tsx
import * as appDom2 from "@toolpad/studio-runtime/appDom";
function createRuntimeState({ dom }) {
  return {
    dom: appDom2.createRenderTree(dom)
  };
}

// src/server/toolpadAppServer.ts
import * as express3 from "express";
import serializeJavascript from "serialize-javascript";

// src/server/config.ts
function readConfig() {
  if (typeof window !== "undefined") {
    throw new Error(`Server-side config can't be loaded on the client side`);
  }
  const encryptionKeys = process.env.TOOLPAD_ENCRYPTION_KEYS?.split(/\s+/).filter(Boolean) ?? [];
  let basicAuthConfig = {};
  if (process.env.TOOLPAD_BASIC_AUTH_USER && process.env.TOOLPAD_BASIC_AUTH_PASSWORD) {
    basicAuthConfig = {
      basicAuthUser: process.env.TOOLPAD_BASIC_AUTH_USER,
      basicAuthPassword: process.env.TOOLPAD_BASIC_AUTH_PASSWORD
    };
  } else if (process.env.TOOLPAD_BASIC_AUTH_USER) {
    throw new Error(
      `Basic Auth user configured without password. Please provide the TOOLPAD_BASIC_AUTH_PASSWORD environment variable.`
    );
  }
  return {
    ...basicAuthConfig,
    databaseUrl: process.env.TOOLPAD_DATABASE_URL,
    googleSheetsClientId: process.env.TOOLPAD_DATASOURCE_GOOGLESHEETS_CLIENT_ID,
    googleSheetsClientSecret: process.env.TOOLPAD_DATASOURCE_GOOGLESHEETS_CLIENT_SECRET,
    encryptionKeys
  };
}
var config_default = readConfig();

// src/server/rpc.ts
import * as superjson from "superjson";
import express from "express";
import * as z from "zod";
import { fromZodError } from "zod-validation-error";
import { hasOwnProperty } from "@toolpad/utils/collections";
import { errorFrom, serializeError } from "@toolpad/utils/errors";
import { withContext, createServerContext } from "@toolpad/studio-runtime/serverRuntime";
var rpcRequestSchema = z.object({
  name: z.string(),
  params: z.array(z.any())
});

// src/server/auth.ts
import express2 from "express";
import { Auth } from "@auth/core";
import GithubProvider from "@auth/core/providers/github";
import GoogleProvider from "@auth/core/providers/google";
import AzureADProvider from "@auth/core/providers/azure-ad";
import CredentialsProvider from "@auth/core/providers/credentials";
import chalk from "chalk";
import * as appDom3 from "@toolpad/studio-runtime/appDom";
import { adaptRequestFromExpressToFetch } from "@toolpad/utils/httpApiAdapters";
import { getUserToken } from "@toolpad/studio-runtime/auth";

// src/server/toolpadAppServer.ts
function postProcessHtml(html, { initialState }) {
  const serializedInitialState = serializeJavascript(initialState, { isJSON: true });
  const toolpadScripts = [
    `<script>window[${JSON.stringify(
      INITIAL_STATE_WINDOW_PROPERTY
    )}] = ${serializedInitialState}</script>`
  ];
  return html.replace(`<!-- __TOOLPAD_SCRIPTS__ -->`, () => toolpadScripts.join("\n"));
}

// src/server/appServerWorker.ts
var { notifyReady, loadDom, getComponents, getPagesManifest } = createRpcClient(
  workerData.mainThreadRpcPort
);
invariant(
  process.env.NODE_ENV === "development",
  "The dev server must be started with NODE_ENV=development"
);
function devServerPlugin() {
  return {
    name: "toolpad-dev-server",
    async configureServer(viteServer) {
      return () => {
        viteServer.middlewares.use("/", async (req, res, next) => {
          invariant(req.url, "request must have a url");
          try {
            const dom = await loadDom();
            const template = getEditorHtmlContent();
            let html = await viteServer.transformIndexHtml(req.url, template);
            html = postProcessHtml(html, {
              initialState: createRuntimeState({ dom })
            });
            res.setHeader("content-type", "text/html; charset=utf-8").end(html);
          } catch (error) {
            next(error);
          }
        });
      };
    }
  };
}
async function main({ port, ...config }) {
  const { reloadComponents, viteConfig } = await createViteConfig({
    ...config,
    dev: true,
    plugins: [devServerPlugin()],
    getComponents,
    getPagesManifest,
    loadDom
  });
  const vite = await import("vite");
  const devServer = await vite.createServer(viteConfig);
  await devServer.listen(port);
  invariant(parentPort, "parentPort must be defined");
  parentPort.on("message", async (msg) => {
    switch (msg.kind) {
      case "reload-components": {
        reloadComponents();
        break;
      }
      case "exit": {
        await devServer.close();
        process.exit();
        break;
      }
      default:
        throw new Error(`Unknown command ${msg}`);
    }
  });
  await notifyReady();
}
main(workerData);
export {
  main
};
//# sourceMappingURL=appServerWorker.mjs.map