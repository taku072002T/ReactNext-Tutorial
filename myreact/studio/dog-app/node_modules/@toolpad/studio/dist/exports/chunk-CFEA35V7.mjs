import {
  getDesignTokens
} from "./chunk-67ZCLAHI.mjs";

// src/utils/browserOnly.ts
if (process.env.NODE_ENV !== "production" && typeof window === "undefined") {
  throw new Error(`Browser-only module loaded outside of the browser`);
}

// src/components/MonacoEditor.tsx
import * as React from "react";
import * as monaco from "monaco-editor";
import { styled } from "@mui/material";
import clsx from "clsx";
import { nanoid } from "nanoid/non-secure";
import invariant from "invariant";
import {
  conf as jsonBasicConf,
  language as jsonBasicLanguage
} from "monaco-editor/esm/vs/basic-languages/javascript/javascript";
import {
  conf as typescriptBasicConf,
  language as typescriptBasicLanguage
} from "monaco-editor/esm/vs/basic-languages/typescript/typescript";
import {
  conf as mdBasicConf,
  language as mdBasicLanguage
} from "monaco-editor/esm/vs/basic-languages/markdown/markdown";
import { useTheme, lighten, rgbToHex } from "@mui/material/styles";
function getExtension(language) {
  switch (language) {
    case "typescript":
      return ".tsx";
    case "json":
      return ".json";
    case "javascript":
      return ".jsx";
    case "markdown":
      return ".md";
    case "css":
      return ".css";
    case "html":
      return ".html";
    case "plaintext":
      return ".txt";
    default:
      return ".jsx";
  }
}
var designTokensDark = getDesignTokens("dark");
invariant(
  designTokensDark.palette?.background?.default && designTokensDark.palette?.background?.paper && designTokensDark.palette?.divider,
  "dark theme tokens missing"
);
var editorBackground = rgbToHex(lighten(designTokensDark.palette.background.default, 0.05));
var paperBackground = rgbToHex(designTokensDark.palette.background.paper);
var dividerColor = rgbToHex(designTokensDark.palette.divider);
monaco.editor.defineTheme("vs-toolpad-dark", {
  base: "vs-dark",
  inherit: true,
  rules: [],
  colors: {
    // See https://code.visualstudio.com/api/references/theme-color
    "editor.background": editorBackground,
    "menu.background": paperBackground,
    "menu.border": dividerColor,
    "menu.separatorBackground": dividerColor,
    "editorWidget.background": paperBackground,
    "editorWidget.border": dividerColor,
    "editor.lineHighlightBorder": dividerColor
  }
});
monaco.editor.defineTheme("vs-toolpad-light", {
  base: "vs",
  inherit: true,
  rules: [],
  colors: {}
});
function registerLanguage(langId, language, conf) {
  monaco.languages.register({ id: langId });
  monaco.languages.registerTokensProviderFactory(langId, {
    create: async () => language
  });
  monaco.languages.onLanguage(langId, async () => {
    monaco.languages.setLanguageConfiguration(langId, conf);
  });
}
registerLanguage("jsonBasic", jsonBasicLanguage, jsonBasicConf);
registerLanguage("typescriptBasic", typescriptBasicLanguage, typescriptBasicConf);
registerLanguage("markdownBasic", mdBasicLanguage, mdBasicConf);
var JSON_DEFAULT_DIAGNOSTICS_OPTIONS = {};
monaco.languages.json.jsonDefaults.setDiagnosticsOptions(JSON_DEFAULT_DIAGNOSTICS_OPTIONS);
var TYPESCRIPT_DEFAULT_DIAGNOSTICS_OPTIONS = {
  noSemanticValidation: false,
  noSyntaxValidation: false
};
monaco.languages.typescript.typescriptDefaults.setDiagnosticsOptions(
  TYPESCRIPT_DEFAULT_DIAGNOSTICS_OPTIONS
);
var TYPESCRIPT_DEFAULT_COMPILER_OPTIONS = {
  target: monaco.languages.typescript.ScriptTarget.Latest,
  allowNonTsExtensions: true,
  moduleResolution: monaco.languages.typescript.ModuleResolutionKind.NodeJs,
  module: monaco.languages.typescript.ModuleKind.ESNext,
  noEmit: true,
  esModuleInterop: true,
  jsx: monaco.languages.typescript.JsxEmit.React,
  reactNamespace: "React",
  allowJs: true,
  lib: ["es2020"],
  typeRoots: ["node_modules/@types"],
  strictNullChecks: true
};
monaco.languages.typescript.typescriptDefaults.setCompilerOptions(
  TYPESCRIPT_DEFAULT_COMPILER_OPTIONS
);
var classes = {
  monacoHost: "Toolpad_MonacoEditorMonacoHost",
  overlay: "Toolpad_MonacoEditorOverlay",
  disabled: "Toolpad_MonacoEditorDisabled"
};
var EditorRoot = styled("div")(({ theme }) => ({
  height: "100%",
  position: "relative",
  [`& .${classes.monacoHost}`]: {
    position: "absolute",
    inset: "0 0 0 0"
  },
  [`& .${classes.overlay}`]: {
    position: "absolute",
    inset: "0 0 0 0",
    background: theme.palette.background.default,
    opacity: 0.5,
    display: "none"
  },
  [`&.${classes.disabled}`]: {
    pointerEvents: "none"
  },
  [`&.${classes.disabled} .${classes.overlay}`]: {
    display: "block"
  }
}));
var overflowWidgetsDomNode = null;
function getOverflowWidgetsDomNode(theme) {
  if (!overflowWidgetsDomNode) {
    overflowWidgetsDomNode = document.createElement("div");
    overflowWidgetsDomNode.classList.add("monaco-editor");
    overflowWidgetsDomNode.style.zIndex = String(theme.zIndex.tooltip + 1);
    document.body.append(overflowWidgetsDomNode);
  }
  return overflowWidgetsDomNode;
}
var MonacoEditor_default = React.forwardRef(function MonacoEditor({
  value,
  onChange,
  sx,
  language = "plaintext",
  diagnostics,
  compilerOptions,
  extraLibs,
  onFocus,
  onBlur,
  className,
  disabled,
  options,
  autoFocus,
  ...props
}, ref) {
  const rootRef = React.useRef(null);
  const instanceRef = React.useRef(null);
  const theme = useTheme();
  const monacoTheme = theme.palette.mode === "dark" ? "vs-toolpad-dark" : "vs-toolpad-light";
  const [isFocused, setIsFocused] = React.useState(false);
  React.useEffect(() => {
    const model = instanceRef.current?.getModel();
    if (!model) {
      return;
    }
    if (language === "json") {
      if (isFocused) {
        monaco.editor.setModelLanguage(model, "json");
        monaco.languages.json.jsonDefaults.setDiagnosticsOptions({
          ...JSON_DEFAULT_DIAGNOSTICS_OPTIONS,
          ...diagnostics
        });
      } else {
        monaco.editor.setModelLanguage(model, "jsonBasic");
      }
    } else if (language === "typescript") {
      if (isFocused) {
        monaco.editor.setModelLanguage(model, "typescript");
        monaco.languages.typescript.typescriptDefaults.setDiagnosticsOptions({
          ...TYPESCRIPT_DEFAULT_DIAGNOSTICS_OPTIONS,
          ...diagnostics
        });
        monaco.languages.typescript.typescriptDefaults.setCompilerOptions({
          ...TYPESCRIPT_DEFAULT_COMPILER_OPTIONS,
          ...compilerOptions
        });
        monaco.languages.typescript.typescriptDefaults.setExtraLibs(extraLibs || []);
      } else {
        monaco.editor.setModelLanguage(model, "typescriptBasic");
      }
    } else {
      monaco.editor.setModelLanguage(model, language);
    }
  }, [isFocused, language, diagnostics, extraLibs, compilerOptions]);
  React.useEffect(() => {
    invariant(rootRef.current, "Ref not attached");
    const extraOptions = {
      readOnly: disabled,
      theme: monacoTheme,
      scrollbar: {
        alwaysConsumeMouseWheel: false,
        ...options?.scrollbar
      },
      ...options
    };
    let instance = instanceRef.current;
    if (instance) {
      instance.updateOptions(extraOptions);
      const model = instance.getModel();
      if (typeof value === "string" && model) {
        const actualValue = model.getValue();
        if (value !== actualValue) {
          const state = instance.saveViewState();
          instance.executeEdits(null, [
            {
              range: model.getFullModelRange(),
              text: value
            }
          ]);
          if (state) {
            instance.restoreViewState(state);
          }
        }
      }
    } else {
      const pathUri = monaco.Uri.parse(`/scripts/${nanoid(7)}${getExtension(language)}`);
      const model = monaco.editor.createModel(value || "", language, pathUri);
      instance = monaco.editor.create(rootRef.current, {
        model,
        language,
        minimap: { enabled: false },
        accessibilitySupport: "off",
        tabSize: 2,
        automaticLayout: true,
        fixedOverflowWidgets: true,
        // See https://github.com/microsoft/monaco-editor/issues/181
        overflowWidgetsDomNode: getOverflowWidgetsDomNode(theme),
        ...extraOptions
      });
      instanceRef.current = instance;
      instance.onDidFocusEditorWidget(() => setIsFocused(true));
      instance.onDidBlurEditorWidget(() => setIsFocused(false));
      if (autoFocus && !disabled) {
        instance.focus();
      }
    }
  }, [language, value, options, disabled, autoFocus, theme, monacoTheme]);
  React.useEffect(() => {
    const editor2 = instanceRef.current;
    const onDidChangeModelContentSub = editor2?.onDidChangeModelContent(() => {
      const editorValue = editor2.getValue();
      if (onChange && value !== editorValue) {
        onChange(editorValue);
      }
    });
    return () => onDidChangeModelContentSub?.dispose();
  }, [onChange, value]);
  React.useEffect(() => {
    const editor2 = instanceRef.current;
    if (onFocus) {
      const onDidFocusEditorTextSub = editor2?.onDidFocusEditorText(onFocus);
      return () => onDidFocusEditorTextSub?.dispose();
    }
    return () => {
    };
  }, [onFocus]);
  React.useEffect(() => {
    const editor2 = instanceRef.current;
    if (onBlur) {
      const onDidBlurEditorTextSub = editor2?.onDidBlurEditorText(onBlur);
      return () => onDidBlurEditorTextSub?.dispose();
    }
    return () => {
    };
  }, [onBlur]);
  React.useEffect(() => {
    return () => {
      instanceRef.current?.getModel()?.dispose();
      instanceRef.current?.dispose();
      instanceRef.current = null;
    };
  }, []);
  React.useImperativeHandle(ref, () => {
    return {
      get editor() {
        const editor2 = instanceRef.current;
        if (!editor2) {
          throw new Error("Editor not created yet");
        }
        return editor2;
      },
      get monaco() {
        return monaco;
      }
    };
  }, []);
  return /* @__PURE__ */ React.createElement(EditorRoot, { className: clsx({ [classes.disabled]: disabled }, className), sx, ...props }, /* @__PURE__ */ React.createElement("div", { className: classes.monacoHost, ref: rootRef }), /* @__PURE__ */ React.createElement("div", { className: classes.overlay }));
});

export {
  MonacoEditor_default
};
//# sourceMappingURL=chunk-CFEA35V7.mjs.map