{"version":3,"sources":["../../src/components/TypescriptEditor.tsx"],"sourcesContent":["/**\n * NOTE: This file can't SSR (use lazyComponent to load it)\n */\n\nimport * as React from 'react';\nimport type * as monaco from 'monaco-editor';\nimport MonacoEditor, { MonacoEditorProps } from './MonacoEditor';\n\nexport interface TypescriptEditorProps extends Omit<MonacoEditorProps, 'language' | 'diagnostics'> {\n  value: string;\n  onChange: (newValue: string) => void;\n  functionBody?: boolean;\n  topLevelAwait?: boolean;\n}\n\nexport default function TypescriptEditor({\n  functionBody,\n  topLevelAwait,\n  ...props\n}: TypescriptEditorProps) {\n  const diagnostics = React.useMemo<monaco.languages.typescript.DiagnosticsOptions>(() => {\n    const diagnosticCodesToIgnore: number[] = [];\n    if (functionBody) {\n      // TS1108: A 'return' statement can only be used within a function body.\n      diagnosticCodesToIgnore.push(1108);\n    }\n    if (topLevelAwait) {\n      // TS1375: 'await' expressions are only allowed at the top level of a file when that file is a module,\n      // but this file has no imports or exports. Consider adding an empty 'export {}' to make this file a module.\n      diagnosticCodesToIgnore.push(1375);\n    }\n    return { diagnosticCodesToIgnore };\n  }, [functionBody, topLevelAwait]);\n\n  return <MonacoEditor language=\"typescript\" diagnostics={diagnostics} {...props} />;\n}\n"],"mappings":";;;;;;;AAIA,YAAY,WAAW;AAWR,SAAR,iBAAkC;AAAA,EACvC;AAAA,EACA;AAAA,EACA,GAAG;AACL,GAA0B;AACxB,QAAM,cAAoB,cAAwD,MAAM;AACtF,UAAM,0BAAoC,CAAC;AAC3C,QAAI,cAAc;AAEhB,8BAAwB,KAAK,IAAI;AAAA,IACnC;AACA,QAAI,eAAe;AAGjB,8BAAwB,KAAK,IAAI;AAAA,IACnC;AACA,WAAO,EAAE,wBAAwB;AAAA,EACnC,GAAG,CAAC,cAAc,aAAa,CAAC;AAEhC,SAAO,oCAAC,wBAAa,UAAS,cAAa,aAA2B,GAAG,OAAO;AAClF;","names":[]}