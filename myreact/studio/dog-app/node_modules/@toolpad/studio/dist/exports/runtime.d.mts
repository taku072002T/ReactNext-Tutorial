export { R as RenderedPage, a as ToolpadApp, T as ToolpadAppProps } from './ToolpadApp-CF8cGzdf.mjs';
import * as React from 'react';
import * as _toolpad_studio_runtime from '@toolpad/studio-runtime';
import { NodeHashes, ComponentConfig } from '@toolpad/studio-runtime';
import * as appDom from '@toolpad/studio-runtime/appDom';
export { R as RuntimeState } from './types-CI_VLzfr.mjs';

declare const componentsStore: {
    getState: () => Partial<Record<string, _toolpad_studio_runtime.ToolpadComponent<any>>>;
    setState: (newState: Partial<Record<string, _toolpad_studio_runtime.ToolpadComponent<any>>> | ((oldValue: Partial<Record<string, _toolpad_studio_runtime.ToolpadComponent<any>>>) => Partial<Record<string, _toolpad_studio_runtime.ToolpadComponent<any>>>)) => void;
    useValue: () => Partial<Record<string, _toolpad_studio_runtime.ToolpadComponent<any>>>;
    useState: () => [Partial<Record<string, _toolpad_studio_runtime.ToolpadComponent<any>>>, React.Dispatch<React.SetStateAction<Partial<Record<string, _toolpad_studio_runtime.ToolpadComponent<any>>>>>];
    subscribe: (cb: (state: Partial<Record<string, _toolpad_studio_runtime.ToolpadComponent<any>>>) => void) => () => void;
};

/**
 * Context created by the app canvas to override behavior for the app editor
 */
interface CanvasHooks {
    savedNodes?: NodeHashes;
    registerNode?: (node: appDom.AppDomNode, props: Record<string, unknown>, componentConfig: ComponentConfig, elm: Element | undefined) => () => void;
    overlayRef?: (elm: HTMLDivElement) => void;
}
declare const CanvasHooksContext: React.Context<CanvasHooks>;

declare function createRemoteFunction(functionFile: string, functionName: string): (...params: any[]) => Promise<unknown>;

export { type CanvasHooks, CanvasHooksContext, componentsStore, createRemoteFunction };
