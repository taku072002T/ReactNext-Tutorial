// src/constants.ts
var INITIAL_STATE_WINDOW_PROPERTY = "__initialToolpadState__";
var DOCUMENTATION_URL = "https://mui.com/toolpad/studio/getting-started/";
var UPGRADE_URL = "https://mui.com/toolpad/studio/getting-started/roadmap/#paid-plan";
var VERSION_CHECK_INTERVAL = 1e3 * 60 * 10;
var FEATURE_FLAG_GLOBAL_FUNCTIONS = false;

// src/utils/insecureHash.ts
function insecureHash(str) {
  let h = 0;
  for (let i = 0; i < str.length; i += 1) {
    h = Math.imul(31, h) + str.charCodeAt(i) | 0;
  }
  return h;
}

// src/runtime/createRuntimeState.tsx
import * as appDom from "@toolpad/studio-runtime/appDom";
function createRuntimeState({ dom }) {
  return {
    dom: appDom.createRenderTree(dom)
  };
}

// src/utils/prettier.ts
import prettier from "prettier";
import parserBabel from "prettier/parser-babel";
var DEFAULT_OPTIONS = {
  parser: "babel-ts",
  plugins: [parserBabel]
};
async function resolvePrettierConfig(filePath) {
  const config = await prettier.resolveConfig(filePath);
  return config;
}
async function format(code, filePath) {
  const readConfig = await resolvePrettierConfig(filePath);
  return prettier.format(code, {
    ...readConfig,
    ...DEFAULT_OPTIONS
  });
}
async function formatExpression(code, config) {
  const formatted = await prettier.format(code, {
    ...config,
    ...DEFAULT_OPTIONS,
    semi: false
  });
  return formatted.replace(/^;/, "");
}
async function tryFormatExpression(code, config) {
  try {
    return await formatExpression(code, config);
  } catch (err) {
    return code;
  }
}

// src/toolpadDataSources/local/shared.tsx
function parseLegacyFunctionId(id) {
  if (!id) {
    return { file: "functions.ts" };
  }
  const [file, handler] = id.split("#");
  return handler ? { file, handler } : { file: "functions.ts", handler: file };
}
function parseFunctionId(id) {
  const [file, handler] = id.split("#");
  return handler ? { file, handler } : { file };
}
function serializeFunctionId({ file, handler }) {
  return handler ? `${file}#${handler}` : file;
}
function transformLegacyFunctionId(id) {
  if (!id) {
    return "";
  }
  const [file, handler] = id.split("#");
  return handler ? id : `functions.ts#${file}`;
}

// src/toolpadDataSources/rest/shared.ts
import { ensureSuffix } from "@toolpad/utils/strings";
var HTTP_NO_BODY = /* @__PURE__ */ new Set(["GET", "HEAD"]);
function getAuthenticationHeaders(auth) {
  if (!auth) {
    return [];
  }
  switch (auth.type) {
    case "basic":
      return [
        [
          "Authorization",
          `Basic ${Buffer.from(`${auth.user}:${auth.password}`, "utf-8").toString("base64")}`
        ]
      ];
    case "bearerToken":
      return [["Authorization", `Bearer ${auth.token}`]];
    case "apiKey":
      return [[auth.header, auth.key]];
    default:
      throw new Error(`Unsupported authentication type "${auth.type}"`);
  }
}
function parseBaseUrl(baseUrl) {
  const parsedBase = new URL(baseUrl);
  parsedBase.pathname = ensureSuffix(parsedBase.pathname, "/");
  parsedBase.search = "";
  parsedBase.hash = "";
  return parsedBase;
}

export {
  insecureHash,
  createRuntimeState,
  INITIAL_STATE_WINDOW_PROPERTY,
  DOCUMENTATION_URL,
  UPGRADE_URL,
  VERSION_CHECK_INTERVAL,
  FEATURE_FLAG_GLOBAL_FUNCTIONS,
  resolvePrettierConfig,
  format,
  tryFormatExpression,
  HTTP_NO_BODY,
  getAuthenticationHeaders,
  parseBaseUrl,
  parseLegacyFunctionId,
  parseFunctionId,
  serializeFunctionId,
  transformLegacyFunctionId
};
//# sourceMappingURL=chunk-MNVDTQN5.mjs.map