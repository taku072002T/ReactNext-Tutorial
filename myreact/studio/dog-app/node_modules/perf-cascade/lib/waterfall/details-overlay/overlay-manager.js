import { getLastItemOfNodeList, getParentByClassName, removeChildren, } from "../../helpers/dom";
import { find, isTabDown, isTabUp, } from "../../helpers/misc";
import { createRowInfoOverlay } from "./svg-details-overlay";
/** Overlay (popup) instance manager */
class OverlayManager {
    constructor(context) {
        this.context = context;
        /** Collection of currely open overlays */
        this.openOverlays = [];
        /**
         * Sets the offset for a request-bar
         * @param {SVGAElement[]} rowItems
         * @param {number} offset
         */
        this.realignRow = (rowItem, offset) => {
            rowItem.setAttribute("transform", `translate(0, ${offset})`);
        };
    }
    /** all open overlays height combined */
    getCombinedOverlayHeight() {
        return this.openOverlays.reduce((pre, curr) => pre + (curr.height || 0), 0);
    }
    /**
     * Opens an overlay - rerenders others internaly
     */
    openOverlay(index, y, detailsHeight, entry, rowItems) {
        if (this.openOverlays.some((o) => o.index === index)) {
            return;
        }
        const self = this;
        const newOverlay = {
            defaultY: y,
            entry,
            index,
            onClose: () => {
                self.closeOverlay(index, detailsHeight, rowItems);
            },
            openTabIndex: 0,
        };
        this.openOverlays.push(newOverlay);
        this.openOverlays = this.openOverlays.sort((a, b) => a.index > b.index ? 1 : -1);
        this.renderOverlays(detailsHeight, rowItems);
        this.context.pubSub.publishToOverlayChanges({
            changedIndex: index,
            combinedOverlayHeight: self.getCombinedOverlayHeight(),
            type: "open",
        });
    }
    /**
     * Toggles an overlay - rerenders others
     */
    toggleOverlay(index, y, detailsHeight, entry, rowItems) {
        if (this.openOverlays.some((o) => o.index === index)) {
            this.closeOverlay(index, detailsHeight, rowItems);
        }
        else {
            this.openOverlay(index, y, detailsHeight, entry, rowItems);
        }
    }
    /**
     * closes on overlay - rerenders others internally
     */
    closeOverlay(index, detailsHeight, rowItems) {
        const self = this;
        this.openOverlays.splice(this.openOverlays.reduce((prev, curr, i) => {
            return (curr.index === index) ? i : prev;
        }, -1), 1);
        this.renderOverlays(detailsHeight, rowItems);
        this.context.pubSub.publishToOverlayChanges({
            changedIndex: index,
            combinedOverlayHeight: self.getCombinedOverlayHeight(),
            type: "closed",
        });
    }
    /**
     * Renders / Adjusts Overlays
     *
     * @summary this is to re-set the "y" position since there is a bug in chrome with
     * tranform of an SVG and positioning/scoll of a foreignObjects
     * @param  {number} detailsHeight
     * @param  {SVGAElement[]} rowItems
     */
    renderOverlays(detailsHeight, rowItems) {
        /** shared variable to keep track of heigth */
        let currY = 0;
        const updateHeight = (overlay, y, currHeight) => {
            currY += currHeight;
            overlay.actualY = y;
            overlay.height = currHeight;
        };
        const addNewOverlay = (overlayHolder, overlay) => {
            const y = overlay.defaultY + currY;
            const infoOverlay = createRowInfoOverlay(overlay, y, detailsHeight);
            // if overlay has a preview image show it
            const previewImg = infoOverlay.querySelector("img.preview");
            if (previewImg && !previewImg.src) {
                previewImg.setAttribute("src", (previewImg.attributes.getNamedItem("data-src") || { value: "" }).value);
            }
            infoOverlay.querySelector("a")
                .addEventListener("keydown", OverlayManager.firstElKeypress);
            getLastItemOfNodeList(infoOverlay.querySelectorAll("button"))
                .addEventListener("keydown", OverlayManager.lastElKeypress);
            overlayHolder.appendChild(infoOverlay);
            updateHeight(overlay, y, infoOverlay.getBoundingClientRect().height);
        };
        const updateRow = (rowItem, index) => {
            const overlay = find(this.openOverlays, (o) => o.index === index);
            const nextRowItem = rowItem.nextElementSibling;
            const overlayEl = nextRowItem.firstElementChild;
            this.realignRow(rowItem, currY);
            if (overlay === undefined) {
                if (overlayEl && nextRowItem !== null) {
                    // remove closed overlay
                    nextRowItem.querySelector("a")
                        .removeEventListener("keydown", OverlayManager.firstElKeypress);
                    getLastItemOfNodeList(nextRowItem.querySelectorAll("button"))
                        .removeEventListener("keydown", OverlayManager.lastElKeypress);
                    removeChildren(nextRowItem);
                }
                return; // not open
            }
            if (overlayEl && overlay.actualY !== undefined) {
                const bg = overlayEl.querySelector(".info-overlay-bg");
                const fo = overlayEl.querySelector("foreignObject");
                const btnRect = overlayEl.querySelector(".info-overlay-close-btn rect");
                const btnText = overlayEl.querySelector(".info-overlay-close-btn text");
                updateHeight(overlay, overlay.defaultY + currY, overlay.height);
                // needs updateHeight
                bg.setAttribute("y", overlay.actualY.toString());
                fo.setAttribute("y", overlay.actualY.toString());
                btnText.setAttribute("y", overlay.actualY.toString());
                btnRect.setAttribute("y", overlay.actualY.toString());
                return;
            }
            addNewOverlay(rowItem.nextElementSibling, overlay);
        };
        rowItems.forEach(updateRow);
    }
}
OverlayManager.showFullName = (el) => {
    el.getElementsByClassName("row-fixed")
        .item(0)?.dispatchEvent(new MouseEvent("mouseenter"));
};
/**
 * Keypress Event handler for fist el in Overlay,
 * to manage highlighting of the element above
 */
OverlayManager.firstElKeypress = (evt) => {
    if (isTabUp(evt)) {
        const par = getParentByClassName(evt.target, "row-overlay-holder");
        if (par && par.previousElementSibling) {
            OverlayManager.showFullName(par.previousElementSibling);
        }
    }
};
/**
 * Keypress Event handler for last el in Overlay,
 * to manage highlighting of the element below
 */
OverlayManager.lastElKeypress = (evt) => {
    if (isTabDown(evt)) {
        const par = getParentByClassName(evt.target, "row-overlay-holder");
        if (par && par.nextElementSibling) {
            OverlayManager.showFullName(par.nextElementSibling);
        }
    }
};
export { OverlayManager, };
export default OverlayManager;
