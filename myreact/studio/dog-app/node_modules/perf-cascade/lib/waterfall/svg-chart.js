import * as svg from "../helpers/svg";
import { requestTypeToCssClass } from "../transformers/styling-converters";
import OverlayManager from "./details-overlay/overlay-manager";
import { PubSub } from "./details-overlay/pub-sub";
import * as row from "./row/svg-row";
import { makeTooltip } from "./row/svg-tooltip";
import * as svgAlignmentHelper from "./sub-components/svg-alignment-helper";
import * as svgGeneralComponents from "./sub-components/svg-general-components";
import * as svgMarks from "./sub-components/svg-marks";
/**
 * Get a string that's as wide, or wider than any number from 0-n.
 * @param {number} n the highest number that should fit within the returned string's width.
 * @returns {string}
 */
function getWidestDigitString(n) {
    const numDigits = Math.floor((Math.log(n) / Math.LN10)) + 1;
    let s = "";
    for (let i = 0; i < numDigits; i++) {
        // No number should take more horizontal space than "0" does.
        s += "0";
    }
    return s;
}
/**
 * Calculate the height of the SVG chart in px
 * @param {Mark[]}       marks      [description]
 * @param  {number} diagramHeight
 * @returns Number
 */
function getSvgHeight(marks, diagramHeight) {
    const maxMarkTextLength = marks.reduce((currMax, currValue) => {
        const attributes = { x: 0, y: 0 };
        return Math.max(currMax, svg.getNodeTextWidth(svg.newTextEl(currValue.name, attributes), true));
    }, 0);
    return Math.floor(diagramHeight + maxMarkTextLength + 35);
}
/**
 * Intitializes the context object
 * @param {WaterfallData} data - Object containing the setup parameter
 * @param {ChartOptions} options - Chart config/customization options
 * @param {WaterfallEntry[]} entriesToShow - Filtered array of entries that will be rendered
 * @return {Context} Context object
 */
function createContext(data, options, entriesToShow) {
    const unit = data.durationMs / 100;
    const diagramHeight = (entriesToShow.length + 1) * options.rowHeight;
    const context = {
        diagramHeight,
        options,
        pubSub: new PubSub(),
        unit,
    };
    // `overlayManager` needs the `context` reference, so it's attached later
    return {
        ...context,
        overlayManager: new OverlayManager(context),
    };
}
/**
 * Entry point to start rendering the full waterfall SVG
 * @param {WaterfallData} data - Object containing the setup parameter
 * @param {ChartOptions} options - Chart config/customization options
 * @return {SVGSVGElement} - SVG Element ready to render
 */
export function createWaterfallSvg(data, options) {
    // constants
    const entriesToShow = data.entries
        .filter((entry) => (typeof entry.start === "number" && typeof entry.total === "number"))
        .sort((a, b) => (a.start || 0) - (b.start || 0));
    /** Holder of request-details overlay */
    const overlayHolder = svg.newG("overlays");
    /** Holds all rows */
    const rowHolder = svg.newG("rows-holder");
    const context = createContext(data, options, entriesToShow);
    /** full height of the SVG chart in px */
    const chartHolderHeight = getSvgHeight(data.marks, context.diagramHeight);
    /** Main SVG Element that holds all data */
    const timeLineHolder = svg.newSvg("water-fall-chart", {
        height: chartHolderHeight,
    });
    /** Holder for scale, event and marks */
    const scaleAndMarksHolder = svg.newSvg("scale-and-marks-holder", {
        width: `${100 - options.leftColumnWidth}%`,
        x: `${options.leftColumnWidth}%`,
    });
    /** Holder for on-hover vertical comparison bars */
    let hoverOverlayHolder;
    let mouseListeners;
    if (options.showAlignmentHelpers) {
        hoverOverlayHolder = svg.newG("hover-overlays");
        const hoverEl = svgAlignmentHelper.createAlignmentLines(context.diagramHeight);
        hoverOverlayHolder.appendChild(hoverEl.startline);
        hoverOverlayHolder.appendChild(hoverEl.endline);
        mouseListeners = svgAlignmentHelper.makeHoverEvtListeners(hoverEl);
    }
    // Start appending SVG elements to the holder element (timeLineHolder)
    scaleAndMarksHolder.appendChild(svgGeneralComponents.createTimeScale(context, data.durationMs));
    scaleAndMarksHolder.appendChild(svgMarks.createMarks(context, data.marks));
    // This assumes all icons (mime and indicators) have the same width
    const perIconWidth = entriesToShow[0].responseDetails.icon.width;
    let maxIcons = 0;
    if (options.showMimeTypeIcon) {
        maxIcons += 1;
    }
    if (options.showIndicatorIcons) {
        const iconsPerBlock = entriesToShow.map((entry) => entry.responseDetails.indicators.filter((i) => i.displayType === "icon").length > 0 ? 1 : 0);
        maxIcons += Math.max.apply(null, iconsPerBlock);
    }
    const maxIconsWidth = maxIcons * perIconWidth;
    const widestRequestNumber = getWidestDigitString(entriesToShow.length);
    const maxNumberWidth = svg.getNodeTextWidth(svg.newTextEl(`${widestRequestNumber}`), true);
    const rowItems = [];
    function getChartHeight() {
        return chartHolderHeight + context.overlayManager.getCombinedOverlayHeight();
    }
    context.pubSub.subscribeToOverlayChanges(() => {
        const newHeight = getChartHeight();
        timeLineHolder.classList.toggle("closing", newHeight < timeLineHolder.clientHeight);
        timeLineHolder.style.height = `${newHeight}px`;
    });
    /** Renders single row and hooks up behaviour */
    function renderRow(entry, i) {
        const entryWidth = entry.total || 1;
        const y = options.rowHeight * i;
        const x = (entry.start || 0.001);
        const detailsHeight = 450;
        const rectData = {
            cssClass: requestTypeToCssClass(entry.responseDetails.requestType),
            height: options.rowHeight,
            hideOverlay: options.showAlignmentHelpers ? mouseListeners.onMouseLeavePartial : undefined,
            label: `<strong>${entry.url}</strong><br/>` +
                `${Math.round(entry.start)}ms - ${Math.round(entry.end)}ms<br/>` +
                `total: ${isNaN(entry.total) ? "n/a " : Math.round(entry.total)}ms`,
            showOverlay: options.showAlignmentHelpers ? mouseListeners.onMouseEnterPartial : undefined,
            unit: context.unit,
            width: entryWidth,
            x,
            y,
        };
        const showDetailsOverlay = () => {
            context.overlayManager.toggleOverlay(i, y + options.rowHeight, detailsHeight, entry, rowItems);
        };
        const rowItem = row.createRow(context, i, maxIconsWidth, maxNumberWidth, rectData, entry, showDetailsOverlay);
        rowItems.push(rowItem);
        rowHolder.appendChild(rowItem);
        rowHolder.appendChild(svg.newG("row-overlay-holder"));
    }
    // Main loop to render rows with blocks
    entriesToShow.forEach(renderRow);
    if (options.showAlignmentHelpers && hoverOverlayHolder !== undefined) {
        scaleAndMarksHolder.appendChild(hoverOverlayHolder);
    }
    timeLineHolder.appendChild(scaleAndMarksHolder);
    timeLineHolder.appendChild(rowHolder);
    timeLineHolder.appendChild(overlayHolder);
    timeLineHolder.appendChild(makeTooltip(options));
    return timeLineHolder;
}
